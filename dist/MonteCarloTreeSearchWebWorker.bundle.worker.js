/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/babel-loader/lib/index.js!./js/deciders/MonteCarloTreeSearchWebWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/actions/PlayerActions.js":
/*!*************************************!*\
  !*** ./js/actions/PlayerActions.js ***!
  \*************************************/
/*! exports provided: tileChosen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tileChosen", function() { return tileChosen; });
/* harmony import */ var _constants_ActionTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/ActionTypes.js */ "./js/constants/ActionTypes.js");
/* harmony import */ var check_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! check-types */ "./node_modules/check-types/src/check-types.js");
/* harmony import */ var check_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(check_types__WEBPACK_IMPORTED_MODULE_1__);


function tileChosen(action) {
  check_types__WEBPACK_IMPORTED_MODULE_1___default.a.assert.assigned(action.tileId, 'tileId must be provided');
  check_types__WEBPACK_IMPORTED_MODULE_1___default.a.assert.assigned(action.colour, 'colour must be provided');
  var tileId = action.tileId,
      colour = action.colour;
  return {
    type: _constants_ActionTypes_js__WEBPACK_IMPORTED_MODULE_0__["TILE_CHOSEN"],
    tileId: tileId,
    colour: colour
  };
}

/***/ }),

/***/ "./js/constants/ActionTypes.js":
/*!*************************************!*\
  !*** ./js/constants/ActionTypes.js ***!
  \*************************************/
/*! exports provided: PLAYERS_JOIN, TILE_CHOSEN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLAYERS_JOIN", function() { return PLAYERS_JOIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TILE_CHOSEN", function() { return TILE_CHOSEN; });
var PLAYERS_JOIN = 'PLAYERS_JOIN';
var TILE_CHOSEN = 'TILE_CHOSEN';

/***/ }),

/***/ "./js/constants/Colours.js":
/*!*********************************!*\
  !*** ./js/constants/Colours.js ***!
  \*********************************/
/*! exports provided: COLOUR_NEUTRAL, COLOUR_BLUE, COLOUR_RED, BORDER_LEFT, BORDER_TOP, BORDER_TOP_RIGHT, BORDER_RIGHT, BORDER_BOTTOM_RIGHT, BORDER_BOTTOM, BORDER_BOTTOM_LEFT, BORDER_TOP_LEFT_BLUE, BORDER_TOP_LEFT_RED, BORDER_BOTTOM_RIGHT_BLUE, BORDER_BOTTOM_RIGHT_RED */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOUR_NEUTRAL", function() { return COLOUR_NEUTRAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOUR_BLUE", function() { return COLOUR_BLUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOUR_RED", function() { return COLOUR_RED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_LEFT", function() { return BORDER_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_TOP", function() { return BORDER_TOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_TOP_RIGHT", function() { return BORDER_TOP_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_RIGHT", function() { return BORDER_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_BOTTOM_RIGHT", function() { return BORDER_BOTTOM_RIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_BOTTOM", function() { return BORDER_BOTTOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_BOTTOM_LEFT", function() { return BORDER_BOTTOM_LEFT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_TOP_LEFT_BLUE", function() { return BORDER_TOP_LEFT_BLUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_TOP_LEFT_RED", function() { return BORDER_TOP_LEFT_RED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_BOTTOM_RIGHT_BLUE", function() { return BORDER_BOTTOM_RIGHT_BLUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BORDER_BOTTOM_RIGHT_RED", function() { return BORDER_BOTTOM_RIGHT_RED; });
var COLOUR_NEUTRAL = 0;
var COLOUR_BLUE = 1;
var COLOUR_RED = 2;
var BORDER_LEFT = 3;
var BORDER_TOP = 4;
var BORDER_TOP_RIGHT = 5;
var BORDER_RIGHT = 6;
var BORDER_BOTTOM_RIGHT = 7;
var BORDER_BOTTOM = 8;
var BORDER_BOTTOM_LEFT = 9;
var BORDER_TOP_LEFT_BLUE = 10;
var BORDER_TOP_LEFT_RED = 11;
var BORDER_BOTTOM_RIGHT_BLUE = 12;
var BORDER_BOTTOM_RIGHT_RED = 13;

/***/ }),

/***/ "./js/constants/Grid.js":
/*!******************************!*\
  !*** ./js/constants/Grid.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// This is the width of the game board.
// The width and height of the playing area is this minus 2.
var size = 7;
/* harmony default export */ __webpack_exports__["default"] = ({
  width: size,
  height: size,
  layout: 'odd-r',
  orientation: 'pointy-topped',
  shape: 'parallelogram',
  validate: false
});

/***/ }),

/***/ "./js/deciders/MonteCarloTreeSearch.js":
/*!*********************************************!*\
  !*** ./js/deciders/MonteCarloTreeSearch.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MonteCarloTreeSearch; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _reducers_hexbusters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../reducers/hexbusters.js */ "./js/reducers/hexbusters.js");
/* harmony import */ var _hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hexbusters/helpers.js */ "./js/hexbusters/helpers.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var Node = /*#__PURE__*/function () {
  function Node(_ref) {
    var _ref$action = _ref.action,
        action = _ref$action === void 0 ? null : _ref$action,
        _ref$parent = _ref.parent,
        parent = _ref$parent === void 0 ? null : _ref$parent,
        _ref$state = _ref.state,
        state = _ref$state === void 0 ? null : _ref$state;

    _classCallCheck(this, Node);

    // The action that led to this node. Null for the root node.
    this.action = action; // Null for the root node.

    this.parentNode = parent;
    this.childNodes = new Set([]);
    this.wins = 0;
    this.visits = 0;
    this.untriedActions = new Set(Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_2__["getActions"])(state));
    this.currentPlayer = Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_2__["getCurrentPlayer"])(state);
  }

  _createClass(Node, [{
    key: "addChild",
    value: function addChild(action, state) {
      var n = new Node({
        action: action,
        state: state,
        parent: this
      });
      this.untriedActions.delete(action);
      this.childNodes.add(n);
      return n;
    }
  }, {
    key: "update",
    value: function update(result) {
      this.visits += 1;
      this.wins += result;
    }
    /**
     * Use the UCB1 formula to select a child node.
     */

  }, {
    key: "UCB1SelectChild",
    value: function UCB1SelectChild() {
      var _this = this;

      return lodash__WEBPACK_IMPORTED_MODULE_0___default()(Array.from(this.childNodes)).sortBy(function (n) {
        return n.wins / n.visits + Math.sqrt(2 * Math.log(_this.visits) / n.visits);
      }).last();
    }
  }]);

  return Node;
}();

function getStateValue(state, player) {
  if (player === null) {
    return null;
  }

  switch (state.winner) {
    case player.colour:
      return -1;

    case null:
      // Stalemate.
      return 0;

    default:
      return 1;
  }
}

var MonteCarloTreeSearch = /*#__PURE__*/function () {
  function MonteCarloTreeSearch() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MonteCarloTreeSearch);

    /**
     * How much time to spend thinking.
     */
    this.timeLimitMs = options.timeLimitMs || 1000;
    /**
     * Whether to output debug information.
     */

    this.debug = options.debug || false;
  }

  _createClass(MonteCarloTreeSearch, [{
    key: "getBestAction",
    value: function getBestAction(playerColour, rootState) {
      var dateLimit = Date.now() + this.timeLimitMs;
      var rootNode = new Node({
        state: rootState
      });
      var iterations = 0;

      while (Date.now() < dateLimit) {
        var node = rootNode;
        var state = rootState; // Select until a new fringe node is found.

        while (node.untriedActions.size === 0 && node.childNodes.size > 0) {
          node = node.UCB1SelectChild();
          state = Object(_reducers_hexbusters_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, node.action);
        } // Expand the new node.


        if (node.untriedActions.size > 0) {
          var action = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.sample(Array.from(node.untriedActions));

          state = Object(_reducers_hexbusters_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, action);
          node = node.addChild(action, state);
        } // Rollout to a terminal state.
        // Random walk the tree to a terminal node.


        var randomAction = Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_2__["getRandomAction"])(state);

        while (randomAction !== null) {
          state = Object(_reducers_hexbusters_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, randomAction);
          randomAction = Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_2__["getRandomAction"])(state);
        } // Back propagate the terminal state's value.


        while (node !== null) {
          node.update(getStateValue(state, node.currentPlayer));
          node = node.parentNode;
        }

        iterations += 1;
      }

      var rankedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default()(Array.from(rootNode.childNodes)).sortBy('visits');

      if (this.debug) {
        var orderedNodes = lodash__WEBPACK_IMPORTED_MODULE_0___default()(Array.from(rootNode.childNodes)).sortBy('action.tileId');

        orderedNodes.forEach(function (n) {
          return console.log("".concat(n.visits, " => ").concat(n.wins, " wins :: tileId=").concat(n.action.tileId));
        });
      }

      return {
        bestAction: rankedNodes.last().action,
        iterations: iterations
      };
    }
  }]);

  return MonteCarloTreeSearch;
}();



/***/ }),

/***/ "./js/hexbusters/helpers.js":
/*!**********************************!*\
  !*** ./js/hexbusters/helpers.js ***!
  \**********************************/
/*! exports provided: getCurrentPlayer, isCurrentPlayer, getActions, getRandomAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentPlayer", function() { return getCurrentPlayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCurrentPlayer", function() { return isCurrentPlayer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getActions", function() { return getActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomAction", function() { return getRandomAction; });
/* harmony import */ var _actions_PlayerActions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actions/PlayerActions.js */ "./js/actions/PlayerActions.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);



var getCurrentPlayer = function getCurrentPlayer(state) {
  if (state.players === undefined || state.players.length === 0) {
    return null;
  }

  return state.players[state.currentPlayerIdx % state.numPlayers];
};

var isCurrentPlayer = function isCurrentPlayer(state, player) {
  if (state.players === undefined) {
    return false;
  }

  var currentPlayer = getCurrentPlayer(state);

  if (currentPlayer === null) {
    return false;
  }

  return currentPlayer.name === player.name;
};

var getActions = function getActions(state) {
  if (state.winner) {
    return [];
  }

  return state.tiles.neutral.toArray().map(function (tileId) {
    return Object(_actions_PlayerActions_js__WEBPACK_IMPORTED_MODULE_0__["tileChosen"])({
      tileId: tileId,
      colour: getCurrentPlayer(state).colour
    });
  });
};

var getRandomAction = function getRandomAction(state) {
  if (state.winner) {
    return null;
  } // Convert immutable.js set to an array.


  var neutralTiles = state.tiles.neutral.toArray();

  if (neutralTiles.length === 0) {
    return null;
  }

  return Object(_actions_PlayerActions_js__WEBPACK_IMPORTED_MODULE_0__["tileChosen"])({
    tileId: lodash__WEBPACK_IMPORTED_MODULE_1___default.a.sample(neutralTiles),
    colour: getCurrentPlayer(state).colour
  });
};



/***/ }),

/***/ "./js/hexbusters/init.js":
/*!*******************************!*\
  !*** ./js/hexbusters/init.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var hex_grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hex-grid */ "./node_modules/hex-grid/src/hex-grid.js");
/* harmony import */ var hex_grid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hex_grid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_Colours_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/Colours.js */ "./js/constants/Colours.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_3__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




 // We can't store the tiles as a Set because it's not supported in the web browser.
// "Set is not function".

/* harmony default export */ __webpack_exports__["default"] = (function (grid) {
  var _startTiles, _endTiles;

  return {
    currentPlayerIdx: 0,
    grid: grid,
    messages: [],
    numPlayers: 2,
    players: [],
    startTiles: (_startTiles = {}, _defineProperty(_startTiles, _constants_Colours_js__WEBPACK_IMPORTED_MODULE_1__["COLOUR_RED"], lodash__WEBPACK_IMPORTED_MODULE_2___default.a.chain(lodash__WEBPACK_IMPORTED_MODULE_2___default.a.range(0, grid.width)).flatMap(function (x) {
      return [Object(hex_grid__WEBPACK_IMPORTED_MODULE_0__["getTileIdByCoordinates"])(grid, x, 0)];
    }).value()), _defineProperty(_startTiles, _constants_Colours_js__WEBPACK_IMPORTED_MODULE_1__["COLOUR_BLUE"], lodash__WEBPACK_IMPORTED_MODULE_2___default.a.chain(lodash__WEBPACK_IMPORTED_MODULE_2___default.a.range(0, grid.height)).flatMap(function (y) {
      return [Object(hex_grid__WEBPACK_IMPORTED_MODULE_0__["getTileIdByCoordinates"])(grid, 0, y)];
    }).value()), _startTiles),
    endTiles: (_endTiles = {}, _defineProperty(_endTiles, _constants_Colours_js__WEBPACK_IMPORTED_MODULE_1__["COLOUR_RED"], lodash__WEBPACK_IMPORTED_MODULE_2___default.a.chain(lodash__WEBPACK_IMPORTED_MODULE_2___default.a.range(0, grid.width)).flatMap(function (x) {
      return [Object(hex_grid__WEBPACK_IMPORTED_MODULE_0__["getTileIdByCoordinates"])(grid, x, grid.height - 1)];
    }).value()), _defineProperty(_endTiles, _constants_Colours_js__WEBPACK_IMPORTED_MODULE_1__["COLOUR_BLUE"], lodash__WEBPACK_IMPORTED_MODULE_2___default.a.chain(lodash__WEBPACK_IMPORTED_MODULE_2___default.a.range(0, grid.height)).flatMap(function (y) {
      return [Object(hex_grid__WEBPACK_IMPORTED_MODULE_0__["getTileIdByCoordinates"])(grid, grid.width - 1, y)];
    }).value()), _endTiles),
    tiles: {
      neutral: new immutable__WEBPACK_IMPORTED_MODULE_3__["Set"](Object(hex_grid__WEBPACK_IMPORTED_MODULE_0__["getTileIds"])(grid)),
      blue: new immutable__WEBPACK_IMPORTED_MODULE_3__["Set"](),
      red: new immutable__WEBPACK_IMPORTED_MODULE_3__["Set"]()
    },
    winner: null
  };
});

/***/ }),

/***/ "./js/reducers/hexbusters.js":
/*!***********************************!*\
  !*** ./js/reducers/hexbusters.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return reduceGame; });
/* harmony import */ var _constants_ActionTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/ActionTypes.js */ "./js/constants/ActionTypes.js");
/* harmony import */ var _hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../hexbusters/helpers.js */ "./js/hexbusters/helpers.js");
/* harmony import */ var _hexbusters_init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../hexbusters/init.js */ "./js/hexbusters/init.js");
/* harmony import */ var _constants_Colours_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants/Colours.js */ "./js/constants/Colours.js");
/* harmony import */ var _constants_Grid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/Grid.js */ "./js/constants/Grid.js");
/* harmony import */ var hex_grid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hex-grid */ "./node_modules/hex-grid/src/hex-grid.js");
/* harmony import */ var hex_grid__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(hex_grid__WEBPACK_IMPORTED_MODULE_5__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function reduceTiles(tiles, tileId, currentPlayer) {
  return {
    red: currentPlayer.colour === _constants_Colours_js__WEBPACK_IMPORTED_MODULE_3__["COLOUR_RED"] ? tiles.red.add(tileId) : tiles.red,
    blue: currentPlayer.colour === _constants_Colours_js__WEBPACK_IMPORTED_MODULE_3__["COLOUR_BLUE"] ? tiles.blue.add(tileId) : tiles.blue,
    neutral: tiles.neutral.delete(tileId)
  };
}

function checkWin(tileId, colour, tiles, startTiles, endTiles, grid) {
  var colourTiles = colour === _constants_Colours_js__WEBPACK_IMPORTED_MODULE_3__["COLOUR_RED"] ? tiles.red : tiles.blue; // This improves performance enormously.

  var colourTilesObj = colourTiles.toObject();

  var pathFn = function pathFn(tileId) {
    return colourTilesObj[tileId] !== undefined;
  };

  var pathToStart = Object(hex_grid__WEBPACK_IMPORTED_MODULE_5__["hasPath"])(grid, [tileId], startTiles, {
    isPathable: pathFn
  });
  var pathToEnd = Object(hex_grid__WEBPACK_IMPORTED_MODULE_5__["hasPath"])(grid, [tileId], endTiles, {
    isPathable: pathFn
  });

  if (pathToStart && pathToEnd) {
    return colour;
  }

  return null;
}

function reduceGame(state, action) {
  if (state === undefined) {
    return Object(_hexbusters_init_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_constants_Grid_js__WEBPACK_IMPORTED_MODULE_4__["default"]);
  }

  switch (action.type) {
    case _constants_ActionTypes_js__WEBPACK_IMPORTED_MODULE_0__["PLAYERS_JOIN"]:
      return _objectSpread(_objectSpread({}, state), {}, {
        players: action.players
      });

    case _constants_ActionTypes_js__WEBPACK_IMPORTED_MODULE_0__["TILE_CHOSEN"]:
      if (state.winner) {
        console.log("Tried to choose a tile after the game is over!");
        return state;
      }

      if (state.tiles.neutral.contains(action.tileId) === false) {
        console.log('Tried to choose an occupied tile', action.tileId);
        return state;
      }

      if (action.colour !== Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_1__["getCurrentPlayer"])(state).colour) {
        console.log('Wrong player tried to go!');
        return state;
      }

      var currentPlayer = Object(_hexbusters_helpers_js__WEBPACK_IMPORTED_MODULE_1__["getCurrentPlayer"])(state);

      var ns = _objectSpread(_objectSpread({}, state), {}, {
        tiles: reduceTiles(state.tiles, action.tileId, currentPlayer),
        currentPlayerIdx: state.currentPlayerIdx + 1
      });

      ns.winner = checkWin(action.tileId, currentPlayer.colour, ns.tiles, ns.startTiles[currentPlayer.colour], ns.endTiles[currentPlayer.colour], ns.grid);
      return ns;

    default:
      return state;
  }
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js!./js/deciders/MonteCarloTreeSearchWebWorker.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./js/deciders/MonteCarloTreeSearchWebWorker.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MonteCarloTreeSearch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MonteCarloTreeSearch.js */ "./js/deciders/MonteCarloTreeSearch.js");
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.js");
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env worker */


/**
 * The slightly odd looking code with onmessage and postmessage is because when
 * this code is ran in a web worker those functions are globally defined. When
 * ran in the tests, they're not.
 */

function handleMessage(message) {
  console.log("[MonteCarloTreeSearchWebWorker] Got message", message);
  var messageObj = _typeof(message) === 'object' ? message.data : JSON.parse(message);

  switch (messageObj.action) {
    case 'getBestAction':
      // We can't store the tiles as a Set because it's not supported in the web browser.
      // "Set is not function".
      var debug = messageObj.debug,
          playerColour = messageObj.playerColour,
          state = messageObj.state,
          _messageObj$timeLimit = messageObj.timeLimitMs,
          timeLimitMs = _messageObj$timeLimit === void 0 ? 5000 : _messageObj$timeLimit; // Convert the immutable.js sets back to sets.

      state.tiles.neutral = new immutable__WEBPACK_IMPORTED_MODULE_1__["Set"](Object(immutable__WEBPACK_IMPORTED_MODULE_1__["fromJS"])(state.tiles.neutral));
      state.tiles.red = new immutable__WEBPACK_IMPORTED_MODULE_1__["Set"](Object(immutable__WEBPACK_IMPORTED_MODULE_1__["fromJS"])(state.tiles.red));
      state.tiles.blue = new immutable__WEBPACK_IMPORTED_MODULE_1__["Set"](Object(immutable__WEBPACK_IMPORTED_MODULE_1__["fromJS"])(state.tiles.blue));
      var mcts = new _MonteCarloTreeSearch_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
        timeLimitMs: timeLimitMs,
        debug: debug
      });
      var action = mcts.getBestAction(playerColour, state);
      console.log("Best action is", action);

      if (typeof postMessage !== 'undefined') {
        postMessage(action);
      }

      return action;

    default:
      console.warn("Unhandled message action: ".concat(message.data.action));
  }
}

if (typeof onmessage !== 'undefined') {
  console.log("Initialising onmessage");
  onmessage = handleMessage;
}

/* harmony default export */ __webpack_exports__["default"] = (handleMessage);

/***/ }),

/***/ "./node_modules/check-types/src/check-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/check-types/src/check-types.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*globals define, module, Symbol */

/**
 * This module exports functions for checking types
 * and throwing exceptions.
 */
(function (globals) {
  'use strict';

  var messages, predicates, functions, assert, not, maybe, either, collections, slice;
  messages = {
    like: 'Invalid type',
    instance: 'Invalid type',
    emptyObject: 'Invalid object',
    object: 'Invalid object',
    assigned: 'Invalid value',
    undefined: 'Invalid value',
    null: 'Invalid value',
    hasLength: 'Invalid length',
    emptyArray: 'Invalid array',
    array: 'Invalid array',
    arrayLike: 'Invalid array-like object',
    iterable: 'Invalid iterable',
    date: 'Invalid date',
    error: 'Invalid error',
    function: 'Invalid function',
    match: 'Invalid string',
    contains: 'Invalid string',
    unemptyString: 'Invalid string',
    string: 'Invalid string',
    odd: 'Invalid number',
    even: 'Invalid number',
    inRange: 'Invalid number',
    greaterOrEqual: 'Invalid number',
    lessOrEqual: 'Invalid number',
    between: 'Invalid number',
    greater: 'Invalid number',
    less: 'Invalid number',
    positive: 'Invalid number',
    negative: 'Invalid number',
    integer: 'Invalid number',
    zero: 'Invalid number',
    number: 'Invalid number',
    boolean: 'Invalid boolean'
  };
  predicates = {
    like: like,
    instance: instance,
    emptyObject: emptyObject,
    object: object,
    assigned: assigned,
    undefined: isUndefined,
    null: isNull,
    hasLength: hasLength,
    emptyArray: emptyArray,
    array: array,
    arrayLike: arrayLike,
    iterable: iterable,
    date: date,
    error: error,
    function: isFunction,
    match: match,
    contains: contains,
    unemptyString: unemptyString,
    string: string,
    odd: odd,
    even: even,
    inRange: inRange,
    greaterOrEqual: greaterOrEqual,
    lessOrEqual: lessOrEqual,
    between: between,
    greater: greater,
    less: less,
    positive: positive,
    negative: negative,
    integer: integer,
    zero: zero,
    number: number,
    boolean: boolean
  };
  functions = {
    apply: apply,
    map: map,
    all: all,
    any: any
  };
  collections = ['array', 'arrayLike', 'iterable', 'object'];
  slice = Array.prototype.slice;
  functions = mixin(functions, predicates);
  assert = createModifiedPredicates(assertModifier, assertImpl);
  not = createModifiedPredicates(notModifier, notImpl);
  maybe = createModifiedPredicates(maybeModifier, maybeImpl);
  either = createModifiedPredicates(eitherModifier);
  assert.not = createModifiedModifier(assertModifier, not);
  assert.maybe = createModifiedModifier(assertModifier, maybe);
  assert.either = createModifiedModifier(assertEitherModifier, predicates);
  collections.forEach(createOfPredicates);
  createOfModifiers(assert, assertModifier);
  createOfModifiers(not, notModifier);
  collections.forEach(createMaybeOfModifiers);
  exportFunctions(mixin(functions, {
    assert: assert,
    not: not,
    maybe: maybe,
    either: either
  }));
  /**
   * Public function `like`.
   *
   * Tests whether an object 'quacks like a duck'.
   * Returns `true` if the first argument has all of
   * the properties of the second, archetypal argument
   * (the 'duck'). Returns `false` otherwise.
   *
   */

  function like(data, duck) {
    var name;

    for (name in duck) {
      if (duck.hasOwnProperty(name)) {
        if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof duck[name]) {
          return false;
        }

        if (object(data[name]) && like(data[name], duck[name]) === false) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * Public function `instance`.
   *
   * Returns `true` if an object is an instance of a prototype,
   * `false` otherwise.
   *
   */


  function instance(data, prototype) {
    if (data && isFunction(prototype) && data instanceof prototype) {
      return true;
    }

    return false;
  }
  /**
   * Public function `emptyObject`.
   *
   * Returns `true` if something is an empty object,
   * `false` otherwise.
   *
   */


  function emptyObject(data) {
    return object(data) && Object.keys(data).length === 0;
  }
  /**
   * Public function `object`.
   *
   * Returns `true` if something is a plain-old JS object,
   * `false` otherwise.
   *
   */


  function object(data) {
    return Object.prototype.toString.call(data) === '[object Object]';
  }
  /**
   * Public function `assigned`.
   *
   * Returns `true` if something is not null or undefined,
   * `false` otherwise.
   *
   */


  function assigned(data) {
    return !isUndefined(data) && !isNull(data);
  }
  /**
   * Public function `undefined`.
   *
   * Returns `true` if something is undefined,
   * `false` otherwise.
   *
   */


  function isUndefined(data) {
    return data === undefined;
  }
  /**
   * Public function `null`.
   *
   * Returns `true` if something is null,
   * `false` otherwise.
   *
   */


  function isNull(data) {
    return data === null;
  }
  /**
   * Public function `hasLength`.
   *
   * Returns `true` if something is has a length property
   * that equals `value`, `false` otherwise.
   *
   */


  function hasLength(data, value) {
    return assigned(data) && data.length === value;
  }
  /**
   * Public function `emptyArray`.
   *
   * Returns `true` if something is an empty array,
   * `false` otherwise.
   *
   */


  function emptyArray(data) {
    return array(data) && data.length === 0;
  }
  /**
   * Public function `array`.
   *
   * Returns `true` something is an array,
   * `false` otherwise.
   *
   */


  function array(data) {
    return Array.isArray(data);
  }
  /**
   * Public function `arrayLike`.
   *
   * Returns `true` something is an array-like object,
   * `false` otherwise.
   *
   */


  function arrayLike(data) {
    return assigned(data) && number(data.length);
  }
  /**
   * Public function `iterable`.
   *
   * Returns `true` something is an iterable,
   * `false` otherwise.
   *
   */


  function iterable(data) {
    if (typeof Symbol === 'undefined') {
      // Fall back to arrayLike predicate in pre-ES6 environments.
      return arrayLike(data);
    }

    return assigned(data) && isFunction(data[Symbol.iterator]);
  }
  /**
   * Public function `date`.
   *
   * Returns `true` something is a valid date,
   * `false` otherwise.
   *
   */


  function date(data) {
    return Object.prototype.toString.call(data) === '[object Date]' && !isNaN(data.getTime());
  }
  /**
   * Public function `error`.
   *
   * Returns `true` if something is a plain-old JS object,
   * `false` otherwise.
   *
   */


  function error(data) {
    return Object.prototype.toString.call(data) === '[object Error]';
  }
  /**
   * Public function `function`.
   *
   * Returns `true` if something is function,
   * `false` otherwise.
   *
   */


  function isFunction(data) {
    return typeof data === 'function';
  }
  /**
   * Public function `match`.
   *
   * Returns `true` if something is a string
   * that matches `regex`, `false` otherwise.
   *
   */


  function match(data, regex) {
    return string(data) && !!data.match(regex);
  }
  /**
   * Public function `contains`.
   *
   * Returns `true` if something is a string
   * that contains `substring`, `false` otherwise.
   *
   */


  function contains(data, substring) {
    return string(data) && data.indexOf(substring) !== -1;
  }
  /**
   * Public function `unemptyString`.
   *
   * Returns `true` if something is a non-empty string,
   * `false` otherwise.
   *
   */


  function unemptyString(data) {
    return string(data) && data !== '';
  }
  /**
   * Public function `string`.
   *
   * Returns `true` if something is a string, `false` otherwise.
   *
   */


  function string(data) {
    return typeof data === 'string';
  }
  /**
   * Public function `odd`.
   *
   * Returns `true` if something is an odd number,
   * `false` otherwise.
   *
   */


  function odd(data) {
    return integer(data) && !even(data);
  }
  /**
   * Public function `even`.
   *
   * Returns `true` if something is an even number,
   * `false` otherwise.
   *
   */


  function even(data) {
    return number(data) && data % 2 === 0;
  }
  /**
   * Public function `integer`.
   *
   * Returns `true` if something is an integer,
   * `false` otherwise.
   *
   */


  function integer(data) {
    return number(data) && data % 1 === 0;
  }
  /**
   * Public function `inRange`.
   *
   * Returns `true` if something is a number in
   * the range `a` .. `b`, `false` otherwise.
   *
   */


  function inRange(data, a, b) {
    if (a < b) {
      return greaterOrEqual(data, a) && lessOrEqual(data, b);
    }

    return lessOrEqual(data, a) && greaterOrEqual(data, b);
  }
  /**
   * Public function `greaterOrEqual`.
   *
   * Returns `true` if something is a number greater
   * than or equal to `value`, `false` otherwise.
   *
   */


  function greaterOrEqual(data, value) {
    return number(data) && data >= value;
  }
  /**
   * Public function `lessOrEqual`.
   *
   * Returns `true` if something is a number less
   * than or equal to `value`, `false` otherwise.
   *
   */


  function lessOrEqual(data, value) {
    return number(data) && data <= value;
  }
  /**
   * Public function `between`.
   *
   * Returns `true` if something is a number
   * between `a` and `b`, `false` otherwise.
   *
   */


  function between(data, a, b) {
    if (a < b) {
      return greater(data, a) && less(data, b);
    }

    return less(data, a) && greater(data, b);
  }
  /**
   * Public function `greater`.
   *
   * Returns `true` if something is a number
   * greater than `value`, `false` otherwise.
   *
   */


  function greater(data, value) {
    return number(data) && data > value;
  }
  /**
   * Public function `less`.
   *
   * Returns `true` if something is a number
   * less than `value`, `false` otherwise.
   *
   */


  function less(data, value) {
    return number(data) && data < value;
  }
  /**
   * Public function `positive`.
   *
   * Returns `true` if something is a positive number,
   * `false` otherwise.
   *
   */


  function positive(data) {
    return greater(data, 0);
  }
  /**
   * Public function `negative`.
   *
   * Returns `true` if something is a negative number,
   * `false` otherwise.
   *
   * @param data          The thing to test.
   */


  function negative(data) {
    return less(data, 0);
  }
  /**
   * Public function `number`.
   *
   * Returns `true` if data is a number,
   * `false` otherwise.
   *
   */


  function number(data) {
    return typeof data === 'number' && isNaN(data) === false && data !== Number.POSITIVE_INFINITY && data !== Number.NEGATIVE_INFINITY;
  }
  /**
   * Public function `zero`.
   *
   * Returns `true` if something is zero,
   * `false` otherwise.
   *
   * @param data          The thing to test.
   */


  function zero(data) {
    return data === 0;
  }
  /**
   * Public function `boolean`.
   *
   * Returns `true` if data is a boolean value,
   * `false` otherwise.
   *
   */


  function boolean(data) {
    return data === false || data === true;
  }
  /**
   * Public function `apply`.
   *
   * Maps each value from the data to the corresponding predicate and returns
   * the result array. If the same function is to be applied across all of the
   * data, a single predicate function may be passed in.
   *
   */


  function apply(data, predicates) {
    assert.array(data);

    if (isFunction(predicates)) {
      return data.map(function (value) {
        return predicates(value);
      });
    }

    assert.array(predicates);
    assert.hasLength(data, predicates.length);
    return data.map(function (value, index) {
      return predicates[index](value);
    });
  }
  /**
   * Public function `map`.
   *
   * Maps each value from the data to the corresponding predicate and returns
   * the result object. Supports nested objects. If the data is not nested and
   * the same function is to be applied across all of it, a single predicate
   * function may be passed in.
   *
   */


  function map(data, predicates) {
    assert.object(data);

    if (isFunction(predicates)) {
      return mapSimple(data, predicates);
    }

    assert.object(predicates);
    return mapComplex(data, predicates);
  }

  function mapSimple(data, predicate) {
    var result = {};
    Object.keys(data).forEach(function (key) {
      result[key] = predicate(data[key]);
    });
    return result;
  }

  function mapComplex(data, predicates) {
    var result = {};
    Object.keys(predicates).forEach(function (key) {
      var predicate = predicates[key];

      if (isFunction(predicate)) {
        if (not.assigned(data)) {
          result[key] = !!predicate._isMaybefied;
        } else {
          result[key] = predicate(data[key]);
        }
      } else if (object(predicate)) {
        result[key] = mapComplex(data[key], predicate);
      }
    });
    return result;
  }
  /**
   * Public function `all`
   *
   * Check that all boolean values are true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */


  function all(data) {
    if (array(data)) {
      return testArray(data, false);
    }

    assert.object(data);
    return testObject(data, false);
  }

  function testArray(data, result) {
    var i;

    for (i = 0; i < data.length; i += 1) {
      if (data[i] === result) {
        return result;
      }
    }

    return !result;
  }

  function testObject(data, result) {
    var key, value;

    for (key in data) {
      if (data.hasOwnProperty(key)) {
        value = data[key];

        if (object(value) && testObject(value, result) === result) {
          return result;
        }

        if (value === result) {
          return result;
        }
      }
    }

    return !result;
  }
  /**
   * Public function `any`
   *
   * Check that at least one boolean value is true
   * in an array (returned from `apply`)
   * or object (returned from `map`).
   *
   */


  function any(data) {
    if (array(data)) {
      return testArray(data, true);
    }

    assert.object(data);
    return testObject(data, true);
  }

  function mixin(target, source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
    return target;
  }
  /**
   * Public modifier `assert`.
   *
   * Throws if `predicate` returns `false`.
   */


  function assertModifier(predicate, defaultMessage) {
    return function () {
      assertPredicate(predicate, arguments, defaultMessage);
    };
  }

  function assertPredicate(predicate, args, defaultMessage) {
    var message = args[args.length - 1];
    assertImpl(predicate.apply(null, args), unemptyString(message) ? message : defaultMessage);
  }

  function assertImpl(value, message) {
    if (value === false) {
      throw new Error(message || 'Assertion failed');
    }
  }

  function assertEitherModifier(predicate, defaultMessage) {
    return function () {
      var error;

      try {
        assertPredicate(predicate, arguments, defaultMessage);
      } catch (e) {
        error = e;
      }

      return {
        or: Object.keys(predicates).reduce(delayedAssert, {})
      };

      function delayedAssert(result, key) {
        result[key] = function () {
          if (error && !predicates[key].apply(null, arguments)) {
            throw error;
          }
        };

        return result;
      }
    };
  }
  /**
   * Public modifier `not`.
   *
   * Negates `predicate`.
   */


  function notModifier(predicate) {
    return function () {
      return notImpl(predicate.apply(null, arguments));
    };
  }

  function notImpl(value) {
    return !value;
  }
  /**
   * Public modifier `maybe`.
   *
   * Returns `true` if predicate argument is  `null` or `undefined`,
   * otherwise propagates the return value from `predicate`.
   */


  function maybeModifier(predicate) {
    var modifiedPredicate = function () {
      if (!assigned(arguments[0])) {
        return true;
      }

      return predicate.apply(null, arguments);
    }; // Hackishly indicate that this is a maybe.xxx predicate.
    // Without this flag, the alternative would be to iterate
    // through the maybe predicates or use indexOf to check,
    // which would be time-consuming.


    modifiedPredicate._isMaybefied = true;
    return modifiedPredicate;
  }

  function maybeImpl(value) {
    if (assigned(value) === false) {
      return true;
    }

    return value;
  }
  /**
   * Public modifier `either`.
   *
   * Returns `true` if either predicate is true.
   */


  function eitherModifier(predicate) {
    return function () {
      var shortcut = predicate.apply(null, arguments);
      return {
        or: Object.keys(predicates).reduce(nopOrPredicate, {})
      };

      function nopOrPredicate(result, key) {
        result[key] = shortcut ? nop : predicates[key];
        return result;
      }
    };

    function nop() {
      return true;
    }
  }
  /**
   * Public modifier `of`.
   *
   * Applies the chained predicate to members of the collection.
   */


  function ofModifier(target, type, predicate) {
    return function () {
      var collection, args;
      collection = arguments[0];

      if (!type(collection)) {
        return false;
      }

      collection = coerceCollection(type, collection);
      args = slice.call(arguments, 1);

      try {
        collection.forEach(function (item) {
          if ((target !== 'maybe' || assigned(item)) && !predicate.apply(null, [item].concat(args))) {
            // HACK: Ideally we'd use a for...of loop and return here,
            //       but that syntax is not supported by ES5. We could
            //       use a transpiler and a build step but I'm happy
            //       enough with this until ES6 is the baseline.
            throw 0;
          }
        });
      } catch (ignore) {
        return false;
      }

      return true;
    };
  }

  function coerceCollection(type, collection) {
    switch (type) {
      case arrayLike:
        return slice.call(collection);

      case object:
        return Object.keys(collection).map(function (key) {
          return collection[key];
        });

      default:
        return collection;
    }
  }

  function createModifiedPredicates(modifier, object) {
    return createModifiedFunctions([modifier, predicates, object]);
  }

  function createModifiedFunctions(args) {
    var modifier, object, functions, result;
    modifier = args.shift();
    object = args.pop();
    functions = args.pop();
    result = object || {};
    Object.keys(functions).forEach(function (key) {
      Object.defineProperty(result, key, {
        configurable: false,
        enumerable: true,
        writable: false,
        value: modifier.apply(null, args.concat(functions[key], messages[key]))
      });
    });
    return result;
  }

  function createModifiedModifier(modifier, modified) {
    return createModifiedFunctions([modifier, modified, null]);
  }

  function createOfPredicates(key) {
    predicates[key].of = createModifiedFunctions([ofModifier.bind(null, null), predicates[key], predicates, null]);
  }

  function createOfModifiers(base, modifier) {
    collections.forEach(function (key) {
      base[key].of = createModifiedModifier(modifier, predicates[key].of);
    });
  }

  function createMaybeOfModifiers(key) {
    maybe[key].of = createModifiedFunctions([ofModifier.bind(null, 'maybe'), predicates[key], predicates, null]);
    assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
    assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
  }

  function exportFunctions(functions) {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return functions;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  }
})(this);

/***/ }),

/***/ "./node_modules/hex-grid/src/hex-grid.js":
/*!***********************************************!*\
  !*** ./node_modules/hex-grid/src/hex-grid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// vim: expandtab:ts=2:sw=2

/**
 * The valid directions for each orientation.
 *
 * The pointy-topped orientation does not have the concept of "north" for
 * example.
 */
var _validDirections = {
  'flat-topped': ['north', 'northeast', 'southeast', 'south', 'southwest', 'northwest'],
  'pointy-topped': ['northeast', 'east', 'southeast', 'southwest', 'west', 'northwest']
};
/**
 * The valid layouts for each orientation.
 */

var _validLayouts = {
  'flat-topped': ['odd-q', 'even-q'],
  'pointy-topped': ['odd-r', 'even-r']
};
var _validShapes = ['rectangle', 'parallelogram'];
/**
 * Validate that the grid settings.
 * @param {object} settings The hex grid settings.
 * @param {number} settings.width The width of the grid, in hexes.
 * @param {number} settings.height The height of the grid, in hexes.
 * @param {string} settings.orientation The orientation of the hexes, either
 * "flat-topped" or "pointy-topped".
 * @param {string} settings.layout The layout of the hexes. For flat-topped,
 * either "odd-q" or "even-q". For pointy-topped, either "odd-r" or "even-r".
 * @param {string} [settings.shape=rectangle] The shape of the hex grid. Should
 * be either "rectangle" or "parallelogram".
 * @throws Error When the settings are invalid.
 */

function validateSettings(settings) {
  if (typeof settings !== 'object') {
    throw new Error('settings must be an object. Got ' + typeof settings);
  }

  if (typeof settings.width !== 'number') {
    throw new Error('settings.width must be a number. Got ' + typeof width);
  }

  if (typeof settings.height !== 'number') {
    throw new Error('settings.height must be a number. Got ' + typeof height);
  }

  if (_validLayouts[settings.orientation] === undefined) {
    throw new Error('Invalid orientation: ' + settings.orientation + '. Must be one of: ' + Object.keys(_validLayouts) + '.');
  }

  if (_validLayouts[settings.orientation].indexOf(settings.layout) === -1) {
    throw new Error('Invalid layout for given orientation: ' + settings.layout + '. Must be one of: ' + _validLayouts[settings.orientation] + '.');
  }

  if (settings.shape && _validShapes.indexOf(settings.shape) === -1) {
    throw new Error('Invalid shape. Must be one of: ' + _validShapes);
  }
}
/**
 * Returns an array of tileIds.
 * @param {object} settings The hex grid settings.
 */


function getTileIds(settings) {
  if (settings.validate !== false) {
    validateSettings(settings);
  }

  var tileIds = [];

  for (var x = 0; x < settings.width; x += 1) {
    for (var y = 0; y < settings.height; y += 1) {
      tileIds.push(getTileIdByCoordinates(settings, x, y));
    }
  }

  return tileIds;
}
/**
 * Returns whether a coordinate is within the grid boundaries.
 * @param {object} settings The hex grid settings.
 * @param {number} x The X coordinate.
 * @param {number} y The Y coordinate.
 * @return {bool} Whether the coordinate is within the boundaries of the
 * grid.
 */


function isWithinBoundaries(settings, x, y) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof x !== 'number') {
      throw new Error('x must be a number. Got ' + typeof x);
    }

    if (typeof y !== 'number') {
      throw new Error('x must be a number. Got ' + typeof y);
    }
  }

  return x <= settings.width - 1 && x >= 0 && y <= settings.height - 1 && y >= 0;
}
/**
 * Gets the tileId given the coordinates.
 * @param {object} settings The hex grid settings.
 * @param {number} x The X coordinate.
 * @param {number} y The Y coordinate.
 * @return {tile|null} The tile. Null if not a valid coordinate.
 */


function getTileIdByCoordinates(settings, x, y) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof x !== 'number') {
      throw new Error('x must be a number. Got ' + typeof x);
    }

    if (typeof y !== 'number') {
      throw new Error('x must be a number. Got ' + typeof y);
    }
  }

  if (isWithinBoundaries(settings, x, y) === false) {
    return null;
  }

  var id = y * settings.width + x;
  return id;
}
/**
 * Whether a given direction is valid for this map layout.
 * @param {object} settings The hex grid settings.
 * @param {string} direction The direction to check.
 * @return {bool} Whether the direction is valid.
 */


function isValidDirection(settings, direction) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof direction !== 'string') {
      throw new Error('direction must be a string. Got ' + typeof direction);
    }
  }

  return _validDirections[settings.orientation].indexOf(direction) >= 0;
}
/**
 * Gets the coordinates of a tile given its ID.
 * @param {object} settings The hex grid settings.
 * @param {string} tileId The ID of the tile.
 * @return {object|null} An object with x and y properties.
 * @throws Error If the tileId is not valid.
 */


function getTileCoordinatesById(settings, tileId) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof tileId !== 'number') {
      throw new Error('tileId must be a number. Got ' + typeof tileId);
    }
  }

  return {
    x: tileId % settings.width,
    y: Math.floor(tileId / settings.width)
  };
}
/**
 * Gets a tile's neighbour given its coordinates and a direction.
 * @param {object} settings The grid settings.
 * @param {number} x The X coordinate of the tile.
 * @param {number} y The Y coordinate of the tile.
 * @param {string} dir A direction. One of: north, northeast, east,
 * southeast, south, southwest, west, northwest.
 * @return {object|null} The neighbouring tile.
 */


function getNeighbourTileIdByCoordinates(settings, x, y, dir) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (isValidDirection(settings, dir) === false) {
      throw new Error('Not a valid direction: ' + dir);
    }
  }

  var rowIsEven = y % 2 === 0;
  var colIsEven = x % 2 === 0;
  var xOffset = 0;

  if (settings.orientation === 'flat-topped' || settings.layout === 'odd-r' && rowIsEven === false && (dir === 'northeast' || dir === 'southeast') || settings.layout === 'odd-r' && rowIsEven === true && (dir === 'northwest' || dir === 'southwest') || settings.layout === 'even-r' && rowIsEven === true && (dir === 'northeast' || dir === 'southeast') || settings.layout === 'even-r' && rowIsEven === false && (dir === 'northwest' || dir === 'southwest')) {
    xOffset = 1;
  }

  var yOffset = 0;

  if (settings.orientation === 'pointy-topped' || settings.layout === 'odd-q' && colIsEven === false && (dir === 'northeast' || dir === 'southeast') || settings.layout === 'odd-q' && colIsEven === true && (dir === 'northwest' || dir === 'southwest') || settings.layout === 'even-q' && colIsEven === true && (dir === 'northeast' || dir === 'southeast') || settings.layout === 'even-q' && colIsEven === false && (dir === 'northwest' || dir === 'southwest')) {
    yOffset = 1;
  }

  var xP = 0;

  if (settings.shape && settings.shape === 'parallelogram') {
    if (rowIsEven) {
      if (dir === 'north' || dir === 'northwest' || dir === 'northeast') {
        xP = 1;
      } else {
        xP = 0;
      }
    } else {
      if (dir === 'south' || dir === 'southwest' || dir === 'southeast') {
        xP = -1;
      }
    }
  }

  var offsets = {
    'north': {
      x: 0,
      y: -1
    },
    'east': {
      x: +1,
      y: 0
    },
    'south': {
      x: 0,
      y: +1
    },
    'west': {
      x: -1,
      y: 0
    },
    'northeast': {
      x: xOffset + xP,
      y: yOffset * -1
    },
    'southeast': {
      x: xOffset + xP,
      y: yOffset
    },
    'southwest': {
      x: xOffset * -1 + xP,
      y: yOffset
    },
    'northwest': {
      x: xOffset * -1 + xP,
      y: yOffset * -1
    }
  };
  var offset = offsets[dir];
  return getTileIdByCoordinates(settings, x + offset.x, y + offset.y);
}
/**
 * Gets a tile's neighbour given the tile's ID and a direction.
 * @param {object} settings The grid settings.
 * @param {string} tileId The tile's ID.
 * @param {string} direction A direction. One of: north, northeast, east,
 * southeast, south, southwest, west, northwest.
 * @return {object|null} The neighbouring tile.
 */


function getNeighbourIdByTileId(settings, tileId, direction) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof tileId !== 'number') {
      throw new Error('tileId must be a number. Got ' + typeof tileId);
    }

    if (typeof direction !== 'string') {
      throw new Error('dir must be a string. Got ' + typeof direction);
    }
  }

  var coords = getTileCoordinatesById(settings, tileId);
  return getNeighbourTileIdByCoordinates(settings, coords.x, coords.y, direction);
}
/**
 * Gets IDs all neighbours of a tile given the tile's ID.
 * @param {object} settings The grid settings.
 * @param {string} tileId The tile's ID.
 * @return {number[]} The neighbouring tiles' IDs.
 */


function getNeighbourIdsByTileId(settings, tileId) {
  if (settings.validate !== false) {
    validateSettings(settings);
  }

  var coords = getTileCoordinatesById(settings, tileId);

  if (settings.orientation === 'pointy-topped' && settings.shape === 'parallelogram') {
    var neighbourIds = [];

    if (coords.x > 0) {
      // West.
      neighbourIds.push(tileId - 1); // Southwest.

      if (coords.y < settings.height - 1) {
        neighbourIds.push(tileId + settings.width - 1);
      }
    }

    if (coords.x < settings.width - 1) {
      // East.
      neighbourIds.push(tileId + 1); // Northeast.

      if (coords.y > 0) {
        neighbourIds.push(1 + tileId - settings.width);
      }
    } // Northwest.


    if (coords.y > 0) {
      neighbourIds.push(tileId - settings.width);
    } // Southeast.


    if (coords.y < settings.height - 1) {
      neighbourIds.push(tileId + settings.width);
    }

    return neighbourIds;
  }

  return _validDirections[settings.orientation].map(function (dir) {
    return getNeighbourTileIdByCoordinates(settings, coords.x, coords.y, dir);
  }).filter(function (tile) {
    return tile !== null;
  });
}
/**
 * Gets the position of a tile by its coordinates. Due to the way
 * hexagonal grids work, the position of half of the tiles are offset by
 * 0.5.
 * @param {number} x The X coordinate of the tile.
 * @param {number} y The Y coordinate of the tile.
 * @return {object} An object with x and y properties.
 */


function getTilePositionByCoords(settings, x, y) {
  if (settings.validate !== false) {
    validateSettings(settings);
  }

  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('x and y must be integers');
  }

  var xOffset = 0,
      yOffset = 0;

  switch (settings.layout) {
    // Flat top.
    case 'odd-q':
      // Odd columns are offset by half.
      if (x % 2 === 1) {
        yOffset += 0.5;
      }

      break;

    case 'even-q':
      // Even columns are offset by half.
      if (x % 2 === 0) {
        yOffset += 0.5;
      }

      break;
    // Pointy top.

    case 'odd-r':
      // Odd rows are offset by half.
      if (y % 2 === 1) {
        xOffset += 0.5;
      }

      break;

    case 'even-r':
      // Even rows are offset by half.
      if (y % 2 === 0) {
        xOffset += 0.5;
      }

      break;

    default:
      throw new Error('getTilePositionByCoords is not implemented for ' + settings.layout + '.');
  }

  if (settings.shape && settings.shape === 'parallelogram') {
    xOffset += Math.floor(y / 2);
  }

  return {
    x: x + xOffset,
    y: y + yOffset
  };
}
/**
 * Gets the position of a tile by its ID.
 * @param {object} settings The grid settings.
 * @param {string} tileId The tile's ID.
 * @return {object} An object with x and y properties.
 */


function getTilePositionById(settings, tileId) {
  var coords = getTileCoordinatesById(settings, tileId);
  return getTilePositionByCoords(settings, coords.x, coords.y);
}
/**
 * Gets shortest paths from a given starting tile to all other reachable tiles.
 *
 * @param {object} settings The grid settings.
 * @param {string} tileId The tile's ID.
 * @param {object} options An options object.
 * @param {number} options.maxCost The maximum allowed cost of a path,
 * or POSITIVE_INFINITY if not specified. If specified, a pathCost function
 * must be provided.
 * @param {number|function} options.moveCost The cost of moving from one tile
 * to another. If a function is provided, it is called like
 * `options.pathCost(fromTileId, toTileId)` and it should return the cost of
 * moving from fromTile to toTile. Defaults to 1.
 * @param {function} options.isPathable An optional function which says
 * whether a tile is pathable. It is called like `options.pathable(tileId)`
 * and should return either true or false.
 * @return {object} An object where the keys are the final tileId in a path
 * and the values are Path objects. The Path object looks like this:
 * {
 *    tileIds: [tileId1, tileId2, ..., tileIdN],
 *    cost: 0
 * }
 *
 * The tileIds are the tile IDs traversed in order, including the starting
 * and final tile.
 *
 * The cost it the total cost of traversing the path. The cost of each step
 * of the path is determined by calling options.pathCost(fromTile, toTile),
 * or 0 if options.pathCost is not supplied.
 *
 * The zero-length path from a tile to itself is not returned.
 */


function getShortestPathsFromTileId(settings, tileId, options) {
  if (settings.validate !== false) {
    validateSettings(settings);

    if (typeof tileId !== 'number') {
      throw new Error('tileId must be a string, got: ' + typeof tileId);
    }
  }

  options = options || {};
  var maxPathCost = options.maxCost;

  if (maxPathCost === undefined) {
    maxPathCost = Number.POSITIVE_INFINITY;
  }

  var moveCost = options.moveCost;

  if (moveCost === undefined) {
    moveCost = 1;
  } // Start with the input tile as the frontier tile and explore from there.


  var frontierTileIds = [tileId]; // For each tile, record the previous tile.

  var from = {};
  from[tileId] = null; // For each destination tile store a Path object.

  var path = {};

  while (frontierTileIds.length) {
    var frontierTileId = frontierTileIds.shift();

    if (path[frontierTileId] === undefined) {
      path[frontierTileId] = {
        tileIds: [frontierTileId],
        cost: 0
      };
    }

    getNeighbourIdsByTileId(settings, frontierTileId).forEach(function expandSearch(neighbourTileId) {
      // Path is too costly.
      if (path[frontierTileId].cost > maxPathCost) {
        return;
      } // Already found a path to tile.id. Breadth-first search
      // guarantees it is shorter.


      if (from[neighbourTileId] !== undefined) {
        return;
      } // Tile is not pathable.


      if (typeof options.isPathable === 'function' && options.isPathable(neighbourTileId) === false) {
        return;
      }

      var cost = null;

      if (typeof moveCost === 'function') {
        cost = moveCost(frontierTileId, neighbourTileId);

        if (typeof cost !== 'number') {
          throw new Error('options.moveCost(fromTileId, toTileId) did not return a number.');
        }
      } else {
        cost = moveCost;
      }

      var pathCost = path[frontierTileId].cost + cost;

      if (pathCost > maxPathCost) {
        return;
      }

      from[neighbourTileId] = frontierTileId;
      path[neighbourTileId] = {
        cost: pathCost,
        tileIds: path[frontierTileId].tileIds.concat([neighbourTileId])
      };
      frontierTileIds.push(neighbourTileId);
    });
  } // Exclude the 0 length path.


  delete path[tileId];
  return path;
}

function hasPath(settings, startTiles, endTiles, options) {
  var i, j, frontierNeighbours;
  var visited = {};
  var endTilesObj = {};

  for (i = 0; i < endTiles.length; i += 1) {
    if (options.isPathable(endTiles[i])) {
      endTilesObj[endTiles[i]] = true;
    }
  }

  var frontierTiles = [];

  for (i = 0; i < startTiles.length; i += 1) {
    if (options.isPathable(startTiles[i])) {
      frontierTiles.push(startTiles[i]);
    }
  }

  while (frontierTiles.length > 0) {
    for (i = 0; i < frontierTiles.length; i += 1) {
      visited[frontierTiles[i]] = true;

      if (endTilesObj[frontierTiles[i]] === true) {
        return true;
      }
    }

    frontierNeighbours = [];

    for (i = 0; i < frontierTiles.length; i += 1) {
      var neighbours = getNeighbourIdsByTileId(settings, frontierTiles[i]);

      for (j = 0; j < neighbours.length; j += 1) {
        if (options.isPathable(neighbours[j]) && frontierNeighbours.indexOf(neighbours[j]) === -1 && visited[neighbours[j]] === undefined) {
          frontierNeighbours.push(neighbours[j]);
        }
      }
    }

    frontierTiles = frontierNeighbours;
  }

  return false;
}

module.exports = {
  validateSettings: validateSettings,
  getTileIds: getTileIds,
  isWithinBoundaries: isWithinBoundaries,
  getTileIdByCoordinates: getTileIdByCoordinates,
  isValidDirection: isValidDirection,
  getTileCoordinatesById: getTileCoordinatesById,
  getNeighbourTileIdByCoordinates: getNeighbourTileIdByCoordinates,
  getNeighbourIdByTileId: getNeighbourIdByTileId,
  getNeighbourIdsByTileId: getNeighbourIdsByTileId,
  getTilePositionByCoords: getTilePositionByCoords,
  getTilePositionById: getTilePositionById,
  getShortestPathsFromTileId: getShortestPathsFromTileId,
  hasPath: hasPath
};

/***/ }),

/***/ "./node_modules/immutable/dist/immutable.js":
/*!**************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) {
   true ? module.exports = factory() : undefined;
})(this, function () {
  'use strict';

  var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }

    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
    return isIterable(value) ? value : Seq(value);
  }

  createClass(KeyedIterable, Iterable);

  function KeyedIterable(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  createClass(IndexedIterable, Iterable);

  function IndexedIterable(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  createClass(SetIterable, Iterable);

  function SetIterable(value) {
    return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;
  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;
  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@'; // Used for setting prototype methods that IE8 chokes on.

  var DELETE = 'delete'; // Constants describing the size of trie nodes.

  var SHIFT = 5; // Resulted in best performance after ______?

  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1; // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.

  var NOT_SET = {}; // Boolean references, Rough equivalent of `bool &`.

  var CHANGE_LENGTH = {
    value: false
  };
  var DID_ALTER = {
    value: false
  };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  } // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.


  function OwnerID() {} // http://jsperf.com/copy-array-inline


  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);

    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }

    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }

    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32−1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32

      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }

      index = uint32Index;
    }

    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
  }
  /* global Symbol */


  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;
  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

  function Iterator(next) {
    this.next = next;
  }

  Iterator.prototype.toString = function () {
    return '[Iterator]';
  };

  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
    return this.toString();
  };

  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };

  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? iteratorResult.value = value : iteratorResult = {
      value: value,
      done: false
    };
    return iteratorResult;
  }

  function iteratorDone() {
    return {
      value: undefined,
      done: true
    };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);

    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);

  function Seq(value) {
    return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
  }

  Seq.of = function () {
    return Seq(arguments);
  };

  Seq.prototype.toSeq = function () {
    return this;
  };

  Seq.prototype.toString = function () {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function () {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }

    return this;
  }; // abstract __iterateUncached(fn, reverse)


  Seq.prototype.__iterate = function (fn, reverse) {
    return seqIterate(this, fn, reverse, true);
  }; // abstract __iteratorUncached(type, reverse)


  Seq.prototype.__iterator = function (type, reverse) {
    return seqIterator(this, type, reverse, true);
  };

  createClass(KeyedSeq, Seq);

  function KeyedSeq(value) {
    return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
  }

  KeyedSeq.prototype.toKeyedSeq = function () {
    return this;
  };

  createClass(IndexedSeq, Seq);

  function IndexedSeq(value) {
    return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
  }

  IndexedSeq.of = function () {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function () {
    return this;
  };

  IndexedSeq.prototype.toString = function () {
    return this.__toString('Seq [', ']');
  };

  IndexedSeq.prototype.__iterate = function (fn, reverse) {
    return seqIterate(this, fn, reverse, false);
  };

  IndexedSeq.prototype.__iterator = function (type, reverse) {
    return seqIterator(this, type, reverse, false);
  };

  createClass(SetSeq, Seq);

  function SetSeq(value) {
    return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
  }

  SetSeq.of = function () {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function () {
    return this;
  };

  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;
  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
  Seq.prototype[IS_SEQ_SENTINEL] = true;
  createClass(ArraySeq, IndexedSeq);

  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  ArraySeq.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function (fn, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;

    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  ArraySeq.prototype.__iterator = function (type, reverse) {
    var array = this._array;
    var maxIndex = array.length - 1;
    var ii = 0;
    return new Iterator(function () {
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
    });
  };

  createClass(ObjectSeq, KeyedSeq);

  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  ObjectSeq.prototype.get = function (key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }

    return this._object[key];
  };

  ObjectSeq.prototype.has = function (key) {
    return this._object.hasOwnProperty(key);
  };

  ObjectSeq.prototype.__iterate = function (fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;

    for (var ii = 0; ii <= maxIndex; ii++) {
      var key = keys[reverse ? maxIndex - ii : ii];

      if (fn(object[key], key, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  ObjectSeq.prototype.__iterator = function (type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;
    var ii = 0;
    return new Iterator(function () {
      var key = keys[reverse ? maxIndex - ii : ii];
      return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
    });
  };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
  createClass(IterableSeq, IndexedSeq);

  function IterableSeq(iterable) {
    this._iterable = iterable;
    this.size = iterable.length || iterable.size;
  }

  IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterable = this._iterable;
    var iterator = getIterator(iterable);
    var iterations = 0;

    if (isIterator(iterator)) {
      var step;

      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }

    return iterations;
  };

  IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterable = this._iterable;
    var iterator = getIterator(iterable);

    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }

    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  createClass(IteratorSeq, IndexedSeq);

  function IteratorSeq(iterator) {
    this._iterator = iterator;
    this._iteratorCache = [];
  }

  IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }

    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;

    while (iterations < cache.length) {
      if (fn(cache[iterations], iterations++, this) === false) {
        return iterations;
      }
    }

    var step;

    while (!(step = iterator.next()).done) {
      var val = step.value;
      cache[iterations] = val;

      if (fn(val, iterations++, this) === false) {
        break;
      }
    }

    return iterations;
  };

  IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }

    var iterator = this._iterator;
    var cache = this._iteratorCache;
    var iterations = 0;
    return new Iterator(function () {
      if (iterations >= cache.length) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        cache[iterations] = step.value;
      }

      return iteratorValue(type, iterations, cache[iterations++]);
    });
  }; // # pragma Helper functions


  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
    }

    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of values: ' + value);
    }

    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) || typeof value === 'object' && new ObjectSeq(value);

    if (!seq) {
      throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
    }

    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;

    if (cache) {
      var maxIndex = cache.length - 1;

      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];

        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }

      return ii;
    }

    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;

    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function () {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }

    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ? fromJSWith(converter, json, '', {
      '': json
    }) : fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
        return fromJSWith(converter, v, k, json);
      }));
    }

    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
        return fromJSWith(converter, v, k, json);
      }));
    }

    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }

    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }

    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }
  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */


  function is(valueA, valueB) {
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }

    if (!valueA || !valueB) {
      return false;
    }

    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();

      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }

      if (!valueA || !valueB) {
        return false;
      }
    }

    if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
      return true;
    }

    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function (v, k) {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;

    var bSize = b.__iterate(function (v, k) {
      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }

    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);

    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }

      EMPTY_REPEAT = this;
    }
  }

  Repeat.prototype.toString = function () {
    if (this.size === 0) {
      return 'Repeat []';
    }

    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function (searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function (begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
  };

  Repeat.prototype.reverse = function () {
    return this;
  };

  Repeat.prototype.indexOf = function (searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }

    return -1;
  };

  Repeat.prototype.lastIndexOf = function (searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }

    return -1;
  };

  Repeat.prototype.__iterate = function (fn, reverse) {
    for (var ii = 0; ii < this.size; ii++) {
      if (fn(this._value, ii, this) === false) {
        return ii + 1;
      }
    }

    return ii;
  };

  Repeat.prototype.__iterator = function (type, reverse) {
    var this$0 = this;
    var ii = 0;
    return new Iterator(function () {
      return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
    });
  };

  Repeat.prototype.equals = function (other) {
    return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
  };

  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }

    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;

    if (end === undefined) {
      end = Infinity;
    }

    step = step === undefined ? 1 : Math.abs(step);

    if (end < start) {
      step = -step;
    }

    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);

    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }

      EMPTY_RANGE = this;
    }
  }

  Range.prototype.toString = function () {
    if (this.size === 0) {
      return 'Range []';
    }

    return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
  };

  Range.prototype.get = function (index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };

  Range.prototype.includes = function (searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };

  Range.prototype.slice = function (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);

    if (end <= begin) {
      return new Range(0, 0);
    }

    return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  };

  Range.prototype.indexOf = function (searchValue) {
    var offsetValue = searchValue - this._start;

    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;

      if (index >= 0 && index < this.size) {
        return index;
      }
    }

    return -1;
  };

  Range.prototype.lastIndexOf = function (searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function (fn, reverse) {
    var maxIndex = this.size - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;

    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(value, ii, this) === false) {
        return ii + 1;
      }

      value += reverse ? -step : step;
    }

    return ii;
  };

  Range.prototype.__iterator = function (type, reverse) {
    var maxIndex = this.size - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;
    var ii = 0;
    return new Iterator(function () {
      var v = value;
      value += reverse ? -step : step;
      return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
    });
  };

  Range.prototype.equals = function (other) {
    return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };

  var EMPTY_RANGE;
  createClass(Collection, Iterable);

  function Collection() {
    throw TypeError('Abstract');
  }

  createClass(KeyedCollection, Collection);

  function KeyedCollection() {}

  createClass(IndexedCollection, Collection);

  function IndexedCollection() {}

  createClass(SetCollection, Collection);

  function SetCollection() {}

  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;
  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
    a = a | 0; // int

    b = b | 0; // int

    var c = a & 0xffff;
    var d = b & 0xffff; // Shift by 0 fixes the sign on the high part.

    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
  }; // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.

  function smi(i32) {
    return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }

    if (typeof o.valueOf === 'function') {
      o = o.valueOf();

      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }

    if (o === true) {
      return 1;
    }

    var type = typeof o;

    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }

      var h = o | 0;

      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }

      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }

      return smi(h);
    }

    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }

    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }

    if (type === 'object') {
      return hashJSObj(o);
    }

    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }

    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];

    if (hash === undefined) {
      hash = hashString(string);

      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }

      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }

    return hash;
  } // http://jsperf.com/hashing-strings


  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;

    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }

    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;

    if (usingWeakMap) {
      hash = weakMap.get(obj);

      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];

    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];

      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);

      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;

    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function () {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };

      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  } // Get references to ES5 object methods.


  var isExtensible = Object.isExtensible; // True if Object.defineProperty works as expected. IE8 fails this test.

  var canDefineProperty = function () {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }(); // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.


  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1:
          // Element
          return node.uniqueID;

        case 9:
          // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  } // If possible, use a WeakMap.


  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;

  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;
  var UID_HASH_KEY = '__immutablehash__';

  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
  }

  createClass(Map, KeyedCollection); // @pragma Construction

  function Map(value) {
    return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  Map.of = function () {
    var keyValues = SLICE$0.call(arguments, 0);
    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }

        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function () {
    return this.__toString('Map {', '}');
  }; // @pragma Access


  Map.prototype.get = function (k, notSetValue) {
    return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
  }; // @pragma Modification


  Map.prototype.set = function (k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.setIn = function (keyPath, v) {
    return this.updateIn(keyPath, NOT_SET, function () {
      return v;
    });
  };

  Map.prototype.remove = function (k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteIn = function (keyPath) {
    return this.updateIn(keyPath, function () {
      return NOT_SET;
    });
  };

  Map.prototype.update = function (k, notSetValue, updater) {
    return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
  };

  Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
    if (!updater) {
      updater = notSetValue;
      notSetValue = undefined;
    }

    var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
    return updatedValue === NOT_SET ? undefined : updatedValue;
  };

  Map.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyMap();
  }; // @pragma Composition


  Map.prototype.merge = function () {
    return mergeIntoMapWith(this, undefined, arguments);
  };

  Map.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoMapWith(this, merger, iters);
  };

  Map.prototype.mergeIn = function (keyPath) {
    var iters = SLICE$0.call(arguments, 1);
    return this.updateIn(keyPath, emptyMap(), function (m) {
      return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
    });
  };

  Map.prototype.mergeDeep = function () {
    return mergeIntoMapWith(this, deepMerger, arguments);
  };

  Map.prototype.mergeDeepWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoMapWith(this, deepMergerWith(merger), iters);
  };

  Map.prototype.mergeDeepIn = function (keyPath) {
    var iters = SLICE$0.call(arguments, 1);
    return this.updateIn(keyPath, emptyMap(), function (m) {
      return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
    });
  };

  Map.prototype.sort = function (comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function (mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  }; // @pragma Mutability


  Map.prototype.withMutations = function (fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  };

  Map.prototype.asMutable = function () {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  };

  Map.prototype.asImmutable = function () {
    return this.__ensureOwner();
  };

  Map.prototype.wasAltered = function () {
    return this.__altered;
  };

  Map.prototype.__iterator = function (type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var iterations = 0;
    this._root && this._root.iterate(function (entry) {
      iterations++;
      return fn(entry[1], entry[0], this$0);
    }, reverse);
    return iterations;
  };

  Map.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;
  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn; // #pragma Trie Nodes

  function ArrayMapNode(ownerID, entries) {
    this.ownerID = ownerID;
    this.entries = entries;
  }

  ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    var entries = this.entries;

    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }

    return notSetValue;
  };

  ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var entries = this.entries;
    var idx = 0;

    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }

    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && entries.length === 1) {
      return; // undefined
    }

    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
      return createNodes(ownerID, entries, key, value);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new ArrayMapNode(ownerID, newEntries);
  };

  function BitmapIndexedNode(ownerID, bitmap, nodes) {
    this.ownerID = ownerID;
    this.bitmap = bitmap;
    this.nodes = nodes;
  }

  BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
  };

  BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var bit = 1 << keyHashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;

    if (!exists && value === NOT_SET) {
      return this;
    }

    var idx = popCount(bitmap & bit - 1);
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : undefined;
    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

    if (newNode === node) {
      return this;
    }

    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
    }

    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }

    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }

    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
  };

  function HashArrayMapNode(ownerID, count, nodes) {
    this.ownerID = ownerID;
    this.count = count;
    this.nodes = nodes;
  }

  HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
  };

  HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];

    if (removed && !node) {
      return this;
    }

    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

    if (newNode === node) {
      return this;
    }

    var newCount = this.count;

    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;

      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setIn(nodes, idx, newNode, isEditable);

    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }

    return new HashArrayMapNode(ownerID, newCount, newNodes);
  };

  function HashCollisionNode(ownerID, keyHash, entries) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entries = entries;
  }

  HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    var entries = this.entries;

    for (var ii = 0, len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }

    return notSetValue;
  };

  HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (keyHash === undefined) {
      keyHash = hash(key);
    }

    var removed = value === NOT_SET;

    if (keyHash !== this.keyHash) {
      if (removed) {
        return this;
      }

      SetRef(didAlter);
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
    }

    var entries = this.entries;
    var idx = 0;

    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }

    var exists = idx < len;

    if (exists ? entries[idx][1] === value : removed) {
      return this;
    }

    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeSize);

    if (removed && len === 2) {
      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
    }

    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);

    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }

    if (isEditable) {
      this.entries = newEntries;
      return this;
    }

    return new HashCollisionNode(ownerID, this.keyHash, newEntries);
  };

  function ValueNode(ownerID, keyHash, entry) {
    this.ownerID = ownerID;
    this.keyHash = keyHash;
    this.entry = entry;
  }

  ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  };

  ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);

    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }

    SetRef(didAlter);

    if (removed) {
      SetRef(didChangeSize);
      return; // undefined
    }

    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }

      return new ValueNode(ownerID, this.keyHash, [key, value]);
    }

    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
  }; // #pragma Iterators


  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;

    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  };

  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;

    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];

      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  };

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  };

  createClass(MapIterator, Iterator);

  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  MapIterator.prototype.next = function () {
    var type = this._type;
    var stack = this._stack;

    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex;

      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;

        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;

        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];

          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }

            stack = this._stack = mapIteratorFrame(subNode, stack);
          }

          continue;
        }
      }

      stack = this._stack = this._stack.__prev;
    }

    return iteratorDone();
  };

  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;

  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;

    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }

      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);

      if (!didAlter.value) {
        return map;
      }

      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }

    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }

    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }

      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }

    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    var newNode;
    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }

    var node = new ValueNode(ownerID, hash(key), [key, value]);

    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }

    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);

    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];

      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }

    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);

    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }

    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];

    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);

      if (!isIterable(value)) {
        iter = iter.map(function (v) {
          return fromJS(v);
        });
      }

      iters.push(iter);
    }

    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function (existing, value, key) {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }

      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function (x) {
      return x.size !== 0;
    });

    if (iters.length === 0) {
      return collection;
    }

    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }

    return collection.withMutations(function (collection) {
      var mergeIntoMap = merger ? function (value, key) {
        collection.update(key, NOT_SET, function (existing) {
          return existing === NOT_SET ? value : merger(existing, value, key);
        });
      } : function (value, key) {
        collection.set(key, value);
      };

      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();

    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }

    invariant(isNotSet || existing && existing.set, 'invalid keyPath');
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - (x >> 1 & 0x55555555);
    x = (x & 0x33333333) + (x >> 2 & 0x33333333);
    x = x + (x >> 4) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;

    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }

    var newArray = new Array(newLen);
    var after = 0;

    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }

    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;

    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }

    var newArray = new Array(newLen);
    var after = 0;

    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }

      newArray[ii] = array[ii + after];
    }

    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
  createClass(List, IndexedCollection); // @pragma Construction

  function List(value) {
    var empty = emptyList();

    if (value === null || value === undefined) {
      return empty;
    }

    if (isList(value)) {
      return value;
    }

    var iter = IndexedIterable(value);
    var size = iter.size;

    if (size === 0) {
      return empty;
    }

    assertNotInfinite(size);

    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }

    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) {
        return list.set(i, v);
      });
    });
  }

  List.of = function () {
    return this(arguments);
  };

  List.prototype.toString = function () {
    return this.__toString('List [', ']');
  }; // @pragma Access


  List.prototype.get = function (index, notSetValue) {
    index = wrapIndex(this, index);

    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }

    return notSetValue;
  }; // @pragma Modification


  List.prototype.set = function (index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function (index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };

  List.prototype.insert = function (index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyList();
  };

  List.prototype.push = function () {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function () {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function () {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);

      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function () {
    return setListBounds(this, 1);
  }; // @pragma Composition


  List.prototype.merge = function () {
    return mergeIntoListWith(this, undefined, arguments);
  };

  List.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoListWith(this, merger, iters);
  };

  List.prototype.mergeDeep = function () {
    return mergeIntoListWith(this, deepMerger, arguments);
  };

  List.prototype.mergeDeepWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return mergeIntoListWith(this, deepMergerWith(merger), iters);
  };

  List.prototype.setSize = function (size) {
    return setListBounds(this, 0, size);
  }; // @pragma Iteration


  List.prototype.slice = function (begin, end) {
    var size = this.size;

    if (wholeSlice(begin, end, size)) {
      return this;
    }

    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
  };

  List.prototype.__iterator = function (type, reverse) {
    var index = 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
    });
  };

  List.prototype.__iterate = function (fn, reverse) {
    var index = 0;
    var values = iterateList(this, reverse);
    var value;

    while ((value = values()) !== DONE) {
      if (fn(value, index++, this) === false) {
        break;
      }
    }

    return index;
  };

  List.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      return this;
    }

    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
  };

  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;
  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;

  function VNode(array, ownerID) {
    this.array = array;
    this.ownerID = ownerID;
  } // TODO: seems like these methods are very similar


  VNode.prototype.removeBefore = function (ownerID, level, index) {
    if (index === level ? 1 << level :  false || this.array.length === 0) {
      return this;
    }

    var originIndex = index >>> level & MASK;

    if (originIndex >= this.array.length) {
      return new VNode([], ownerID);
    }

    var removingFirst = originIndex === 0;
    var newChild;

    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);

      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }

    if (removingFirst && !newChild) {
      return this;
    }

    var editable = editableVNode(this, ownerID);

    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        editable.array[ii] = undefined;
      }
    }

    if (newChild) {
      editable.array[originIndex] = newChild;
    }

    return editable;
  };

  VNode.prototype.removeAfter = function (ownerID, level, index) {
    if (index === (level ? 1 << level : 0) || this.array.length === 0) {
      return this;
    }

    var sizeIndex = index - 1 >>> level & MASK;

    if (sizeIndex >= this.array.length) {
      return this;
    }

    var newChild;

    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);

      if (newChild === oldChild && sizeIndex === this.array.length - 1) {
        return this;
      }
    }

    var editable = editableVNode(this, ownerID);
    editable.array.splice(sizeIndex + 1);

    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }

    return editable;
  };

  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;
    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;

      if (to > SIZE) {
        to = SIZE;
      }

      return function () {
        if (from === to) {
          return DONE;
        }

        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : left - offset >> level;
      var to = (right - offset >> level) + 1;

      if (to > SIZE) {
        to = SIZE;
      }

      return function () {
        do {
          if (values) {
            var value = values();

            if (value !== DONE) {
              return value;
            }

            values = null;
          }

          if (from === to) {
            return DONE;
          }

          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;

  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function (list) {
        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
      });
    }

    index += list._origin;
    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);

    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }

    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = index >>> level & MASK;
    var nodeHas = node && idx < node.array.length;

    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);

      if (newLowerNode === lowerNode) {
        return node;
      }

      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);
    newNode = editableVNode(node, ownerID);

    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }

    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }

    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }

    if (rawIndex < 1 << list._level + SHIFT) {
      var node = list._root;
      var level = list._level;

      while (node && level > 0) {
        node = node.array[rawIndex >>> level & MASK];
        level -= SHIFT;
      }

      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }

    if (end !== undefined) {
      end = end | 0;
    }

    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;

    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    } // If it's going to end after it starts, it's empty.


    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root; // New origin might need creating a higher root.

    var offsetShift = 0;

    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }

    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity); // New size might need creating a higher root.

    while (newTailOffset >= 1 << newLevel + SHIFT) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    } // Locate or create the new tail.


    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail; // Merge Tail into tree.

    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;

      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = oldTailOffset >>> level & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }

      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
    } // If the size has been reduced, there's a chance the tail needs to be trimmed.


    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    } // If the new origin is within the tail, then we do not need a root.


    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin); // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0; // Identify the new top root node of the subtree of the old root.

      while (newRoot) {
        var beginIndex = newOrigin >>> newLevel & MASK;

        if (beginIndex !== newTailOffset >>> newLevel & MASK) {
          break;
        }

        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }

        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      } // Trim the new sides of the new root.


      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }

      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }

      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }

    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;

    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);

      if (iter.size > maxSize) {
        maxSize = iter.size;
      }

      if (!isIterable(value)) {
        iter = iter.map(function (v) {
          return fromJS(v);
        });
      }

      iters.push(iter);
    }

    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }

    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
  }

  createClass(OrderedMap, Map); // @pragma Construction

  function OrderedMap(value) {
    return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v, k) {
        return map.set(k, v);
      });
    });
  }

  OrderedMap.of = function () {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function () {
    return this.__toString('OrderedMap {', '}');
  }; // @pragma Access


  OrderedMap.prototype.get = function (k, notSetValue) {
    var index = this._map.get(k);

    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  }; // @pragma Modification


  OrderedMap.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;

      this._map.clear();

      this._list.clear();

      return this;
    }

    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function (k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function (k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function () {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._list.__iterate(function (entry) {
      return entry && fn(entry[1], entry[0], this$0);
    }, reverse);
  };

  OrderedMap.prototype.__iterator = function (type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    var newList = this._list.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }

    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;
  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;

  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;

    if (v === NOT_SET) {
      // removed
      if (!has) {
        return omap;
      }

      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function (entry, idx) {
          return entry !== undefined && i !== idx;
        });
        newMap = newList.toKeyedSeq().map(function (entry) {
          return entry[0];
        }).flip().toMap();

        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }

        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }

    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }

    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);

  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  ToKeyedSequence.prototype.get = function (key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function (key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function () {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function () {
    var this$0 = this;
    var reversedSequence = reverseFactory(this, true);

    if (!this._useKeys) {
      reversedSequence.valueSeq = function () {
        return this$0._iter.toSeq().reverse();
      };
    }

    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function (mapper, context) {
    var this$0 = this;
    var mappedSequence = mapFactory(this, mapper, context);

    if (!this._useKeys) {
      mappedSequence.valueSeq = function () {
        return this$0._iter.toSeq().map(mapper, context);
      };
    }

    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var ii;
    return this._iter.__iterate(this._useKeys ? function (v, k) {
      return fn(v, k, this$0);
    } : (ii = reverse ? resolveSize(this) : 0, function (v) {
      return fn(v, reverse ? --ii : ii++, this$0);
    }), reverse);
  };

  ToKeyedSequence.prototype.__iterator = function (type, reverse) {
    if (this._useKeys) {
      return this._iter.__iterator(type, reverse);
    }

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    var ii = reverse ? resolveSize(this) : 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
    });
  };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
  createClass(ToIndexedSequence, IndexedSeq);

  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  ToIndexedSequence.prototype.includes = function (value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    var iterations = 0;
    return this._iter.__iterate(function (v) {
      return fn(v, iterations++, this$0);
    }, reverse);
  };

  ToIndexedSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value, step);
    });
  };

  createClass(ToSetSequence, SetSeq);

  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  ToSetSequence.prototype.has = function (key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._iter.__iterate(function (v) {
      return fn(v, v, this$0);
    }, reverse);
  };

  ToSetSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };

  createClass(FromEntriesSequence, KeyedSeq);

  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  FromEntriesSequence.prototype.entrySeq = function () {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._iter.__iterate(function (entry) {
      // Check if entry exists first so array access doesn't throw for holes
      // in the parent iteration.
      if (entry) {
        validateEntry(entry);
        var indexedIterable = isIterable(entry);
        return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
      }
    }, reverse);
  };

  FromEntriesSequence.prototype.__iterator = function (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);

    return new Iterator(function () {
      while (true) {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value; // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.

        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
        }
      }
    });
  };

  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;

    flipSequence.flip = function () {
      return iterable;
    };

    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()

      reversedSequence.flip = function () {
        return iterable.reverse();
      };

      return reversedSequence;
    };

    flipSequence.has = function (key) {
      return iterable.includes(key);
    };

    flipSequence.includes = function (key) {
      return iterable.has(key);
    };

    flipSequence.cacheResult = cacheResultThrough;

    flipSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k) {
        return fn(k, v, this$0) !== false;
      }, reverse);
    };

    flipSequence.__iteratorUncached = function (type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);

        return new Iterator(function () {
          var step = iterator.next();

          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }

          return step;
        });
      }

      return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
    };

    return flipSequence;
  }

  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;

    mappedSequence.has = function (key) {
      return iterable.has(key);
    };

    mappedSequence.get = function (key, notSetValue) {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
    };

    mappedSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$0) !== false;
      }, reverse);
    };

    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      return new Iterator(function () {
        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value;
        var key = entry[0];
        return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
      });
    };

    return mappedSequence;
  }

  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;

    reversedSequence.reverse = function () {
      return iterable;
    };

    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);

        flipSequence.reverse = function () {
          return iterable.flip();
        };

        return flipSequence;
      };
    }

    reversedSequence.get = function (key, notSetValue) {
      return iterable.get(useKeys ? key : -1 - key, notSetValue);
    };

    reversedSequence.has = function (key) {
      return iterable.has(useKeys ? key : -1 - key);
    };

    reversedSequence.includes = function (value) {
      return iterable.includes(value);
    };

    reversedSequence.cacheResult = cacheResultThrough;

    reversedSequence.__iterate = function (fn, reverse) {
      var this$0 = this;
      return iterable.__iterate(function (v, k) {
        return fn(v, k, this$0);
      }, !reverse);
    };

    reversedSequence.__iterator = function (type, reverse) {
      return iterable.__iterator(type, !reverse);
    };

    return reversedSequence;
  }

  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);

    if (useKeys) {
      filterSequence.has = function (key) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };

      filterSequence.get = function (key, notSetValue) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
      };
    }

    filterSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);

      return iterations;
    };

    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var iterations = 0;
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();

          if (step.done) {
            return step;
          }

          var entry = step.value;
          var key = entry[0];
          var value = entry[1];

          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    };

    return filterSequence;
  }

  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();

    iterable.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
        return a + 1;
      });
    });

    return groups.asImmutable();
  }

  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();

    iterable.__iterate(function (v, k) {
      groups.update(grouper.call(context, v, k, iterable), function (a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      });
    });

    var coerce = iterableClass(iterable);
    return groups.map(function (arr) {
      return reify(iterable, coerce(arr));
    });
  }

  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size; // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32

    if (begin !== undefined) {
      begin = begin | 0;
    }

    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize); // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.

    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    } // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.


    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;

    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable); // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0

    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
      };
    }

    sliceSeq.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (sliceSize === 0) {
        return 0;
      }

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;

      iterable.__iterate(function (v, k) {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
        }
      });

      return iterations;
    };

    sliceSeq.__iteratorUncached = function (type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      } // Don't bother instantiating parent iterator if taking 0.


      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);

      var skipped = 0;
      var iterations = 0;
      return new Iterator(function () {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }

        if (++iterations > sliceSize) {
          return iteratorDone();
        }

        var step = iterator.next();

        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    };

    return sliceSeq;
  }

  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);

    takeSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
      });

      return iterations;
    };

    takeSequence.__iteratorUncached = function (type, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }

      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var iterating = true;
      return new Iterator(function () {
        if (!iterating) {
          return iteratorDone();
        }

        var step = iterator.next();

        if (step.done) {
          return step;
        }

        var entry = step.value;
        var k = entry[0];
        var v = entry[1];

        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }

        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };

    return takeSequence;
  }

  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);

    skipSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }

      var isSkipping = true;
      var iterations = 0;

      iterable.__iterate(function (v, k, c) {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });

      return iterations;
    };

    skipSequence.__iteratorUncached = function (type, reverse) {
      var this$0 = this;

      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }

      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);

      var skipping = true;
      var iterations = 0;
      return new Iterator(function () {
        var step, k, v;

        do {
          step = iterator.next();

          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }

          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);

        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
      });
    };

    return skipSequence;
  }

  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function (v) {
      if (!isIterable(v)) {
        v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }

      return v;
    }).filter(function (v) {
      return v.size !== 0;
    });

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];

      if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);

    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }

    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(function (sum, seq) {
      if (sum !== undefined) {
        var size = seq.size;

        if (size !== undefined) {
          return sum + size;
        }
      }
    }, 0);
    return concatSeq;
  }

  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);

    flatSequence.__iterateUncached = function (fn, reverse) {
      var iterations = 0;
      var stopped = false;

      function flatDeep(iter, currentDepth) {
        var this$0 = this;

        iter.__iterate(function (v, k) {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }

          return !stopped;
        }, reverse);
      }

      flatDeep(iterable, 0);
      return iterations;
    };

    flatSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(type, reverse);

      var stack = [];
      var iterations = 0;
      return new Iterator(function () {
        while (iterator) {
          var step = iterator.next();

          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }

          var v = step.value;

          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }

          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }

        return iteratorDone();
      });
    };

    return flatSequence;
  }

  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(function (v, k) {
      return coerce(mapper.call(context, v, k, iterable));
    }).flatten(true);
  }

  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 - 1;

    interposedSequence.__iterateUncached = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;

      iterable.__iterate(function (v, k) {
        return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
      }, reverse);

      return iterations;
    };

    interposedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);

      var iterations = 0;
      var step;
      return new Iterator(function () {
        if (!step || iterations % 2) {
          step = iterator.next();

          if (step.done) {
            return step;
          }
        }

        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
      });
    };

    return interposedSequence;
  }

  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }

    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(function (v, k) {
      return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
    }).toArray();
    entries.sort(function (a, b) {
      return comparator(a[3], b[3]) || a[2] - b[2];
    }).forEach(isKeyedIterable ? function (v, i) {
      entries[i].length = 2;
    } : function (v, i) {
      entries[i] = v[1];
    });
    return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
  }

  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }

    if (mapper) {
      var entry = iterable.toSeq().map(function (v, k) {
        return [v, mapper(v, k, iterable)];
      }).reduce(function (a, b) {
        return maxCompare(comparator, a[1], b[1]) ? b : a;
      });
      return entry && entry[0];
    } else {
      return iterable.reduce(function (a, b) {
        return maxCompare(comparator, a, b) ? b : a;
      });
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a); // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.

    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
  }

  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function (i) {
      return i.size;
    }).min(); // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.

    zipSequence.__iterate = function (fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);

      var step;
      var iterations = 0;

      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }

      return iterations;
    };

    zipSequence.__iteratorUncached = function (type, reverse) {
      var iterators = iters.map(function (i) {
        return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
      });
      var iterations = 0;
      var isDone = false;
      return new Iterator(function () {
        var steps;

        if (!isDone) {
          steps = iterators.map(function (i) {
            return i.next();
          });
          isDone = steps.some(function (s) {
            return s.done;
          });
        }

        if (isDone) {
          return iteratorDone();
        }

        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
          return s.value;
        })));
      });
    };

    return zipSequence;
  } // #pragma Helper Functions


  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();

      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);

    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }

      iter = getIterator(Iterable(keyPath));
    }

    return iter;
  }

  createClass(Record, KeyedCollection);

  function Record(defaultValues, name) {
    var hasInitialized;

    var RecordType = function Record(values) {
      if (values instanceof RecordType) {
        return values;
      }

      if (!(this instanceof RecordType)) {
        return new RecordType(values);
      }

      if (!hasInitialized) {
        hasInitialized = true;
        var keys = Object.keys(defaultValues);
        setProps(RecordTypePrototype, keys);
        RecordTypePrototype.size = keys.length;
        RecordTypePrototype._name = name;
        RecordTypePrototype._keys = keys;
        RecordTypePrototype._defaultValues = defaultValues;
      }

      this._map = Map(values);
    };

    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
    RecordTypePrototype.constructor = RecordType;
    return RecordType;
  }

  Record.prototype.toString = function () {
    return this.__toString(recordName(this) + ' {', '}');
  }; // @pragma Access


  Record.prototype.has = function (k) {
    return this._defaultValues.hasOwnProperty(k);
  };

  Record.prototype.get = function (k, notSetValue) {
    if (!this.has(k)) {
      return notSetValue;
    }

    var defaultVal = this._defaultValues[k];
    return this._map ? this._map.get(k, defaultVal) : defaultVal;
  }; // @pragma Modification


  Record.prototype.clear = function () {
    if (this.__ownerID) {
      this._map && this._map.clear();
      return this;
    }

    var RecordType = this.constructor;
    return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
  };

  Record.prototype.set = function (k, v) {
    if (!this.has(k)) {
      throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
    }

    if (this._map && !this._map.has(k)) {
      var defaultVal = this._defaultValues[k];

      if (v === defaultVal) {
        return this;
      }
    }

    var newMap = this._map && this._map.set(k, v);

    if (this.__ownerID || newMap === this._map) {
      return this;
    }

    return makeRecord(this, newMap);
  };

  Record.prototype.remove = function (k) {
    if (!this.has(k)) {
      return this;
    }

    var newMap = this._map && this._map.remove(k);

    if (this.__ownerID || newMap === this._map) {
      return this;
    }

    return makeRecord(this, newMap);
  };

  Record.prototype.wasAltered = function () {
    return this._map.wasAltered();
  };

  Record.prototype.__iterator = function (type, reverse) {
    var this$0 = this;
    return KeyedIterable(this._defaultValues).map(function (_, k) {
      return this$0.get(k);
    }).__iterator(type, reverse);
  };

  Record.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return KeyedIterable(this._defaultValues).map(function (_, k) {
      return this$0.get(k);
    }).__iterate(fn, reverse);
  };

  Record.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map && this._map.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }

    return makeRecord(this, newMap, ownerID);
  };

  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;

  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {// Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function () {
        return this.get(name);
      },
      set: function (value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection); // @pragma Construction

  function Set(value) {
    return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  Set.of = function () {
    return this(arguments);
  };

  Set.fromKeys = function (value) {
    return this(KeyedIterable(value).keySeq());
  };

  Set.prototype.toString = function () {
    return this.__toString('Set {', '}');
  }; // @pragma Access


  Set.prototype.has = function (value) {
    return this._map.has(value);
  }; // @pragma Modification


  Set.prototype.add = function (value) {
    return updateSet(this, this._map.set(value, true));
  };

  Set.prototype.remove = function (value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function () {
    return updateSet(this, this._map.clear());
  }; // @pragma Composition


  Set.prototype.union = function () {
    var iters = SLICE$0.call(arguments, 0);
    iters = iters.filter(function (x) {
      return x.size !== 0;
    });

    if (iters.length === 0) {
      return this;
    }

    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }

    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetIterable(iters[ii]).forEach(function (value) {
          return set.add(value);
        });
      }
    });
  };

  Set.prototype.intersect = function () {
    var iters = SLICE$0.call(arguments, 0);

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetIterable(iter);
    });
    var originalSet = this;
    return this.withMutations(function (set) {
      originalSet.forEach(function (value) {
        if (!iters.every(function (iter) {
          return iter.includes(value);
        })) {
          set.remove(value);
        }
      });
    });
  };

  Set.prototype.subtract = function () {
    var iters = SLICE$0.call(arguments, 0);

    if (iters.length === 0) {
      return this;
    }

    iters = iters.map(function (iter) {
      return SetIterable(iter);
    });
    var originalSet = this;
    return this.withMutations(function (set) {
      originalSet.forEach(function (value) {
        if (iters.some(function (iter) {
          return iter.includes(value);
        })) {
          set.remove(value);
        }
      });
    });
  };

  Set.prototype.merge = function () {
    return this.union.apply(this, arguments);
  };

  Set.prototype.mergeWith = function (merger) {
    var iters = SLICE$0.call(arguments, 1);
    return this.union.apply(this, iters);
  };

  Set.prototype.sort = function (comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function (mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function () {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function (fn, reverse) {
    var this$0 = this;
    return this._map.__iterate(function (_, k) {
      return fn(k, k, this$0);
    }, reverse);
  };

  Set.prototype.__iterator = function (type, reverse) {
    return this._map.map(function (_, k) {
      return k;
    }).__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    var newMap = this._map.__ensureOwner(ownerID);

    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }

    return this.__make(newMap, ownerID);
  };

  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;
  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;
  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }

    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;

  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set); // @pragma Construction

  function OrderedSet(value) {
    return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function (v) {
        return set.add(v);
      });
    });
  }

  OrderedSet.of = function () {
    return this(arguments);
  };

  OrderedSet.fromKeys = function (value) {
    return this(KeyedIterable(value).keySeq());
  };

  OrderedSet.prototype.toString = function () {
    return this.__toString('OrderedSet {', '}');
  };

  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;
  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;

  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection); // @pragma Construction

  function Stack(value) {
    return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
  }

  Stack.of = function () {
    return this(arguments);
  };

  Stack.prototype.toString = function () {
    return this.__toString('Stack [', ']');
  }; // @pragma Access


  Stack.prototype.get = function (index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);

    while (head && index--) {
      head = head.next;
    }

    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function () {
    return this._head && this._head.value;
  }; // @pragma Modification


  Stack.prototype.push = function () {
    if (arguments.length === 0) {
      return this;
    }

    var newSize = this.size + arguments.length;
    var head = this._head;

    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments[ii],
        next: head
      };
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function (iter) {
    iter = IndexedIterable(iter);

    if (iter.size === 0) {
      return this;
    }

    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.reverse().forEach(function (value) {
      newSize++;
      head = {
        value: value,
        next: head
      };
    });

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function () {
    return this.slice(1);
  };

  Stack.prototype.unshift = function () {
    return this.push.apply(this, arguments);
  };

  Stack.prototype.unshiftAll = function (iter) {
    return this.pushAll(iter);
  };

  Stack.prototype.shift = function () {
    return this.pop.apply(this, arguments);
  };

  Stack.prototype.clear = function () {
    if (this.size === 0) {
      return this;
    }

    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return emptyStack();
  };

  Stack.prototype.slice = function (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }

    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);

    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection.prototype.slice.call(this, begin, end);
    }

    var newSize = this.size - resolvedBegin;
    var head = this._head;

    while (resolvedBegin--) {
      head = head.next;
    }

    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }

    return makeStack(newSize, head);
  }; // @pragma Mutability


  Stack.prototype.__ensureOwner = function (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }

    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }

    return makeStack(this.size, this._head, ownerID, this.__hash);
  }; // @pragma Iteration


  Stack.prototype.__iterate = function (fn, reverse) {
    if (reverse) {
      return this.reverse().__iterate(fn);
    }

    var iterations = 0;
    var node = this._head;

    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }

      node = node.next;
    }

    return iterations;
  };

  Stack.prototype.__iterator = function (type, reverse) {
    if (reverse) {
      return this.reverse().__iterator(type);
    }

    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }

      return iteratorDone();
    });
  };

  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;
  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;

  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;

  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }
  /**
   * Contributes additional methods to a constructor
   */


  function mixin(ctor, methods) {
    var keyCopier = function (key) {
      ctor.prototype[key] = methods[key];
    };

    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;
  mixin(Iterable, {
    // ### Conversion to other types
    toArray: function () {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);

      this.valueSeq().__iterate(function (v, i) {
        array[i] = v;
      });

      return array;
    },
    toIndexedSeq: function () {
      return new ToIndexedSequence(this);
    },
    toJS: function () {
      return this.toSeq().map(function (value) {
        return value && typeof value.toJS === 'function' ? value.toJS() : value;
      }).__toJS();
    },
    toJSON: function () {
      return this.toSeq().map(function (value) {
        return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
      }).__toJS();
    },
    toKeyedSeq: function () {
      return new ToKeyedSequence(this, true);
    },
    toMap: function () {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },
    toObject: function () {
      assertNotInfinite(this.size);
      var object = {};

      this.__iterate(function (v, k) {
        object[k] = v;
      });

      return object;
    },
    toOrderedMap: function () {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },
    toOrderedSet: function () {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },
    toSet: function () {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },
    toSetSeq: function () {
      return new ToSetSequence(this);
    },
    toSeq: function () {
      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
    },
    toStack: function () {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },
    toList: function () {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },
    // ### Common JavaScript methods and properties
    toString: function () {
      return '[Iterable]';
    },
    __toString: function (head, tail) {
      if (this.size === 0) {
        return head + tail;
      }

      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    concat: function () {
      var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },
    includes: function (searchValue) {
      return this.some(function (value) {
        return is(value, searchValue);
      });
    },
    entries: function () {
      return this.__iterator(ITERATE_ENTRIES);
    },
    every: function (predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;

      this.__iterate(function (v, k, c) {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });

      return returnValue;
    },
    filter: function (predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },
    find: function (predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },
    forEach: function (sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },
    join: function (separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;

      this.__iterate(function (v) {
        isFirst ? isFirst = false : joined += separator;
        joined += v !== null && v !== undefined ? v.toString() : '';
      });

      return joined;
    },
    keys: function () {
      return this.__iterator(ITERATE_KEYS);
    },
    map: function (mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },
    reduce: function (reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;

      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }

      this.__iterate(function (v, k, c) {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });

      return reduction;
    },
    reduceRight: function (reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },
    reverse: function () {
      return reify(this, reverseFactory(this, true));
    },
    slice: function (begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },
    some: function (predicate, context) {
      return !this.every(not(predicate), context);
    },
    sort: function (comparator) {
      return reify(this, sortFactory(this, comparator));
    },
    values: function () {
      return this.__iterator(ITERATE_VALUES);
    },
    // ### More sequential methods
    butLast: function () {
      return this.slice(0, -1);
    },
    isEmpty: function () {
      return this.size !== undefined ? this.size === 0 : !this.some(function () {
        return true;
      });
    },
    count: function (predicate, context) {
      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
    },
    countBy: function (grouper, context) {
      return countByFactory(this, grouper, context);
    },
    equals: function (other) {
      return deepEqual(this, other);
    },
    entrySeq: function () {
      var iterable = this;

      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }

      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();

      entriesSequence.fromEntrySeq = function () {
        return iterable.toSeq();
      };

      return entriesSequence;
    },
    filterNot: function (predicate, context) {
      return this.filter(not(predicate), context);
    },
    findEntry: function (predicate, context, notSetValue) {
      var found = notSetValue;

      this.__iterate(function (v, k, c) {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });

      return found;
    },
    findKey: function (predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },
    findLast: function (predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },
    findLastEntry: function (predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },
    findLastKey: function (predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },
    first: function () {
      return this.find(returnTrue);
    },
    flatMap: function (mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },
    flatten: function (depth) {
      return reify(this, flattenFactory(this, depth, true));
    },
    fromEntrySeq: function () {
      return new FromEntriesSequence(this);
    },
    get: function (searchKey, notSetValue) {
      return this.find(function (_, key) {
        return is(key, searchKey);
      }, undefined, notSetValue);
    },
    getIn: function (searchKeyPath, notSetValue) {
      var nested = this; // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {

      var iter = forceIterator(searchKeyPath);
      var step;

      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;

        if (nested === NOT_SET) {
          return notSetValue;
        }
      }

      return nested;
    },
    groupBy: function (grouper, context) {
      return groupByFactory(this, grouper, context);
    },
    has: function (searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },
    hasIn: function (searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },
    isSubset: function (iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function (value) {
        return iter.includes(value);
      });
    },
    isSuperset: function (iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },
    keyOf: function (searchValue) {
      return this.findKey(function (value) {
        return is(value, searchValue);
      });
    },
    keySeq: function () {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },
    last: function () {
      return this.toSeq().reverse().first();
    },
    lastKeyOf: function (searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },
    max: function (comparator) {
      return maxFactory(this, comparator);
    },
    maxBy: function (mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },
    min: function (comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },
    minBy: function (mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },
    rest: function () {
      return this.slice(1);
    },
    skip: function (amount) {
      return this.slice(Math.max(0, amount));
    },
    skipLast: function (amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },
    skipWhile: function (predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },
    skipUntil: function (predicate, context) {
      return this.skipWhile(not(predicate), context);
    },
    sortBy: function (mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },
    take: function (amount) {
      return this.slice(0, Math.max(0, amount));
    },
    takeLast: function (amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },
    takeWhile: function (predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },
    takeUntil: function (predicate, context) {
      return this.takeWhile(not(predicate), context);
    },
    valueSeq: function () {
      return this.toIndexedSeq();
    },
    // ### Hashable Object
    hashCode: function () {
      return this.__hash || (this.__hash = hashIterable(this));
    } // ### Internal
    // abstract __iterate(fn, reverse)
    // abstract __iterator(type, reverse)

  }); // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;

  IterablePrototype.inspect = IterablePrototype.toSource = function () {
    return this.toString();
  };

  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;
  mixin(KeyedIterable, {
    // ### More sequential methods
    flip: function () {
      return reify(this, flipFactory(this));
    },
    mapEntries: function (mapper, context) {
      var this$0 = this;
      var iterations = 0;
      return reify(this, this.toSeq().map(function (v, k) {
        return mapper.call(context, [k, v], iterations++, this$0);
      }).fromEntrySeq());
    },
    mapKeys: function (mapper, context) {
      var this$0 = this;
      return reify(this, this.toSeq().flip().map(function (k, v) {
        return mapper.call(context, k, v, this$0);
      }).flip());
    }
  });
  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;

  KeyedIterablePrototype.__toStringMapper = function (v, k) {
    return JSON.stringify(k) + ': ' + quoteString(v);
  };

  mixin(IndexedIterable, {
    // ### Conversion to other types
    toKeyedSeq: function () {
      return new ToKeyedSequence(this, false);
    },
    // ### ES6 Collection methods (ES6 Array and Map)
    filter: function (predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },
    findIndex: function (predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },
    indexOf: function (searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },
    lastIndexOf: function (searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },
    reverse: function () {
      return reify(this, reverseFactory(this, false));
    },
    slice: function (begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },
    splice: function (index, removeNum
    /*, ...values*/
    ) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);

      if (numArgs === 0 || numArgs === 2 && !removeNum) {
        return this;
      } // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.


      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
    },
    // ### More collection methods
    findLastIndex: function (predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },
    first: function () {
      return this.get(0);
    },
    flatten: function (depth) {
      return reify(this, flattenFactory(this, depth, false));
    },
    get: function (index, notSetValue) {
      index = wrapIndex(this, index);
      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
        return key === index;
      }, undefined, notSetValue);
    },
    has: function (index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
    },
    interpose: function (separator) {
      return reify(this, interposeFactory(this, separator));
    },
    interleave: function () {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);

      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }

      return reify(this, interleaved);
    },
    keySeq: function () {
      return Range(0, this.size);
    },
    last: function () {
      return this.get(-1);
    },
    skipWhile: function (predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },
    zip: function () {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },
    zipWith: function (zipper
    /*, ...iterables */
    ) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }
  });
  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
  mixin(SetIterable, {
    // ### ES6 Collection methods (ES6 Array and Map)
    get: function (value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },
    includes: function (value) {
      return this.has(value);
    },
    // ### More sequential methods
    keySeq: function () {
      return this.valueSeq();
    }
  });
  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes; // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);
  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype); // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  }

  function neg(predicate) {
    return function () {
      return -predicate.apply(this, arguments);
    };
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }

    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;

    var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
    } : function (v, k) {
      h = h + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function (v) {
      h = 31 * h + hash(v) | 0;
    } : function (v) {
      h = h + hash(v) | 0;
    });

    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {
    Iterable: Iterable,
    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,
    Record: Record,
    Range: Range,
    Repeat: Repeat,
    is: is,
    fromJS: fromJS
  };
  return Immutable;
});

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||isBuff&&(key=='offset'||key=='parent')||isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMvYWN0aW9ucy9QbGF5ZXJBY3Rpb25zLmpzIiwid2VicGFjazovLy8uL2pzL2NvbnN0YW50cy9BY3Rpb25UeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb25zdGFudHMvQ29sb3Vycy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb25zdGFudHMvR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9kZWNpZGVycy9Nb250ZUNhcmxvVHJlZVNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9oZXhidXN0ZXJzL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvaGV4YnVzdGVycy9pbml0LmpzIiwid2VicGFjazovLy8uL2pzL3JlZHVjZXJzL2hleGJ1c3RlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvZGVjaWRlcnMvTW9udGVDYXJsb1RyZWVTZWFyY2hXZWJXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NoZWNrLXR5cGVzL3NyYy9jaGVjay10eXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGV4LWdyaWQvc3JjL2hleC1ncmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9pbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIl0sIm5hbWVzIjpbInRpbGVDaG9zZW4iLCJhY3Rpb24iLCJjaGVjayIsImFzc2VydCIsImFzc2lnbmVkIiwidGlsZUlkIiwiY29sb3VyIiwidHlwZSIsIlRJTEVfQ0hPU0VOIiwiUExBWUVSU19KT0lOIiwiQ09MT1VSX05FVVRSQUwiLCJDT0xPVVJfQkxVRSIsIkNPTE9VUl9SRUQiLCJCT1JERVJfTEVGVCIsIkJPUkRFUl9UT1AiLCJCT1JERVJfVE9QX1JJR0hUIiwiQk9SREVSX1JJR0hUIiwiQk9SREVSX0JPVFRPTV9SSUdIVCIsIkJPUkRFUl9CT1RUT00iLCJCT1JERVJfQk9UVE9NX0xFRlQiLCJCT1JERVJfVE9QX0xFRlRfQkxVRSIsIkJPUkRFUl9UT1BfTEVGVF9SRUQiLCJCT1JERVJfQk9UVE9NX1JJR0hUX0JMVUUiLCJCT1JERVJfQk9UVE9NX1JJR0hUX1JFRCIsInNpemUiLCJ3aWR0aCIsImhlaWdodCIsImxheW91dCIsIm9yaWVudGF0aW9uIiwic2hhcGUiLCJ2YWxpZGF0ZSIsIk5vZGUiLCJwYXJlbnQiLCJzdGF0ZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGVzIiwiU2V0Iiwid2lucyIsInZpc2l0cyIsInVudHJpZWRBY3Rpb25zIiwiZ2V0QWN0aW9ucyIsImN1cnJlbnRQbGF5ZXIiLCJnZXRDdXJyZW50UGxheWVyIiwibiIsImRlbGV0ZSIsImFkZCIsInJlc3VsdCIsIl8iLCJBcnJheSIsImZyb20iLCJzb3J0QnkiLCJNYXRoIiwic3FydCIsImxvZyIsImxhc3QiLCJnZXRTdGF0ZVZhbHVlIiwicGxheWVyIiwid2lubmVyIiwiTW9udGVDYXJsb1RyZWVTZWFyY2giLCJvcHRpb25zIiwidGltZUxpbWl0TXMiLCJkZWJ1ZyIsInBsYXllckNvbG91ciIsInJvb3RTdGF0ZSIsImRhdGVMaW1pdCIsIkRhdGUiLCJub3ciLCJyb290Tm9kZSIsIml0ZXJhdGlvbnMiLCJub2RlIiwiVUNCMVNlbGVjdENoaWxkIiwiZ2FtZVJlZHVjZXIiLCJzYW1wbGUiLCJhZGRDaGlsZCIsInJhbmRvbUFjdGlvbiIsImdldFJhbmRvbUFjdGlvbiIsInVwZGF0ZSIsInJhbmtlZE5vZGVzIiwib3JkZXJlZE5vZGVzIiwiZm9yRWFjaCIsImNvbnNvbGUiLCJiZXN0QWN0aW9uIiwicGxheWVycyIsInVuZGVmaW5lZCIsImxlbmd0aCIsImN1cnJlbnRQbGF5ZXJJZHgiLCJudW1QbGF5ZXJzIiwiaXNDdXJyZW50UGxheWVyIiwibmFtZSIsInRpbGVzIiwibmV1dHJhbCIsInRvQXJyYXkiLCJtYXAiLCJuZXV0cmFsVGlsZXMiLCJncmlkIiwibWVzc2FnZXMiLCJzdGFydFRpbGVzIiwiY2hhaW4iLCJyYW5nZSIsImZsYXRNYXAiLCJ4IiwiZ2V0VGlsZUlkQnlDb29yZGluYXRlcyIsInZhbHVlIiwieSIsImVuZFRpbGVzIiwiZ2V0VGlsZUlkcyIsImJsdWUiLCJyZWQiLCJyZWR1Y2VUaWxlcyIsImNoZWNrV2luIiwiY29sb3VyVGlsZXMiLCJjb2xvdXJUaWxlc09iaiIsInRvT2JqZWN0IiwicGF0aEZuIiwicGF0aFRvU3RhcnQiLCJoYXNQYXRoIiwiaXNQYXRoYWJsZSIsInBhdGhUb0VuZCIsInJlZHVjZUdhbWUiLCJpbml0IiwiR1JJRCIsImNvbnRhaW5zIiwibnMiLCJoYW5kbGVNZXNzYWdlIiwibWVzc2FnZSIsIm1lc3NhZ2VPYmoiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZnJvbUpTIiwibWN0cyIsImdldEJlc3RBY3Rpb24iLCJwb3N0TWVzc2FnZSIsIndhcm4iLCJvbm1lc3NhZ2UiLCJnbG9iYWxzIiwicHJlZGljYXRlcyIsImZ1bmN0aW9ucyIsIm5vdCIsIm1heWJlIiwiZWl0aGVyIiwiY29sbGVjdGlvbnMiLCJzbGljZSIsImxpa2UiLCJpbnN0YW5jZSIsImVtcHR5T2JqZWN0Iiwib2JqZWN0IiwibnVsbCIsImhhc0xlbmd0aCIsImVtcHR5QXJyYXkiLCJhcnJheSIsImFycmF5TGlrZSIsIml0ZXJhYmxlIiwiZGF0ZSIsImVycm9yIiwiZnVuY3Rpb24iLCJtYXRjaCIsInVuZW1wdHlTdHJpbmciLCJzdHJpbmciLCJvZGQiLCJldmVuIiwiaW5SYW5nZSIsImdyZWF0ZXJPckVxdWFsIiwibGVzc09yRXF1YWwiLCJiZXR3ZWVuIiwiZ3JlYXRlciIsImxlc3MiLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiaW50ZWdlciIsInplcm8iLCJudW1iZXIiLCJib29sZWFuIiwiaXNVbmRlZmluZWQiLCJpc051bGwiLCJpc0Z1bmN0aW9uIiwiYXBwbHkiLCJhbGwiLCJhbnkiLCJwcm90b3R5cGUiLCJtaXhpbiIsImNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyIsImFzc2VydE1vZGlmaWVyIiwiYXNzZXJ0SW1wbCIsIm5vdE1vZGlmaWVyIiwibm90SW1wbCIsIm1heWJlTW9kaWZpZXIiLCJtYXliZUltcGwiLCJlaXRoZXJNb2RpZmllciIsImNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIiLCJhc3NlcnRFaXRoZXJNb2RpZmllciIsImNyZWF0ZU9mUHJlZGljYXRlcyIsImNyZWF0ZU9mTW9kaWZpZXJzIiwiY3JlYXRlTWF5YmVPZk1vZGlmaWVycyIsImV4cG9ydEZ1bmN0aW9ucyIsImR1Y2siLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImtleXMiLCJ0b1N0cmluZyIsImNhbGwiLCJpc0FycmF5IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc05hTiIsImdldFRpbWUiLCJyZWdleCIsInN1YnN0cmluZyIsImluZGV4T2YiLCJhIiwiYiIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJpbmRleCIsIm1hcFNpbXBsZSIsIm1hcENvbXBsZXgiLCJwcmVkaWNhdGUiLCJrZXkiLCJfaXNNYXliZWZpZWQiLCJ0ZXN0QXJyYXkiLCJ0ZXN0T2JqZWN0IiwiaSIsInRhcmdldCIsInNvdXJjZSIsImRlZmF1bHRNZXNzYWdlIiwiYXNzZXJ0UHJlZGljYXRlIiwiYXJndW1lbnRzIiwiYXJncyIsIkVycm9yIiwiZSIsIm9yIiwicmVkdWNlIiwiZGVsYXllZEFzc2VydCIsIm1vZGlmaWVkUHJlZGljYXRlIiwic2hvcnRjdXQiLCJub3BPclByZWRpY2F0ZSIsIm5vcCIsIm9mTW9kaWZpZXIiLCJjb2xsZWN0aW9uIiwiY29lcmNlQ29sbGVjdGlvbiIsIml0ZW0iLCJjb25jYXQiLCJpZ25vcmUiLCJtb2RpZmllciIsImNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIiwic2hpZnQiLCJwb3AiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIm1vZGlmaWVkIiwib2YiLCJiaW5kIiwiYmFzZSIsImRlZmluZSIsIl92YWxpZERpcmVjdGlvbnMiLCJfdmFsaWRMYXlvdXRzIiwiX3ZhbGlkU2hhcGVzIiwidmFsaWRhdGVTZXR0aW5ncyIsInNldHRpbmdzIiwidGlsZUlkcyIsInB1c2giLCJpc1dpdGhpbkJvdW5kYXJpZXMiLCJpZCIsImlzVmFsaWREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJnZXRUaWxlQ29vcmRpbmF0ZXNCeUlkIiwiZmxvb3IiLCJnZXROZWlnaGJvdXJUaWxlSWRCeUNvb3JkaW5hdGVzIiwiZGlyIiwicm93SXNFdmVuIiwiY29sSXNFdmVuIiwieE9mZnNldCIsInlPZmZzZXQiLCJ4UCIsIm9mZnNldHMiLCJvZmZzZXQiLCJnZXROZWlnaGJvdXJJZEJ5VGlsZUlkIiwiY29vcmRzIiwiZ2V0TmVpZ2hib3VySWRzQnlUaWxlSWQiLCJuZWlnaGJvdXJJZHMiLCJmaWx0ZXIiLCJ0aWxlIiwiZ2V0VGlsZVBvc2l0aW9uQnlDb29yZHMiLCJnZXRUaWxlUG9zaXRpb25CeUlkIiwiZ2V0U2hvcnRlc3RQYXRoc0Zyb21UaWxlSWQiLCJtYXhQYXRoQ29zdCIsIm1heENvc3QiLCJtb3ZlQ29zdCIsImZyb250aWVyVGlsZUlkcyIsInBhdGgiLCJmcm9udGllclRpbGVJZCIsImNvc3QiLCJleHBhbmRTZWFyY2giLCJuZWlnaGJvdXJUaWxlSWQiLCJwYXRoQ29zdCIsImoiLCJmcm9udGllck5laWdoYm91cnMiLCJ2aXNpdGVkIiwiZW5kVGlsZXNPYmoiLCJmcm9udGllclRpbGVzIiwibmVpZ2hib3VycyIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJmYWN0b3J5IiwiU0xJQ0UkMCIsImNyZWF0ZUNsYXNzIiwiY3RvciIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkl0ZXJhYmxlIiwiaXNJdGVyYWJsZSIsIlNlcSIsIktleWVkSXRlcmFibGUiLCJpc0tleWVkIiwiS2V5ZWRTZXEiLCJJbmRleGVkSXRlcmFibGUiLCJpc0luZGV4ZWQiLCJJbmRleGVkU2VxIiwiU2V0SXRlcmFibGUiLCJpc0Fzc29jaWF0aXZlIiwiU2V0U2VxIiwibWF5YmVJdGVyYWJsZSIsIklTX0lURVJBQkxFX1NFTlRJTkVMIiwibWF5YmVLZXllZCIsIklTX0tFWUVEX1NFTlRJTkVMIiwibWF5YmVJbmRleGVkIiwiSVNfSU5ERVhFRF9TRU5USU5FTCIsIm1heWJlQXNzb2NpYXRpdmUiLCJpc09yZGVyZWQiLCJtYXliZU9yZGVyZWQiLCJJU19PUkRFUkVEX1NFTlRJTkVMIiwiS2V5ZWQiLCJJbmRleGVkIiwiREVMRVRFIiwiU0hJRlQiLCJTSVpFIiwiTUFTSyIsIk5PVF9TRVQiLCJDSEFOR0VfTEVOR1RIIiwiRElEX0FMVEVSIiwiTWFrZVJlZiIsInJlZiIsIlNldFJlZiIsIk93bmVySUQiLCJhcnJDb3B5IiwiYXJyIiwibGVuIiwibWF4IiwibmV3QXJyIiwiaWkiLCJlbnN1cmVTaXplIiwiaXRlciIsIl9faXRlcmF0ZSIsInJldHVyblRydWUiLCJ3cmFwSW5kZXgiLCJ1aW50MzJJbmRleCIsIk5hTiIsIndob2xlU2xpY2UiLCJiZWdpbiIsImVuZCIsInJlc29sdmVCZWdpbiIsInJlc29sdmVJbmRleCIsInJlc29sdmVFbmQiLCJkZWZhdWx0SW5kZXgiLCJtaW4iLCJJVEVSQVRFX0tFWVMiLCJJVEVSQVRFX1ZBTFVFUyIsIklURVJBVEVfRU5UUklFUyIsIlJFQUxfSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJJVEVSQVRPUl9TWU1CT0wiLCJJdGVyYXRvciIsIm5leHQiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsImluc3BlY3QiLCJ0b1NvdXJjZSIsIml0ZXJhdG9yVmFsdWUiLCJrIiwidiIsIml0ZXJhdG9yUmVzdWx0IiwiZG9uZSIsIml0ZXJhdG9yRG9uZSIsImhhc0l0ZXJhdG9yIiwiZ2V0SXRlcmF0b3JGbiIsImlzSXRlcmF0b3IiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0SXRlcmF0b3IiLCJpdGVyYXRvckZuIiwiaXNBcnJheUxpa2UiLCJlbXB0eVNlcXVlbmNlIiwidG9TZXEiLCJzZXFGcm9tVmFsdWUiLCJfX3RvU3RyaW5nIiwiY2FjaGVSZXN1bHQiLCJfY2FjaGUiLCJfX2l0ZXJhdGVVbmNhY2hlZCIsImVudHJ5U2VxIiwiZm4iLCJyZXZlcnNlIiwic2VxSXRlcmF0ZSIsIl9faXRlcmF0b3IiLCJzZXFJdGVyYXRvciIsInRvS2V5ZWRTZXEiLCJmcm9tRW50cnlTZXEiLCJrZXllZFNlcUZyb21WYWx1ZSIsImluZGV4ZWRTZXFGcm9tVmFsdWUiLCJ0b0luZGV4ZWRTZXEiLCJ0b1NldFNlcSIsImlzU2VxIiwiSVNfU0VRX1NFTlRJTkVMIiwiQXJyYXlTZXEiLCJfYXJyYXkiLCJnZXQiLCJub3RTZXRWYWx1ZSIsImhhcyIsIm1heEluZGV4IiwiT2JqZWN0U2VxIiwiX29iamVjdCIsIl9rZXlzIiwiSXRlcmFibGVTZXEiLCJfaXRlcmFibGUiLCJzdGVwIiwiX19pdGVyYXRvclVuY2FjaGVkIiwiSXRlcmF0b3JTZXEiLCJfaXRlcmF0b3IiLCJfaXRlcmF0b3JDYWNoZSIsImNhY2hlIiwidmFsIiwibWF5YmVTZXEiLCJFTVBUWV9TRVEiLCJzZXEiLCJUeXBlRXJyb3IiLCJtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUiLCJ1c2VLZXlzIiwiZW50cnkiLCJqc29uIiwiY29udmVydGVyIiwiZnJvbUpTV2l0aCIsImZyb21KU0RlZmF1bHQiLCJwYXJlbnRKU09OIiwiaXNQbGFpbk9iaiIsInRvTGlzdCIsInRvTWFwIiwiaXMiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJ2YWx1ZU9mIiwiZXF1YWxzIiwiZGVlcEVxdWFsIiwiX19oYXNoIiwibm90QXNzb2NpYXRpdmUiLCJlbnRyaWVzIiwiZXZlcnkiLCJmbGlwcGVkIiwiYWxsRXF1YWwiLCJiU2l6ZSIsIlJlcGVhdCIsInRpbWVzIiwiX3ZhbHVlIiwiSW5maW5pdHkiLCJFTVBUWV9SRVBFQVQiLCJpbmNsdWRlcyIsInNlYXJjaFZhbHVlIiwibGFzdEluZGV4T2YiLCJ0aGlzJDAiLCJvdGhlciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsIlJhbmdlIiwic3RhcnQiLCJhYnMiLCJfc3RhcnQiLCJfZW5kIiwiX3N0ZXAiLCJjZWlsIiwiRU1QVFlfUkFOR0UiLCJwb3NzaWJsZUluZGV4Iiwib2Zmc2V0VmFsdWUiLCJDb2xsZWN0aW9uIiwiS2V5ZWRDb2xsZWN0aW9uIiwiSW5kZXhlZENvbGxlY3Rpb24iLCJTZXRDb2xsZWN0aW9uIiwiaW11bCIsImMiLCJkIiwic21pIiwiaTMyIiwiaGFzaCIsIm8iLCJoIiwiU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiIsImNhY2hlZEhhc2hTdHJpbmciLCJoYXNoU3RyaW5nIiwiaGFzaENvZGUiLCJoYXNoSlNPYmoiLCJzdHJpbmdIYXNoQ2FjaGUiLCJTVFJJTkdfSEFTSF9DQUNIRV9TSVpFIiwiU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUiLCJjaGFyQ29kZUF0Iiwib2JqIiwidXNpbmdXZWFrTWFwIiwid2Vha01hcCIsIlVJRF9IQVNIX0tFWSIsImNhbkRlZmluZVByb3BlcnR5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJnZXRJRU5vZGVIYXNoIiwib2JqSGFzaFVJRCIsInNldCIsImlzRXh0ZW5zaWJsZSIsIm5vZGVUeXBlIiwidW5pcXVlSUQiLCJkb2N1bWVudEVsZW1lbnQiLCJXZWFrTWFwIiwiYXNzZXJ0Tm90SW5maW5pdGUiLCJNYXAiLCJlbXB0eU1hcCIsImlzTWFwIiwid2l0aE11dGF0aW9ucyIsImtleVZhbHVlcyIsIl9yb290IiwidXBkYXRlTWFwIiwic2V0SW4iLCJrZXlQYXRoIiwidXBkYXRlSW4iLCJyZW1vdmUiLCJkZWxldGVJbiIsInVwZGF0ZXIiLCJ1cGRhdGVkVmFsdWUiLCJ1cGRhdGVJbkRlZXBNYXAiLCJmb3JjZUl0ZXJhdG9yIiwiY2xlYXIiLCJfX293bmVySUQiLCJfX2FsdGVyZWQiLCJtZXJnZSIsIm1lcmdlSW50b01hcFdpdGgiLCJtZXJnZVdpdGgiLCJtZXJnZXIiLCJpdGVycyIsIm1lcmdlSW4iLCJtIiwibWVyZ2VEZWVwIiwiZGVlcE1lcmdlciIsIm1lcmdlRGVlcFdpdGgiLCJkZWVwTWVyZ2VyV2l0aCIsIm1lcmdlRGVlcEluIiwic29ydCIsImNvbXBhcmF0b3IiLCJPcmRlcmVkTWFwIiwic29ydEZhY3RvcnkiLCJtYXBwZXIiLCJtdXRhYmxlIiwiYXNNdXRhYmxlIiwid2FzQWx0ZXJlZCIsIl9fZW5zdXJlT3duZXIiLCJhc0ltbXV0YWJsZSIsIk1hcEl0ZXJhdG9yIiwiaXRlcmF0ZSIsIm93bmVySUQiLCJtYWtlTWFwIiwibWF5YmVNYXAiLCJJU19NQVBfU0VOVElORUwiLCJNYXBQcm90b3R5cGUiLCJyZW1vdmVJbiIsIkFycmF5TWFwTm9kZSIsImtleUhhc2giLCJkaWRDaGFuZ2VTaXplIiwiZGlkQWx0ZXIiLCJyZW1vdmVkIiwiaWR4IiwiZXhpc3RzIiwiTUFYX0FSUkFZX01BUF9TSVpFIiwiY3JlYXRlTm9kZXMiLCJpc0VkaXRhYmxlIiwibmV3RW50cmllcyIsIkJpdG1hcEluZGV4ZWROb2RlIiwiYml0bWFwIiwibm9kZXMiLCJiaXQiLCJwb3BDb3VudCIsImtleUhhc2hGcmFnIiwibmV3Tm9kZSIsInVwZGF0ZU5vZGUiLCJNQVhfQklUTUFQX0lOREVYRURfU0laRSIsImV4cGFuZE5vZGVzIiwiaXNMZWFmTm9kZSIsIm5ld0JpdG1hcCIsIm5ld05vZGVzIiwic3BsaWNlT3V0Iiwic3BsaWNlSW4iLCJIYXNoQXJyYXlNYXBOb2RlIiwiY291bnQiLCJuZXdDb3VudCIsIk1JTl9IQVNIX0FSUkFZX01BUF9TSVpFIiwicGFja05vZGVzIiwiSGFzaENvbGxpc2lvbk5vZGUiLCJtZXJnZUludG9Ob2RlIiwiVmFsdWVOb2RlIiwia2V5TWF0Y2giLCJfdHlwZSIsIl9yZXZlcnNlIiwiX3N0YWNrIiwibWFwSXRlcmF0b3JGcmFtZSIsInN0YWNrIiwibWFwSXRlcmF0b3JWYWx1ZSIsInN1Yk5vZGUiLCJfX3ByZXYiLCJwcmV2Iiwicm9vdCIsIkVNUFRZX01BUCIsIm5ld1Jvb3QiLCJuZXdTaXplIiwiaWR4MSIsImlkeDIiLCJleGNsdWRpbmciLCJwYWNrZWRJSSIsInBhY2tlZE5vZGVzIiwiaW5jbHVkaW5nIiwiZXhwYW5kZWROb2RlcyIsIml0ZXJhYmxlcyIsIm1lcmdlSW50b0NvbGxlY3Rpb25XaXRoIiwiZXhpc3RpbmciLCJuZXh0VmFsdWUiLCJtZXJnZUludG9NYXAiLCJrZXlQYXRoSXRlciIsImlzTm90U2V0IiwiZXhpc3RpbmdWYWx1ZSIsIm5ld1ZhbHVlIiwibmV4dEV4aXN0aW5nIiwibmV4dFVwZGF0ZWQiLCJjYW5FZGl0IiwibmV3QXJyYXkiLCJuZXdMZW4iLCJhZnRlciIsIkxpc3QiLCJlbXB0eSIsImVtcHR5TGlzdCIsImlzTGlzdCIsIm1ha2VMaXN0IiwiVk5vZGUiLCJsaXN0Iiwic2V0U2l6ZSIsIl9vcmlnaW4iLCJsaXN0Tm9kZUZvciIsInVwZGF0ZUxpc3QiLCJzcGxpY2UiLCJpbnNlcnQiLCJfY2FwYWNpdHkiLCJfbGV2ZWwiLCJfdGFpbCIsInZhbHVlcyIsIm9sZFNpemUiLCJzZXRMaXN0Qm91bmRzIiwidW5zaGlmdCIsIm1lcmdlSW50b0xpc3RXaXRoIiwiaXRlcmF0ZUxpc3QiLCJET05FIiwibWF5YmVMaXN0IiwiSVNfTElTVF9TRU5USU5FTCIsIkxpc3RQcm90b3R5cGUiLCJyZW1vdmVCZWZvcmUiLCJsZXZlbCIsIm9yaWdpbkluZGV4IiwicmVtb3ZpbmdGaXJzdCIsIm5ld0NoaWxkIiwib2xkQ2hpbGQiLCJlZGl0YWJsZSIsImVkaXRhYmxlVk5vZGUiLCJyZW1vdmVBZnRlciIsInNpemVJbmRleCIsImxlZnQiLCJyaWdodCIsInRhaWxQb3MiLCJnZXRUYWlsT2Zmc2V0IiwidGFpbCIsIml0ZXJhdGVOb2RlT3JMZWFmIiwiaXRlcmF0ZUxlYWYiLCJpdGVyYXRlTm9kZSIsInRvIiwib3JpZ2luIiwiY2FwYWNpdHkiLCJFTVBUWV9MSVNUIiwibmV3VGFpbCIsInVwZGF0ZVZOb2RlIiwibm9kZUhhcyIsImxvd2VyTm9kZSIsIm5ld0xvd2VyTm9kZSIsInJhd0luZGV4Iiwib3duZXIiLCJvbGRPcmlnaW4iLCJvbGRDYXBhY2l0eSIsIm5ld09yaWdpbiIsIm5ld0NhcGFjaXR5IiwibmV3TGV2ZWwiLCJvZmZzZXRTaGlmdCIsIm9sZFRhaWxPZmZzZXQiLCJuZXdUYWlsT2Zmc2V0Iiwib2xkVGFpbCIsImJlZ2luSW5kZXgiLCJtYXhTaXplIiwiZW1wdHlPcmRlcmVkTWFwIiwiaXNPcmRlcmVkTWFwIiwiX21hcCIsIl9saXN0IiwidXBkYXRlT3JkZXJlZE1hcCIsIm5ld01hcCIsIm5ld0xpc3QiLCJtYWtlT3JkZXJlZE1hcCIsIm1heWJlT3JkZXJlZE1hcCIsIm9tYXAiLCJFTVBUWV9PUkRFUkVEX01BUCIsImZsaXAiLCJUb0tleWVkU2VxdWVuY2UiLCJpbmRleGVkIiwiX2l0ZXIiLCJfdXNlS2V5cyIsInZhbHVlU2VxIiwicmV2ZXJzZWRTZXF1ZW5jZSIsInJldmVyc2VGYWN0b3J5IiwiY29udGV4dCIsIm1hcHBlZFNlcXVlbmNlIiwibWFwRmFjdG9yeSIsInJlc29sdmVTaXplIiwiVG9JbmRleGVkU2VxdWVuY2UiLCJUb1NldFNlcXVlbmNlIiwiRnJvbUVudHJpZXNTZXF1ZW5jZSIsInZhbGlkYXRlRW50cnkiLCJpbmRleGVkSXRlcmFibGUiLCJjYWNoZVJlc3VsdFRocm91Z2giLCJmbGlwRmFjdG9yeSIsImZsaXBTZXF1ZW5jZSIsIm1ha2VTZXF1ZW5jZSIsImZpbHRlckZhY3RvcnkiLCJmaWx0ZXJTZXF1ZW5jZSIsImNvdW50QnlGYWN0b3J5IiwiZ3JvdXBlciIsImdyb3VwcyIsImdyb3VwQnlGYWN0b3J5IiwiaXNLZXllZEl0ZXIiLCJjb2VyY2UiLCJpdGVyYWJsZUNsYXNzIiwicmVpZnkiLCJzbGljZUZhY3RvcnkiLCJvcmlnaW5hbFNpemUiLCJyZXNvbHZlZEJlZ2luIiwicmVzb2x2ZWRFbmQiLCJyZXNvbHZlZFNpemUiLCJzbGljZVNpemUiLCJzbGljZVNlcSIsInNraXBwZWQiLCJpc1NraXBwaW5nIiwidGFrZVdoaWxlRmFjdG9yeSIsInRha2VTZXF1ZW5jZSIsIml0ZXJhdGluZyIsInNraXBXaGlsZUZhY3RvcnkiLCJza2lwU2VxdWVuY2UiLCJza2lwcGluZyIsImNvbmNhdEZhY3RvcnkiLCJpc0tleWVkSXRlcmFibGUiLCJzaW5nbGV0b24iLCJjb25jYXRTZXEiLCJmbGF0dGVuIiwic3VtIiwiZmxhdHRlbkZhY3RvcnkiLCJkZXB0aCIsImZsYXRTZXF1ZW5jZSIsInN0b3BwZWQiLCJmbGF0RGVlcCIsImN1cnJlbnREZXB0aCIsImZsYXRNYXBGYWN0b3J5IiwiaW50ZXJwb3NlRmFjdG9yeSIsInNlcGFyYXRvciIsImludGVycG9zZWRTZXF1ZW5jZSIsImRlZmF1bHRDb21wYXJhdG9yIiwibWF4RmFjdG9yeSIsIm1heENvbXBhcmUiLCJjb21wIiwiemlwV2l0aEZhY3RvcnkiLCJrZXlJdGVyIiwiemlwcGVyIiwiemlwU2VxdWVuY2UiLCJpdGVyYXRvcnMiLCJpc0RvbmUiLCJzdGVwcyIsInNvbWUiLCJzIiwiUmVjb3JkIiwiZGVmYXVsdFZhbHVlcyIsImhhc0luaXRpYWxpemVkIiwiUmVjb3JkVHlwZSIsInNldFByb3BzIiwiUmVjb3JkVHlwZVByb3RvdHlwZSIsIl9uYW1lIiwiX2RlZmF1bHRWYWx1ZXMiLCJSZWNvcmRQcm90b3R5cGUiLCJyZWNvcmROYW1lIiwiZGVmYXVsdFZhbCIsIl9lbXB0eSIsIm1ha2VSZWNvcmQiLCJsaWtlUmVjb3JkIiwicmVjb3JkIiwiZ2V0UHJvdG90eXBlT2YiLCJuYW1lcyIsInNldFByb3AiLCJlbXB0eVNldCIsImlzU2V0IiwiZnJvbUtleXMiLCJrZXlTZXEiLCJ1cGRhdGVTZXQiLCJ1bmlvbiIsImludGVyc2VjdCIsIm9yaWdpbmFsU2V0Iiwic3VidHJhY3QiLCJPcmRlcmVkU2V0IiwiX19tYWtlIiwibWF5YmVTZXQiLCJJU19TRVRfU0VOVElORUwiLCJTZXRQcm90b3R5cGUiLCJfX2VtcHR5IiwibWFrZVNldCIsIkVNUFRZX1NFVCIsImVtcHR5T3JkZXJlZFNldCIsImlzT3JkZXJlZFNldCIsIm1heWJlT3JkZXJlZFNldCIsIk9yZGVyZWRTZXRQcm90b3R5cGUiLCJtYWtlT3JkZXJlZFNldCIsIkVNUFRZX09SREVSRURfU0VUIiwiU3RhY2siLCJlbXB0eVN0YWNrIiwiaXNTdGFjayIsInVuc2hpZnRBbGwiLCJoZWFkIiwiX2hlYWQiLCJwZWVrIiwibWFrZVN0YWNrIiwicHVzaEFsbCIsIm1heWJlU3RhY2siLCJJU19TVEFDS19TRU5USU5FTCIsIlN0YWNrUHJvdG90eXBlIiwiRU1QVFlfU1RBQ0siLCJtZXRob2RzIiwia2V5Q29waWVyIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwidG9KUyIsIl9fdG9KUyIsInRvSlNPTiIsInRvT3JkZXJlZE1hcCIsInRvT3JkZXJlZFNldCIsInRvU2V0IiwidG9TdGFjayIsIl9fdG9TdHJpbmdNYXBwZXIiLCJqb2luIiwicmV0dXJuVmFsdWUiLCJmaW5kIiwiZmluZEVudHJ5Iiwic2lkZUVmZmVjdCIsImpvaW5lZCIsImlzRmlyc3QiLCJyZWR1Y2VyIiwiaW5pdGlhbFJlZHVjdGlvbiIsInJlZHVjdGlvbiIsInVzZUZpcnN0IiwicmVkdWNlUmlnaHQiLCJyZXZlcnNlZCIsImJ1dExhc3QiLCJpc0VtcHR5IiwiY291bnRCeSIsImVudHJpZXNTZXF1ZW5jZSIsImVudHJ5TWFwcGVyIiwiZmlsdGVyTm90IiwiZm91bmQiLCJmaW5kS2V5IiwiZmluZExhc3QiLCJmaW5kTGFzdEVudHJ5IiwiZmluZExhc3RLZXkiLCJmaXJzdCIsInNlYXJjaEtleSIsImdldEluIiwic2VhcmNoS2V5UGF0aCIsIm5lc3RlZCIsImdyb3VwQnkiLCJoYXNJbiIsImlzU3Vic2V0IiwiaXNTdXBlcnNldCIsImtleU9mIiwia2V5TWFwcGVyIiwibGFzdEtleU9mIiwibWF4QnkiLCJuZWciLCJkZWZhdWx0TmVnQ29tcGFyYXRvciIsIm1pbkJ5IiwicmVzdCIsInNraXAiLCJhbW91bnQiLCJza2lwTGFzdCIsInNraXBXaGlsZSIsInNraXBVbnRpbCIsInRha2UiLCJ0YWtlTGFzdCIsInRha2VXaGlsZSIsInRha2VVbnRpbCIsImhhc2hJdGVyYWJsZSIsIkl0ZXJhYmxlUHJvdG90eXBlIiwicXVvdGVTdHJpbmciLCJtYXBFbnRyaWVzIiwibWFwS2V5cyIsIktleWVkSXRlcmFibGVQcm90b3R5cGUiLCJzdHJpbmdpZnkiLCJmaW5kSW5kZXgiLCJyZW1vdmVOdW0iLCJudW1BcmdzIiwic3BsaWNlZCIsImZpbmRMYXN0SW5kZXgiLCJpbnRlcnBvc2UiLCJpbnRlcmxlYXZlIiwiemlwcGVkIiwiaW50ZXJsZWF2ZWQiLCJ6aXAiLCJkZWZhdWx0WmlwcGVyIiwiemlwV2l0aCIsIlN0cmluZyIsIm9yZGVyZWQiLCJrZXllZCIsImhhc2hNZXJnZSIsIm11cm11ckhhc2hPZlNpemUiLCJJbW11dGFibGUiLCJWRVJTSU9OIiwiTEFSR0VfQVJSQVlfU0laRSIsIkNPUkVfRVJST1JfVEVYVCIsIkZVTkNfRVJST1JfVEVYVCIsIklOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQiLCJIQVNIX1VOREVGSU5FRCIsIk1BWF9NRU1PSVpFX1NJWkUiLCJQTEFDRUhPTERFUiIsIkNMT05FX0RFRVBfRkxBRyIsIkNMT05FX0ZMQVRfRkxBRyIsIkNMT05FX1NZTUJPTFNfRkxBRyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsIldSQVBfQklORF9GTEFHIiwiV1JBUF9CSU5EX0tFWV9GTEFHIiwiV1JBUF9DVVJSWV9CT1VORF9GTEFHIiwiV1JBUF9DVVJSWV9GTEFHIiwiV1JBUF9DVVJSWV9SSUdIVF9GTEFHIiwiV1JBUF9QQVJUSUFMX0ZMQUciLCJXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyIsIldSQVBfQVJZX0ZMQUciLCJXUkFQX1JFQVJHX0ZMQUciLCJXUkFQX0ZMSVBfRkxBRyIsIkRFRkFVTFRfVFJVTkNfTEVOR1RIIiwiREVGQVVMVF9UUlVOQ19PTUlTU0lPTiIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwiTEFaWV9GSUxURVJfRkxBRyIsIkxBWllfTUFQX0ZMQUciLCJMQVpZX1dISUxFX0ZMQUciLCJJTkZJTklUWSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIk5BTiIsIk1BWF9BUlJBWV9MRU5HVEgiLCJNQVhfQVJSQVlfSU5ERVgiLCJIQUxGX01BWF9BUlJBWV9MRU5HVEgiLCJ3cmFwRmxhZ3MiLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJhc3luY1RhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwibnVsbFRhZyIsIm9iamVjdFRhZyIsInByb21pc2VUYWciLCJwcm94eVRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsInVuZGVmaW5lZFRhZyIsIndlYWtNYXBUYWciLCJ3ZWFrU2V0VGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNjYXBlZEh0bWwiLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc0VzY2FwZWRIdG1sIiwiUmVnRXhwIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwicmVFc2NhcGUiLCJyZUV2YWx1YXRlIiwicmVJbnRlcnBvbGF0ZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJyZVByb3BOYW1lIiwicmVSZWdFeHBDaGFyIiwicmVIYXNSZWdFeHBDaGFyIiwicmVUcmltU3RhcnQiLCJyZVdoaXRlc3BhY2UiLCJyZVdyYXBDb21tZW50IiwicmVXcmFwRGV0YWlscyIsInJlU3BsaXREZXRhaWxzIiwicmVBc2NpaVdvcmQiLCJyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyIsInJlRXNjYXBlQ2hhciIsInJlRXNUZW1wbGF0ZSIsInJlRmxhZ3MiLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNIb3N0Q3RvciIsInJlSXNPY3RhbCIsInJlSXNVaW50IiwicmVMYXRpbiIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwicnNBc3RyYWxSYW5nZSIsInJzQ29tYm9NYXJrc1JhbmdlIiwicmVDb21ib0hhbGZNYXJrc1JhbmdlIiwicnNDb21ib1N5bWJvbHNSYW5nZSIsInJzQ29tYm9SYW5nZSIsInJzRGluZ2JhdFJhbmdlIiwicnNMb3dlclJhbmdlIiwicnNNYXRoT3BSYW5nZSIsInJzTm9uQ2hhclJhbmdlIiwicnNQdW5jdHVhdGlvblJhbmdlIiwicnNTcGFjZVJhbmdlIiwicnNVcHBlclJhbmdlIiwicnNWYXJSYW5nZSIsInJzQnJlYWtSYW5nZSIsInJzQXBvcyIsInJzQXN0cmFsIiwicnNCcmVhayIsInJzQ29tYm8iLCJyc0RpZ2l0cyIsInJzRGluZ2JhdCIsInJzTG93ZXIiLCJyc01pc2MiLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJzVXBwZXIiLCJyc1pXSiIsInJzTWlzY0xvd2VyIiwicnNNaXNjVXBwZXIiLCJyc09wdENvbnRyTG93ZXIiLCJyc09wdENvbnRyVXBwZXIiLCJyZU9wdE1vZCIsInJzT3B0VmFyIiwicnNPcHRKb2luIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc1NlcSIsInJzRW1vamkiLCJyc1N5bWJvbCIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZSIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJ0eXBlZEFycmF5VGFncyIsImNsb25lYWJsZVRhZ3MiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJwYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50IiwicGFyc2VJbnQiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwiRnVuY3Rpb24iLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsIm5vZGVJc1JlZ0V4cCIsImlzUmVnRXhwIiwibm9kZUlzU2V0Iiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJyYXlBZ2dyZWdhdG9yIiwic2V0dGVyIiwiaXRlcmF0ZWUiLCJhY2N1bXVsYXRvciIsImFycmF5RWFjaCIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJhcnJheUluY2x1ZGVzIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImFycmF5TWFwIiwiYXJyYXlQdXNoIiwiYXJyYXlSZWR1Y2UiLCJpbml0QWNjdW0iLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb21lIiwiYXNjaWlTaXplIiwiYmFzZVByb3BlcnR5IiwiYXNjaWlUb0FycmF5Iiwic3BsaXQiLCJhc2NpaVdvcmRzIiwiYmFzZUZpbmRLZXkiLCJlYWNoRnVuYyIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJzdHJpY3RJbmRleE9mIiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlUmVkdWNlIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwiY3VycmVudCIsImJhc2VUaW1lcyIsImJhc2VUb1BhaXJzIiwicHJvcHMiLCJiYXNlVHJpbSIsInRyaW1tZWRFbmRJbmRleCIsInJlcGxhY2UiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImdldFZhbHVlIiwiaGFzVW5pY29kZSIsInRlc3QiLCJoYXNVbmljb2RlV29yZCIsIml0ZXJhdG9yVG9BcnJheSIsIm1hcFRvQXJyYXkiLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwiYXJnIiwicmVwbGFjZUhvbGRlcnMiLCJzZXRUb0FycmF5Iiwic2V0VG9QYWlycyIsInN0cmljdExhc3RJbmRleE9mIiwic3RyaW5nU2l6ZSIsInVuaWNvZGVTaXplIiwic3RyaW5nVG9BcnJheSIsInVuaWNvZGVUb0FycmF5IiwiY2hhckF0IiwidW5lc2NhcGVIdG1sQ2hhciIsImxhc3RJbmRleCIsInVuaWNvZGVXb3JkcyIsInJ1bkluQ29udGV4dCIsImRlZmF1bHRzIiwicGljayIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImNvcmVKc0RhdGEiLCJmdW5jVG9TdHJpbmciLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJvYmplY3RDdG9yU3RyaW5nIiwib2xkRGFzaCIsInJlSXNOYXRpdmUiLCJCdWZmZXIiLCJVaW50OEFycmF5IiwiYWxsb2NVbnNhZmUiLCJnZXRQcm90b3R5cGUiLCJvYmplY3RDcmVhdGUiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ltSXRlcmF0b3IiLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0TmF0aXZlIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJuYXRpdmVDZWlsIiwibmF0aXZlRmxvb3IiLCJuYXRpdmVHZXRTeW1ib2xzIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsIm5hdGl2ZUlzRmluaXRlIiwiaXNGaW5pdGUiLCJuYXRpdmVKb2luIiwibmF0aXZlS2V5cyIsIm5hdGl2ZU1heCIsIm5hdGl2ZU1pbiIsIm5hdGl2ZU5vdyIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsIkRhdGFWaWV3IiwiUHJvbWlzZSIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsImlzT2JqZWN0TGlrZSIsIkxhenlXcmFwcGVyIiwiTG9kYXNoV3JhcHBlciIsIndyYXBwZXJDbG9uZSIsImJhc2VDcmVhdGUiLCJwcm90byIsImlzT2JqZWN0IiwiYmFzZUxvZGFzaCIsImNoYWluQWxsIiwiX193cmFwcGVkX18iLCJfX2FjdGlvbnNfXyIsIl9fY2hhaW5fXyIsIl9faW5kZXhfXyIsIl9fdmFsdWVzX18iLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiX19kaXJfXyIsIl9fZmlsdGVyZWRfXyIsIl9faXRlcmF0ZWVzX18iLCJfX3Rha2VDb3VudF9fIiwiX192aWV3c19fIiwibGF6eUNsb25lIiwiY29weUFycmF5IiwibGF6eVJldmVyc2UiLCJjbG9uZSIsImxhenlWYWx1ZSIsImlzQXJyIiwiaXNSaWdodCIsImFyckxlbmd0aCIsInZpZXciLCJnZXRWaWV3IiwiaXRlcmF0ZWVzIiwiaXRlckxlbmd0aCIsInRha2VDb3VudCIsImJhc2VXcmFwcGVyVmFsdWUiLCJvdXRlciIsIml0ZXJJbmRleCIsImNvbXB1dGVkIiwiSGFzaCIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFycmF5U2FtcGxlIiwiYmFzZVJhbmRvbSIsImFycmF5U2FtcGxlU2l6ZSIsInNodWZmbGVTZWxmIiwiYmFzZUNsYW1wIiwiYXJyYXlTaHVmZmxlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwibG93ZXIiLCJ1cHBlciIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJpc0NvbW1vbiIsInZhbHVlc0xlbmd0aCIsInZhbHVlc0luZGV4IiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRm9yT3duIiwiYmFzZUVhY2hSaWdodCIsImJhc2VGb3JPd25SaWdodCIsImJhc2VFdmVyeSIsImJhc2VFeHRyZW11bSIsImlzU3ltYm9sIiwiYmFzZUZpbGwiLCJ0b0ludGVnZXIiLCJ0b0xlbmd0aCIsImJhc2VGaWx0ZXIiLCJiYXNlRmxhdHRlbiIsImlzU3RyaWN0IiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImJhc2VHZXQiLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImJhc2VHZXRUYWciLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsImJhc2VHdCIsImJhc2VIYXMiLCJiYXNlSGFzSW4iLCJiYXNlSW5SYW5nZSIsImJhc2VJbnRlcnNlY3Rpb24iLCJhcnJheXMiLCJvdGhMZW5ndGgiLCJvdGhJbmRleCIsImNhY2hlcyIsIm1heExlbmd0aCIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzQXJyYXlCdWZmZXIiLCJiYXNlSXNEYXRlIiwiYmFzZUlzRXF1YWwiLCJiYXNlSXNFcXVhbERlZXAiLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsImVxdWFsQXJyYXlzIiwiZXF1YWxCeVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImVxdWFsT2JqZWN0cyIsImJhc2VJc01hcCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwic3JjVmFsdWUiLCJiYXNlSXNOYXRpdmUiLCJpc01hc2tlZCIsInBhdHRlcm4iLCJiYXNlSXNSZWdFeHAiLCJiYXNlSXNTZXQiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNMZW5ndGgiLCJiYXNlSXRlcmF0ZWUiLCJpZGVudGl0eSIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlTWF0Y2hlcyIsInByb3BlcnR5IiwiYmFzZUtleXMiLCJpc1Byb3RvdHlwZSIsImJhc2VLZXlzSW4iLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZUx0IiwiYmFzZU1hcCIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaXNLZXkiLCJpc1N0cmljdENvbXBhcmFibGUiLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJzYWZlR2V0IiwibWVyZ2VGdW5jIiwiaXNUeXBlZCIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY2xvbmVUeXBlZEFycmF5IiwiaXNQbGFpbk9iamVjdCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVNldCIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUHVsbEFsbCIsImJhc2VQdWxsQXQiLCJpbmRleGVzIiwicHJldmlvdXMiLCJiYXNlVW5zZXQiLCJiYXNlUmFuZ2UiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwiYmFzZVNldERhdGEiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsImJhc2VTaHVmZmxlIiwiYmFzZVNsaWNlIiwiYmFzZVNvbWUiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImJhc2VTb3J0ZWRJbmRleEJ5IiwidmFsSXNOYU4iLCJ2YWxJc051bGwiLCJ2YWxJc1N5bWJvbCIsInZhbElzVW5kZWZpbmVkIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsInNldExvdyIsImJhc2VTb3J0ZWRVbmlxIiwiYmFzZVRvTnVtYmVyIiwiYmFzZVRvU3RyaW5nIiwiYmFzZVVuaXEiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0IiwiY2FzdEZ1bmN0aW9uIiwic3RyaW5nVG9QYXRoIiwiY2FzdFJlc3QiLCJjYXN0U2xpY2UiLCJidWZmZXIiLCJjb3B5IiwiY2xvbmVBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJjbG9uZVJlZ0V4cCIsInJlZ2V4cCIsImNsb25lU3ltYm9sIiwic3ltYm9sIiwidHlwZWRBcnJheSIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc1JlZmxleGl2ZSIsIm9iakNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsImNvbXBvc2VBcmdzIiwicGFydGlhbHMiLCJob2xkZXJzIiwiaXNDdXJyaWVkIiwiYXJnc0luZGV4IiwiYXJnc0xlbmd0aCIsImhvbGRlcnNMZW5ndGgiLCJsZWZ0SW5kZXgiLCJsZWZ0TGVuZ3RoIiwicmFuZ2VMZW5ndGgiLCJpc1VuY3VycmllZCIsImNvbXBvc2VBcmdzUmlnaHQiLCJob2xkZXJzSW5kZXgiLCJyaWdodEluZGV4IiwicmlnaHRMZW5ndGgiLCJpc05ldyIsImdldFN5bWJvbHMiLCJnZXRTeW1ib2xzSW4iLCJjcmVhdGVBZ2dyZWdhdG9yIiwiaW5pdGlhbGl6ZXIiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiQ3RvciIsImNyZWF0ZUN0b3IiLCJ3cmFwcGVyIiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsInRyYWlsaW5nIiwiY3JlYXRlQ29tcG91bmRlciIsImNhbGxiYWNrIiwid29yZHMiLCJkZWJ1cnIiLCJ0aGlzQmluZGluZyIsImNyZWF0ZUN1cnJ5IiwiYXJpdHkiLCJnZXRIb2xkZXIiLCJjcmVhdGVSZWN1cnJ5IiwiY3JlYXRlSHlicmlkIiwiY3JlYXRlRmluZCIsImZpbmRJbmRleEZ1bmMiLCJjcmVhdGVGbG93IiwiZmxhdFJlc3QiLCJmdW5jcyIsInByZXJlcSIsInRocnUiLCJnZXRGdW5jTmFtZSIsImZ1bmNOYW1lIiwiZ2V0RGF0YSIsImlzTGF6aWFibGUiLCJwbGFudCIsInBhcnRpYWxzUmlnaHQiLCJob2xkZXJzUmlnaHQiLCJhcmdQb3MiLCJhcnkiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiZGVmYXVsdFZhbHVlIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsIm5vb3AiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiaXNQYXJ0aWFsIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJjb252ZXJ0Iiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsIm9ialN0YWNrZWQiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwib3RoZXJGdW5jIiwiaXNLZXlhYmxlIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJ0cmFuc2Zvcm1zIiwiZ2V0V3JhcERldGFpbHMiLCJoYXNGdW5jIiwiaW5wdXQiLCJpbnNlcnRXcmFwRGV0YWlscyIsImRldGFpbHMiLCJpc01hc2thYmxlIiwic3R1YkZhbHNlIiwibWVtb2l6ZUNhcHBlZCIsIm1lbW9pemUiLCJzcmNCaXRtYXNrIiwibmV3Qml0bWFzayIsImlzQ29tYm8iLCJvdGhlckFyZ3MiLCJvbGRBcnJheSIsInNob3J0T3V0IiwicmVmZXJlbmNlIiwidXBkYXRlV3JhcERldGFpbHMiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyYW5kIiwicXVvdGUiLCJzdWJTdHJpbmciLCJjaHVuayIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaWxsIiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJpbml0aWFsIiwiaW50ZXJzZWN0aW9uIiwibWFwcGVkIiwiaW50ZXJzZWN0aW9uQnkiLCJpbnRlcnNlY3Rpb25XaXRoIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRha2VSaWdodCIsInRha2VSaWdodFdoaWxlIiwidW5pb25CeSIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsInVuemlwIiwiZ3JvdXAiLCJ1bnppcFdpdGgiLCJ3aXRob3V0IiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInRhcCIsImludGVyY2VwdG9yIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0Iiwid3JhcHBlclRvSXRlcmF0b3IiLCJ3cmFwcGVyUGxhbnQiLCJ3cmFwcGVyUmV2ZXJzZSIsIndyYXBwZWQiLCJ3cmFwcGVyVmFsdWUiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImlzU3RyaW5nIiwiaW52b2tlTWFwIiwia2V5QnkiLCJvcmRlckJ5IiwicGFydGl0aW9uIiwicmVqZWN0IiwibmVnYXRlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJiZWZvcmUiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJpbnZva2VGdW5jIiwidGltZSIsImxlYWRpbmdFZGdlIiwidGltZXJFeHBpcmVkIiwicmVtYWluaW5nV2FpdCIsInRpbWVTaW5jZUxhc3RDYWxsIiwidGltZVNpbmNlTGFzdEludm9rZSIsInRpbWVXYWl0aW5nIiwic2hvdWxkSW52b2tlIiwidHJhaWxpbmdFZGdlIiwiY2FuY2VsIiwiZmx1c2giLCJkZWJvdW5jZWQiLCJpc0ludm9raW5nIiwiZGVmZXIiLCJkZWxheSIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm9uY2UiLCJvdmVyQXJncyIsImZ1bmNzTGVuZ3RoIiwicGFydGlhbCIsInBhcnRpYWxSaWdodCIsInJlYXJnIiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNFcnJvciIsImlzSW50ZWdlciIsImlzTWF0Y2giLCJpc01hdGNoV2l0aCIsImlzTnVtYmVyIiwiaXNOYXRpdmUiLCJpc05pbCIsImlzU2FmZUludGVnZXIiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJsdCIsImx0ZSIsInNpZ24iLCJyZW1haW5kZXIiLCJpc0JpbmFyeSIsInRvU2FmZUludGVnZXIiLCJhc3NpZ24iLCJhc3NpZ25JbiIsImFzc2lnbkluV2l0aCIsImFzc2lnbldpdGgiLCJhdCIsInByb3BlcnRpZXMiLCJwcm9wc0luZGV4IiwicHJvcHNMZW5ndGgiLCJkZWZhdWx0c0RlZXAiLCJmb3JJbiIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImZ1bmN0aW9uc0luIiwiaW52ZXJ0IiwiaW52ZXJ0QnkiLCJpbnZva2UiLCJtYXBWYWx1ZXMiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5IiwicHJvcCIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImZsb2F0aW5nIiwidGVtcCIsImNhbWVsQ2FzZSIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImNhcGl0YWxpemUiLCJ1cHBlckZpcnN0IiwiZW5kc1dpdGgiLCJwb3NpdGlvbiIsImVzY2FwZSIsImVzY2FwZVJlZ0V4cCIsImtlYmFiQ2FzZSIsImxvd2VyQ2FzZSIsImxvd2VyRmlyc3QiLCJwYWQiLCJzdHJMZW5ndGgiLCJwYWRFbmQiLCJwYWRTdGFydCIsInJhZGl4IiwicmVwZWF0Iiwic25ha2VDYXNlIiwibGltaXQiLCJzdGFydENhc2UiLCJzdGFydHNXaXRoIiwidGVtcGxhdGUiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwidmFyaWFibGUiLCJhdHRlbXB0IiwidG9Mb3dlciIsInRvVXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInNlYXJjaCIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2VSaWdodCIsInN0dWJPYmplY3QiLCJzdHViU3RyaW5nIiwic3R1YlRydWUiLCJ0b1BhdGgiLCJ1bmlxdWVJZCIsInByZWZpeCIsImF1Z2VuZCIsImFkZGVuZCIsImRpdmlkZSIsImRpdmlkZW5kIiwiZGl2aXNvciIsIm1lYW4iLCJtZWFuQnkiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJyb3VuZCIsIm1pbnVlbmQiLCJzdWJ0cmFoZW5kIiwic3VtQnkiLCJlbnRyaWVzSW4iLCJleHRlbmQiLCJleHRlbmRXaXRoIiwiZWFjaCIsImVhY2hSaWdodCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJnIiwid2luZG93Iiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwiY2hpbGRyZW4iLCJsIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRU8sU0FBU0EsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDakNDLG9EQUFLLENBQUNDLE1BQU4sQ0FBYUMsUUFBYixDQUFzQkgsTUFBTSxDQUFDSSxNQUE3QixFQUFxQyx5QkFBckM7QUFDQUgsb0RBQUssQ0FBQ0MsTUFBTixDQUFhQyxRQUFiLENBQXNCSCxNQUFNLENBQUNLLE1BQTdCLEVBQXFDLHlCQUFyQztBQUNBLE1BQVFELE1BQVIsR0FBMkJKLE1BQTNCLENBQVFJLE1BQVI7QUFBQSxNQUFnQkMsTUFBaEIsR0FBMkJMLE1BQTNCLENBQWdCSyxNQUFoQjtBQUVBLFNBQU87QUFDTEMsUUFBSSxFQUFFQyxxRUFERDtBQUVMSCxVQUFNLEVBQU5BLE1BRks7QUFHTEMsVUFBTSxFQUFOQTtBQUhLLEdBQVA7QUFLRCxDOzs7Ozs7Ozs7Ozs7QUNiRDtBQUFBO0FBQUE7QUFBTyxJQUFNRyxZQUFZLEdBQUcsY0FBckI7QUFDQSxJQUFNRCxXQUFXLEdBQUcsYUFBcEIsQzs7Ozs7Ozs7Ozs7O0FDRFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQU8sSUFBTUUsY0FBYyxHQUFHLENBQXZCO0FBQ0EsSUFBTUMsV0FBVyxHQUFHLENBQXBCO0FBQ0EsSUFBTUMsVUFBVSxHQUFHLENBQW5CO0FBQ0EsSUFBTUMsV0FBVyxHQUFHLENBQXBCO0FBQ0EsSUFBTUMsVUFBVSxHQUFHLENBQW5CO0FBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsQ0FBekI7QUFDQSxJQUFNQyxZQUFZLEdBQUcsQ0FBckI7QUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxDQUE1QjtBQUNBLElBQU1DLGFBQWEsR0FBRyxDQUF0QjtBQUNBLElBQU1DLGtCQUFrQixHQUFHLENBQTNCO0FBQ0EsSUFBTUMsb0JBQW9CLEdBQUcsRUFBN0I7QUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxFQUE1QjtBQUNBLElBQU1DLHdCQUF3QixHQUFHLEVBQWpDO0FBQ0EsSUFBTUMsdUJBQXVCLEdBQUcsRUFBaEMsQzs7Ozs7Ozs7Ozs7O0FDYlA7QUFBQTtBQUNBO0FBQ0EsSUFBTUMsSUFBSSxHQUFHLENBQWI7QUFFZTtBQUNiQyxPQUFLLEVBQUVELElBRE07QUFFYkUsUUFBTSxFQUFFRixJQUZLO0FBR2JHLFFBQU0sRUFBRSxPQUhLO0FBSWJDLGFBQVcsRUFBRSxlQUpBO0FBS2JDLE9BQUssRUFBRSxlQUxNO0FBTWJDLFVBQVEsRUFBRTtBQU5HLENBQWYsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBOztJQU1NQyxJO0FBQ0osc0JBQTREO0FBQUEsMkJBQTlDOUIsTUFBOEM7QUFBQSxRQUE5Q0EsTUFBOEMsNEJBQXJDLElBQXFDO0FBQUEsMkJBQS9CK0IsTUFBK0I7QUFBQSxRQUEvQkEsTUFBK0IsNEJBQXRCLElBQXNCO0FBQUEsMEJBQWhCQyxLQUFnQjtBQUFBLFFBQWhCQSxLQUFnQiwyQkFBUixJQUFROztBQUFBOztBQUMxRDtBQUNBLFNBQUtoQyxNQUFMLEdBQWNBLE1BQWQsQ0FGMEQsQ0FJMUQ7O0FBQ0EsU0FBS2lDLFVBQUwsR0FBa0JGLE1BQWxCO0FBQ0EsU0FBS0csVUFBTCxHQUFrQixJQUFJQyxHQUFKLENBQVEsRUFBUixDQUFsQjtBQUNBLFNBQUtDLElBQUwsR0FBWSxDQUFaO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLENBQWQ7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLElBQUlILEdBQUosQ0FBUUkseUVBQVUsQ0FBQ1AsS0FBRCxDQUFsQixDQUF0QjtBQUNBLFNBQUtRLGFBQUwsR0FBcUJDLCtFQUFnQixDQUFDVCxLQUFELENBQXJDO0FBQ0Q7Ozs7V0FFRCxrQkFBU2hDLE1BQVQsRUFBaUJnQyxLQUFqQixFQUF3QjtBQUN0QixVQUFNVSxDQUFDLEdBQUcsSUFBSVosSUFBSixDQUFTO0FBQUU5QixjQUFNLEVBQU5BLE1BQUY7QUFBVWdDLGFBQUssRUFBTEEsS0FBVjtBQUFpQkQsY0FBTSxFQUFFO0FBQXpCLE9BQVQsQ0FBVjtBQUNBLFdBQUtPLGNBQUwsQ0FBb0JLLE1BQXBCLENBQTJCM0MsTUFBM0I7QUFDQSxXQUFLa0MsVUFBTCxDQUFnQlUsR0FBaEIsQ0FBb0JGLENBQXBCO0FBQ0EsYUFBT0EsQ0FBUDtBQUNEOzs7V0FFRCxnQkFBT0csTUFBUCxFQUFlO0FBQ2IsV0FBS1IsTUFBTCxJQUFlLENBQWY7QUFDQSxXQUFLRCxJQUFMLElBQWFTLE1BQWI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztXQUNFLDJCQUFrQjtBQUFBOztBQUNoQixhQUFPQyw2Q0FBQyxDQUFDQyxLQUFLLENBQUNDLElBQU4sQ0FBVyxLQUFLZCxVQUFoQixDQUFELENBQUQsQ0FDSmUsTUFESSxDQUVILFVBQUNQLENBQUQ7QUFBQSxlQUNFQSxDQUFDLENBQUNOLElBQUYsR0FBU00sQ0FBQyxDQUFDTCxNQUFYLEdBQW9CYSxJQUFJLENBQUNDLElBQUwsQ0FBVyxJQUFJRCxJQUFJLENBQUNFLEdBQUwsQ0FBUyxLQUFJLENBQUNmLE1BQWQsQ0FBTCxHQUE4QkssQ0FBQyxDQUFDTCxNQUExQyxDQUR0QjtBQUFBLE9BRkcsRUFLSmdCLElBTEksRUFBUDtBQU1EOzs7Ozs7QUFHSCxTQUFTQyxhQUFULENBQXVCdEIsS0FBdkIsRUFBOEJ1QixNQUE5QixFQUFzQztBQUNwQyxNQUFJQSxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNuQixXQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFRdkIsS0FBSyxDQUFDd0IsTUFBZDtBQUNFLFNBQUtELE1BQU0sQ0FBQ2xELE1BQVo7QUFDRSxhQUFPLENBQUMsQ0FBUjs7QUFDRixTQUFLLElBQUw7QUFDRTtBQUNBLGFBQU8sQ0FBUDs7QUFDRjtBQUNFLGFBQU8sQ0FBUDtBQVBKO0FBU0Q7O0lBRW9Cb0Qsb0I7QUFDbkIsa0NBQTBCO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUN4QjtBQUNKO0FBQ0E7QUFDSSxTQUFLQyxXQUFMLEdBQW1CRCxPQUFPLENBQUNDLFdBQVIsSUFBdUIsSUFBMUM7QUFFQTtBQUNKO0FBQ0E7O0FBQ0ksU0FBS0MsS0FBTCxHQUFhRixPQUFPLENBQUNFLEtBQVIsSUFBaUIsS0FBOUI7QUFDRDs7OztXQUVELHVCQUFjQyxZQUFkLEVBQTRCQyxTQUE1QixFQUF1QztBQUNyQyxVQUFNQyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxLQUFhLEtBQUtOLFdBQXBDO0FBQ0EsVUFBTU8sUUFBUSxHQUFHLElBQUlwQyxJQUFKLENBQVM7QUFBRUUsYUFBSyxFQUFFOEI7QUFBVCxPQUFULENBQWpCO0FBRUEsVUFBSUssVUFBVSxHQUFHLENBQWpCOztBQUNBLGFBQU9ILElBQUksQ0FBQ0MsR0FBTCxLQUFhRixTQUFwQixFQUErQjtBQUM3QixZQUFJSyxJQUFJLEdBQUdGLFFBQVg7QUFDQSxZQUFJbEMsS0FBSyxHQUFHOEIsU0FBWixDQUY2QixDQUk3Qjs7QUFDQSxlQUFPTSxJQUFJLENBQUM5QixjQUFMLENBQW9CZixJQUFwQixLQUE2QixDQUE3QixJQUFrQzZDLElBQUksQ0FBQ2xDLFVBQUwsQ0FBZ0JYLElBQWhCLEdBQXVCLENBQWhFLEVBQW1FO0FBQ2pFNkMsY0FBSSxHQUFHQSxJQUFJLENBQUNDLGVBQUwsRUFBUDtBQUNBckMsZUFBSyxHQUFHc0MsdUVBQVcsQ0FBQ3RDLEtBQUQsRUFBUW9DLElBQUksQ0FBQ3BFLE1BQWIsQ0FBbkI7QUFDRCxTQVI0QixDQVU3Qjs7O0FBQ0EsWUFBSW9FLElBQUksQ0FBQzlCLGNBQUwsQ0FBb0JmLElBQXBCLEdBQTJCLENBQS9CLEVBQWtDO0FBQ2hDLGNBQUl2QixNQUFNLEdBQUc4Qyw2Q0FBQyxDQUFDeUIsTUFBRixDQUFTeEIsS0FBSyxDQUFDQyxJQUFOLENBQVdvQixJQUFJLENBQUM5QixjQUFoQixDQUFULENBQWI7O0FBQ0FOLGVBQUssR0FBR3NDLHVFQUFXLENBQUN0QyxLQUFELEVBQVFoQyxNQUFSLENBQW5CO0FBQ0FvRSxjQUFJLEdBQUdBLElBQUksQ0FBQ0ksUUFBTCxDQUFjeEUsTUFBZCxFQUFzQmdDLEtBQXRCLENBQVA7QUFDRCxTQWY0QixDQWlCN0I7QUFDQTs7O0FBQ0EsWUFBSXlDLFlBQVksR0FBR0MsOEVBQWUsQ0FBQzFDLEtBQUQsQ0FBbEM7O0FBQ0EsZUFBT3lDLFlBQVksS0FBSyxJQUF4QixFQUE4QjtBQUM1QnpDLGVBQUssR0FBR3NDLHVFQUFXLENBQUN0QyxLQUFELEVBQVF5QyxZQUFSLENBQW5CO0FBQ0FBLHNCQUFZLEdBQUdDLDhFQUFlLENBQUMxQyxLQUFELENBQTlCO0FBQ0QsU0F2QjRCLENBeUI3Qjs7O0FBQ0EsZUFBT29DLElBQUksS0FBSyxJQUFoQixFQUFzQjtBQUNwQkEsY0FBSSxDQUFDTyxNQUFMLENBQVlyQixhQUFhLENBQUN0QixLQUFELEVBQVFvQyxJQUFJLENBQUM1QixhQUFiLENBQXpCO0FBQ0E0QixjQUFJLEdBQUdBLElBQUksQ0FBQ25DLFVBQVo7QUFDRDs7QUFFRGtDLGtCQUFVLElBQUksQ0FBZDtBQUNEOztBQUVELFVBQU1TLFdBQVcsR0FBRzlCLDZDQUFDLENBQUNDLEtBQUssQ0FBQ0MsSUFBTixDQUFXa0IsUUFBUSxDQUFDaEMsVUFBcEIsQ0FBRCxDQUFELENBQW1DZSxNQUFuQyxDQUEwQyxRQUExQyxDQUFwQjs7QUFFQSxVQUFJLEtBQUtXLEtBQVQsRUFBZ0I7QUFDZCxZQUFNaUIsWUFBWSxHQUFHL0IsNkNBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFOLENBQVdrQixRQUFRLENBQUNoQyxVQUFwQixDQUFELENBQUQsQ0FBbUNlLE1BQW5DLENBQ25CLGVBRG1CLENBQXJCOztBQUdBNEIsb0JBQVksQ0FBQ0MsT0FBYixDQUFxQixVQUFDcEMsQ0FBRDtBQUFBLGlCQUNuQnFDLE9BQU8sQ0FBQzNCLEdBQVIsV0FDS1YsQ0FBQyxDQUFDTCxNQURQLGlCQUNvQkssQ0FBQyxDQUFDTixJQUR0Qiw2QkFDNkNNLENBQUMsQ0FBQzFDLE1BQUYsQ0FBU0ksTUFEdEQsRUFEbUI7QUFBQSxTQUFyQjtBQUtEOztBQUVELGFBQU87QUFDTDRFLGtCQUFVLEVBQUVKLFdBQVcsQ0FBQ3ZCLElBQVosR0FBbUJyRCxNQUQxQjtBQUVMbUUsa0JBQVUsRUFBVkE7QUFGSyxPQUFQO0FBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BJSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQSxJQUFNMUIsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFDVCxLQUFELEVBQVc7QUFDbEMsTUFBSUEsS0FBSyxDQUFDaUQsT0FBTixLQUFrQkMsU0FBbEIsSUFBK0JsRCxLQUFLLENBQUNpRCxPQUFOLENBQWNFLE1BQWQsS0FBeUIsQ0FBNUQsRUFBK0Q7QUFDN0QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBT25ELEtBQUssQ0FBQ2lELE9BQU4sQ0FBY2pELEtBQUssQ0FBQ29ELGdCQUFOLEdBQXlCcEQsS0FBSyxDQUFDcUQsVUFBN0MsQ0FBUDtBQUNELENBTkQ7O0FBUUEsSUFBTUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDdEQsS0FBRCxFQUFRdUIsTUFBUixFQUFtQjtBQUN6QyxNQUFJdkIsS0FBSyxDQUFDaUQsT0FBTixLQUFrQkMsU0FBdEIsRUFBaUM7QUFDL0IsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBTTFDLGFBQWEsR0FBR0MsZ0JBQWdCLENBQUNULEtBQUQsQ0FBdEM7O0FBQ0EsTUFBSVEsYUFBYSxLQUFLLElBQXRCLEVBQTRCO0FBQzFCLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU9BLGFBQWEsQ0FBQytDLElBQWQsS0FBdUJoQyxNQUFNLENBQUNnQyxJQUFyQztBQUNELENBWEQ7O0FBYUEsSUFBTWhELFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUNQLEtBQUQsRUFBVztBQUM1QixNQUFJQSxLQUFLLENBQUN3QixNQUFWLEVBQWtCO0FBQ2hCLFdBQU8sRUFBUDtBQUNEOztBQUVELFNBQU94QixLQUFLLENBQUN3RCxLQUFOLENBQVlDLE9BQVosQ0FBb0JDLE9BQXBCLEdBQThCQyxHQUE5QixDQUFrQyxVQUFDdkYsTUFBRCxFQUFZO0FBQ25ELFdBQU9MLDRFQUFVLENBQUM7QUFDaEJLLFlBQU0sRUFBRUEsTUFEUTtBQUVoQkMsWUFBTSxFQUFFb0MsZ0JBQWdCLENBQUNULEtBQUQsQ0FBaEIsQ0FBd0IzQjtBQUZoQixLQUFELENBQWpCO0FBSUQsR0FMTSxDQUFQO0FBTUQsQ0FYRDs7QUFhQSxJQUFNcUUsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDMUMsS0FBRCxFQUFXO0FBQ2pDLE1BQUlBLEtBQUssQ0FBQ3dCLE1BQVYsRUFBa0I7QUFDaEIsV0FBTyxJQUFQO0FBQ0QsR0FIZ0MsQ0FLakM7OztBQUNBLE1BQU1vQyxZQUFZLEdBQUc1RCxLQUFLLENBQUN3RCxLQUFOLENBQVlDLE9BQVosQ0FBb0JDLE9BQXBCLEVBQXJCOztBQUNBLE1BQUlFLFlBQVksQ0FBQ1QsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM3QixXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPcEYsNEVBQVUsQ0FBQztBQUNoQkssVUFBTSxFQUFFMEMsNkNBQUMsQ0FBQ3lCLE1BQUYsQ0FBU3FCLFlBQVQsQ0FEUTtBQUVoQnZGLFVBQU0sRUFBRW9DLGdCQUFnQixDQUFDVCxLQUFELENBQWhCLENBQXdCM0I7QUFGaEIsR0FBRCxDQUFqQjtBQUlELENBZkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7Q0FHQTtBQUNBOztBQUNlLHlFQUFDd0YsSUFBRCxFQUFVO0FBQUE7O0FBQ3ZCLFNBQU87QUFDTFQsb0JBQWdCLEVBQUUsQ0FEYjtBQUVMUyxRQUFJLEVBQUVBLElBRkQ7QUFHTEMsWUFBUSxFQUFFLEVBSEw7QUFJTFQsY0FBVSxFQUFFLENBSlA7QUFLTEosV0FBTyxFQUFFLEVBTEo7QUFNTGMsY0FBVSxrREFDUHBGLGdFQURPLEVBQ01tQyw2Q0FBQyxDQUFDa0QsS0FBRixDQUFRbEQsNkNBQUMsQ0FBQ21ELEtBQUYsQ0FBUSxDQUFSLEVBQVdKLElBQUksQ0FBQ3JFLEtBQWhCLENBQVIsRUFDWDBFLE9BRFcsQ0FDSCxVQUFDQyxDQUFEO0FBQUEsYUFBTyxDQUFDQyx1RUFBc0IsQ0FBQ1AsSUFBRCxFQUFPTSxDQUFQLEVBQVUsQ0FBVixDQUF2QixDQUFQO0FBQUEsS0FERyxFQUVYRSxLQUZXLEVBRE4sZ0NBSVAzRixpRUFKTyxFQUlPb0MsNkNBQUMsQ0FBQ2tELEtBQUYsQ0FBUWxELDZDQUFDLENBQUNtRCxLQUFGLENBQVEsQ0FBUixFQUFXSixJQUFJLENBQUNwRSxNQUFoQixDQUFSLEVBQ1p5RSxPQURZLENBQ0osVUFBQ0ksQ0FBRDtBQUFBLGFBQU8sQ0FBQ0YsdUVBQXNCLENBQUNQLElBQUQsRUFBTyxDQUFQLEVBQVVTLENBQVYsQ0FBdkIsQ0FBUDtBQUFBLEtBREksRUFFWkQsS0FGWSxFQUpQLGVBTkw7QUFjTEUsWUFBUSw4Q0FDTDVGLGdFQURLLEVBQ1FtQyw2Q0FBQyxDQUFDa0QsS0FBRixDQUFRbEQsNkNBQUMsQ0FBQ21ELEtBQUYsQ0FBUSxDQUFSLEVBQVdKLElBQUksQ0FBQ3JFLEtBQWhCLENBQVIsRUFDWDBFLE9BRFcsQ0FDSCxVQUFDQyxDQUFEO0FBQUEsYUFBTyxDQUFDQyx1RUFBc0IsQ0FBQ1AsSUFBRCxFQUFPTSxDQUFQLEVBQVVOLElBQUksQ0FBQ3BFLE1BQUwsR0FBYyxDQUF4QixDQUF2QixDQUFQO0FBQUEsS0FERyxFQUVYNEUsS0FGVyxFQURSLDhCQUlMM0YsaUVBSkssRUFJU29DLDZDQUFDLENBQUNrRCxLQUFGLENBQVFsRCw2Q0FBQyxDQUFDbUQsS0FBRixDQUFRLENBQVIsRUFBV0osSUFBSSxDQUFDcEUsTUFBaEIsQ0FBUixFQUNaeUUsT0FEWSxDQUNKLFVBQUNJLENBQUQ7QUFBQSxhQUFPLENBQUNGLHVFQUFzQixDQUFDUCxJQUFELEVBQU9BLElBQUksQ0FBQ3JFLEtBQUwsR0FBYSxDQUFwQixFQUF1QjhFLENBQXZCLENBQXZCLENBQVA7QUFBQSxLQURJLEVBRVpELEtBRlksRUFKVCxhQWRIO0FBc0JMYixTQUFLLEVBQUU7QUFDTEMsYUFBTyxFQUFFLElBQUl0RCw2Q0FBSixDQUFRcUUsMkRBQVUsQ0FBQ1gsSUFBRCxDQUFsQixDQURKO0FBRUxZLFVBQUksRUFBRSxJQUFJdEUsNkNBQUosRUFGRDtBQUdMdUUsU0FBRyxFQUFFLElBQUl2RSw2Q0FBSjtBQUhBLEtBdEJGO0FBMkJMcUIsVUFBTSxFQUFFO0FBM0JILEdBQVA7QUE2QkQsQ0E5QkQsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNtRCxXQUFULENBQXFCbkIsS0FBckIsRUFBNEJwRixNQUE1QixFQUFvQ29DLGFBQXBDLEVBQW1EO0FBQ2pELFNBQU87QUFDTGtFLE9BQUcsRUFDRGxFLGFBQWEsQ0FBQ25DLE1BQWQsS0FBeUJNLGdFQUF6QixHQUFzQzZFLEtBQUssQ0FBQ2tCLEdBQU4sQ0FBVTlELEdBQVYsQ0FBY3hDLE1BQWQsQ0FBdEMsR0FBOERvRixLQUFLLENBQUNrQixHQUZqRTtBQUdMRCxRQUFJLEVBQ0ZqRSxhQUFhLENBQUNuQyxNQUFkLEtBQXlCSyxpRUFBekIsR0FDSThFLEtBQUssQ0FBQ2lCLElBQU4sQ0FBVzdELEdBQVgsQ0FBZXhDLE1BQWYsQ0FESixHQUVJb0YsS0FBSyxDQUFDaUIsSUFOUDtBQU9MaEIsV0FBTyxFQUFFRCxLQUFLLENBQUNDLE9BQU4sQ0FBYzlDLE1BQWQsQ0FBcUJ2QyxNQUFyQjtBQVBKLEdBQVA7QUFTRDs7QUFFRCxTQUFTd0csUUFBVCxDQUFrQnhHLE1BQWxCLEVBQTBCQyxNQUExQixFQUFrQ21GLEtBQWxDLEVBQXlDTyxVQUF6QyxFQUFxRFEsUUFBckQsRUFBK0RWLElBQS9ELEVBQXFFO0FBQ25FLE1BQU1nQixXQUFXLEdBQUd4RyxNQUFNLEtBQUtNLGdFQUFYLEdBQXdCNkUsS0FBSyxDQUFDa0IsR0FBOUIsR0FBb0NsQixLQUFLLENBQUNpQixJQUE5RCxDQURtRSxDQUduRTs7QUFDQSxNQUFNSyxjQUFjLEdBQUdELFdBQVcsQ0FBQ0UsUUFBWixFQUF2Qjs7QUFDQSxNQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFDNUcsTUFBRDtBQUFBLFdBQVkwRyxjQUFjLENBQUMxRyxNQUFELENBQWQsS0FBMkI4RSxTQUF2QztBQUFBLEdBQWY7O0FBRUEsTUFBTStCLFdBQVcsR0FBR0Msd0RBQU8sQ0FBQ3JCLElBQUQsRUFBTyxDQUFDekYsTUFBRCxDQUFQLEVBQWlCMkYsVUFBakIsRUFBNkI7QUFDdERvQixjQUFVLEVBQUVIO0FBRDBDLEdBQTdCLENBQTNCO0FBR0EsTUFBTUksU0FBUyxHQUFHRix3REFBTyxDQUFDckIsSUFBRCxFQUFPLENBQUN6RixNQUFELENBQVAsRUFBaUJtRyxRQUFqQixFQUEyQjtBQUFFWSxjQUFVLEVBQUVIO0FBQWQsR0FBM0IsQ0FBekI7O0FBRUEsTUFBSUMsV0FBVyxJQUFJRyxTQUFuQixFQUE4QjtBQUM1QixXQUFPL0csTUFBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVjLFNBQVNnSCxVQUFULENBQW9CckYsS0FBcEIsRUFBMkJoQyxNQUEzQixFQUFtQztBQUNoRCxNQUFJZ0MsS0FBSyxLQUFLa0QsU0FBZCxFQUF5QjtBQUN2QixXQUFPb0MsbUVBQUksQ0FBQ0MsMERBQUQsQ0FBWDtBQUNEOztBQUVELFVBQVF2SCxNQUFNLENBQUNNLElBQWY7QUFDRSxTQUFLRSxzRUFBTDtBQUNFLDZDQUNLd0IsS0FETDtBQUVFaUQsZUFBTyxFQUFFakYsTUFBTSxDQUFDaUY7QUFGbEI7O0FBS0YsU0FBSzFFLHFFQUFMO0FBQ0UsVUFBSXlCLEtBQUssQ0FBQ3dCLE1BQVYsRUFBa0I7QUFDaEJ1QixlQUFPLENBQUMzQixHQUFSO0FBQ0EsZUFBT3BCLEtBQVA7QUFDRDs7QUFFRCxVQUFJQSxLQUFLLENBQUN3RCxLQUFOLENBQVlDLE9BQVosQ0FBb0IrQixRQUFwQixDQUE2QnhILE1BQU0sQ0FBQ0ksTUFBcEMsTUFBZ0QsS0FBcEQsRUFBMkQ7QUFDekQyRSxlQUFPLENBQUMzQixHQUFSLENBQVksa0NBQVosRUFBZ0RwRCxNQUFNLENBQUNJLE1BQXZEO0FBQ0EsZUFBTzRCLEtBQVA7QUFDRDs7QUFFRCxVQUFJaEMsTUFBTSxDQUFDSyxNQUFQLEtBQWtCb0MsK0VBQWdCLENBQUNULEtBQUQsQ0FBaEIsQ0FBd0IzQixNQUE5QyxFQUFzRDtBQUNwRDBFLGVBQU8sQ0FBQzNCLEdBQVIsQ0FBWSwyQkFBWjtBQUNBLGVBQU9wQixLQUFQO0FBQ0Q7O0FBRUQsVUFBTVEsYUFBYSxHQUFHQywrRUFBZ0IsQ0FBQ1QsS0FBRCxDQUF0Qzs7QUFDQSxVQUFJeUYsRUFBRSxtQ0FDRHpGLEtBREM7QUFFSndELGFBQUssRUFBRW1CLFdBQVcsQ0FBQzNFLEtBQUssQ0FBQ3dELEtBQVAsRUFBY3hGLE1BQU0sQ0FBQ0ksTUFBckIsRUFBNkJvQyxhQUE3QixDQUZkO0FBR0o0Qyx3QkFBZ0IsRUFBRXBELEtBQUssQ0FBQ29ELGdCQUFOLEdBQXlCO0FBSHZDLFFBQU47O0FBTUFxQyxRQUFFLENBQUNqRSxNQUFILEdBQVlvRCxRQUFRLENBQ2xCNUcsTUFBTSxDQUFDSSxNQURXLEVBRWxCb0MsYUFBYSxDQUFDbkMsTUFGSSxFQUdsQm9ILEVBQUUsQ0FBQ2pDLEtBSGUsRUFJbEJpQyxFQUFFLENBQUMxQixVQUFILENBQWN2RCxhQUFhLENBQUNuQyxNQUE1QixDQUprQixFQUtsQm9ILEVBQUUsQ0FBQ2xCLFFBQUgsQ0FBWS9ELGFBQWEsQ0FBQ25DLE1BQTFCLENBTGtCLEVBTWxCb0gsRUFBRSxDQUFDNUIsSUFOZSxDQUFwQjtBQVFBLGFBQU80QixFQUFQOztBQUVGO0FBQ0UsYUFBT3pGLEtBQVA7QUF6Q0o7QUEyQ0QsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEZEO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzBGLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDO0FBQzlCNUMsU0FBTyxDQUFDM0IsR0FBUixnREFBMkR1RSxPQUEzRDtBQUVBLE1BQU1DLFVBQVUsR0FDZCxRQUFPRCxPQUFQLE1BQW1CLFFBQW5CLEdBQThCQSxPQUFPLENBQUNFLElBQXRDLEdBQTZDQyxJQUFJLENBQUNDLEtBQUwsQ0FBV0osT0FBWCxDQUQvQzs7QUFHQSxVQUFRQyxVQUFVLENBQUM1SCxNQUFuQjtBQUNFLFNBQUssZUFBTDtBQUNFO0FBQ0E7QUFDQSxVQUFRNEQsS0FBUixHQUEyRGdFLFVBQTNELENBQVFoRSxLQUFSO0FBQUEsVUFBZUMsWUFBZixHQUEyRCtELFVBQTNELENBQWUvRCxZQUFmO0FBQUEsVUFBNkI3QixLQUE3QixHQUEyRDRGLFVBQTNELENBQTZCNUYsS0FBN0I7QUFBQSxrQ0FBMkQ0RixVQUEzRCxDQUFvQ2pFLFdBQXBDO0FBQUEsVUFBb0NBLFdBQXBDLHNDQUFrRCxJQUFsRCx5QkFIRixDQUtFOztBQUNBM0IsV0FBSyxDQUFDd0QsS0FBTixDQUFZQyxPQUFaLEdBQXNCLElBQUl0RCw2Q0FBSixDQUFRNkYsd0RBQU0sQ0FBQ2hHLEtBQUssQ0FBQ3dELEtBQU4sQ0FBWUMsT0FBYixDQUFkLENBQXRCO0FBQ0F6RCxXQUFLLENBQUN3RCxLQUFOLENBQVlrQixHQUFaLEdBQWtCLElBQUl2RSw2Q0FBSixDQUFRNkYsd0RBQU0sQ0FBQ2hHLEtBQUssQ0FBQ3dELEtBQU4sQ0FBWWtCLEdBQWIsQ0FBZCxDQUFsQjtBQUNBMUUsV0FBSyxDQUFDd0QsS0FBTixDQUFZaUIsSUFBWixHQUFtQixJQUFJdEUsNkNBQUosQ0FBUTZGLHdEQUFNLENBQUNoRyxLQUFLLENBQUN3RCxLQUFOLENBQVlpQixJQUFiLENBQWQsQ0FBbkI7QUFFQSxVQUFNd0IsSUFBSSxHQUFHLElBQUl4RSxnRUFBSixDQUF5QjtBQUFFRSxtQkFBVyxFQUFYQSxXQUFGO0FBQWVDLGFBQUssRUFBTEE7QUFBZixPQUF6QixDQUFiO0FBQ0EsVUFBTTVELE1BQU0sR0FBR2lJLElBQUksQ0FBQ0MsYUFBTCxDQUFtQnJFLFlBQW5CLEVBQWlDN0IsS0FBakMsQ0FBZjtBQUNBK0MsYUFBTyxDQUFDM0IsR0FBUixtQkFBOEJwRCxNQUE5Qjs7QUFFQSxVQUFJLE9BQU9tSSxXQUFQLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3RDQSxtQkFBVyxDQUFDbkksTUFBRCxDQUFYO0FBQ0Q7O0FBRUQsYUFBT0EsTUFBUDs7QUFDRjtBQUNFK0UsYUFBTyxDQUFDcUQsSUFBUixxQ0FBMENULE9BQU8sQ0FBQ0UsSUFBUixDQUFhN0gsTUFBdkQ7QUFyQko7QUF1QkQ7O0FBRUQsSUFBSSxPQUFPcUksU0FBUCxLQUFxQixXQUF6QixFQUFzQztBQUNwQ3RELFNBQU8sQ0FBQzNCLEdBQVI7QUFDQWlGLFdBQVMsR0FBR1gsYUFBWjtBQUNEOztBQUVjQSw0RUFBZixFOzs7Ozs7Ozs7OztBQzlDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVDLFdBQVVZLE9BQVYsRUFBbUI7QUFDaEI7O0FBRUEsTUFBSXhDLFFBQUosRUFBY3lDLFVBQWQsRUFBMEJDLFNBQTFCLEVBQXFDdEksTUFBckMsRUFBNkN1SSxHQUE3QyxFQUFrREMsS0FBbEQsRUFBeURDLE1BQXpELEVBQWlFQyxXQUFqRSxFQUE4RUMsS0FBOUU7QUFFQS9DLFVBQVEsR0FBRztBQUNQZ0QsUUFBSSxFQUFFLGNBREM7QUFFUEMsWUFBUSxFQUFFLGNBRkg7QUFHUEMsZUFBVyxFQUFFLGdCQUhOO0FBSVBDLFVBQU0sRUFBRSxnQkFKRDtBQUtQOUksWUFBUSxFQUFFLGVBTEg7QUFNUCtFLGFBQVMsRUFBRSxlQU5KO0FBT1BnRSxRQUFJLEVBQUUsZUFQQztBQVFQQyxhQUFTLEVBQUUsZ0JBUko7QUFTUEMsY0FBVSxFQUFFLGVBVEw7QUFVUEMsU0FBSyxFQUFFLGVBVkE7QUFXUEMsYUFBUyxFQUFFLDJCQVhKO0FBWVBDLFlBQVEsRUFBRSxrQkFaSDtBQWFQQyxRQUFJLEVBQUUsY0FiQztBQWNQQyxTQUFLLEVBQUUsZUFkQTtBQWVQQyxZQUFRLEVBQUUsa0JBZkg7QUFnQlBDLFNBQUssRUFBRSxnQkFoQkE7QUFpQlBuQyxZQUFRLEVBQUUsZ0JBakJIO0FBa0JQb0MsaUJBQWEsRUFBRSxnQkFsQlI7QUFtQlBDLFVBQU0sRUFBRSxnQkFuQkQ7QUFvQlBDLE9BQUcsRUFBRSxnQkFwQkU7QUFxQlBDLFFBQUksRUFBRSxnQkFyQkM7QUFzQlBDLFdBQU8sRUFBRSxnQkF0QkY7QUF1QlBDLGtCQUFjLEVBQUUsZ0JBdkJUO0FBd0JQQyxlQUFXLEVBQUUsZ0JBeEJOO0FBeUJQQyxXQUFPLEVBQUUsZ0JBekJGO0FBMEJQQyxXQUFPLEVBQUUsZ0JBMUJGO0FBMkJQQyxRQUFJLEVBQUUsZ0JBM0JDO0FBNEJQQyxZQUFRLEVBQUUsZ0JBNUJIO0FBNkJQQyxZQUFRLEVBQUUsZ0JBN0JIO0FBOEJQQyxXQUFPLEVBQUUsZ0JBOUJGO0FBK0JQQyxRQUFJLEVBQUUsZ0JBL0JDO0FBZ0NQQyxVQUFNLEVBQUUsZ0JBaENEO0FBaUNQQyxXQUFPLEVBQUU7QUFqQ0YsR0FBWDtBQW9DQXBDLFlBQVUsR0FBRztBQUNUTyxRQUFJLEVBQUVBLElBREc7QUFFVEMsWUFBUSxFQUFFQSxRQUZEO0FBR1RDLGVBQVcsRUFBRUEsV0FISjtBQUlUQyxVQUFNLEVBQUVBLE1BSkM7QUFLVDlJLFlBQVEsRUFBRUEsUUFMRDtBQU1UK0UsYUFBUyxFQUFFMEYsV0FORjtBQU9UMUIsUUFBSSxFQUFFMkIsTUFQRztBQVFUMUIsYUFBUyxFQUFFQSxTQVJGO0FBU1RDLGNBQVUsRUFBRUEsVUFUSDtBQVVUQyxTQUFLLEVBQUVBLEtBVkU7QUFXVEMsYUFBUyxFQUFFQSxTQVhGO0FBWVRDLFlBQVEsRUFBRUEsUUFaRDtBQWFUQyxRQUFJLEVBQUVBLElBYkc7QUFjVEMsU0FBSyxFQUFFQSxLQWRFO0FBZVRDLFlBQVEsRUFBRW9CLFVBZkQ7QUFnQlRuQixTQUFLLEVBQUVBLEtBaEJFO0FBaUJUbkMsWUFBUSxFQUFFQSxRQWpCRDtBQWtCVG9DLGlCQUFhLEVBQUVBLGFBbEJOO0FBbUJUQyxVQUFNLEVBQUVBLE1BbkJDO0FBb0JUQyxPQUFHLEVBQUVBLEdBcEJJO0FBcUJUQyxRQUFJLEVBQUVBLElBckJHO0FBc0JUQyxXQUFPLEVBQUVBLE9BdEJBO0FBdUJUQyxrQkFBYyxFQUFFQSxjQXZCUDtBQXdCVEMsZUFBVyxFQUFFQSxXQXhCSjtBQXlCVEMsV0FBTyxFQUFFQSxPQXpCQTtBQTBCVEMsV0FBTyxFQUFFQSxPQTFCQTtBQTJCVEMsUUFBSSxFQUFFQSxJQTNCRztBQTRCVEMsWUFBUSxFQUFFQSxRQTVCRDtBQTZCVEMsWUFBUSxFQUFFQSxRQTdCRDtBQThCVEMsV0FBTyxFQUFHQSxPQTlCRDtBQStCVEMsUUFBSSxFQUFFQSxJQS9CRztBQWdDVEMsVUFBTSxFQUFFQSxNQWhDQztBQWlDVEMsV0FBTyxFQUFFQTtBQWpDQSxHQUFiO0FBb0NBbkMsV0FBUyxHQUFHO0FBQ1J1QyxTQUFLLEVBQUVBLEtBREM7QUFFUnBGLE9BQUcsRUFBRUEsR0FGRztBQUdScUYsT0FBRyxFQUFFQSxHQUhHO0FBSVJDLE9BQUcsRUFBRUE7QUFKRyxHQUFaO0FBT0FyQyxhQUFXLEdBQUcsQ0FBRSxPQUFGLEVBQVcsV0FBWCxFQUF3QixVQUF4QixFQUFvQyxRQUFwQyxDQUFkO0FBQ0FDLE9BQUssR0FBRzlGLEtBQUssQ0FBQ21JLFNBQU4sQ0FBZ0JyQyxLQUF4QjtBQUVBTCxXQUFTLEdBQUcyQyxLQUFLLENBQUMzQyxTQUFELEVBQVlELFVBQVosQ0FBakI7QUFDQXJJLFFBQU0sR0FBR2tMLHdCQUF3QixDQUFDQyxjQUFELEVBQWlCQyxVQUFqQixDQUFqQztBQUNBN0MsS0FBRyxHQUFHMkMsd0JBQXdCLENBQUNHLFdBQUQsRUFBY0MsT0FBZCxDQUE5QjtBQUNBOUMsT0FBSyxHQUFHMEMsd0JBQXdCLENBQUNLLGFBQUQsRUFBZ0JDLFNBQWhCLENBQWhDO0FBQ0EvQyxRQUFNLEdBQUd5Qyx3QkFBd0IsQ0FBQ08sY0FBRCxDQUFqQztBQUNBekwsUUFBTSxDQUFDdUksR0FBUCxHQUFhbUQsc0JBQXNCLENBQUNQLGNBQUQsRUFBaUI1QyxHQUFqQixDQUFuQztBQUNBdkksUUFBTSxDQUFDd0ksS0FBUCxHQUFla0Qsc0JBQXNCLENBQUNQLGNBQUQsRUFBaUIzQyxLQUFqQixDQUFyQztBQUNBeEksUUFBTSxDQUFDeUksTUFBUCxHQUFnQmlELHNCQUFzQixDQUFDQyxvQkFBRCxFQUF1QnRELFVBQXZCLENBQXRDO0FBRUFLLGFBQVcsQ0FBQzlELE9BQVosQ0FBb0JnSCxrQkFBcEI7QUFDQUMsbUJBQWlCLENBQUM3TCxNQUFELEVBQVNtTCxjQUFULENBQWpCO0FBQ0FVLG1CQUFpQixDQUFDdEQsR0FBRCxFQUFNOEMsV0FBTixDQUFqQjtBQUNBM0MsYUFBVyxDQUFDOUQsT0FBWixDQUFvQmtILHNCQUFwQjtBQUVBQyxpQkFBZSxDQUFDZCxLQUFLLENBQUMzQyxTQUFELEVBQVk7QUFDN0J0SSxVQUFNLEVBQUVBLE1BRHFCO0FBRTdCdUksT0FBRyxFQUFFQSxHQUZ3QjtBQUc3QkMsU0FBSyxFQUFFQSxLQUhzQjtBQUk3QkMsVUFBTSxFQUFFQTtBQUpxQixHQUFaLENBQU4sQ0FBZjtBQU9BO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDSSxXQUFTRyxJQUFULENBQWVqQixJQUFmLEVBQXFCcUUsSUFBckIsRUFBMkI7QUFDdkIsUUFBSTNHLElBQUo7O0FBRUEsU0FBS0EsSUFBTCxJQUFhMkcsSUFBYixFQUFtQjtBQUNmLFVBQUlBLElBQUksQ0FBQ0MsY0FBTCxDQUFvQjVHLElBQXBCLENBQUosRUFBK0I7QUFDM0IsWUFBSXNDLElBQUksQ0FBQ3NFLGNBQUwsQ0FBb0I1RyxJQUFwQixNQUE4QixLQUE5QixJQUF1QyxPQUFPc0MsSUFBSSxDQUFDdEMsSUFBRCxDQUFYLEtBQXNCLE9BQU8yRyxJQUFJLENBQUMzRyxJQUFELENBQTVFLEVBQW9GO0FBQ2hGLGlCQUFPLEtBQVA7QUFDSDs7QUFFRCxZQUFJMEQsTUFBTSxDQUFDcEIsSUFBSSxDQUFDdEMsSUFBRCxDQUFMLENBQU4sSUFBc0J1RCxJQUFJLENBQUNqQixJQUFJLENBQUN0QyxJQUFELENBQUwsRUFBYTJHLElBQUksQ0FBQzNHLElBQUQsQ0FBakIsQ0FBSixLQUFpQyxLQUEzRCxFQUFrRTtBQUM5RCxpQkFBTyxLQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUVELFdBQU8sSUFBUDtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVN3RCxRQUFULENBQW1CbEIsSUFBbkIsRUFBeUJxRCxTQUF6QixFQUFvQztBQUNoQyxRQUFJckQsSUFBSSxJQUFJaUQsVUFBVSxDQUFDSSxTQUFELENBQWxCLElBQWlDckQsSUFBSSxZQUFZcUQsU0FBckQsRUFBZ0U7QUFDNUQsYUFBTyxJQUFQO0FBQ0g7O0FBRUQsV0FBTyxLQUFQO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU2xDLFdBQVQsQ0FBc0JuQixJQUF0QixFQUE0QjtBQUN4QixXQUFPb0IsTUFBTSxDQUFDcEIsSUFBRCxDQUFOLElBQWdCdUUsTUFBTSxDQUFDQyxJQUFQLENBQVl4RSxJQUFaLEVBQWtCMUMsTUFBbEIsS0FBNkIsQ0FBcEQ7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTOEQsTUFBVCxDQUFpQnBCLElBQWpCLEVBQXVCO0FBQ25CLFdBQU91RSxNQUFNLENBQUNsQixTQUFQLENBQWlCb0IsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCMUUsSUFBL0IsTUFBeUMsaUJBQWhEO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUzFILFFBQVQsQ0FBbUIwSCxJQUFuQixFQUF5QjtBQUNyQixXQUFPLENBQUMrQyxXQUFXLENBQUMvQyxJQUFELENBQVosSUFBc0IsQ0FBQ2dELE1BQU0sQ0FBQ2hELElBQUQsQ0FBcEM7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTK0MsV0FBVCxDQUFzQi9DLElBQXRCLEVBQTRCO0FBQ3hCLFdBQU9BLElBQUksS0FBSzNDLFNBQWhCO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUzJGLE1BQVQsQ0FBaUJoRCxJQUFqQixFQUF1QjtBQUNuQixXQUFPQSxJQUFJLEtBQUssSUFBaEI7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTc0IsU0FBVCxDQUFvQnRCLElBQXBCLEVBQTBCeEIsS0FBMUIsRUFBaUM7QUFDN0IsV0FBT2xHLFFBQVEsQ0FBQzBILElBQUQsQ0FBUixJQUFrQkEsSUFBSSxDQUFDMUMsTUFBTCxLQUFnQmtCLEtBQXpDO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUytDLFVBQVQsQ0FBcUJ2QixJQUFyQixFQUEyQjtBQUN2QixXQUFPd0IsS0FBSyxDQUFDeEIsSUFBRCxDQUFMLElBQWVBLElBQUksQ0FBQzFDLE1BQUwsS0FBZ0IsQ0FBdEM7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTa0UsS0FBVCxDQUFnQnhCLElBQWhCLEVBQXNCO0FBQ2xCLFdBQU85RSxLQUFLLENBQUN5SixPQUFOLENBQWMzRSxJQUFkLENBQVA7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTeUIsU0FBVCxDQUFvQnpCLElBQXBCLEVBQTBCO0FBQ3RCLFdBQU8xSCxRQUFRLENBQUMwSCxJQUFELENBQVIsSUFBa0I2QyxNQUFNLENBQUM3QyxJQUFJLENBQUMxQyxNQUFOLENBQS9CO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU29FLFFBQVQsQ0FBbUIxQixJQUFuQixFQUF5QjtBQUNyQixRQUFJLE9BQU80RSxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQy9CO0FBQ0EsYUFBT25ELFNBQVMsQ0FBQ3pCLElBQUQsQ0FBaEI7QUFDSDs7QUFFRCxXQUFPMUgsUUFBUSxDQUFDMEgsSUFBRCxDQUFSLElBQWtCaUQsVUFBVSxDQUFDakQsSUFBSSxDQUFDNEUsTUFBTSxDQUFDQyxRQUFSLENBQUwsQ0FBbkM7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTbEQsSUFBVCxDQUFlM0IsSUFBZixFQUFxQjtBQUNqQixXQUFPdUUsTUFBTSxDQUFDbEIsU0FBUCxDQUFpQm9CLFFBQWpCLENBQTBCQyxJQUExQixDQUErQjFFLElBQS9CLE1BQXlDLGVBQXpDLElBQ0gsQ0FBQzhFLEtBQUssQ0FBQzlFLElBQUksQ0FBQytFLE9BQUwsRUFBRCxDQURWO0FBRUg7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU25ELEtBQVQsQ0FBZ0I1QixJQUFoQixFQUFzQjtBQUNsQixXQUFPdUUsTUFBTSxDQUFDbEIsU0FBUCxDQUFpQm9CLFFBQWpCLENBQTBCQyxJQUExQixDQUErQjFFLElBQS9CLE1BQXlDLGdCQUFoRDtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNpRCxVQUFULENBQXFCakQsSUFBckIsRUFBMkI7QUFDdkIsV0FBTyxPQUFPQSxJQUFQLEtBQWdCLFVBQXZCO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUzhCLEtBQVQsQ0FBZ0I5QixJQUFoQixFQUFzQmdGLEtBQXRCLEVBQTZCO0FBQ3pCLFdBQU9oRCxNQUFNLENBQUNoQyxJQUFELENBQU4sSUFBZ0IsQ0FBQyxDQUFDQSxJQUFJLENBQUM4QixLQUFMLENBQVdrRCxLQUFYLENBQXpCO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU3JGLFFBQVQsQ0FBbUJLLElBQW5CLEVBQXlCaUYsU0FBekIsRUFBb0M7QUFDaEMsV0FBT2pELE1BQU0sQ0FBQ2hDLElBQUQsQ0FBTixJQUFnQkEsSUFBSSxDQUFDa0YsT0FBTCxDQUFhRCxTQUFiLE1BQTRCLENBQUMsQ0FBcEQ7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTbEQsYUFBVCxDQUF3Qi9CLElBQXhCLEVBQThCO0FBQzFCLFdBQU9nQyxNQUFNLENBQUNoQyxJQUFELENBQU4sSUFBZ0JBLElBQUksS0FBSyxFQUFoQztBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTZ0MsTUFBVCxDQUFpQmhDLElBQWpCLEVBQXVCO0FBQ25CLFdBQU8sT0FBT0EsSUFBUCxLQUFnQixRQUF2QjtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNpQyxHQUFULENBQWNqQyxJQUFkLEVBQW9CO0FBQ2hCLFdBQU8yQyxPQUFPLENBQUMzQyxJQUFELENBQVAsSUFBaUIsQ0FBQ2tDLElBQUksQ0FBQ2xDLElBQUQsQ0FBN0I7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTa0MsSUFBVCxDQUFlbEMsSUFBZixFQUFxQjtBQUNqQixXQUFPNkMsTUFBTSxDQUFDN0MsSUFBRCxDQUFOLElBQWdCQSxJQUFJLEdBQUcsQ0FBUCxLQUFhLENBQXBDO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUzJDLE9BQVQsQ0FBa0IzQyxJQUFsQixFQUF3QjtBQUNwQixXQUFPNkMsTUFBTSxDQUFDN0MsSUFBRCxDQUFOLElBQWdCQSxJQUFJLEdBQUcsQ0FBUCxLQUFhLENBQXBDO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU21DLE9BQVQsQ0FBa0JuQyxJQUFsQixFQUF3Qm1GLENBQXhCLEVBQTJCQyxDQUEzQixFQUE4QjtBQUMxQixRQUFJRCxDQUFDLEdBQUdDLENBQVIsRUFBVztBQUNQLGFBQU9oRCxjQUFjLENBQUNwQyxJQUFELEVBQU9tRixDQUFQLENBQWQsSUFBMkI5QyxXQUFXLENBQUNyQyxJQUFELEVBQU9vRixDQUFQLENBQTdDO0FBQ0g7O0FBRUQsV0FBTy9DLFdBQVcsQ0FBQ3JDLElBQUQsRUFBT21GLENBQVAsQ0FBWCxJQUF3Qi9DLGNBQWMsQ0FBQ3BDLElBQUQsRUFBT29GLENBQVAsQ0FBN0M7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTaEQsY0FBVCxDQUF5QnBDLElBQXpCLEVBQStCeEIsS0FBL0IsRUFBc0M7QUFDbEMsV0FBT3FFLE1BQU0sQ0FBQzdDLElBQUQsQ0FBTixJQUFnQkEsSUFBSSxJQUFJeEIsS0FBL0I7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTNkQsV0FBVCxDQUFzQnJDLElBQXRCLEVBQTRCeEIsS0FBNUIsRUFBbUM7QUFDL0IsV0FBT3FFLE1BQU0sQ0FBQzdDLElBQUQsQ0FBTixJQUFnQkEsSUFBSSxJQUFJeEIsS0FBL0I7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTOEQsT0FBVCxDQUFrQnRDLElBQWxCLEVBQXdCbUYsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCO0FBQzFCLFFBQUlELENBQUMsR0FBR0MsQ0FBUixFQUFXO0FBQ1AsYUFBTzdDLE9BQU8sQ0FBQ3ZDLElBQUQsRUFBT21GLENBQVAsQ0FBUCxJQUFvQjNDLElBQUksQ0FBQ3hDLElBQUQsRUFBT29GLENBQVAsQ0FBL0I7QUFDSDs7QUFFRCxXQUFPNUMsSUFBSSxDQUFDeEMsSUFBRCxFQUFPbUYsQ0FBUCxDQUFKLElBQWlCNUMsT0FBTyxDQUFDdkMsSUFBRCxFQUFPb0YsQ0FBUCxDQUEvQjtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVM3QyxPQUFULENBQWtCdkMsSUFBbEIsRUFBd0J4QixLQUF4QixFQUErQjtBQUMzQixXQUFPcUUsTUFBTSxDQUFDN0MsSUFBRCxDQUFOLElBQWdCQSxJQUFJLEdBQUd4QixLQUE5QjtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNnRSxJQUFULENBQWV4QyxJQUFmLEVBQXFCeEIsS0FBckIsRUFBNEI7QUFDeEIsV0FBT3FFLE1BQU0sQ0FBQzdDLElBQUQsQ0FBTixJQUFnQkEsSUFBSSxHQUFHeEIsS0FBOUI7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTaUUsUUFBVCxDQUFtQnpDLElBQW5CLEVBQXlCO0FBQ3JCLFdBQU91QyxPQUFPLENBQUN2QyxJQUFELEVBQU8sQ0FBUCxDQUFkO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTMEMsUUFBVCxDQUFtQjFDLElBQW5CLEVBQXlCO0FBQ3JCLFdBQU93QyxJQUFJLENBQUN4QyxJQUFELEVBQU8sQ0FBUCxDQUFYO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBUzZDLE1BQVQsQ0FBaUI3QyxJQUFqQixFQUF1QjtBQUNuQixXQUFPLE9BQU9BLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEI4RSxLQUFLLENBQUM5RSxJQUFELENBQUwsS0FBZ0IsS0FBNUMsSUFDQUEsSUFBSSxLQUFLcUYsTUFBTSxDQUFDQyxpQkFEaEIsSUFFQXRGLElBQUksS0FBS3FGLE1BQU0sQ0FBQ0UsaUJBRnZCO0FBR0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTM0MsSUFBVCxDQUFlNUMsSUFBZixFQUFxQjtBQUNqQixXQUFPQSxJQUFJLEtBQUssQ0FBaEI7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTOEMsT0FBVCxDQUFrQjlDLElBQWxCLEVBQXdCO0FBQ3BCLFdBQU9BLElBQUksS0FBSyxLQUFULElBQWtCQSxJQUFJLEtBQUssSUFBbEM7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNrRCxLQUFULENBQWdCbEQsSUFBaEIsRUFBc0JVLFVBQXRCLEVBQWtDO0FBQzlCckksVUFBTSxDQUFDbUosS0FBUCxDQUFheEIsSUFBYjs7QUFFQSxRQUFJaUQsVUFBVSxDQUFDdkMsVUFBRCxDQUFkLEVBQTRCO0FBQ3hCLGFBQU9WLElBQUksQ0FBQ2xDLEdBQUwsQ0FBUyxVQUFVVSxLQUFWLEVBQWlCO0FBQzdCLGVBQU9rQyxVQUFVLENBQUNsQyxLQUFELENBQWpCO0FBQ0gsT0FGTSxDQUFQO0FBR0g7O0FBRURuRyxVQUFNLENBQUNtSixLQUFQLENBQWFkLFVBQWI7QUFDQXJJLFVBQU0sQ0FBQ2lKLFNBQVAsQ0FBaUJ0QixJQUFqQixFQUF1QlUsVUFBVSxDQUFDcEQsTUFBbEM7QUFFQSxXQUFPMEMsSUFBSSxDQUFDbEMsR0FBTCxDQUFTLFVBQVVVLEtBQVYsRUFBaUJnSCxLQUFqQixFQUF3QjtBQUNwQyxhQUFPOUUsVUFBVSxDQUFDOEUsS0FBRCxDQUFWLENBQWtCaEgsS0FBbEIsQ0FBUDtBQUNILEtBRk0sQ0FBUDtBQUdIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTVixHQUFULENBQWNrQyxJQUFkLEVBQW9CVSxVQUFwQixFQUFnQztBQUM1QnJJLFVBQU0sQ0FBQytJLE1BQVAsQ0FBY3BCLElBQWQ7O0FBRUEsUUFBSWlELFVBQVUsQ0FBQ3ZDLFVBQUQsQ0FBZCxFQUE0QjtBQUN4QixhQUFPK0UsU0FBUyxDQUFDekYsSUFBRCxFQUFPVSxVQUFQLENBQWhCO0FBQ0g7O0FBRURySSxVQUFNLENBQUMrSSxNQUFQLENBQWNWLFVBQWQ7QUFFQSxXQUFPZ0YsVUFBVSxDQUFDMUYsSUFBRCxFQUFPVSxVQUFQLENBQWpCO0FBQ0g7O0FBRUQsV0FBUytFLFNBQVQsQ0FBb0J6RixJQUFwQixFQUEwQjJGLFNBQTFCLEVBQXFDO0FBQ2pDLFFBQUkzSyxNQUFNLEdBQUcsRUFBYjtBQUVBdUosVUFBTSxDQUFDQyxJQUFQLENBQVl4RSxJQUFaLEVBQWtCL0MsT0FBbEIsQ0FBMEIsVUFBVTJJLEdBQVYsRUFBZTtBQUNyQzVLLFlBQU0sQ0FBQzRLLEdBQUQsQ0FBTixHQUFjRCxTQUFTLENBQUMzRixJQUFJLENBQUM0RixHQUFELENBQUwsQ0FBdkI7QUFDSCxLQUZEO0FBSUEsV0FBTzVLLE1BQVA7QUFDSDs7QUFFRCxXQUFTMEssVUFBVCxDQUFxQjFGLElBQXJCLEVBQTJCVSxVQUEzQixFQUF1QztBQUNuQyxRQUFJMUYsTUFBTSxHQUFHLEVBQWI7QUFFQXVKLFVBQU0sQ0FBQ0MsSUFBUCxDQUFZOUQsVUFBWixFQUF3QnpELE9BQXhCLENBQWdDLFVBQVUySSxHQUFWLEVBQWU7QUFDM0MsVUFBSUQsU0FBUyxHQUFHakYsVUFBVSxDQUFDa0YsR0FBRCxDQUExQjs7QUFFQSxVQUFJM0MsVUFBVSxDQUFDMEMsU0FBRCxDQUFkLEVBQTJCO0FBQ3ZCLFlBQUkvRSxHQUFHLENBQUN0SSxRQUFKLENBQWEwSCxJQUFiLENBQUosRUFBd0I7QUFDcEJoRixnQkFBTSxDQUFDNEssR0FBRCxDQUFOLEdBQWMsQ0FBQyxDQUFDRCxTQUFTLENBQUNFLFlBQTFCO0FBQ0gsU0FGRCxNQUVPO0FBQ0g3SyxnQkFBTSxDQUFDNEssR0FBRCxDQUFOLEdBQWNELFNBQVMsQ0FBQzNGLElBQUksQ0FBQzRGLEdBQUQsQ0FBTCxDQUF2QjtBQUNIO0FBQ0osT0FORCxNQU1PLElBQUl4RSxNQUFNLENBQUN1RSxTQUFELENBQVYsRUFBdUI7QUFDMUIzSyxjQUFNLENBQUM0SyxHQUFELENBQU4sR0FBY0YsVUFBVSxDQUFDMUYsSUFBSSxDQUFDNEYsR0FBRCxDQUFMLEVBQVlELFNBQVosQ0FBeEI7QUFDSDtBQUNKLEtBWkQ7QUFjQSxXQUFPM0ssTUFBUDtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU21JLEdBQVQsQ0FBY25ELElBQWQsRUFBb0I7QUFDaEIsUUFBSXdCLEtBQUssQ0FBQ3hCLElBQUQsQ0FBVCxFQUFpQjtBQUNiLGFBQU84RixTQUFTLENBQUM5RixJQUFELEVBQU8sS0FBUCxDQUFoQjtBQUNIOztBQUVEM0gsVUFBTSxDQUFDK0ksTUFBUCxDQUFjcEIsSUFBZDtBQUVBLFdBQU8rRixVQUFVLENBQUMvRixJQUFELEVBQU8sS0FBUCxDQUFqQjtBQUNIOztBQUVELFdBQVM4RixTQUFULENBQW9COUYsSUFBcEIsRUFBMEJoRixNQUExQixFQUFrQztBQUM5QixRQUFJZ0wsQ0FBSjs7QUFFQSxTQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdoRyxJQUFJLENBQUMxQyxNQUFyQixFQUE2QjBJLENBQUMsSUFBSSxDQUFsQyxFQUFxQztBQUNqQyxVQUFJaEcsSUFBSSxDQUFDZ0csQ0FBRCxDQUFKLEtBQVloTCxNQUFoQixFQUF3QjtBQUNwQixlQUFPQSxNQUFQO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLENBQUNBLE1BQVI7QUFDSDs7QUFFRCxXQUFTK0ssVUFBVCxDQUFxQi9GLElBQXJCLEVBQTJCaEYsTUFBM0IsRUFBbUM7QUFDL0IsUUFBSTRLLEdBQUosRUFBU3BILEtBQVQ7O0FBRUEsU0FBS29ILEdBQUwsSUFBWTVGLElBQVosRUFBa0I7QUFDZCxVQUFJQSxJQUFJLENBQUNzRSxjQUFMLENBQW9Cc0IsR0FBcEIsQ0FBSixFQUE4QjtBQUMxQnBILGFBQUssR0FBR3dCLElBQUksQ0FBQzRGLEdBQUQsQ0FBWjs7QUFFQSxZQUFJeEUsTUFBTSxDQUFDNUMsS0FBRCxDQUFOLElBQWlCdUgsVUFBVSxDQUFDdkgsS0FBRCxFQUFReEQsTUFBUixDQUFWLEtBQThCQSxNQUFuRCxFQUEyRDtBQUN2RCxpQkFBT0EsTUFBUDtBQUNIOztBQUVELFlBQUl3RCxLQUFLLEtBQUt4RCxNQUFkLEVBQXNCO0FBQ2xCLGlCQUFPQSxNQUFQO0FBQ0g7QUFDSjtBQUNKOztBQUVELFdBQU8sQ0FBQ0EsTUFBUjtBQUNIO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ksV0FBU29JLEdBQVQsQ0FBY3BELElBQWQsRUFBb0I7QUFDaEIsUUFBSXdCLEtBQUssQ0FBQ3hCLElBQUQsQ0FBVCxFQUFpQjtBQUNiLGFBQU84RixTQUFTLENBQUM5RixJQUFELEVBQU8sSUFBUCxDQUFoQjtBQUNIOztBQUVEM0gsVUFBTSxDQUFDK0ksTUFBUCxDQUFjcEIsSUFBZDtBQUVBLFdBQU8rRixVQUFVLENBQUMvRixJQUFELEVBQU8sSUFBUCxDQUFqQjtBQUNIOztBQUVELFdBQVNzRCxLQUFULENBQWdCMkMsTUFBaEIsRUFBd0JDLE1BQXhCLEVBQWdDO0FBQzVCM0IsVUFBTSxDQUFDQyxJQUFQLENBQVkwQixNQUFaLEVBQW9CakosT0FBcEIsQ0FBNEIsVUFBVTJJLEdBQVYsRUFBZTtBQUN2Q0ssWUFBTSxDQUFDTCxHQUFELENBQU4sR0FBY00sTUFBTSxDQUFDTixHQUFELENBQXBCO0FBQ0gsS0FGRDtBQUlBLFdBQU9LLE1BQVA7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVN6QyxjQUFULENBQXlCbUMsU0FBekIsRUFBb0NRLGNBQXBDLEVBQW9EO0FBQ2hELFdBQU8sWUFBWTtBQUNmQyxxQkFBZSxDQUFDVCxTQUFELEVBQVlVLFNBQVosRUFBdUJGLGNBQXZCLENBQWY7QUFDSCxLQUZEO0FBR0g7O0FBRUQsV0FBU0MsZUFBVCxDQUEwQlQsU0FBMUIsRUFBcUNXLElBQXJDLEVBQTJDSCxjQUEzQyxFQUEyRDtBQUN2RCxRQUFJckcsT0FBTyxHQUFHd0csSUFBSSxDQUFDQSxJQUFJLENBQUNoSixNQUFMLEdBQWMsQ0FBZixDQUFsQjtBQUNBbUcsY0FBVSxDQUFDa0MsU0FBUyxDQUFDekMsS0FBVixDQUFnQixJQUFoQixFQUFzQm9ELElBQXRCLENBQUQsRUFBOEJ2RSxhQUFhLENBQUNqQyxPQUFELENBQWIsR0FBeUJBLE9BQXpCLEdBQW1DcUcsY0FBakUsQ0FBVjtBQUNIOztBQUVELFdBQVMxQyxVQUFULENBQXFCakYsS0FBckIsRUFBNEJzQixPQUE1QixFQUFxQztBQUNqQyxRQUFJdEIsS0FBSyxLQUFLLEtBQWQsRUFBcUI7QUFDakIsWUFBTSxJQUFJK0gsS0FBSixDQUFVekcsT0FBTyxJQUFJLGtCQUFyQixDQUFOO0FBQ0g7QUFDSjs7QUFFRCxXQUFTa0Usb0JBQVQsQ0FBK0IyQixTQUEvQixFQUEwQ1EsY0FBMUMsRUFBMEQ7QUFDdEQsV0FBTyxZQUFZO0FBQ2YsVUFBSXZFLEtBQUo7O0FBRUEsVUFBSTtBQUNBd0UsdUJBQWUsQ0FBQ1QsU0FBRCxFQUFZVSxTQUFaLEVBQXVCRixjQUF2QixDQUFmO0FBQ0gsT0FGRCxDQUVFLE9BQU9LLENBQVAsRUFBVTtBQUNSNUUsYUFBSyxHQUFHNEUsQ0FBUjtBQUNIOztBQUVELGFBQU87QUFDSEMsVUFBRSxFQUFFbEMsTUFBTSxDQUFDQyxJQUFQLENBQVk5RCxVQUFaLEVBQXdCZ0csTUFBeEIsQ0FBK0JDLGFBQS9CLEVBQThDLEVBQTlDO0FBREQsT0FBUDs7QUFJQSxlQUFTQSxhQUFULENBQXdCM0wsTUFBeEIsRUFBZ0M0SyxHQUFoQyxFQUFxQztBQUNqQzVLLGNBQU0sQ0FBQzRLLEdBQUQsQ0FBTixHQUFjLFlBQVk7QUFDdEIsY0FBSWhFLEtBQUssSUFBSSxDQUFDbEIsVUFBVSxDQUFDa0YsR0FBRCxDQUFWLENBQWdCMUMsS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJtRCxTQUE1QixDQUFkLEVBQXNEO0FBQ2xELGtCQUFNekUsS0FBTjtBQUNIO0FBQ0osU0FKRDs7QUFNQSxlQUFPNUcsTUFBUDtBQUNIO0FBQ0osS0F0QkQ7QUF1Qkg7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTMEksV0FBVCxDQUFzQmlDLFNBQXRCLEVBQWlDO0FBQzdCLFdBQU8sWUFBWTtBQUNmLGFBQU9oQyxPQUFPLENBQUNnQyxTQUFTLENBQUN6QyxLQUFWLENBQWdCLElBQWhCLEVBQXNCbUQsU0FBdEIsQ0FBRCxDQUFkO0FBQ0gsS0FGRDtBQUdIOztBQUVELFdBQVMxQyxPQUFULENBQWtCbkYsS0FBbEIsRUFBeUI7QUFDckIsV0FBTyxDQUFDQSxLQUFSO0FBQ0g7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNvRixhQUFULENBQXdCK0IsU0FBeEIsRUFBbUM7QUFDL0IsUUFBSWlCLGlCQUFpQixHQUFHLFlBQVk7QUFDaEMsVUFBSSxDQUFDdE8sUUFBUSxDQUFDK04sU0FBUyxDQUFDLENBQUQsQ0FBVixDQUFiLEVBQTZCO0FBQ3pCLGVBQU8sSUFBUDtBQUNIOztBQUVELGFBQU9WLFNBQVMsQ0FBQ3pDLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JtRCxTQUF0QixDQUFQO0FBQ0gsS0FORCxDQUQrQixDQVMvQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FPLHFCQUFpQixDQUFDZixZQUFsQixHQUFpQyxJQUFqQztBQUVBLFdBQU9lLGlCQUFQO0FBQ0g7O0FBRUQsV0FBUy9DLFNBQVQsQ0FBb0JyRixLQUFwQixFQUEyQjtBQUN2QixRQUFJbEcsUUFBUSxDQUFDa0csS0FBRCxDQUFSLEtBQW9CLEtBQXhCLEVBQStCO0FBQzNCLGFBQU8sSUFBUDtBQUNIOztBQUVELFdBQU9BLEtBQVA7QUFDSDtBQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUNJLFdBQVNzRixjQUFULENBQXlCNkIsU0FBekIsRUFBb0M7QUFDaEMsV0FBTyxZQUFZO0FBQ2YsVUFBSWtCLFFBQVEsR0FBR2xCLFNBQVMsQ0FBQ3pDLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JtRCxTQUF0QixDQUFmO0FBRUEsYUFBTztBQUNISSxVQUFFLEVBQUVsQyxNQUFNLENBQUNDLElBQVAsQ0FBWTlELFVBQVosRUFBd0JnRyxNQUF4QixDQUErQkksY0FBL0IsRUFBK0MsRUFBL0M7QUFERCxPQUFQOztBQUlBLGVBQVNBLGNBQVQsQ0FBeUI5TCxNQUF6QixFQUFpQzRLLEdBQWpDLEVBQXNDO0FBQ2xDNUssY0FBTSxDQUFDNEssR0FBRCxDQUFOLEdBQWNpQixRQUFRLEdBQUdFLEdBQUgsR0FBU3JHLFVBQVUsQ0FBQ2tGLEdBQUQsQ0FBekM7QUFDQSxlQUFPNUssTUFBUDtBQUNIO0FBQ0osS0FYRDs7QUFhQSxhQUFTK0wsR0FBVCxHQUFnQjtBQUNaLGFBQU8sSUFBUDtBQUNIO0FBQ0o7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFDSSxXQUFTQyxVQUFULENBQXFCZixNQUFyQixFQUE2QnhOLElBQTdCLEVBQW1Da04sU0FBbkMsRUFBOEM7QUFDMUMsV0FBTyxZQUFZO0FBQ2YsVUFBSXNCLFVBQUosRUFBZ0JYLElBQWhCO0FBRUFXLGdCQUFVLEdBQUdaLFNBQVMsQ0FBQyxDQUFELENBQXRCOztBQUVBLFVBQUksQ0FBQzVOLElBQUksQ0FBQ3dPLFVBQUQsQ0FBVCxFQUF1QjtBQUNuQixlQUFPLEtBQVA7QUFDSDs7QUFFREEsZ0JBQVUsR0FBR0MsZ0JBQWdCLENBQUN6TyxJQUFELEVBQU93TyxVQUFQLENBQTdCO0FBQ0FYLFVBQUksR0FBR3RGLEtBQUssQ0FBQzBELElBQU4sQ0FBVzJCLFNBQVgsRUFBc0IsQ0FBdEIsQ0FBUDs7QUFFQSxVQUFJO0FBQ0FZLGtCQUFVLENBQUNoSyxPQUFYLENBQW1CLFVBQVVrSyxJQUFWLEVBQWdCO0FBQy9CLGNBQ0ksQ0FBQ2xCLE1BQU0sS0FBSyxPQUFYLElBQXNCM04sUUFBUSxDQUFDNk8sSUFBRCxDQUEvQixLQUNBLENBQUN4QixTQUFTLENBQUN6QyxLQUFWLENBQWdCLElBQWhCLEVBQXNCLENBQUVpRSxJQUFGLEVBQVNDLE1BQVQsQ0FBZ0JkLElBQWhCLENBQXRCLENBRkwsRUFHRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQU0sQ0FBTjtBQUNIO0FBQ0osU0FYRDtBQVlILE9BYkQsQ0FhRSxPQUFPZSxNQUFQLEVBQWU7QUFDYixlQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFPLElBQVA7QUFDSCxLQTlCRDtBQStCSDs7QUFFRCxXQUFTSCxnQkFBVCxDQUEyQnpPLElBQTNCLEVBQWlDd08sVUFBakMsRUFBNkM7QUFDekMsWUFBUXhPLElBQVI7QUFDSSxXQUFLZ0osU0FBTDtBQUNJLGVBQU9ULEtBQUssQ0FBQzBELElBQU4sQ0FBV3VDLFVBQVgsQ0FBUDs7QUFDSixXQUFLN0YsTUFBTDtBQUNJLGVBQU9tRCxNQUFNLENBQUNDLElBQVAsQ0FBWXlDLFVBQVosRUFBd0JuSixHQUF4QixDQUE0QixVQUFVOEgsR0FBVixFQUFlO0FBQzlDLGlCQUFPcUIsVUFBVSxDQUFDckIsR0FBRCxDQUFqQjtBQUNILFNBRk0sQ0FBUDs7QUFHSjtBQUNJLGVBQU9xQixVQUFQO0FBUlI7QUFVSDs7QUFFRCxXQUFTMUQsd0JBQVQsQ0FBbUMrRCxRQUFuQyxFQUE2Q2xHLE1BQTdDLEVBQXFEO0FBQ2pELFdBQU9tRyx1QkFBdUIsQ0FBQyxDQUFFRCxRQUFGLEVBQVk1RyxVQUFaLEVBQXdCVSxNQUF4QixDQUFELENBQTlCO0FBQ0g7O0FBRUQsV0FBU21HLHVCQUFULENBQWtDakIsSUFBbEMsRUFBd0M7QUFDcEMsUUFBSWdCLFFBQUosRUFBY2xHLE1BQWQsRUFBc0JULFNBQXRCLEVBQWlDM0YsTUFBakM7QUFFQXNNLFlBQVEsR0FBR2hCLElBQUksQ0FBQ2tCLEtBQUwsRUFBWDtBQUNBcEcsVUFBTSxHQUFHa0YsSUFBSSxDQUFDbUIsR0FBTCxFQUFUO0FBQ0E5RyxhQUFTLEdBQUcyRixJQUFJLENBQUNtQixHQUFMLEVBQVo7QUFFQXpNLFVBQU0sR0FBR29HLE1BQU0sSUFBSSxFQUFuQjtBQUVBbUQsVUFBTSxDQUFDQyxJQUFQLENBQVk3RCxTQUFaLEVBQXVCMUQsT0FBdkIsQ0FBK0IsVUFBVTJJLEdBQVYsRUFBZTtBQUMxQ3JCLFlBQU0sQ0FBQ21ELGNBQVAsQ0FBc0IxTSxNQUF0QixFQUE4QjRLLEdBQTlCLEVBQW1DO0FBQy9CK0Isb0JBQVksRUFBRSxLQURpQjtBQUUvQkMsa0JBQVUsRUFBRSxJQUZtQjtBQUcvQkMsZ0JBQVEsRUFBRSxLQUhxQjtBQUkvQnJKLGFBQUssRUFBRThJLFFBQVEsQ0FBQ3BFLEtBQVQsQ0FBZSxJQUFmLEVBQXFCb0QsSUFBSSxDQUFDYyxNQUFMLENBQVl6RyxTQUFTLENBQUNpRixHQUFELENBQXJCLEVBQTRCM0gsUUFBUSxDQUFDMkgsR0FBRCxDQUFwQyxDQUFyQjtBQUp3QixPQUFuQztBQU1ILEtBUEQ7QUFTQSxXQUFPNUssTUFBUDtBQUNIOztBQUVELFdBQVMrSSxzQkFBVCxDQUFpQ3VELFFBQWpDLEVBQTJDUSxRQUEzQyxFQUFxRDtBQUNqRCxXQUFPUCx1QkFBdUIsQ0FBQyxDQUFFRCxRQUFGLEVBQVlRLFFBQVosRUFBc0IsSUFBdEIsQ0FBRCxDQUE5QjtBQUNIOztBQUVELFdBQVM3RCxrQkFBVCxDQUE2QjJCLEdBQTdCLEVBQWtDO0FBQzlCbEYsY0FBVSxDQUFDa0YsR0FBRCxDQUFWLENBQWdCbUMsRUFBaEIsR0FBcUJSLHVCQUF1QixDQUN4QyxDQUFFUCxVQUFVLENBQUNnQixJQUFYLENBQWdCLElBQWhCLEVBQXNCLElBQXRCLENBQUYsRUFBK0J0SCxVQUFVLENBQUNrRixHQUFELENBQXpDLEVBQWdEbEYsVUFBaEQsRUFBNEQsSUFBNUQsQ0FEd0MsQ0FBNUM7QUFHSDs7QUFFRCxXQUFTd0QsaUJBQVQsQ0FBNEIrRCxJQUE1QixFQUFrQ1gsUUFBbEMsRUFBNEM7QUFDeEN2RyxlQUFXLENBQUM5RCxPQUFaLENBQW9CLFVBQVUySSxHQUFWLEVBQWU7QUFDL0JxQyxVQUFJLENBQUNyQyxHQUFELENBQUosQ0FBVW1DLEVBQVYsR0FBZWhFLHNCQUFzQixDQUFDdUQsUUFBRCxFQUFXNUcsVUFBVSxDQUFDa0YsR0FBRCxDQUFWLENBQWdCbUMsRUFBM0IsQ0FBckM7QUFDSCxLQUZEO0FBR0g7O0FBRUQsV0FBUzVELHNCQUFULENBQWlDeUIsR0FBakMsRUFBc0M7QUFDbEMvRSxTQUFLLENBQUMrRSxHQUFELENBQUwsQ0FBV21DLEVBQVgsR0FBZ0JSLHVCQUF1QixDQUNuQyxDQUFFUCxVQUFVLENBQUNnQixJQUFYLENBQWdCLElBQWhCLEVBQXNCLE9BQXRCLENBQUYsRUFBa0N0SCxVQUFVLENBQUNrRixHQUFELENBQTVDLEVBQW1EbEYsVUFBbkQsRUFBK0QsSUFBL0QsQ0FEbUMsQ0FBdkM7QUFHQXJJLFVBQU0sQ0FBQ3dJLEtBQVAsQ0FBYStFLEdBQWIsRUFBa0JtQyxFQUFsQixHQUF1QmhFLHNCQUFzQixDQUFDUCxjQUFELEVBQWlCM0MsS0FBSyxDQUFDK0UsR0FBRCxDQUFMLENBQVdtQyxFQUE1QixDQUE3QztBQUNBMVAsVUFBTSxDQUFDdUksR0FBUCxDQUFXZ0YsR0FBWCxFQUFnQm1DLEVBQWhCLEdBQXFCaEUsc0JBQXNCLENBQUNQLGNBQUQsRUFBaUI1QyxHQUFHLENBQUNnRixHQUFELENBQUgsQ0FBU21DLEVBQTFCLENBQTNDO0FBQ0g7O0FBRUQsV0FBUzNELGVBQVQsQ0FBMEJ6RCxTQUExQixFQUFxQztBQUNqQyxRQUFJLElBQUosRUFBZ0Q7QUFDNUN1SCx5Q0FBTyxZQUFZO0FBQ2YsZUFBT3ZILFNBQVA7QUFDSCxPQUZLO0FBQUEsb0dBQU47QUFHSCxLQUpELE1BSU8sRUFJTjtBQUNKO0FBQ0osQ0EzM0JBLEVBMjNCQyxJQTMzQkQsQ0FBRCxDOzs7Ozs7Ozs7OztBQ1BBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUl3SCxnQkFBZ0IsR0FBRztBQUNyQixpQkFBZSxDQUNiLE9BRGEsRUFFYixXQUZhLEVBR2IsV0FIYSxFQUliLE9BSmEsRUFLYixXQUxhLEVBTWIsV0FOYSxDQURNO0FBU3JCLG1CQUFpQixDQUNmLFdBRGUsRUFFZixNQUZlLEVBR2YsV0FIZSxFQUlmLFdBSmUsRUFLZixNQUxlLEVBTWYsV0FOZTtBQVRJLENBQXZCO0FBbUJBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxhQUFhLEdBQUc7QUFDbEIsaUJBQWUsQ0FBQyxPQUFELEVBQVUsUUFBVixDQURHO0FBRWxCLG1CQUFpQixDQUFDLE9BQUQsRUFBVSxRQUFWO0FBRkMsQ0FBcEI7QUFLQSxJQUFJQyxZQUFZLEdBQUcsQ0FBQyxXQUFELEVBQWMsZUFBZCxDQUFuQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNDLGdCQUFULENBQTBCQyxRQUExQixFQUFvQztBQUNsQyxNQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaEMsVUFBTSxJQUFJaEMsS0FBSixDQUFVLHFDQUFxQyxPQUFPZ0MsUUFBdEQsQ0FBTjtBQUNEOztBQUVELE1BQUksT0FBT0EsUUFBUSxDQUFDNU8sS0FBaEIsS0FBMEIsUUFBOUIsRUFBd0M7QUFDdEMsVUFBTSxJQUFJNE0sS0FBSixDQUFVLDBDQUEwQyxPQUFPNU0sS0FBM0QsQ0FBTjtBQUNEOztBQUVELE1BQUksT0FBTzRPLFFBQVEsQ0FBQzNPLE1BQWhCLEtBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDLFVBQU0sSUFBSTJNLEtBQUosQ0FBVSwyQ0FBMkMsT0FBTzNNLE1BQTVELENBQU47QUFDRDs7QUFFRCxNQUFJd08sYUFBYSxDQUFDRyxRQUFRLENBQUN6TyxXQUFWLENBQWIsS0FBd0N1RCxTQUE1QyxFQUF1RDtBQUNyRCxVQUFNLElBQUlrSixLQUFKLENBQVUsMEJBQTBCZ0MsUUFBUSxDQUFDek8sV0FBbkMsR0FDZCxvQkFEYyxHQUNTeUssTUFBTSxDQUFDQyxJQUFQLENBQVk0RCxhQUFaLENBRFQsR0FDc0MsR0FEaEQsQ0FBTjtBQUVEOztBQUVELE1BQUlBLGFBQWEsQ0FBQ0csUUFBUSxDQUFDek8sV0FBVixDQUFiLENBQW9Db0wsT0FBcEMsQ0FBNENxRCxRQUFRLENBQUMxTyxNQUFyRCxNQUFpRSxDQUFDLENBQXRFLEVBQXlFO0FBQ3ZFLFVBQU0sSUFBSTBNLEtBQUosQ0FBVSwyQ0FBMkNnQyxRQUFRLENBQUMxTyxNQUFwRCxHQUNkLG9CQURjLEdBQ1N1TyxhQUFhLENBQUNHLFFBQVEsQ0FBQ3pPLFdBQVYsQ0FEdEIsR0FDK0MsR0FEekQsQ0FBTjtBQUVEOztBQUVELE1BQUl5TyxRQUFRLENBQUN4TyxLQUFULElBQWtCc08sWUFBWSxDQUFDbkQsT0FBYixDQUFxQnFELFFBQVEsQ0FBQ3hPLEtBQTlCLE1BQXlDLENBQUMsQ0FBaEUsRUFBbUU7QUFDakUsVUFBTSxJQUFJd00sS0FBSixDQUFVLG9DQUFvQzhCLFlBQTlDLENBQU47QUFDRDtBQUNGO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVMxSixVQUFULENBQW9CNEosUUFBcEIsRUFBOEI7QUFDNUIsTUFBSUEsUUFBUSxDQUFDdk8sUUFBVCxLQUFzQixLQUExQixFQUFpQztBQUMvQnNPLG9CQUFnQixDQUFDQyxRQUFELENBQWhCO0FBQ0Q7O0FBRUQsTUFBSUMsT0FBTyxHQUFHLEVBQWQ7O0FBQ0EsT0FBSyxJQUFJbEssQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lLLFFBQVEsQ0FBQzVPLEtBQTdCLEVBQW9DMkUsQ0FBQyxJQUFJLENBQXpDLEVBQTRDO0FBQzFDLFNBQUssSUFBSUcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhKLFFBQVEsQ0FBQzNPLE1BQTdCLEVBQXFDNkUsQ0FBQyxJQUFJLENBQTFDLEVBQTZDO0FBQzNDK0osYUFBTyxDQUFDQyxJQUFSLENBQWFsSyxzQkFBc0IsQ0FBQ2dLLFFBQUQsRUFBV2pLLENBQVgsRUFBY0csQ0FBZCxDQUFuQztBQUNEO0FBQ0Y7O0FBRUQsU0FBTytKLE9BQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNFLGtCQUFULENBQTRCSCxRQUE1QixFQUFzQ2pLLENBQXRDLEVBQXlDRyxDQUF6QyxFQUE0QztBQUMxQyxNQUFJOEosUUFBUSxDQUFDdk8sUUFBVCxLQUFzQixLQUExQixFQUFpQztBQUMvQnNPLG9CQUFnQixDQUFDQyxRQUFELENBQWhCOztBQUNBLFFBQUksT0FBT2pLLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUN6QixZQUFNLElBQUlpSSxLQUFKLENBQVUsNkJBQTZCLE9BQU9qSSxDQUE5QyxDQUFOO0FBQ0Q7O0FBQ0QsUUFBSSxPQUFPRyxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDekIsWUFBTSxJQUFJOEgsS0FBSixDQUFVLDZCQUE2QixPQUFPOUgsQ0FBOUMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0gsQ0FBQyxJQUFJaUssUUFBUSxDQUFDNU8sS0FBVCxHQUFpQixDQUF0QixJQUNMMkUsQ0FBQyxJQUFJLENBREEsSUFFTEcsQ0FBQyxJQUFJOEosUUFBUSxDQUFDM08sTUFBVCxHQUFrQixDQUZsQixJQUdMNkUsQ0FBQyxJQUFJLENBSFA7QUFJRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTRixzQkFBVCxDQUFnQ2dLLFFBQWhDLEVBQTBDakssQ0FBMUMsRUFBNkNHLENBQTdDLEVBQWdEO0FBQzlDLE1BQUk4SixRQUFRLENBQUN2TyxRQUFULEtBQXNCLEtBQTFCLEVBQWlDO0FBQy9Cc08sb0JBQWdCLENBQUNDLFFBQUQsQ0FBaEI7O0FBQ0EsUUFBSSxPQUFPakssQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLFlBQU0sSUFBSWlJLEtBQUosQ0FBVSw2QkFBNkIsT0FBT2pJLENBQTlDLENBQU47QUFDRDs7QUFDRCxRQUFJLE9BQU9HLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUN6QixZQUFNLElBQUk4SCxLQUFKLENBQVUsNkJBQTZCLE9BQU85SCxDQUE5QyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJaUssa0JBQWtCLENBQUNILFFBQUQsRUFBV2pLLENBQVgsRUFBY0csQ0FBZCxDQUFsQixLQUF1QyxLQUEzQyxFQUFrRDtBQUNoRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJa0ssRUFBRSxHQUFHbEssQ0FBQyxHQUFHOEosUUFBUSxDQUFDNU8sS0FBYixHQUFxQjJFLENBQTlCO0FBQ0EsU0FBT3FLLEVBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsZ0JBQVQsQ0FBMEJMLFFBQTFCLEVBQW9DTSxTQUFwQyxFQUErQztBQUM3QyxNQUFJTixRQUFRLENBQUN2TyxRQUFULEtBQXNCLEtBQTFCLEVBQWlDO0FBQy9Cc08sb0JBQWdCLENBQUNDLFFBQUQsQ0FBaEI7O0FBQ0EsUUFBSSxPQUFPTSxTQUFQLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLFlBQU0sSUFBSXRDLEtBQUosQ0FBVSxxQ0FBcUMsT0FBT3NDLFNBQXRELENBQU47QUFDRDtBQUNGOztBQUVELFNBQVFWLGdCQUFnQixDQUFDSSxRQUFRLENBQUN6TyxXQUFWLENBQWhCLENBQXVDb0wsT0FBdkMsQ0FBK0MyRCxTQUEvQyxLQUE2RCxDQUFyRTtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNDLHNCQUFULENBQWdDUCxRQUFoQyxFQUEwQ2hRLE1BQTFDLEVBQWtEO0FBQ2hELE1BQUlnUSxRQUFRLENBQUN2TyxRQUFULEtBQXNCLEtBQTFCLEVBQWlDO0FBQy9Cc08sb0JBQWdCLENBQUNDLFFBQUQsQ0FBaEI7O0FBQ0EsUUFBSSxPQUFPaFEsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixZQUFNLElBQUlnTyxLQUFKLENBQVUsa0NBQWtDLE9BQU9oTyxNQUFuRCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPO0FBQ0wrRixLQUFDLEVBQUUvRixNQUFNLEdBQUdnUSxRQUFRLENBQUM1TyxLQURoQjtBQUVMOEUsS0FBQyxFQUFFcEQsSUFBSSxDQUFDME4sS0FBTCxDQUFXeFEsTUFBTSxHQUFHZ1EsUUFBUSxDQUFDNU8sS0FBN0I7QUFGRSxHQUFQO0FBSUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNxUCwrQkFBVCxDQUF5Q1QsUUFBekMsRUFBbURqSyxDQUFuRCxFQUFzREcsQ0FBdEQsRUFBeUR3SyxHQUF6RCxFQUE4RDtBQUM1RCxNQUFJVixRQUFRLENBQUN2TyxRQUFULEtBQXNCLEtBQTFCLEVBQWlDO0FBQy9Cc08sb0JBQWdCLENBQUNDLFFBQUQsQ0FBaEI7O0FBQ0EsUUFBSUssZ0JBQWdCLENBQUNMLFFBQUQsRUFBV1UsR0FBWCxDQUFoQixLQUFvQyxLQUF4QyxFQUErQztBQUM3QyxZQUFNLElBQUkxQyxLQUFKLENBQVUsNEJBQTRCMEMsR0FBdEMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUMsU0FBUyxHQUFJekssQ0FBQyxHQUFHLENBQUosS0FBVSxDQUEzQjtBQUNBLE1BQUkwSyxTQUFTLEdBQUk3SyxDQUFDLEdBQUcsQ0FBSixLQUFVLENBQTNCO0FBRUEsTUFBSThLLE9BQU8sR0FBRyxDQUFkOztBQUNBLE1BQ0ViLFFBQVEsQ0FBQ3pPLFdBQVQsS0FBeUIsYUFBekIsSUFDQ3lPLFFBQVEsQ0FBQzFPLE1BQVQsS0FBb0IsT0FBcEIsSUFBK0JxUCxTQUFTLEtBQUssS0FBN0MsS0FBdURELEdBQUcsS0FBSyxXQUFSLElBQXVCQSxHQUFHLEtBQUssV0FBdEYsQ0FERCxJQUVDVixRQUFRLENBQUMxTyxNQUFULEtBQW9CLE9BQXBCLElBQStCcVAsU0FBUyxLQUFLLElBQTdDLEtBQXNERCxHQUFHLEtBQUssV0FBUixJQUF1QkEsR0FBRyxLQUFLLFdBQXJGLENBRkQsSUFHQ1YsUUFBUSxDQUFDMU8sTUFBVCxLQUFvQixRQUFwQixJQUFnQ3FQLFNBQVMsS0FBSyxJQUE5QyxLQUF1REQsR0FBRyxLQUFLLFdBQVIsSUFBdUJBLEdBQUcsS0FBSyxXQUF0RixDQUhELElBSUNWLFFBQVEsQ0FBQzFPLE1BQVQsS0FBb0IsUUFBcEIsSUFBZ0NxUCxTQUFTLEtBQUssS0FBOUMsS0FBd0RELEdBQUcsS0FBSyxXQUFSLElBQXVCQSxHQUFHLEtBQUssV0FBdkYsQ0FMSCxFQU1FO0FBQ0FHLFdBQU8sR0FBRyxDQUFWO0FBQ0Q7O0FBRUQsTUFBSUMsT0FBTyxHQUFHLENBQWQ7O0FBQ0EsTUFDRWQsUUFBUSxDQUFDek8sV0FBVCxLQUF5QixlQUF6QixJQUNDeU8sUUFBUSxDQUFDMU8sTUFBVCxLQUFvQixPQUFwQixJQUErQnNQLFNBQVMsS0FBSyxLQUE3QyxLQUF1REYsR0FBRyxLQUFLLFdBQVIsSUFBdUJBLEdBQUcsS0FBSyxXQUF0RixDQURELElBRUNWLFFBQVEsQ0FBQzFPLE1BQVQsS0FBb0IsT0FBcEIsSUFBK0JzUCxTQUFTLEtBQUssSUFBN0MsS0FBc0RGLEdBQUcsS0FBSyxXQUFSLElBQXVCQSxHQUFHLEtBQUssV0FBckYsQ0FGRCxJQUdDVixRQUFRLENBQUMxTyxNQUFULEtBQW9CLFFBQXBCLElBQWdDc1AsU0FBUyxLQUFLLElBQTlDLEtBQXVERixHQUFHLEtBQUssV0FBUixJQUF1QkEsR0FBRyxLQUFLLFdBQXRGLENBSEQsSUFJQ1YsUUFBUSxDQUFDMU8sTUFBVCxLQUFvQixRQUFwQixJQUFnQ3NQLFNBQVMsS0FBSyxLQUE5QyxLQUF3REYsR0FBRyxLQUFLLFdBQVIsSUFBdUJBLEdBQUcsS0FBSyxXQUF2RixDQUxILEVBTUU7QUFDQUksV0FBTyxHQUFHLENBQVY7QUFDRDs7QUFFRCxNQUFJQyxFQUFFLEdBQUcsQ0FBVDs7QUFDQSxNQUFJZixRQUFRLENBQUN4TyxLQUFULElBQW1Cd08sUUFBUSxDQUFDeE8sS0FBVCxLQUFtQixlQUExQyxFQUEyRDtBQUN6RCxRQUFJbVAsU0FBSixFQUFlO0FBQ2IsVUFBSUQsR0FBRyxLQUFLLE9BQVIsSUFBbUJBLEdBQUcsS0FBSyxXQUEzQixJQUEwQ0EsR0FBRyxLQUFLLFdBQXRELEVBQW1FO0FBQ2pFSyxVQUFFLEdBQUcsQ0FBTDtBQUNELE9BRkQsTUFFTztBQUNMQSxVQUFFLEdBQUcsQ0FBTDtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0wsVUFBSUwsR0FBRyxLQUFLLE9BQVIsSUFBbUJBLEdBQUcsS0FBSyxXQUEzQixJQUEwQ0EsR0FBRyxLQUFLLFdBQXRELEVBQW1FO0FBQ2pFSyxVQUFFLEdBQUcsQ0FBQyxDQUFOO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQUlDLE9BQU8sR0FBRztBQUNaLGFBQVM7QUFBQ2pMLE9BQUMsRUFBRSxDQUFKO0FBQU9HLE9BQUMsRUFBRSxDQUFDO0FBQVgsS0FERztBQUVaLFlBQVE7QUFBQ0gsT0FBQyxFQUFFLENBQUMsQ0FBTDtBQUFRRyxPQUFDLEVBQUU7QUFBWCxLQUZJO0FBR1osYUFBUztBQUFDSCxPQUFDLEVBQUUsQ0FBSjtBQUFPRyxPQUFDLEVBQUUsQ0FBQztBQUFYLEtBSEc7QUFJWixZQUFRO0FBQUNILE9BQUMsRUFBRSxDQUFDLENBQUw7QUFBUUcsT0FBQyxFQUFFO0FBQVgsS0FKSTtBQUtaLGlCQUFhO0FBQUNILE9BQUMsRUFBRThLLE9BQU8sR0FBR0UsRUFBZDtBQUFrQjdLLE9BQUMsRUFBRTRLLE9BQU8sR0FBRyxDQUFDO0FBQWhDLEtBTEQ7QUFNWixpQkFBYTtBQUFDL0ssT0FBQyxFQUFFOEssT0FBTyxHQUFHRSxFQUFkO0FBQWtCN0ssT0FBQyxFQUFFNEs7QUFBckIsS0FORDtBQU9aLGlCQUFhO0FBQUMvSyxPQUFDLEVBQUc4SyxPQUFPLEdBQUcsQ0FBQyxDQUFaLEdBQWlCRSxFQUFyQjtBQUF5QjdLLE9BQUMsRUFBRTRLO0FBQTVCLEtBUEQ7QUFRWixpQkFBYTtBQUFDL0ssT0FBQyxFQUFHOEssT0FBTyxHQUFHLENBQUMsQ0FBWixHQUFpQkUsRUFBckI7QUFBeUI3SyxPQUFDLEVBQUU0SyxPQUFPLEdBQUcsQ0FBQztBQUF2QztBQVJELEdBQWQ7QUFXQSxNQUFJRyxNQUFNLEdBQUdELE9BQU8sQ0FBQ04sR0FBRCxDQUFwQjtBQUNBLFNBQU8xSyxzQkFBc0IsQ0FBQ2dLLFFBQUQsRUFBV2pLLENBQUMsR0FBR2tMLE1BQU0sQ0FBQ2xMLENBQXRCLEVBQXlCRyxDQUFDLEdBQUcrSyxNQUFNLENBQUMvSyxDQUFwQyxDQUE3QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU2dMLHNCQUFULENBQWdDbEIsUUFBaEMsRUFBMENoUSxNQUExQyxFQUFrRHNRLFNBQWxELEVBQTZEO0FBQzNELE1BQUlOLFFBQVEsQ0FBQ3ZPLFFBQVQsS0FBc0IsS0FBMUIsRUFBaUM7QUFDL0JzTyxvQkFBZ0IsQ0FBQ0MsUUFBRCxDQUFoQjs7QUFDQSxRQUFJLE9BQU9oUSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFlBQU0sSUFBSWdPLEtBQUosQ0FBVSxrQ0FBa0MsT0FBT2hPLE1BQW5ELENBQU47QUFDRDs7QUFDRCxRQUFJLE9BQU9zUSxTQUFQLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLFlBQU0sSUFBSXRDLEtBQUosQ0FBVSwrQkFBK0IsT0FBT3NDLFNBQWhELENBQU47QUFDRDtBQUNGOztBQUVELE1BQUlhLE1BQU0sR0FBR1osc0JBQXNCLENBQUNQLFFBQUQsRUFBV2hRLE1BQVgsQ0FBbkM7QUFDQSxTQUFPeVEsK0JBQStCLENBQUNULFFBQUQsRUFBV21CLE1BQU0sQ0FBQ3BMLENBQWxCLEVBQXFCb0wsTUFBTSxDQUFDakwsQ0FBNUIsRUFBK0JvSyxTQUEvQixDQUF0QztBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTYyx1QkFBVCxDQUFpQ3BCLFFBQWpDLEVBQTJDaFEsTUFBM0MsRUFBbUQ7QUFDakQsTUFBSWdRLFFBQVEsQ0FBQ3ZPLFFBQVQsS0FBc0IsS0FBMUIsRUFBaUM7QUFDL0JzTyxvQkFBZ0IsQ0FBQ0MsUUFBRCxDQUFoQjtBQUNEOztBQUVELE1BQUltQixNQUFNLEdBQUdaLHNCQUFzQixDQUFDUCxRQUFELEVBQVdoUSxNQUFYLENBQW5DOztBQUNBLE1BQUlnUSxRQUFRLENBQUN6TyxXQUFULEtBQXlCLGVBQXpCLElBQTRDeU8sUUFBUSxDQUFDeE8sS0FBVCxLQUFtQixlQUFuRSxFQUFvRjtBQUNsRixRQUFJNlAsWUFBWSxHQUFHLEVBQW5COztBQUNBLFFBQUlGLE1BQU0sQ0FBQ3BMLENBQVAsR0FBVyxDQUFmLEVBQWtCO0FBQ2hCO0FBQ0FzTCxrQkFBWSxDQUFDbkIsSUFBYixDQUFrQmxRLE1BQU0sR0FBRyxDQUEzQixFQUZnQixDQUloQjs7QUFDQSxVQUFJbVIsTUFBTSxDQUFDakwsQ0FBUCxHQUFXOEosUUFBUSxDQUFDM08sTUFBVCxHQUFrQixDQUFqQyxFQUFvQztBQUNsQ2dRLG9CQUFZLENBQUNuQixJQUFiLENBQWtCbFEsTUFBTSxHQUFHZ1EsUUFBUSxDQUFDNU8sS0FBbEIsR0FBMEIsQ0FBNUM7QUFDRDtBQUVGOztBQUVELFFBQUkrUCxNQUFNLENBQUNwTCxDQUFQLEdBQVdpSyxRQUFRLENBQUM1TyxLQUFULEdBQWlCLENBQWhDLEVBQW1DO0FBQ2pDO0FBQ0FpUSxrQkFBWSxDQUFDbkIsSUFBYixDQUFrQmxRLE1BQU0sR0FBRyxDQUEzQixFQUZpQyxDQUlqQzs7QUFDQSxVQUFJbVIsTUFBTSxDQUFDakwsQ0FBUCxHQUFXLENBQWYsRUFBa0I7QUFDaEJtTCxvQkFBWSxDQUFDbkIsSUFBYixDQUFrQixJQUFJbFEsTUFBSixHQUFhZ1EsUUFBUSxDQUFDNU8sS0FBeEM7QUFDRDtBQUNGLEtBckJpRixDQXVCbEY7OztBQUNBLFFBQUkrUCxNQUFNLENBQUNqTCxDQUFQLEdBQVcsQ0FBZixFQUFrQjtBQUNoQm1MLGtCQUFZLENBQUNuQixJQUFiLENBQWtCbFEsTUFBTSxHQUFHZ1EsUUFBUSxDQUFDNU8sS0FBcEM7QUFDRCxLQTFCaUYsQ0E0QmxGOzs7QUFDQSxRQUFJK1AsTUFBTSxDQUFDakwsQ0FBUCxHQUFXOEosUUFBUSxDQUFDM08sTUFBVCxHQUFrQixDQUFqQyxFQUFvQztBQUNsQ2dRLGtCQUFZLENBQUNuQixJQUFiLENBQWtCbFEsTUFBTSxHQUFHZ1EsUUFBUSxDQUFDNU8sS0FBcEM7QUFDRDs7QUFFRCxXQUFPaVEsWUFBUDtBQUNEOztBQUVELFNBQU96QixnQkFBZ0IsQ0FBQ0ksUUFBUSxDQUFDek8sV0FBVixDQUFoQixDQUF1Q2dFLEdBQXZDLENBQTJDLFVBQVVtTCxHQUFWLEVBQWU7QUFDL0QsV0FBT0QsK0JBQStCLENBQUNULFFBQUQsRUFBV21CLE1BQU0sQ0FBQ3BMLENBQWxCLEVBQXFCb0wsTUFBTSxDQUFDakwsQ0FBNUIsRUFBK0J3SyxHQUEvQixDQUF0QztBQUNELEdBRk0sRUFFSlksTUFGSSxDQUVHLFVBQVVDLElBQVYsRUFBZ0I7QUFDeEIsV0FBT0EsSUFBSSxLQUFLLElBQWhCO0FBQ0QsR0FKTSxDQUFQO0FBS0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTQyx1QkFBVCxDQUFpQ3hCLFFBQWpDLEVBQTJDakssQ0FBM0MsRUFBOENHLENBQTlDLEVBQWlEO0FBQy9DLE1BQUk4SixRQUFRLENBQUN2TyxRQUFULEtBQXNCLEtBQTFCLEVBQWlDO0FBQy9Cc08sb0JBQWdCLENBQUNDLFFBQUQsQ0FBaEI7QUFDRDs7QUFFRCxNQUFJLE9BQU9qSyxDQUFQLEtBQWEsUUFBYixJQUF5QixPQUFPRyxDQUFQLEtBQWEsUUFBMUMsRUFBb0Q7QUFDbEQsVUFBTSxJQUFJOEgsS0FBSixDQUFVLDBCQUFWLENBQU47QUFDRDs7QUFFRCxNQUFJNkMsT0FBTyxHQUFHLENBQWQ7QUFBQSxNQUNFQyxPQUFPLEdBQUcsQ0FEWjs7QUFHQSxVQUFRZCxRQUFRLENBQUMxTyxNQUFqQjtBQUNBO0FBQ0EsU0FBSyxPQUFMO0FBQ0U7QUFDQSxVQUFJeUUsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFkLEVBQWlCO0FBQ2YrSyxlQUFPLElBQUksR0FBWDtBQUNEOztBQUNEOztBQUVGLFNBQUssUUFBTDtBQUNFO0FBQ0EsVUFBSS9LLENBQUMsR0FBRyxDQUFKLEtBQVUsQ0FBZCxFQUFpQjtBQUNmK0ssZUFBTyxJQUFJLEdBQVg7QUFDRDs7QUFDRDtBQUVGOztBQUNBLFNBQUssT0FBTDtBQUNFO0FBQ0EsVUFBSTVLLENBQUMsR0FBRyxDQUFKLEtBQVUsQ0FBZCxFQUFpQjtBQUNmMkssZUFBTyxJQUFJLEdBQVg7QUFDRDs7QUFFRDs7QUFFRixTQUFLLFFBQUw7QUFDRTtBQUNBLFVBQUkzSyxDQUFDLEdBQUcsQ0FBSixLQUFVLENBQWQsRUFBaUI7QUFDZjJLLGVBQU8sSUFBSSxHQUFYO0FBQ0Q7O0FBRUQ7O0FBQ0Y7QUFDRSxZQUFNLElBQUk3QyxLQUFKLENBQ0osb0RBQW9EZ0MsUUFBUSxDQUFDMU8sTUFBN0QsR0FBc0UsR0FEbEUsQ0FBTjtBQWpDRjs7QUFxQ0EsTUFBSTBPLFFBQVEsQ0FBQ3hPLEtBQVQsSUFBa0J3TyxRQUFRLENBQUN4TyxLQUFULEtBQW1CLGVBQXpDLEVBQTBEO0FBQ3hEcVAsV0FBTyxJQUFJL04sSUFBSSxDQUFDME4sS0FBTCxDQUFXdEssQ0FBQyxHQUFHLENBQWYsQ0FBWDtBQUNEOztBQUVELFNBQU87QUFDTEgsS0FBQyxFQUFFQSxDQUFDLEdBQUc4SyxPQURGO0FBRUwzSyxLQUFDLEVBQUVBLENBQUMsR0FBRzRLO0FBRkYsR0FBUDtBQUlEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTVyxtQkFBVCxDQUE2QnpCLFFBQTdCLEVBQXVDaFEsTUFBdkMsRUFBK0M7QUFDN0MsTUFBSW1SLE1BQU0sR0FBR1osc0JBQXNCLENBQUNQLFFBQUQsRUFBV2hRLE1BQVgsQ0FBbkM7QUFDQSxTQUFPd1IsdUJBQXVCLENBQUN4QixRQUFELEVBQVdtQixNQUFNLENBQUNwTCxDQUFsQixFQUFxQm9MLE1BQU0sQ0FBQ2pMLENBQTVCLENBQTlCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTd0wsMEJBQVQsQ0FBb0MxQixRQUFwQyxFQUE4Q2hRLE1BQTlDLEVBQXNEc0QsT0FBdEQsRUFBK0Q7QUFDN0QsTUFBSTBNLFFBQVEsQ0FBQ3ZPLFFBQVQsS0FBc0IsS0FBMUIsRUFBaUM7QUFDL0JzTyxvQkFBZ0IsQ0FBQ0MsUUFBRCxDQUFoQjs7QUFDQSxRQUFJLE9BQU9oUSxNQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CLFlBQU0sSUFBSWdPLEtBQUosQ0FBVSxtQ0FBbUMsT0FBT2hPLE1BQXBELENBQU47QUFDRDtBQUNGOztBQUVEc0QsU0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7QUFDQSxNQUFJcU8sV0FBVyxHQUFHck8sT0FBTyxDQUFDc08sT0FBMUI7O0FBQ0EsTUFBSUQsV0FBVyxLQUFLN00sU0FBcEIsRUFBK0I7QUFDN0I2TSxlQUFXLEdBQUc3RSxNQUFNLENBQUNDLGlCQUFyQjtBQUNEOztBQUVELE1BQUk4RSxRQUFRLEdBQUd2TyxPQUFPLENBQUN1TyxRQUF2Qjs7QUFDQSxNQUFJQSxRQUFRLEtBQUsvTSxTQUFqQixFQUE0QjtBQUMxQitNLFlBQVEsR0FBRyxDQUFYO0FBQ0QsR0FqQjRELENBbUI3RDs7O0FBQ0EsTUFBSUMsZUFBZSxHQUFHLENBQUM5UixNQUFELENBQXRCLENBcEI2RCxDQXNCN0Q7O0FBQ0EsTUFBSTRDLElBQUksR0FBRyxFQUFYO0FBQ0FBLE1BQUksQ0FBQzVDLE1BQUQsQ0FBSixHQUFlLElBQWYsQ0F4QjZELENBMEI3RDs7QUFDQSxNQUFJK1IsSUFBSSxHQUFHLEVBQVg7O0FBRUEsU0FBT0QsZUFBZSxDQUFDL00sTUFBdkIsRUFBK0I7QUFDN0IsUUFBSWlOLGNBQWMsR0FBR0YsZUFBZSxDQUFDN0MsS0FBaEIsRUFBckI7O0FBQ0EsUUFBSThDLElBQUksQ0FBQ0MsY0FBRCxDQUFKLEtBQXlCbE4sU0FBN0IsRUFBd0M7QUFDdENpTixVQUFJLENBQUNDLGNBQUQsQ0FBSixHQUF1QjtBQUNyQi9CLGVBQU8sRUFBRSxDQUFDK0IsY0FBRCxDQURZO0FBRXJCQyxZQUFJLEVBQUU7QUFGZSxPQUF2QjtBQUlEOztBQUVEYiwyQkFBdUIsQ0FBQ3BCLFFBQUQsRUFBV2dDLGNBQVgsQ0FBdkIsQ0FBa0R0TixPQUFsRCxDQUEwRCxTQUFTd04sWUFBVCxDQUFzQkMsZUFBdEIsRUFBdUM7QUFDL0Y7QUFDQSxVQUFJSixJQUFJLENBQUNDLGNBQUQsQ0FBSixDQUFxQkMsSUFBckIsR0FBNEJOLFdBQWhDLEVBQTZDO0FBQzNDO0FBQ0QsT0FKOEYsQ0FNL0Y7QUFDQTs7O0FBQ0EsVUFBSS9PLElBQUksQ0FBQ3VQLGVBQUQsQ0FBSixLQUEwQnJOLFNBQTlCLEVBQXlDO0FBQ3ZDO0FBQ0QsT0FWOEYsQ0FZL0Y7OztBQUNBLFVBQUksT0FBT3hCLE9BQU8sQ0FBQ3lELFVBQWYsS0FBK0IsVUFBL0IsSUFDRnpELE9BQU8sQ0FBQ3lELFVBQVIsQ0FBbUJvTCxlQUFuQixNQUF3QyxLQUQxQyxFQUVFO0FBQ0E7QUFDRDs7QUFFRCxVQUFJRixJQUFJLEdBQUcsSUFBWDs7QUFDQSxVQUFJLE9BQU9KLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbENJLFlBQUksR0FBR0osUUFBUSxDQUFDRyxjQUFELEVBQWlCRyxlQUFqQixDQUFmOztBQUNBLFlBQUksT0FBT0YsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixnQkFBTSxJQUFJakUsS0FBSixDQUNKLGlFQURJLENBQU47QUFHRDtBQUNGLE9BUEQsTUFPTztBQUNMaUUsWUFBSSxHQUFHSixRQUFQO0FBQ0Q7O0FBRUQsVUFBSU8sUUFBUSxHQUFHTCxJQUFJLENBQUNDLGNBQUQsQ0FBSixDQUFxQkMsSUFBckIsR0FBNEJBLElBQTNDOztBQUNBLFVBQUlHLFFBQVEsR0FBR1QsV0FBZixFQUE0QjtBQUMxQjtBQUNEOztBQUVEL08sVUFBSSxDQUFDdVAsZUFBRCxDQUFKLEdBQXdCSCxjQUF4QjtBQUNBRCxVQUFJLENBQUNJLGVBQUQsQ0FBSixHQUF3QjtBQUN0QkYsWUFBSSxFQUFFRyxRQURnQjtBQUV0Qm5DLGVBQU8sRUFBRThCLElBQUksQ0FBQ0MsY0FBRCxDQUFKLENBQXFCL0IsT0FBckIsQ0FBNkJwQixNQUE3QixDQUFvQyxDQUFDc0QsZUFBRCxDQUFwQztBQUZhLE9BQXhCO0FBS0FMLHFCQUFlLENBQUM1QixJQUFoQixDQUFxQmlDLGVBQXJCO0FBQ0QsS0EzQ0Q7QUE0Q0QsR0FsRjRELENBb0Y3RDs7O0FBQ0EsU0FBT0osSUFBSSxDQUFDL1IsTUFBRCxDQUFYO0FBRUEsU0FBTytSLElBQVA7QUFDRDs7QUFFRCxTQUFTakwsT0FBVCxDQUFrQmtKLFFBQWxCLEVBQTRCckssVUFBNUIsRUFBd0NRLFFBQXhDLEVBQWtEN0MsT0FBbEQsRUFBMkQ7QUFDekQsTUFBSW1LLENBQUosRUFBTzRFLENBQVAsRUFBVUMsa0JBQVY7QUFFQSxNQUFJQyxPQUFPLEdBQUcsRUFBZDtBQUVBLE1BQUlDLFdBQVcsR0FBRyxFQUFsQjs7QUFDQSxPQUFLL0UsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdEgsUUFBUSxDQUFDcEIsTUFBekIsRUFBaUMwSSxDQUFDLElBQUksQ0FBdEMsRUFBeUM7QUFDdkMsUUFBSW5LLE9BQU8sQ0FBQ3lELFVBQVIsQ0FBbUJaLFFBQVEsQ0FBQ3NILENBQUQsQ0FBM0IsQ0FBSixFQUFxQztBQUNuQytFLGlCQUFXLENBQUNyTSxRQUFRLENBQUNzSCxDQUFELENBQVQsQ0FBWCxHQUEyQixJQUEzQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSWdGLGFBQWEsR0FBRyxFQUFwQjs7QUFDQSxPQUFLaEYsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHOUgsVUFBVSxDQUFDWixNQUEzQixFQUFtQzBJLENBQUMsSUFBSSxDQUF4QyxFQUEyQztBQUN6QyxRQUFJbkssT0FBTyxDQUFDeUQsVUFBUixDQUFtQnBCLFVBQVUsQ0FBQzhILENBQUQsQ0FBN0IsQ0FBSixFQUF1QztBQUNyQ2dGLG1CQUFhLENBQUN2QyxJQUFkLENBQW1CdkssVUFBVSxDQUFDOEgsQ0FBRCxDQUE3QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT2dGLGFBQWEsQ0FBQzFOLE1BQWQsR0FBdUIsQ0FBOUIsRUFBaUM7QUFDL0IsU0FBSzBJLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2dGLGFBQWEsQ0FBQzFOLE1BQTlCLEVBQXNDMEksQ0FBQyxJQUFJLENBQTNDLEVBQThDO0FBQzVDOEUsYUFBTyxDQUFDRSxhQUFhLENBQUNoRixDQUFELENBQWQsQ0FBUCxHQUE0QixJQUE1Qjs7QUFDQSxVQUFJK0UsV0FBVyxDQUFDQyxhQUFhLENBQUNoRixDQUFELENBQWQsQ0FBWCxLQUFrQyxJQUF0QyxFQUE0QztBQUMxQyxlQUFPLElBQVA7QUFDRDtBQUNGOztBQUVENkUsc0JBQWtCLEdBQUcsRUFBckI7O0FBQ0EsU0FBSzdFLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2dGLGFBQWEsQ0FBQzFOLE1BQTlCLEVBQXNDMEksQ0FBQyxJQUFJLENBQTNDLEVBQThDO0FBQzVDLFVBQUlpRixVQUFVLEdBQUd0Qix1QkFBdUIsQ0FBQ3BCLFFBQUQsRUFBV3lDLGFBQWEsQ0FBQ2hGLENBQUQsQ0FBeEIsQ0FBeEM7O0FBRUEsV0FBSzRFLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR0ssVUFBVSxDQUFDM04sTUFBM0IsRUFBbUNzTixDQUFDLElBQUksQ0FBeEMsRUFBMkM7QUFDekMsWUFBSS9PLE9BQU8sQ0FBQ3lELFVBQVIsQ0FBbUIyTCxVQUFVLENBQUNMLENBQUQsQ0FBN0IsS0FDRkMsa0JBQWtCLENBQUMzRixPQUFuQixDQUEyQitGLFVBQVUsQ0FBQ0wsQ0FBRCxDQUFyQyxNQUE4QyxDQUFDLENBRDdDLElBRUZFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDTCxDQUFELENBQVgsQ0FBUCxLQUEyQnZOLFNBRjdCLEVBR0U7QUFDQXdOLDRCQUFrQixDQUFDcEMsSUFBbkIsQ0FBd0J3QyxVQUFVLENBQUNMLENBQUQsQ0FBbEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRURJLGlCQUFhLEdBQUdILGtCQUFoQjtBQUNEOztBQUVELFNBQU8sS0FBUDtBQUNEOztBQUVESyxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZjdDLGtCQUFnQixFQUFFQSxnQkFESDtBQUVmM0osWUFBVSxFQUFFQSxVQUZHO0FBR2YrSixvQkFBa0IsRUFBRUEsa0JBSEw7QUFJZm5LLHdCQUFzQixFQUFFQSxzQkFKVDtBQUtmcUssa0JBQWdCLEVBQUVBLGdCQUxIO0FBTWZFLHdCQUFzQixFQUFFQSxzQkFOVDtBQU9mRSxpQ0FBK0IsRUFBRUEsK0JBUGxCO0FBUWZTLHdCQUFzQixFQUFFQSxzQkFSVDtBQVNmRSx5QkFBdUIsRUFBRUEsdUJBVFY7QUFVZkkseUJBQXVCLEVBQUVBLHVCQVZWO0FBV2ZDLHFCQUFtQixFQUFFQSxtQkFYTjtBQVlmQyw0QkFBMEIsRUFBRUEsMEJBWmI7QUFhZjVLLFNBQU8sRUFBRUE7QUFiTSxDQUFqQixDOzs7Ozs7Ozs7OztBQ3ZrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUMsV0FBVStMLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzFCLFVBQStESCxNQUFNLENBQUNDLE9BQVAsR0FBaUJFLE9BQU8sRUFBdkYsR0FDQSxTQURBO0FBR0QsQ0FKQSxFQUlDLElBSkQsRUFJTyxZQUFZO0FBQUU7O0FBQWEsTUFBSUMsT0FBTyxHQUFHcFEsS0FBSyxDQUFDbUksU0FBTixDQUFnQnJDLEtBQTlCOztBQUVqQyxXQUFTdUssV0FBVCxDQUFxQkMsSUFBckIsRUFBMkJDLFVBQTNCLEVBQXVDO0FBQ3JDLFFBQUlBLFVBQUosRUFBZ0I7QUFDZEQsVUFBSSxDQUFDbkksU0FBTCxHQUFpQmtCLE1BQU0sQ0FBQ21ILE1BQVAsQ0FBY0QsVUFBVSxDQUFDcEksU0FBekIsQ0FBakI7QUFDRDs7QUFDRG1JLFFBQUksQ0FBQ25JLFNBQUwsQ0FBZXNJLFdBQWYsR0FBNkJILElBQTdCO0FBQ0Q7O0FBRUQsV0FBU0ksUUFBVCxDQUFrQnBOLEtBQWxCLEVBQXlCO0FBQ3JCLFdBQU9xTixVQUFVLENBQUNyTixLQUFELENBQVYsR0FBb0JBLEtBQXBCLEdBQTRCc04sR0FBRyxDQUFDdE4sS0FBRCxDQUF0QztBQUNEOztBQUdIK00sYUFBVyxDQUFDUSxhQUFELEVBQWdCSCxRQUFoQixDQUFYOztBQUNFLFdBQVNHLGFBQVQsQ0FBdUJ2TixLQUF2QixFQUE4QjtBQUM1QixXQUFPd04sT0FBTyxDQUFDeE4sS0FBRCxDQUFQLEdBQWlCQSxLQUFqQixHQUF5QnlOLFFBQVEsQ0FBQ3pOLEtBQUQsQ0FBeEM7QUFDRDs7QUFHSCtNLGFBQVcsQ0FBQ1csZUFBRCxFQUFrQk4sUUFBbEIsQ0FBWDs7QUFDRSxXQUFTTSxlQUFULENBQXlCMU4sS0FBekIsRUFBZ0M7QUFDOUIsV0FBTzJOLFNBQVMsQ0FBQzNOLEtBQUQsQ0FBVCxHQUFtQkEsS0FBbkIsR0FBMkI0TixVQUFVLENBQUM1TixLQUFELENBQTVDO0FBQ0Q7O0FBR0grTSxhQUFXLENBQUNjLFdBQUQsRUFBY1QsUUFBZCxDQUFYOztBQUNFLFdBQVNTLFdBQVQsQ0FBcUI3TixLQUFyQixFQUE0QjtBQUMxQixXQUFPcU4sVUFBVSxDQUFDck4sS0FBRCxDQUFWLElBQXFCLENBQUM4TixhQUFhLENBQUM5TixLQUFELENBQW5DLEdBQTZDQSxLQUE3QyxHQUFxRCtOLE1BQU0sQ0FBQy9OLEtBQUQsQ0FBbEU7QUFDRDs7QUFJSCxXQUFTcU4sVUFBVCxDQUFvQlcsYUFBcEIsRUFBbUM7QUFDakMsV0FBTyxDQUFDLEVBQUVBLGFBQWEsSUFBSUEsYUFBYSxDQUFDQyxvQkFBRCxDQUFoQyxDQUFSO0FBQ0Q7O0FBRUQsV0FBU1QsT0FBVCxDQUFpQlUsVUFBakIsRUFBNkI7QUFDM0IsV0FBTyxDQUFDLEVBQUVBLFVBQVUsSUFBSUEsVUFBVSxDQUFDQyxpQkFBRCxDQUExQixDQUFSO0FBQ0Q7O0FBRUQsV0FBU1IsU0FBVCxDQUFtQlMsWUFBbkIsRUFBaUM7QUFDL0IsV0FBTyxDQUFDLEVBQUVBLFlBQVksSUFBSUEsWUFBWSxDQUFDQyxtQkFBRCxDQUE5QixDQUFSO0FBQ0Q7O0FBRUQsV0FBU1AsYUFBVCxDQUF1QlEsZ0JBQXZCLEVBQXlDO0FBQ3ZDLFdBQU9kLE9BQU8sQ0FBQ2MsZ0JBQUQsQ0FBUCxJQUE2QlgsU0FBUyxDQUFDVyxnQkFBRCxDQUE3QztBQUNEOztBQUVELFdBQVNDLFNBQVQsQ0FBbUJDLFlBQW5CLEVBQWlDO0FBQy9CLFdBQU8sQ0FBQyxFQUFFQSxZQUFZLElBQUlBLFlBQVksQ0FBQ0MsbUJBQUQsQ0FBOUIsQ0FBUjtBQUNEOztBQUVEckIsVUFBUSxDQUFDQyxVQUFULEdBQXNCQSxVQUF0QjtBQUNBRCxVQUFRLENBQUNJLE9BQVQsR0FBbUJBLE9BQW5CO0FBQ0FKLFVBQVEsQ0FBQ08sU0FBVCxHQUFxQkEsU0FBckI7QUFDQVAsVUFBUSxDQUFDVSxhQUFULEdBQXlCQSxhQUF6QjtBQUNBVixVQUFRLENBQUNtQixTQUFULEdBQXFCQSxTQUFyQjtBQUVBbkIsVUFBUSxDQUFDc0IsS0FBVCxHQUFpQm5CLGFBQWpCO0FBQ0FILFVBQVEsQ0FBQ3VCLE9BQVQsR0FBbUJqQixlQUFuQjtBQUNBTixVQUFRLENBQUN0UixHQUFULEdBQWUrUixXQUFmO0FBR0EsTUFBSUksb0JBQW9CLEdBQUcsNEJBQTNCO0FBQ0EsTUFBSUUsaUJBQWlCLEdBQUcseUJBQXhCO0FBQ0EsTUFBSUUsbUJBQW1CLEdBQUcsMkJBQTFCO0FBQ0EsTUFBSUksbUJBQW1CLEdBQUcsMkJBQTFCLENBbkVrQixDQXFFbEI7O0FBQ0EsTUFBSUcsTUFBTSxHQUFHLFFBQWIsQ0F0RWtCLENBd0VsQjs7QUFDQSxNQUFJQyxLQUFLLEdBQUcsQ0FBWixDQXpFa0IsQ0F5RUg7O0FBQ2YsTUFBSUMsSUFBSSxHQUFHLEtBQUtELEtBQWhCO0FBQ0EsTUFBSUUsSUFBSSxHQUFHRCxJQUFJLEdBQUcsQ0FBbEIsQ0EzRWtCLENBNkVsQjtBQUNBOztBQUNBLE1BQUlFLE9BQU8sR0FBRyxFQUFkLENBL0VrQixDQWlGbEI7O0FBQ0EsTUFBSUMsYUFBYSxHQUFHO0FBQUVqUCxTQUFLLEVBQUU7QUFBVCxHQUFwQjtBQUNBLE1BQUlrUCxTQUFTLEdBQUc7QUFBRWxQLFNBQUssRUFBRTtBQUFULEdBQWhCOztBQUVBLFdBQVNtUCxPQUFULENBQWlCQyxHQUFqQixFQUFzQjtBQUNwQkEsT0FBRyxDQUFDcFAsS0FBSixHQUFZLEtBQVo7QUFDQSxXQUFPb1AsR0FBUDtBQUNEOztBQUVELFdBQVNDLE1BQVQsQ0FBZ0JELEdBQWhCLEVBQXFCO0FBQ25CQSxPQUFHLEtBQUtBLEdBQUcsQ0FBQ3BQLEtBQUosR0FBWSxJQUFqQixDQUFIO0FBQ0QsR0E1RmlCLENBOEZsQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVNzUCxPQUFULEdBQW1CLENBQUUsQ0FqR0gsQ0FtR2xCOzs7QUFDQSxXQUFTQyxPQUFULENBQWlCQyxHQUFqQixFQUFzQnhFLE1BQXRCLEVBQThCO0FBQzVCQSxVQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFuQjtBQUNBLFFBQUl5RSxHQUFHLEdBQUc1UyxJQUFJLENBQUM2UyxHQUFMLENBQVMsQ0FBVCxFQUFZRixHQUFHLENBQUMxUSxNQUFKLEdBQWFrTSxNQUF6QixDQUFWO0FBQ0EsUUFBSTJFLE1BQU0sR0FBRyxJQUFJalQsS0FBSixDQUFVK1MsR0FBVixDQUFiOztBQUNBLFNBQUssSUFBSUcsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR0gsR0FBdEIsRUFBMkJHLEVBQUUsRUFBN0IsRUFBaUM7QUFDL0JELFlBQU0sQ0FBQ0MsRUFBRCxDQUFOLEdBQWFKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHNUUsTUFBTixDQUFoQjtBQUNEOztBQUNELFdBQU8yRSxNQUFQO0FBQ0Q7O0FBRUQsV0FBU0UsVUFBVCxDQUFvQkMsSUFBcEIsRUFBMEI7QUFDeEIsUUFBSUEsSUFBSSxDQUFDNVUsSUFBTCxLQUFjMkQsU0FBbEIsRUFBNkI7QUFDM0JpUixVQUFJLENBQUM1VSxJQUFMLEdBQVk0VSxJQUFJLENBQUNDLFNBQUwsQ0FBZUMsVUFBZixDQUFaO0FBQ0Q7O0FBQ0QsV0FBT0YsSUFBSSxDQUFDNVUsSUFBWjtBQUNEOztBQUVELFdBQVMrVSxTQUFULENBQW1CSCxJQUFuQixFQUF5QjlJLEtBQXpCLEVBQWdDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFVBQUlrSixXQUFXLEdBQUdsSixLQUFLLEtBQUssQ0FBNUIsQ0FENkIsQ0FDRTs7QUFDL0IsVUFBSSxLQUFLa0osV0FBTCxLQUFxQmxKLEtBQXJCLElBQThCa0osV0FBVyxLQUFLLFVBQWxELEVBQThEO0FBQzVELGVBQU9DLEdBQVA7QUFDRDs7QUFDRG5KLFdBQUssR0FBR2tKLFdBQVI7QUFDRDs7QUFDRCxXQUFPbEosS0FBSyxHQUFHLENBQVIsR0FBWTZJLFVBQVUsQ0FBQ0MsSUFBRCxDQUFWLEdBQW1COUksS0FBL0IsR0FBdUNBLEtBQTlDO0FBQ0Q7O0FBRUQsV0FBU2dKLFVBQVQsR0FBc0I7QUFDcEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBU0ksVUFBVCxDQUFvQkMsS0FBcEIsRUFBMkJDLEdBQTNCLEVBQWdDcFYsSUFBaEMsRUFBc0M7QUFDcEMsV0FBTyxDQUFDbVYsS0FBSyxLQUFLLENBQVYsSUFBZ0JuVixJQUFJLEtBQUsyRCxTQUFULElBQXNCd1IsS0FBSyxJQUFJLENBQUNuVixJQUFqRCxNQUNKb1YsR0FBRyxLQUFLelIsU0FBUixJQUFzQjNELElBQUksS0FBSzJELFNBQVQsSUFBc0J5UixHQUFHLElBQUlwVixJQUQvQyxDQUFQO0FBRUQ7O0FBRUQsV0FBU3FWLFlBQVQsQ0FBc0JGLEtBQXRCLEVBQTZCblYsSUFBN0IsRUFBbUM7QUFDakMsV0FBT3NWLFlBQVksQ0FBQ0gsS0FBRCxFQUFRblYsSUFBUixFQUFjLENBQWQsQ0FBbkI7QUFDRDs7QUFFRCxXQUFTdVYsVUFBVCxDQUFvQkgsR0FBcEIsRUFBeUJwVixJQUF6QixFQUErQjtBQUM3QixXQUFPc1YsWUFBWSxDQUFDRixHQUFELEVBQU1wVixJQUFOLEVBQVlBLElBQVosQ0FBbkI7QUFDRDs7QUFFRCxXQUFTc1YsWUFBVCxDQUFzQnhKLEtBQXRCLEVBQTZCOUwsSUFBN0IsRUFBbUN3VixZQUFuQyxFQUFpRDtBQUMvQyxXQUFPMUosS0FBSyxLQUFLbkksU0FBVixHQUNMNlIsWUFESyxHQUVMMUosS0FBSyxHQUFHLENBQVIsR0FDRW5LLElBQUksQ0FBQzZTLEdBQUwsQ0FBUyxDQUFULEVBQVl4VSxJQUFJLEdBQUc4TCxLQUFuQixDQURGLEdBRUU5TCxJQUFJLEtBQUsyRCxTQUFULEdBQ0VtSSxLQURGLEdBRUVuSyxJQUFJLENBQUM4VCxHQUFMLENBQVN6VixJQUFULEVBQWU4TCxLQUFmLENBTk47QUFPRDtBQUVEOzs7QUFFQSxNQUFJNEosWUFBWSxHQUFHLENBQW5CO0FBQ0EsTUFBSUMsY0FBYyxHQUFHLENBQXJCO0FBQ0EsTUFBSUMsZUFBZSxHQUFHLENBQXRCO0FBRUEsTUFBSUMsb0JBQW9CLEdBQUcsT0FBTzNLLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0NBLE1BQU0sQ0FBQ0MsUUFBbEU7QUFDQSxNQUFJMkssb0JBQW9CLEdBQUcsWUFBM0I7QUFFQSxNQUFJQyxlQUFlLEdBQUdGLG9CQUFvQixJQUFJQyxvQkFBOUM7O0FBR0EsV0FBU0UsUUFBVCxDQUFrQkMsSUFBbEIsRUFBd0I7QUFDcEIsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7O0FBRURELFVBQVEsQ0FBQ3JNLFNBQVQsQ0FBbUJvQixRQUFuQixHQUE4QixZQUFXO0FBQ3ZDLFdBQU8sWUFBUDtBQUNELEdBRkQ7O0FBS0ZpTCxVQUFRLENBQUNFLElBQVQsR0FBZ0JSLFlBQWhCO0FBQ0FNLFVBQVEsQ0FBQ0csTUFBVCxHQUFrQlIsY0FBbEI7QUFDQUssVUFBUSxDQUFDSSxPQUFULEdBQW1CUixlQUFuQjs7QUFFQUksVUFBUSxDQUFDck0sU0FBVCxDQUFtQjBNLE9BQW5CLEdBQ0FMLFFBQVEsQ0FBQ3JNLFNBQVQsQ0FBbUIyTSxRQUFuQixHQUE4QixZQUFZO0FBQUUsV0FBTyxLQUFLdkwsUUFBTCxFQUFQO0FBQXlCLEdBRHJFOztBQUVBaUwsVUFBUSxDQUFDck0sU0FBVCxDQUFtQm9NLGVBQW5CLElBQXNDLFlBQVk7QUFDaEQsV0FBTyxJQUFQO0FBQ0QsR0FGRDs7QUFLQSxXQUFTUSxhQUFULENBQXVCeFgsSUFBdkIsRUFBNkJ5WCxDQUE3QixFQUFnQ0MsQ0FBaEMsRUFBbUNDLGNBQW5DLEVBQW1EO0FBQ2pELFFBQUk1UixLQUFLLEdBQUcvRixJQUFJLEtBQUssQ0FBVCxHQUFheVgsQ0FBYixHQUFpQnpYLElBQUksS0FBSyxDQUFULEdBQWEwWCxDQUFiLEdBQWlCLENBQUNELENBQUQsRUFBSUMsQ0FBSixDQUE5QztBQUNBQyxrQkFBYyxHQUFJQSxjQUFjLENBQUM1UixLQUFmLEdBQXVCQSxLQUEzQixHQUFxQzRSLGNBQWMsR0FBRztBQUNsRTVSLFdBQUssRUFBRUEsS0FEMkQ7QUFDcEQ2UixVQUFJLEVBQUU7QUFEOEMsS0FBcEU7QUFHQSxXQUFPRCxjQUFQO0FBQ0Q7O0FBRUQsV0FBU0UsWUFBVCxHQUF3QjtBQUN0QixXQUFPO0FBQUU5UixXQUFLLEVBQUVuQixTQUFUO0FBQW9CZ1QsVUFBSSxFQUFFO0FBQTFCLEtBQVA7QUFDRDs7QUFFRCxXQUFTRSxXQUFULENBQXFCL0QsYUFBckIsRUFBb0M7QUFDbEMsV0FBTyxDQUFDLENBQUNnRSxhQUFhLENBQUNoRSxhQUFELENBQXRCO0FBQ0Q7O0FBRUQsV0FBU2lFLFVBQVQsQ0FBb0JDLGFBQXBCLEVBQW1DO0FBQ2pDLFdBQU9BLGFBQWEsSUFBSSxPQUFPQSxhQUFhLENBQUNmLElBQXJCLEtBQThCLFVBQXREO0FBQ0Q7O0FBRUQsV0FBU2dCLFdBQVQsQ0FBcUJqUCxRQUFyQixFQUErQjtBQUM3QixRQUFJa1AsVUFBVSxHQUFHSixhQUFhLENBQUM5TyxRQUFELENBQTlCO0FBQ0EsV0FBT2tQLFVBQVUsSUFBSUEsVUFBVSxDQUFDbE0sSUFBWCxDQUFnQmhELFFBQWhCLENBQXJCO0FBQ0Q7O0FBRUQsV0FBUzhPLGFBQVQsQ0FBdUI5TyxRQUF2QixFQUFpQztBQUMvQixRQUFJa1AsVUFBVSxHQUFHbFAsUUFBUSxLQUN0QjZOLG9CQUFvQixJQUFJN04sUUFBUSxDQUFDNk4sb0JBQUQsQ0FBakMsSUFDQTdOLFFBQVEsQ0FBQzhOLG9CQUFELENBRmUsQ0FBekI7O0FBSUEsUUFBSSxPQUFPb0IsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxhQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTQyxXQUFULENBQXFCclMsS0FBckIsRUFBNEI7QUFDMUIsV0FBT0EsS0FBSyxJQUFJLE9BQU9BLEtBQUssQ0FBQ2xCLE1BQWIsS0FBd0IsUUFBeEM7QUFDRDs7QUFFRGlPLGFBQVcsQ0FBQ08sR0FBRCxFQUFNRixRQUFOLENBQVg7O0FBQ0UsV0FBU0UsR0FBVCxDQUFhdE4sS0FBYixFQUFvQjtBQUNsQixXQUFPQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLbkIsU0FBNUIsR0FBd0N5VCxhQUFhLEVBQXJELEdBQ0xqRixVQUFVLENBQUNyTixLQUFELENBQVYsR0FBb0JBLEtBQUssQ0FBQ3VTLEtBQU4sRUFBcEIsR0FBb0NDLFlBQVksQ0FBQ3hTLEtBQUQsQ0FEbEQ7QUFFRDs7QUFFRHNOLEtBQUcsQ0FBQy9ELEVBQUosR0FBUyxZQUF3QjtBQUMvQixXQUFPK0QsR0FBRyxDQUFDekYsU0FBRCxDQUFWO0FBQ0QsR0FGRDs7QUFJQXlGLEtBQUcsQ0FBQ3pJLFNBQUosQ0FBYzBOLEtBQWQsR0FBc0IsWUFBVztBQUMvQixXQUFPLElBQVA7QUFDRCxHQUZEOztBQUlBakYsS0FBRyxDQUFDekksU0FBSixDQUFjb0IsUUFBZCxHQUF5QixZQUFXO0FBQ2xDLFdBQU8sS0FBS3dNLFVBQUwsQ0FBZ0IsT0FBaEIsRUFBeUIsR0FBekIsQ0FBUDtBQUNELEdBRkQ7O0FBSUFuRixLQUFHLENBQUN6SSxTQUFKLENBQWM2TixXQUFkLEdBQTRCLFlBQVc7QUFDckMsUUFBSSxDQUFDLEtBQUtDLE1BQU4sSUFBZ0IsS0FBS0MsaUJBQXpCLEVBQTRDO0FBQzFDLFdBQUtELE1BQUwsR0FBYyxLQUFLRSxRQUFMLEdBQWdCeFQsT0FBaEIsRUFBZDtBQUNBLFdBQUtuRSxJQUFMLEdBQVksS0FBS3lYLE1BQUwsQ0FBWTdULE1BQXhCO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0FORCxDQTNQZ0IsQ0FtUWhCOzs7QUFFQXdPLEtBQUcsQ0FBQ3pJLFNBQUosQ0FBY2tMLFNBQWQsR0FBMEIsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUM5QyxXQUFPQyxVQUFVLENBQUMsSUFBRCxFQUFPRixFQUFQLEVBQVdDLE9BQVgsRUFBb0IsSUFBcEIsQ0FBakI7QUFDRCxHQUZELENBclFnQixDQXlRaEI7OztBQUVBekYsS0FBRyxDQUFDekksU0FBSixDQUFjb08sVUFBZCxHQUEyQixVQUFTaFosSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUNqRCxXQUFPRyxXQUFXLENBQUMsSUFBRCxFQUFPalosSUFBUCxFQUFhOFksT0FBYixFQUFzQixJQUF0QixDQUFsQjtBQUNELEdBRkQ7O0FBTUZoRyxhQUFXLENBQUNVLFFBQUQsRUFBV0gsR0FBWCxDQUFYOztBQUNFLFdBQVNHLFFBQVQsQ0FBa0J6TixLQUFsQixFQUF5QjtBQUN2QixXQUFPQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLbkIsU0FBNUIsR0FDTHlULGFBQWEsR0FBR2EsVUFBaEIsRUFESyxHQUVMOUYsVUFBVSxDQUFDck4sS0FBRCxDQUFWLEdBQ0d3TixPQUFPLENBQUN4TixLQUFELENBQVAsR0FBaUJBLEtBQUssQ0FBQ3VTLEtBQU4sRUFBakIsR0FBaUN2UyxLQUFLLENBQUNvVCxZQUFOLEVBRHBDLEdBRUVDLGlCQUFpQixDQUFDclQsS0FBRCxDQUpyQjtBQUtEOztBQUVEeU4sVUFBUSxDQUFDNUksU0FBVCxDQUFtQnNPLFVBQW5CLEdBQWdDLFlBQVc7QUFDekMsV0FBTyxJQUFQO0FBQ0QsR0FGRDs7QUFNRnBHLGFBQVcsQ0FBQ2EsVUFBRCxFQUFhTixHQUFiLENBQVg7O0FBQ0UsV0FBU00sVUFBVCxDQUFvQjVOLEtBQXBCLEVBQTJCO0FBQ3pCLFdBQU9BLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUtuQixTQUE1QixHQUF3Q3lULGFBQWEsRUFBckQsR0FDTCxDQUFDakYsVUFBVSxDQUFDck4sS0FBRCxDQUFYLEdBQXFCc1QsbUJBQW1CLENBQUN0VCxLQUFELENBQXhDLEdBQ0F3TixPQUFPLENBQUN4TixLQUFELENBQVAsR0FBaUJBLEtBQUssQ0FBQzZTLFFBQU4sRUFBakIsR0FBb0M3UyxLQUFLLENBQUN1VCxZQUFOLEVBRnRDO0FBR0Q7O0FBRUQzRixZQUFVLENBQUNyRSxFQUFYLEdBQWdCLFlBQXdCO0FBQ3RDLFdBQU9xRSxVQUFVLENBQUMvRixTQUFELENBQWpCO0FBQ0QsR0FGRDs7QUFJQStGLFlBQVUsQ0FBQy9JLFNBQVgsQ0FBcUIwTyxZQUFyQixHQUFvQyxZQUFXO0FBQzdDLFdBQU8sSUFBUDtBQUNELEdBRkQ7O0FBSUEzRixZQUFVLENBQUMvSSxTQUFYLENBQXFCb0IsUUFBckIsR0FBZ0MsWUFBVztBQUN6QyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLE9BQWhCLEVBQXlCLEdBQXpCLENBQVA7QUFDRCxHQUZEOztBQUlBN0UsWUFBVSxDQUFDL0ksU0FBWCxDQUFxQmtMLFNBQXJCLEdBQWlDLFVBQVMrQyxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFDckQsV0FBT0MsVUFBVSxDQUFDLElBQUQsRUFBT0YsRUFBUCxFQUFXQyxPQUFYLEVBQW9CLEtBQXBCLENBQWpCO0FBQ0QsR0FGRDs7QUFJQW5GLFlBQVUsQ0FBQy9JLFNBQVgsQ0FBcUJvTyxVQUFyQixHQUFrQyxVQUFTaFosSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUN4RCxXQUFPRyxXQUFXLENBQUMsSUFBRCxFQUFPalosSUFBUCxFQUFhOFksT0FBYixFQUFzQixLQUF0QixDQUFsQjtBQUNELEdBRkQ7O0FBTUZoRyxhQUFXLENBQUNnQixNQUFELEVBQVNULEdBQVQsQ0FBWDs7QUFDRSxXQUFTUyxNQUFULENBQWdCL04sS0FBaEIsRUFBdUI7QUFDckIsV0FBTyxDQUNMQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLbkIsU0FBNUIsR0FBd0N5VCxhQUFhLEVBQXJELEdBQ0EsQ0FBQ2pGLFVBQVUsQ0FBQ3JOLEtBQUQsQ0FBWCxHQUFxQnNULG1CQUFtQixDQUFDdFQsS0FBRCxDQUF4QyxHQUNBd04sT0FBTyxDQUFDeE4sS0FBRCxDQUFQLEdBQWlCQSxLQUFLLENBQUM2UyxRQUFOLEVBQWpCLEdBQW9DN1MsS0FIL0IsRUFJTHdULFFBSkssRUFBUDtBQUtEOztBQUVEekYsUUFBTSxDQUFDeEUsRUFBUCxHQUFZLFlBQXdCO0FBQ2xDLFdBQU93RSxNQUFNLENBQUNsRyxTQUFELENBQWI7QUFDRCxHQUZEOztBQUlBa0csUUFBTSxDQUFDbEosU0FBUCxDQUFpQjJPLFFBQWpCLEdBQTRCLFlBQVc7QUFDckMsV0FBTyxJQUFQO0FBQ0QsR0FGRDs7QUFNRmxHLEtBQUcsQ0FBQ21HLEtBQUosR0FBWUEsS0FBWjtBQUNBbkcsS0FBRyxDQUFDb0IsS0FBSixHQUFZakIsUUFBWjtBQUNBSCxLQUFHLENBQUN4UixHQUFKLEdBQVVpUyxNQUFWO0FBQ0FULEtBQUcsQ0FBQ3FCLE9BQUosR0FBY2YsVUFBZDtBQUVBLE1BQUk4RixlQUFlLEdBQUcsdUJBQXRCO0FBRUFwRyxLQUFHLENBQUN6SSxTQUFKLENBQWM2TyxlQUFkLElBQWlDLElBQWpDO0FBSUEzRyxhQUFXLENBQUM0RyxRQUFELEVBQVcvRixVQUFYLENBQVg7O0FBQ0UsV0FBUytGLFFBQVQsQ0FBa0IzUSxLQUFsQixFQUF5QjtBQUN2QixTQUFLNFEsTUFBTCxHQUFjNVEsS0FBZDtBQUNBLFNBQUs5SCxJQUFMLEdBQVk4SCxLQUFLLENBQUNsRSxNQUFsQjtBQUNEOztBQUVENlUsVUFBUSxDQUFDOU8sU0FBVCxDQUFtQmdQLEdBQW5CLEdBQXlCLFVBQVM3TSxLQUFULEVBQWdCOE0sV0FBaEIsRUFBNkI7QUFDcEQsV0FBTyxLQUFLQyxHQUFMLENBQVMvTSxLQUFULElBQWtCLEtBQUs0TSxNQUFMLENBQVkzRCxTQUFTLENBQUMsSUFBRCxFQUFPakosS0FBUCxDQUFyQixDQUFsQixHQUF3RDhNLFdBQS9EO0FBQ0QsR0FGRDs7QUFJQUgsVUFBUSxDQUFDOU8sU0FBVCxDQUFtQmtMLFNBQW5CLEdBQStCLFVBQVMrQyxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFDbkQsUUFBSS9QLEtBQUssR0FBRyxLQUFLNFEsTUFBakI7QUFDQSxRQUFJSSxRQUFRLEdBQUdoUixLQUFLLENBQUNsRSxNQUFOLEdBQWUsQ0FBOUI7O0FBQ0EsU0FBSyxJQUFJOFEsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsSUFBSW9FLFFBQXZCLEVBQWlDcEUsRUFBRSxFQUFuQyxFQUF1QztBQUNyQyxVQUFJa0QsRUFBRSxDQUFDOVAsS0FBSyxDQUFDK1AsT0FBTyxHQUFHaUIsUUFBUSxHQUFHcEUsRUFBZCxHQUFtQkEsRUFBM0IsQ0FBTixFQUFzQ0EsRUFBdEMsRUFBMEMsSUFBMUMsQ0FBRixLQUFzRCxLQUExRCxFQUFpRTtBQUMvRCxlQUFPQSxFQUFFLEdBQUcsQ0FBWjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT0EsRUFBUDtBQUNELEdBVEQ7O0FBV0ErRCxVQUFRLENBQUM5TyxTQUFULENBQW1Cb08sVUFBbkIsR0FBZ0MsVUFBU2haLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFDdEQsUUFBSS9QLEtBQUssR0FBRyxLQUFLNFEsTUFBakI7QUFDQSxRQUFJSSxRQUFRLEdBQUdoUixLQUFLLENBQUNsRSxNQUFOLEdBQWUsQ0FBOUI7QUFDQSxRQUFJOFEsRUFBRSxHQUFHLENBQVQ7QUFDQSxXQUFPLElBQUlzQixRQUFKLENBQWEsWUFDbEI7QUFBQyxhQUFPdEIsRUFBRSxHQUFHb0UsUUFBTCxHQUNObEMsWUFBWSxFQUROLEdBRU5MLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTzJWLEVBQVAsRUFBVzVNLEtBQUssQ0FBQytQLE9BQU8sR0FBR2lCLFFBQVEsR0FBR3BFLEVBQUUsRUFBaEIsR0FBcUJBLEVBQUUsRUFBL0IsQ0FBaEIsQ0FGZDtBQUVrRSxLQUg5RCxDQUFQO0FBS0QsR0FURDs7QUFhRjdDLGFBQVcsQ0FBQ2tILFNBQUQsRUFBWXhHLFFBQVosQ0FBWDs7QUFDRSxXQUFTd0csU0FBVCxDQUFtQnJSLE1BQW5CLEVBQTJCO0FBQ3pCLFFBQUlvRCxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBUCxDQUFZcEQsTUFBWixDQUFYO0FBQ0EsU0FBS3NSLE9BQUwsR0FBZXRSLE1BQWY7QUFDQSxTQUFLdVIsS0FBTCxHQUFhbk8sSUFBYjtBQUNBLFNBQUs5SyxJQUFMLEdBQVk4SyxJQUFJLENBQUNsSCxNQUFqQjtBQUNEOztBQUVEbVYsV0FBUyxDQUFDcFAsU0FBVixDQUFvQmdQLEdBQXBCLEdBQTBCLFVBQVN6TSxHQUFULEVBQWMwTSxXQUFkLEVBQTJCO0FBQ25ELFFBQUlBLFdBQVcsS0FBS2pWLFNBQWhCLElBQTZCLENBQUMsS0FBS2tWLEdBQUwsQ0FBUzNNLEdBQVQsQ0FBbEMsRUFBaUQ7QUFDL0MsYUFBTzBNLFdBQVA7QUFDRDs7QUFDRCxXQUFPLEtBQUtJLE9BQUwsQ0FBYTlNLEdBQWIsQ0FBUDtBQUNELEdBTEQ7O0FBT0E2TSxXQUFTLENBQUNwUCxTQUFWLENBQW9Ca1AsR0FBcEIsR0FBMEIsVUFBUzNNLEdBQVQsRUFBYztBQUN0QyxXQUFPLEtBQUs4TSxPQUFMLENBQWFwTyxjQUFiLENBQTRCc0IsR0FBNUIsQ0FBUDtBQUNELEdBRkQ7O0FBSUE2TSxXQUFTLENBQUNwUCxTQUFWLENBQW9Ca0wsU0FBcEIsR0FBZ0MsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUNwRCxRQUFJblEsTUFBTSxHQUFHLEtBQUtzUixPQUFsQjtBQUNBLFFBQUlsTyxJQUFJLEdBQUcsS0FBS21PLEtBQWhCO0FBQ0EsUUFBSUgsUUFBUSxHQUFHaE8sSUFBSSxDQUFDbEgsTUFBTCxHQUFjLENBQTdCOztBQUNBLFNBQUssSUFBSThRLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLElBQUlvRSxRQUF2QixFQUFpQ3BFLEVBQUUsRUFBbkMsRUFBdUM7QUFDckMsVUFBSXhJLEdBQUcsR0FBR3BCLElBQUksQ0FBQytNLE9BQU8sR0FBR2lCLFFBQVEsR0FBR3BFLEVBQWQsR0FBbUJBLEVBQTNCLENBQWQ7O0FBQ0EsVUFBSWtELEVBQUUsQ0FBQ2xRLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBUCxFQUFjQSxHQUFkLEVBQW1CLElBQW5CLENBQUYsS0FBK0IsS0FBbkMsRUFBMEM7QUFDeEMsZUFBT3dJLEVBQUUsR0FBRyxDQUFaO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPQSxFQUFQO0FBQ0QsR0FYRDs7QUFhQXFFLFdBQVMsQ0FBQ3BQLFNBQVYsQ0FBb0JvTyxVQUFwQixHQUFpQyxVQUFTaFosSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUN2RCxRQUFJblEsTUFBTSxHQUFHLEtBQUtzUixPQUFsQjtBQUNBLFFBQUlsTyxJQUFJLEdBQUcsS0FBS21PLEtBQWhCO0FBQ0EsUUFBSUgsUUFBUSxHQUFHaE8sSUFBSSxDQUFDbEgsTUFBTCxHQUFjLENBQTdCO0FBQ0EsUUFBSThRLEVBQUUsR0FBRyxDQUFUO0FBQ0EsV0FBTyxJQUFJc0IsUUFBSixDQUFhLFlBQVk7QUFDOUIsVUFBSTlKLEdBQUcsR0FBR3BCLElBQUksQ0FBQytNLE9BQU8sR0FBR2lCLFFBQVEsR0FBR3BFLEVBQWQsR0FBbUJBLEVBQTNCLENBQWQ7QUFDQSxhQUFPQSxFQUFFLEtBQUtvRSxRQUFQLEdBQ0xsQyxZQUFZLEVBRFAsR0FFTEwsYUFBYSxDQUFDeFgsSUFBRCxFQUFPbU4sR0FBUCxFQUFZeEUsTUFBTSxDQUFDd0UsR0FBRCxDQUFsQixDQUZmO0FBR0QsS0FMTSxDQUFQO0FBTUQsR0FYRDs7QUFhRjZNLFdBQVMsQ0FBQ3BQLFNBQVYsQ0FBb0I0SixtQkFBcEIsSUFBMkMsSUFBM0M7QUFHQTFCLGFBQVcsQ0FBQ3FILFdBQUQsRUFBY3hHLFVBQWQsQ0FBWDs7QUFDRSxXQUFTd0csV0FBVCxDQUFxQmxSLFFBQXJCLEVBQStCO0FBQzdCLFNBQUttUixTQUFMLEdBQWlCblIsUUFBakI7QUFDQSxTQUFLaEksSUFBTCxHQUFZZ0ksUUFBUSxDQUFDcEUsTUFBVCxJQUFtQm9FLFFBQVEsQ0FBQ2hJLElBQXhDO0FBQ0Q7O0FBRURrWixhQUFXLENBQUN2UCxTQUFaLENBQXNCK04saUJBQXRCLEdBQTBDLFVBQVNFLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUM5RCxRQUFJQSxPQUFKLEVBQWE7QUFDWCxhQUFPLEtBQUtMLFdBQUwsR0FBbUIzQyxTQUFuQixDQUE2QitDLEVBQTdCLEVBQWlDQyxPQUFqQyxDQUFQO0FBQ0Q7O0FBQ0QsUUFBSTdQLFFBQVEsR0FBRyxLQUFLbVIsU0FBcEI7QUFDQSxRQUFJaE8sUUFBUSxHQUFHOEwsV0FBVyxDQUFDalAsUUFBRCxDQUExQjtBQUNBLFFBQUlwRixVQUFVLEdBQUcsQ0FBakI7O0FBQ0EsUUFBSW1VLFVBQVUsQ0FBQzVMLFFBQUQsQ0FBZCxFQUEwQjtBQUN4QixVQUFJaU8sSUFBSjs7QUFDQSxhQUFPLENBQUMsQ0FBQ0EsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFSLEVBQXlCVSxJQUFqQyxFQUF1QztBQUNyQyxZQUFJaUIsRUFBRSxDQUFDd0IsSUFBSSxDQUFDdFUsS0FBTixFQUFhbEMsVUFBVSxFQUF2QixFQUEyQixJQUEzQixDQUFGLEtBQXVDLEtBQTNDLEVBQWtEO0FBQ2hEO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFdBQU9BLFVBQVA7QUFDRCxHQWhCRDs7QUFrQkFzVyxhQUFXLENBQUN2UCxTQUFaLENBQXNCMFAsa0JBQXRCLEdBQTJDLFVBQVN0YSxJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ2pFLFFBQUlBLE9BQUosRUFBYTtBQUNYLGFBQU8sS0FBS0wsV0FBTCxHQUFtQk8sVUFBbkIsQ0FBOEJoWixJQUE5QixFQUFvQzhZLE9BQXBDLENBQVA7QUFDRDs7QUFDRCxRQUFJN1AsUUFBUSxHQUFHLEtBQUttUixTQUFwQjtBQUNBLFFBQUloTyxRQUFRLEdBQUc4TCxXQUFXLENBQUNqUCxRQUFELENBQTFCOztBQUNBLFFBQUksQ0FBQytPLFVBQVUsQ0FBQzVMLFFBQUQsQ0FBZixFQUEyQjtBQUN6QixhQUFPLElBQUk2SyxRQUFKLENBQWFZLFlBQWIsQ0FBUDtBQUNEOztBQUNELFFBQUloVSxVQUFVLEdBQUcsQ0FBakI7QUFDQSxXQUFPLElBQUlvVCxRQUFKLENBQWEsWUFBWTtBQUM5QixVQUFJb0QsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYO0FBQ0EsYUFBT21ELElBQUksQ0FBQ3pDLElBQUwsR0FBWXlDLElBQVosR0FBbUI3QyxhQUFhLENBQUN4WCxJQUFELEVBQU82RCxVQUFVLEVBQWpCLEVBQXFCd1csSUFBSSxDQUFDdFUsS0FBMUIsQ0FBdkM7QUFDRCxLQUhNLENBQVA7QUFJRCxHQWREOztBQWtCRitNLGFBQVcsQ0FBQ3lILFdBQUQsRUFBYzVHLFVBQWQsQ0FBWDs7QUFDRSxXQUFTNEcsV0FBVCxDQUFxQm5PLFFBQXJCLEVBQStCO0FBQzdCLFNBQUtvTyxTQUFMLEdBQWlCcE8sUUFBakI7QUFDQSxTQUFLcU8sY0FBTCxHQUFzQixFQUF0QjtBQUNEOztBQUVERixhQUFXLENBQUMzUCxTQUFaLENBQXNCK04saUJBQXRCLEdBQTBDLFVBQVNFLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUM5RCxRQUFJQSxPQUFKLEVBQWE7QUFDWCxhQUFPLEtBQUtMLFdBQUwsR0FBbUIzQyxTQUFuQixDQUE2QitDLEVBQTdCLEVBQWlDQyxPQUFqQyxDQUFQO0FBQ0Q7O0FBQ0QsUUFBSTFNLFFBQVEsR0FBRyxLQUFLb08sU0FBcEI7QUFDQSxRQUFJRSxLQUFLLEdBQUcsS0FBS0QsY0FBakI7QUFDQSxRQUFJNVcsVUFBVSxHQUFHLENBQWpCOztBQUNBLFdBQU9BLFVBQVUsR0FBRzZXLEtBQUssQ0FBQzdWLE1BQTFCLEVBQWtDO0FBQ2hDLFVBQUlnVSxFQUFFLENBQUM2QixLQUFLLENBQUM3VyxVQUFELENBQU4sRUFBb0JBLFVBQVUsRUFBOUIsRUFBa0MsSUFBbEMsQ0FBRixLQUE4QyxLQUFsRCxFQUF5RDtBQUN2RCxlQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJd1csSUFBSjs7QUFDQSxXQUFPLENBQUMsQ0FBQ0EsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFSLEVBQXlCVSxJQUFqQyxFQUF1QztBQUNyQyxVQUFJK0MsR0FBRyxHQUFHTixJQUFJLENBQUN0VSxLQUFmO0FBQ0EyVSxXQUFLLENBQUM3VyxVQUFELENBQUwsR0FBb0I4VyxHQUFwQjs7QUFDQSxVQUFJOUIsRUFBRSxDQUFDOEIsR0FBRCxFQUFNOVcsVUFBVSxFQUFoQixFQUFvQixJQUFwQixDQUFGLEtBQWdDLEtBQXBDLEVBQTJDO0FBQ3pDO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPQSxVQUFQO0FBQ0QsR0FyQkQ7O0FBdUJBMFcsYUFBVyxDQUFDM1AsU0FBWixDQUFzQjBQLGtCQUF0QixHQUEyQyxVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUNqRSxRQUFJQSxPQUFKLEVBQWE7QUFDWCxhQUFPLEtBQUtMLFdBQUwsR0FBbUJPLFVBQW5CLENBQThCaFosSUFBOUIsRUFBb0M4WSxPQUFwQyxDQUFQO0FBQ0Q7O0FBQ0QsUUFBSTFNLFFBQVEsR0FBRyxLQUFLb08sU0FBcEI7QUFDQSxRQUFJRSxLQUFLLEdBQUcsS0FBS0QsY0FBakI7QUFDQSxRQUFJNVcsVUFBVSxHQUFHLENBQWpCO0FBQ0EsV0FBTyxJQUFJb1QsUUFBSixDQUFhLFlBQVk7QUFDOUIsVUFBSXBULFVBQVUsSUFBSTZXLEtBQUssQ0FBQzdWLE1BQXhCLEVBQWdDO0FBQzlCLFlBQUl3VixJQUFJLEdBQUdqTyxRQUFRLENBQUM4SyxJQUFULEVBQVg7O0FBQ0EsWUFBSW1ELElBQUksQ0FBQ3pDLElBQVQsRUFBZTtBQUNiLGlCQUFPeUMsSUFBUDtBQUNEOztBQUNESyxhQUFLLENBQUM3VyxVQUFELENBQUwsR0FBb0J3VyxJQUFJLENBQUN0VSxLQUF6QjtBQUNEOztBQUNELGFBQU95UixhQUFhLENBQUN4WCxJQUFELEVBQU82RCxVQUFQLEVBQW1CNlcsS0FBSyxDQUFDN1csVUFBVSxFQUFYLENBQXhCLENBQXBCO0FBQ0QsS0FUTSxDQUFQO0FBVUQsR0FqQkQsQ0FwZmdCLENBMGdCbEI7OztBQUVBLFdBQVMyVixLQUFULENBQWVvQixRQUFmLEVBQXlCO0FBQ3ZCLFdBQU8sQ0FBQyxFQUFFQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ25CLGVBQUQsQ0FBdEIsQ0FBUjtBQUNEOztBQUVELE1BQUlvQixTQUFKOztBQUVBLFdBQVN4QyxhQUFULEdBQXlCO0FBQ3ZCLFdBQU93QyxTQUFTLEtBQUtBLFNBQVMsR0FBRyxJQUFJbkIsUUFBSixDQUFhLEVBQWIsQ0FBakIsQ0FBaEI7QUFDRDs7QUFFRCxXQUFTTixpQkFBVCxDQUEyQnJULEtBQTNCLEVBQWtDO0FBQ2hDLFFBQUkrVSxHQUFHLEdBQ0xyWSxLQUFLLENBQUN5SixPQUFOLENBQWNuRyxLQUFkLElBQXVCLElBQUkyVCxRQUFKLENBQWEzVCxLQUFiLEVBQW9Cb1QsWUFBcEIsRUFBdkIsR0FDQW5CLFVBQVUsQ0FBQ2pTLEtBQUQsQ0FBVixHQUFvQixJQUFJd1UsV0FBSixDQUFnQnhVLEtBQWhCLEVBQXVCb1QsWUFBdkIsRUFBcEIsR0FDQXJCLFdBQVcsQ0FBQy9SLEtBQUQsQ0FBWCxHQUFxQixJQUFJb1UsV0FBSixDQUFnQnBVLEtBQWhCLEVBQXVCb1QsWUFBdkIsRUFBckIsR0FDQSxPQUFPcFQsS0FBUCxLQUFpQixRQUFqQixHQUE0QixJQUFJaVUsU0FBSixDQUFjalUsS0FBZCxDQUE1QixHQUNBbkIsU0FMRjs7QUFNQSxRQUFJLENBQUNrVyxHQUFMLEVBQVU7QUFDUixZQUFNLElBQUlDLFNBQUosQ0FDSiwwREFDQSxtQkFEQSxHQUNzQmhWLEtBRmxCLENBQU47QUFJRDs7QUFDRCxXQUFPK1UsR0FBUDtBQUNEOztBQUVELFdBQVN6QixtQkFBVCxDQUE2QnRULEtBQTdCLEVBQW9DO0FBQ2xDLFFBQUkrVSxHQUFHLEdBQUdFLHdCQUF3QixDQUFDalYsS0FBRCxDQUFsQzs7QUFDQSxRQUFJLENBQUMrVSxHQUFMLEVBQVU7QUFDUixZQUFNLElBQUlDLFNBQUosQ0FDSixrREFBa0RoVixLQUQ5QyxDQUFOO0FBR0Q7O0FBQ0QsV0FBTytVLEdBQVA7QUFDRDs7QUFFRCxXQUFTdkMsWUFBVCxDQUFzQnhTLEtBQXRCLEVBQTZCO0FBQzNCLFFBQUkrVSxHQUFHLEdBQUdFLHdCQUF3QixDQUFDalYsS0FBRCxDQUF4QixJQUNQLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsSUFBSWlVLFNBQUosQ0FBY2pVLEtBQWQsQ0FEaEM7O0FBRUEsUUFBSSxDQUFDK1UsR0FBTCxFQUFVO0FBQ1IsWUFBTSxJQUFJQyxTQUFKLENBQ0osbUVBQW1FaFYsS0FEL0QsQ0FBTjtBQUdEOztBQUNELFdBQU8rVSxHQUFQO0FBQ0Q7O0FBRUQsV0FBU0Usd0JBQVQsQ0FBa0NqVixLQUFsQyxFQUF5QztBQUN2QyxXQUNFcVMsV0FBVyxDQUFDclMsS0FBRCxDQUFYLEdBQXFCLElBQUkyVCxRQUFKLENBQWEzVCxLQUFiLENBQXJCLEdBQ0FpUyxVQUFVLENBQUNqUyxLQUFELENBQVYsR0FBb0IsSUFBSXdVLFdBQUosQ0FBZ0J4VSxLQUFoQixDQUFwQixHQUNBK1IsV0FBVyxDQUFDL1IsS0FBRCxDQUFYLEdBQXFCLElBQUlvVSxXQUFKLENBQWdCcFUsS0FBaEIsQ0FBckIsR0FDQW5CLFNBSkY7QUFNRDs7QUFFRCxXQUFTbVUsVUFBVCxDQUFvQitCLEdBQXBCLEVBQXlCakMsRUFBekIsRUFBNkJDLE9BQTdCLEVBQXNDbUMsT0FBdEMsRUFBK0M7QUFDN0MsUUFBSVAsS0FBSyxHQUFHSSxHQUFHLENBQUNwQyxNQUFoQjs7QUFDQSxRQUFJZ0MsS0FBSixFQUFXO0FBQ1QsVUFBSVgsUUFBUSxHQUFHVyxLQUFLLENBQUM3VixNQUFOLEdBQWUsQ0FBOUI7O0FBQ0EsV0FBSyxJQUFJOFEsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsSUFBSW9FLFFBQXZCLEVBQWlDcEUsRUFBRSxFQUFuQyxFQUF1QztBQUNyQyxZQUFJdUYsS0FBSyxHQUFHUixLQUFLLENBQUM1QixPQUFPLEdBQUdpQixRQUFRLEdBQUdwRSxFQUFkLEdBQW1CQSxFQUEzQixDQUFqQjs7QUFDQSxZQUFJa0QsRUFBRSxDQUFDcUMsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXRCxPQUFPLEdBQUdDLEtBQUssQ0FBQyxDQUFELENBQVIsR0FBY3ZGLEVBQWhDLEVBQW9DbUYsR0FBcEMsQ0FBRixLQUErQyxLQUFuRCxFQUEwRDtBQUN4RCxpQkFBT25GLEVBQUUsR0FBRyxDQUFaO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPQSxFQUFQO0FBQ0Q7O0FBQ0QsV0FBT21GLEdBQUcsQ0FBQ25DLGlCQUFKLENBQXNCRSxFQUF0QixFQUEwQkMsT0FBMUIsQ0FBUDtBQUNEOztBQUVELFdBQVNHLFdBQVQsQ0FBcUI2QixHQUFyQixFQUEwQjlhLElBQTFCLEVBQWdDOFksT0FBaEMsRUFBeUNtQyxPQUF6QyxFQUFrRDtBQUNoRCxRQUFJUCxLQUFLLEdBQUdJLEdBQUcsQ0FBQ3BDLE1BQWhCOztBQUNBLFFBQUlnQyxLQUFKLEVBQVc7QUFDVCxVQUFJWCxRQUFRLEdBQUdXLEtBQUssQ0FBQzdWLE1BQU4sR0FBZSxDQUE5QjtBQUNBLFVBQUk4USxFQUFFLEdBQUcsQ0FBVDtBQUNBLGFBQU8sSUFBSXNCLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFlBQUlpRSxLQUFLLEdBQUdSLEtBQUssQ0FBQzVCLE9BQU8sR0FBR2lCLFFBQVEsR0FBR3BFLEVBQWQsR0FBbUJBLEVBQTNCLENBQWpCO0FBQ0EsZUFBT0EsRUFBRSxLQUFLb0UsUUFBUCxHQUNMbEMsWUFBWSxFQURQLEdBRUxMLGFBQWEsQ0FBQ3hYLElBQUQsRUFBT2liLE9BQU8sR0FBR0MsS0FBSyxDQUFDLENBQUQsQ0FBUixHQUFjdkYsRUFBRSxHQUFHLENBQWpDLEVBQW9DdUYsS0FBSyxDQUFDLENBQUQsQ0FBekMsQ0FGZjtBQUdELE9BTE0sQ0FBUDtBQU1EOztBQUNELFdBQU9KLEdBQUcsQ0FBQ1Isa0JBQUosQ0FBdUJ0YSxJQUF2QixFQUE2QjhZLE9BQTdCLENBQVA7QUFDRDs7QUFFRCxXQUFTcFIsTUFBVCxDQUFnQnlULElBQWhCLEVBQXNCQyxTQUF0QixFQUFpQztBQUMvQixXQUFPQSxTQUFTLEdBQ2RDLFVBQVUsQ0FBQ0QsU0FBRCxFQUFZRCxJQUFaLEVBQWtCLEVBQWxCLEVBQXNCO0FBQUMsVUFBSUE7QUFBTCxLQUF0QixDQURJLEdBRWRHLGFBQWEsQ0FBQ0gsSUFBRCxDQUZmO0FBR0Q7O0FBRUQsV0FBU0UsVUFBVCxDQUFvQkQsU0FBcEIsRUFBK0JELElBQS9CLEVBQXFDaE8sR0FBckMsRUFBMENvTyxVQUExQyxFQUFzRDtBQUNwRCxRQUFJOVksS0FBSyxDQUFDeUosT0FBTixDQUFjaVAsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCLGFBQU9DLFNBQVMsQ0FBQ25QLElBQVYsQ0FBZXNQLFVBQWYsRUFBMkJwTyxHQUEzQixFQUFnQ3dHLFVBQVUsQ0FBQ3dILElBQUQsQ0FBVixDQUFpQjlWLEdBQWpCLENBQXFCLFVBQVNxUyxDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBQyxlQUFPNEQsVUFBVSxDQUFDRCxTQUFELEVBQVkxRCxDQUFaLEVBQWVELENBQWYsRUFBa0IwRCxJQUFsQixDQUFqQjtBQUF5QyxPQUEvRSxDQUFoQyxDQUFQO0FBQ0Q7O0FBQ0QsUUFBSUssVUFBVSxDQUFDTCxJQUFELENBQWQsRUFBc0I7QUFDcEIsYUFBT0MsU0FBUyxDQUFDblAsSUFBVixDQUFlc1AsVUFBZixFQUEyQnBPLEdBQTNCLEVBQWdDcUcsUUFBUSxDQUFDMkgsSUFBRCxDQUFSLENBQWU5VixHQUFmLENBQW1CLFVBQVNxUyxDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBQyxlQUFPNEQsVUFBVSxDQUFDRCxTQUFELEVBQVkxRCxDQUFaLEVBQWVELENBQWYsRUFBa0IwRCxJQUFsQixDQUFqQjtBQUF5QyxPQUE3RSxDQUFoQyxDQUFQO0FBQ0Q7O0FBQ0QsV0FBT0EsSUFBUDtBQUNEOztBQUVELFdBQVNHLGFBQVQsQ0FBdUJILElBQXZCLEVBQTZCO0FBQzNCLFFBQUkxWSxLQUFLLENBQUN5SixPQUFOLENBQWNpUCxJQUFkLENBQUosRUFBeUI7QUFDdkIsYUFBT3hILFVBQVUsQ0FBQ3dILElBQUQsQ0FBVixDQUFpQjlWLEdBQWpCLENBQXFCaVcsYUFBckIsRUFBb0NHLE1BQXBDLEVBQVA7QUFDRDs7QUFDRCxRQUFJRCxVQUFVLENBQUNMLElBQUQsQ0FBZCxFQUFzQjtBQUNwQixhQUFPM0gsUUFBUSxDQUFDMkgsSUFBRCxDQUFSLENBQWU5VixHQUFmLENBQW1CaVcsYUFBbkIsRUFBa0NJLEtBQWxDLEVBQVA7QUFDRDs7QUFDRCxXQUFPUCxJQUFQO0FBQ0Q7O0FBRUQsV0FBU0ssVUFBVCxDQUFvQnpWLEtBQXBCLEVBQTJCO0FBQ3pCLFdBQU9BLEtBQUssS0FBS0EsS0FBSyxDQUFDbU4sV0FBTixLQUFzQnBILE1BQXRCLElBQWdDL0YsS0FBSyxDQUFDbU4sV0FBTixLQUFzQnRPLFNBQTNELENBQVo7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsV0FBUytXLEVBQVQsQ0FBWUMsTUFBWixFQUFvQkMsTUFBcEIsRUFBNEI7QUFDMUIsUUFBSUQsTUFBTSxLQUFLQyxNQUFYLElBQXNCRCxNQUFNLEtBQUtBLE1BQVgsSUFBcUJDLE1BQU0sS0FBS0EsTUFBMUQsRUFBbUU7QUFDakUsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDRCxNQUFELElBQVcsQ0FBQ0MsTUFBaEIsRUFBd0I7QUFDdEIsYUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsUUFBSSxPQUFPRCxNQUFNLENBQUNFLE9BQWQsS0FBMEIsVUFBMUIsSUFDQSxPQUFPRCxNQUFNLENBQUNDLE9BQWQsS0FBMEIsVUFEOUIsRUFDMEM7QUFDeENGLFlBQU0sR0FBR0EsTUFBTSxDQUFDRSxPQUFQLEVBQVQ7QUFDQUQsWUFBTSxHQUFHQSxNQUFNLENBQUNDLE9BQVAsRUFBVDs7QUFDQSxVQUFJRixNQUFNLEtBQUtDLE1BQVgsSUFBc0JELE1BQU0sS0FBS0EsTUFBWCxJQUFxQkMsTUFBTSxLQUFLQSxNQUExRCxFQUFtRTtBQUNqRSxlQUFPLElBQVA7QUFDRDs7QUFDRCxVQUFJLENBQUNELE1BQUQsSUFBVyxDQUFDQyxNQUFoQixFQUF3QjtBQUN0QixlQUFPLEtBQVA7QUFDRDtBQUNGOztBQUNELFFBQUksT0FBT0QsTUFBTSxDQUFDRyxNQUFkLEtBQXlCLFVBQXpCLElBQ0EsT0FBT0YsTUFBTSxDQUFDRSxNQUFkLEtBQXlCLFVBRHpCLElBRUFILE1BQU0sQ0FBQ0csTUFBUCxDQUFjRixNQUFkLENBRkosRUFFMkI7QUFDekIsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBU0csU0FBVCxDQUFtQnRQLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QixRQUFJRCxDQUFDLEtBQUtDLENBQVYsRUFBYTtBQUNYLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQ0UsQ0FBQ3lHLFVBQVUsQ0FBQ3pHLENBQUQsQ0FBWCxJQUNBRCxDQUFDLENBQUN6TCxJQUFGLEtBQVcyRCxTQUFYLElBQXdCK0gsQ0FBQyxDQUFDMUwsSUFBRixLQUFXMkQsU0FBbkMsSUFBZ0Q4SCxDQUFDLENBQUN6TCxJQUFGLEtBQVcwTCxDQUFDLENBQUMxTCxJQUQ3RCxJQUVBeUwsQ0FBQyxDQUFDdVAsTUFBRixLQUFhclgsU0FBYixJQUEwQitILENBQUMsQ0FBQ3NQLE1BQUYsS0FBYXJYLFNBQXZDLElBQW9EOEgsQ0FBQyxDQUFDdVAsTUFBRixLQUFhdFAsQ0FBQyxDQUFDc1AsTUFGbkUsSUFHQTFJLE9BQU8sQ0FBQzdHLENBQUQsQ0FBUCxLQUFlNkcsT0FBTyxDQUFDNUcsQ0FBRCxDQUh0QixJQUlBK0csU0FBUyxDQUFDaEgsQ0FBRCxDQUFULEtBQWlCZ0gsU0FBUyxDQUFDL0csQ0FBRCxDQUoxQixJQUtBMkgsU0FBUyxDQUFDNUgsQ0FBRCxDQUFULEtBQWlCNEgsU0FBUyxDQUFDM0gsQ0FBRCxDQU41QixFQU9FO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsUUFBSUQsQ0FBQyxDQUFDekwsSUFBRixLQUFXLENBQVgsSUFBZ0IwTCxDQUFDLENBQUMxTCxJQUFGLEtBQVcsQ0FBL0IsRUFBa0M7QUFDaEMsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSWliLGNBQWMsR0FBRyxDQUFDckksYUFBYSxDQUFDbkgsQ0FBRCxDQUFuQzs7QUFFQSxRQUFJNEgsU0FBUyxDQUFDNUgsQ0FBRCxDQUFiLEVBQWtCO0FBQ2hCLFVBQUl5UCxPQUFPLEdBQUd6UCxDQUFDLENBQUN5UCxPQUFGLEVBQWQ7QUFDQSxhQUFPeFAsQ0FBQyxDQUFDeVAsS0FBRixDQUFRLFVBQVMxRSxDQUFULEVBQVlELENBQVosRUFBZ0I7QUFDN0IsWUFBSXlELEtBQUssR0FBR2lCLE9BQU8sQ0FBQ2pGLElBQVIsR0FBZW5SLEtBQTNCO0FBQ0EsZUFBT21WLEtBQUssSUFBSVMsRUFBRSxDQUFDVCxLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVd4RCxDQUFYLENBQVgsS0FBNkJ3RSxjQUFjLElBQUlQLEVBQUUsQ0FBQ1QsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXekQsQ0FBWCxDQUFqRCxDQUFQO0FBQ0QsT0FITSxLQUdEMEUsT0FBTyxDQUFDakYsSUFBUixHQUFlVSxJQUhyQjtBQUlEOztBQUVELFFBQUl5RSxPQUFPLEdBQUcsS0FBZDs7QUFFQSxRQUFJM1AsQ0FBQyxDQUFDekwsSUFBRixLQUFXMkQsU0FBZixFQUEwQjtBQUN4QixVQUFJK0gsQ0FBQyxDQUFDMUwsSUFBRixLQUFXMkQsU0FBZixFQUEwQjtBQUN4QixZQUFJLE9BQU84SCxDQUFDLENBQUMrTCxXQUFULEtBQXlCLFVBQTdCLEVBQXlDO0FBQ3ZDL0wsV0FBQyxDQUFDK0wsV0FBRjtBQUNEO0FBQ0YsT0FKRCxNQUlPO0FBQ0w0RCxlQUFPLEdBQUcsSUFBVjtBQUNBLFlBQUk3WixDQUFDLEdBQUdrSyxDQUFSO0FBQ0FBLFNBQUMsR0FBR0MsQ0FBSjtBQUNBQSxTQUFDLEdBQUduSyxDQUFKO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJOFosUUFBUSxHQUFHLElBQWY7O0FBQ0EsUUFBSUMsS0FBSyxHQUFHNVAsQ0FBQyxDQUFDbUosU0FBRixDQUFZLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFDdEMsVUFBSXlFLGNBQWMsR0FBRyxDQUFDeFAsQ0FBQyxDQUFDb04sR0FBRixDQUFNcEMsQ0FBTixDQUFKLEdBQ2QyRSxPQUFPLEdBQUcsQ0FBQ1YsRUFBRSxDQUFDakUsQ0FBRCxFQUFJaEwsQ0FBQyxDQUFDa04sR0FBRixDQUFNbkMsQ0FBTixFQUFTMUMsT0FBVCxDQUFKLENBQU4sR0FBK0IsQ0FBQzRHLEVBQUUsQ0FBQ2pQLENBQUMsQ0FBQ2tOLEdBQUYsQ0FBTW5DLENBQU4sRUFBUzFDLE9BQVQsQ0FBRCxFQUFvQjJDLENBQXBCLENBRDdDLEVBQ3FFO0FBQ25FNEUsZ0JBQVEsR0FBRyxLQUFYO0FBQ0EsZUFBTyxLQUFQO0FBQ0Q7QUFDRixLQU5XLENBQVo7O0FBUUEsV0FBT0EsUUFBUSxJQUFJNVAsQ0FBQyxDQUFDekwsSUFBRixLQUFXc2IsS0FBOUI7QUFDRDs7QUFFRHpKLGFBQVcsQ0FBQzBKLE1BQUQsRUFBUzdJLFVBQVQsQ0FBWDs7QUFFRSxXQUFTNkksTUFBVCxDQUFnQnpXLEtBQWhCLEVBQXVCMFcsS0FBdkIsRUFBOEI7QUFDNUIsUUFBSSxFQUFFLGdCQUFnQkQsTUFBbEIsQ0FBSixFQUErQjtBQUM3QixhQUFPLElBQUlBLE1BQUosQ0FBV3pXLEtBQVgsRUFBa0IwVyxLQUFsQixDQUFQO0FBQ0Q7O0FBQ0QsU0FBS0MsTUFBTCxHQUFjM1csS0FBZDtBQUNBLFNBQUs5RSxJQUFMLEdBQVl3YixLQUFLLEtBQUs3WCxTQUFWLEdBQXNCK1gsUUFBdEIsR0FBaUMvWixJQUFJLENBQUM2UyxHQUFMLENBQVMsQ0FBVCxFQUFZZ0gsS0FBWixDQUE3Qzs7QUFDQSxRQUFJLEtBQUt4YixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsVUFBSTJiLFlBQUosRUFBa0I7QUFDaEIsZUFBT0EsWUFBUDtBQUNEOztBQUNEQSxrQkFBWSxHQUFHLElBQWY7QUFDRDtBQUNGOztBQUVESixRQUFNLENBQUM1UixTQUFQLENBQWlCb0IsUUFBakIsR0FBNEIsWUFBVztBQUNyQyxRQUFJLEtBQUsvSyxJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsYUFBTyxXQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxjQUFjLEtBQUt5YixNQUFuQixHQUE0QixHQUE1QixHQUFrQyxLQUFLemIsSUFBdkMsR0FBOEMsVUFBckQ7QUFDRCxHQUxEOztBQU9BdWIsUUFBTSxDQUFDNVIsU0FBUCxDQUFpQmdQLEdBQWpCLEdBQXVCLFVBQVM3TSxLQUFULEVBQWdCOE0sV0FBaEIsRUFBNkI7QUFDbEQsV0FBTyxLQUFLQyxHQUFMLENBQVMvTSxLQUFULElBQWtCLEtBQUsyUCxNQUF2QixHQUFnQzdDLFdBQXZDO0FBQ0QsR0FGRDs7QUFJQTJDLFFBQU0sQ0FBQzVSLFNBQVAsQ0FBaUJpUyxRQUFqQixHQUE0QixVQUFTQyxXQUFULEVBQXNCO0FBQ2hELFdBQU9uQixFQUFFLENBQUMsS0FBS2UsTUFBTixFQUFjSSxXQUFkLENBQVQ7QUFDRCxHQUZEOztBQUlBTixRQUFNLENBQUM1UixTQUFQLENBQWlCckMsS0FBakIsR0FBeUIsVUFBUzZOLEtBQVQsRUFBZ0JDLEdBQWhCLEVBQXFCO0FBQzVDLFFBQUlwVixJQUFJLEdBQUcsS0FBS0EsSUFBaEI7QUFDQSxXQUFPa1YsVUFBVSxDQUFDQyxLQUFELEVBQVFDLEdBQVIsRUFBYXBWLElBQWIsQ0FBVixHQUErQixJQUEvQixHQUNMLElBQUl1YixNQUFKLENBQVcsS0FBS0UsTUFBaEIsRUFBd0JsRyxVQUFVLENBQUNILEdBQUQsRUFBTXBWLElBQU4sQ0FBVixHQUF3QnFWLFlBQVksQ0FBQ0YsS0FBRCxFQUFRblYsSUFBUixDQUE1RCxDQURGO0FBRUQsR0FKRDs7QUFNQXViLFFBQU0sQ0FBQzVSLFNBQVAsQ0FBaUJrTyxPQUFqQixHQUEyQixZQUFXO0FBQ3BDLFdBQU8sSUFBUDtBQUNELEdBRkQ7O0FBSUEwRCxRQUFNLENBQUM1UixTQUFQLENBQWlCNkIsT0FBakIsR0FBMkIsVUFBU3FRLFdBQVQsRUFBc0I7QUFDL0MsUUFBSW5CLEVBQUUsQ0FBQyxLQUFLZSxNQUFOLEVBQWNJLFdBQWQsQ0FBTixFQUFrQztBQUNoQyxhQUFPLENBQVA7QUFDRDs7QUFDRCxXQUFPLENBQUMsQ0FBUjtBQUNELEdBTEQ7O0FBT0FOLFFBQU0sQ0FBQzVSLFNBQVAsQ0FBaUJtUyxXQUFqQixHQUErQixVQUFTRCxXQUFULEVBQXNCO0FBQ25ELFFBQUluQixFQUFFLENBQUMsS0FBS2UsTUFBTixFQUFjSSxXQUFkLENBQU4sRUFBa0M7QUFDaEMsYUFBTyxLQUFLN2IsSUFBWjtBQUNEOztBQUNELFdBQU8sQ0FBQyxDQUFSO0FBQ0QsR0FMRDs7QUFPQXViLFFBQU0sQ0FBQzVSLFNBQVAsQ0FBaUJrTCxTQUFqQixHQUE2QixVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQ2pELFNBQUssSUFBSW5ELEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUcsS0FBSzFVLElBQTNCLEVBQWlDMFUsRUFBRSxFQUFuQyxFQUF1QztBQUNyQyxVQUFJa0QsRUFBRSxDQUFDLEtBQUs2RCxNQUFOLEVBQWMvRyxFQUFkLEVBQWtCLElBQWxCLENBQUYsS0FBOEIsS0FBbEMsRUFBeUM7QUFDdkMsZUFBT0EsRUFBRSxHQUFHLENBQVo7QUFDRDtBQUNGOztBQUNELFdBQU9BLEVBQVA7QUFDRCxHQVBEOztBQVNBNkcsUUFBTSxDQUFDNVIsU0FBUCxDQUFpQm9PLFVBQWpCLEdBQThCLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQUMsUUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ3JELFFBQUlySCxFQUFFLEdBQUcsQ0FBVDtBQUNBLFdBQU8sSUFBSXNCLFFBQUosQ0FBYSxZQUNsQjtBQUFDLGFBQU90QixFQUFFLEdBQUdxSCxNQUFNLENBQUMvYixJQUFaLEdBQW1CdVcsYUFBYSxDQUFDeFgsSUFBRCxFQUFPMlYsRUFBRSxFQUFULEVBQWFxSCxNQUFNLENBQUNOLE1BQXBCLENBQWhDLEdBQThEN0UsWUFBWSxFQUFqRjtBQUFvRixLQURoRixDQUFQO0FBR0QsR0FMRDs7QUFPQTJFLFFBQU0sQ0FBQzVSLFNBQVAsQ0FBaUJtUixNQUFqQixHQUEwQixVQUFTa0IsS0FBVCxFQUFnQjtBQUN4QyxXQUFPQSxLQUFLLFlBQVlULE1BQWpCLEdBQ0xiLEVBQUUsQ0FBQyxLQUFLZSxNQUFOLEVBQWNPLEtBQUssQ0FBQ1AsTUFBcEIsQ0FERyxHQUVMVixTQUFTLENBQUNpQixLQUFELENBRlg7QUFHRCxHQUpEOztBQU9GLE1BQUlMLFlBQUo7O0FBRUEsV0FBU00sU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEJoVSxLQUE5QixFQUFxQztBQUNuQyxRQUFJLENBQUNnVSxTQUFMLEVBQWdCLE1BQU0sSUFBSXJQLEtBQUosQ0FBVTNFLEtBQVYsQ0FBTjtBQUNqQjs7QUFFRDJKLGFBQVcsQ0FBQ3NLLEtBQUQsRUFBUXpKLFVBQVIsQ0FBWDs7QUFFRSxXQUFTeUosS0FBVCxDQUFlQyxLQUFmLEVBQXNCaEgsR0FBdEIsRUFBMkJnRSxJQUEzQixFQUFpQztBQUMvQixRQUFJLEVBQUUsZ0JBQWdCK0MsS0FBbEIsQ0FBSixFQUE4QjtBQUM1QixhQUFPLElBQUlBLEtBQUosQ0FBVUMsS0FBVixFQUFpQmhILEdBQWpCLEVBQXNCZ0UsSUFBdEIsQ0FBUDtBQUNEOztBQUNENkMsYUFBUyxDQUFDN0MsSUFBSSxLQUFLLENBQVYsRUFBYSwwQkFBYixDQUFUO0FBQ0FnRCxTQUFLLEdBQUdBLEtBQUssSUFBSSxDQUFqQjs7QUFDQSxRQUFJaEgsR0FBRyxLQUFLelIsU0FBWixFQUF1QjtBQUNyQnlSLFNBQUcsR0FBR3NHLFFBQU47QUFDRDs7QUFDRHRDLFFBQUksR0FBR0EsSUFBSSxLQUFLelYsU0FBVCxHQUFxQixDQUFyQixHQUF5QmhDLElBQUksQ0FBQzBhLEdBQUwsQ0FBU2pELElBQVQsQ0FBaEM7O0FBQ0EsUUFBSWhFLEdBQUcsR0FBR2dILEtBQVYsRUFBaUI7QUFDZmhELFVBQUksR0FBRyxDQUFDQSxJQUFSO0FBQ0Q7O0FBQ0QsU0FBS2tELE1BQUwsR0FBY0YsS0FBZDtBQUNBLFNBQUtHLElBQUwsR0FBWW5ILEdBQVo7QUFDQSxTQUFLb0gsS0FBTCxHQUFhcEQsSUFBYjtBQUNBLFNBQUtwWixJQUFMLEdBQVkyQixJQUFJLENBQUM2UyxHQUFMLENBQVMsQ0FBVCxFQUFZN1MsSUFBSSxDQUFDOGEsSUFBTCxDQUFVLENBQUNySCxHQUFHLEdBQUdnSCxLQUFQLElBQWdCaEQsSUFBaEIsR0FBdUIsQ0FBakMsSUFBc0MsQ0FBbEQsQ0FBWjs7QUFDQSxRQUFJLEtBQUtwWixJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDbkIsVUFBSTBjLFdBQUosRUFBaUI7QUFDZixlQUFPQSxXQUFQO0FBQ0Q7O0FBQ0RBLGlCQUFXLEdBQUcsSUFBZDtBQUNEO0FBQ0Y7O0FBRURQLE9BQUssQ0FBQ3hTLFNBQU4sQ0FBZ0JvQixRQUFoQixHQUEyQixZQUFXO0FBQ3BDLFFBQUksS0FBSy9LLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPLFVBQVA7QUFDRDs7QUFDRCxXQUFPLGFBQ0wsS0FBS3NjLE1BREEsR0FDUyxLQURULEdBQ2lCLEtBQUtDLElBRHRCLElBRUosS0FBS0MsS0FBTCxLQUFlLENBQWYsR0FBbUIsU0FBUyxLQUFLQSxLQUFqQyxHQUF5QyxFQUZyQyxJQUdQLElBSEE7QUFJRCxHQVJEOztBQVVBTCxPQUFLLENBQUN4UyxTQUFOLENBQWdCZ1AsR0FBaEIsR0FBc0IsVUFBUzdNLEtBQVQsRUFBZ0I4TSxXQUFoQixFQUE2QjtBQUNqRCxXQUFPLEtBQUtDLEdBQUwsQ0FBUy9NLEtBQVQsSUFDTCxLQUFLd1EsTUFBTCxHQUFjdkgsU0FBUyxDQUFDLElBQUQsRUFBT2pKLEtBQVAsQ0FBVCxHQUF5QixLQUFLMFEsS0FEdkMsR0FFTDVELFdBRkY7QUFHRCxHQUpEOztBQU1BdUQsT0FBSyxDQUFDeFMsU0FBTixDQUFnQmlTLFFBQWhCLEdBQTJCLFVBQVNDLFdBQVQsRUFBc0I7QUFDL0MsUUFBSWMsYUFBYSxHQUFHLENBQUNkLFdBQVcsR0FBRyxLQUFLUyxNQUFwQixJQUE4QixLQUFLRSxLQUF2RDtBQUNBLFdBQU9HLGFBQWEsSUFBSSxDQUFqQixJQUNMQSxhQUFhLEdBQUcsS0FBSzNjLElBRGhCLElBRUwyYyxhQUFhLEtBQUtoYixJQUFJLENBQUMwTixLQUFMLENBQVdzTixhQUFYLENBRnBCO0FBR0QsR0FMRDs7QUFPQVIsT0FBSyxDQUFDeFMsU0FBTixDQUFnQnJDLEtBQWhCLEdBQXdCLFVBQVM2TixLQUFULEVBQWdCQyxHQUFoQixFQUFxQjtBQUMzQyxRQUFJRixVQUFVLENBQUNDLEtBQUQsRUFBUUMsR0FBUixFQUFhLEtBQUtwVixJQUFsQixDQUFkLEVBQXVDO0FBQ3JDLGFBQU8sSUFBUDtBQUNEOztBQUNEbVYsU0FBSyxHQUFHRSxZQUFZLENBQUNGLEtBQUQsRUFBUSxLQUFLblYsSUFBYixDQUFwQjtBQUNBb1YsT0FBRyxHQUFHRyxVQUFVLENBQUNILEdBQUQsRUFBTSxLQUFLcFYsSUFBWCxDQUFoQjs7QUFDQSxRQUFJb1YsR0FBRyxJQUFJRCxLQUFYLEVBQWtCO0FBQ2hCLGFBQU8sSUFBSWdILEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFJQSxLQUFKLENBQVUsS0FBS3hELEdBQUwsQ0FBU3hELEtBQVQsRUFBZ0IsS0FBS29ILElBQXJCLENBQVYsRUFBc0MsS0FBSzVELEdBQUwsQ0FBU3ZELEdBQVQsRUFBYyxLQUFLbUgsSUFBbkIsQ0FBdEMsRUFBZ0UsS0FBS0MsS0FBckUsQ0FBUDtBQUNELEdBVkQ7O0FBWUFMLE9BQUssQ0FBQ3hTLFNBQU4sQ0FBZ0I2QixPQUFoQixHQUEwQixVQUFTcVEsV0FBVCxFQUFzQjtBQUM5QyxRQUFJZSxXQUFXLEdBQUdmLFdBQVcsR0FBRyxLQUFLUyxNQUFyQzs7QUFDQSxRQUFJTSxXQUFXLEdBQUcsS0FBS0osS0FBbkIsS0FBNkIsQ0FBakMsRUFBb0M7QUFDbEMsVUFBSTFRLEtBQUssR0FBRzhRLFdBQVcsR0FBRyxLQUFLSixLQUEvQjs7QUFDQSxVQUFJMVEsS0FBSyxJQUFJLENBQVQsSUFBY0EsS0FBSyxHQUFHLEtBQUs5TCxJQUEvQixFQUFxQztBQUNuQyxlQUFPOEwsS0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTyxDQUFDLENBQVI7QUFDRCxHQVREOztBQVdBcVEsT0FBSyxDQUFDeFMsU0FBTixDQUFnQm1TLFdBQWhCLEdBQThCLFVBQVNELFdBQVQsRUFBc0I7QUFDbEQsV0FBTyxLQUFLclEsT0FBTCxDQUFhcVEsV0FBYixDQUFQO0FBQ0QsR0FGRDs7QUFJQU0sT0FBSyxDQUFDeFMsU0FBTixDQUFnQmtMLFNBQWhCLEdBQTRCLFVBQVMrQyxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFDaEQsUUFBSWlCLFFBQVEsR0FBRyxLQUFLOVksSUFBTCxHQUFZLENBQTNCO0FBQ0EsUUFBSW9aLElBQUksR0FBRyxLQUFLb0QsS0FBaEI7QUFDQSxRQUFJMVgsS0FBSyxHQUFHK1MsT0FBTyxHQUFHLEtBQUt5RSxNQUFMLEdBQWN4RCxRQUFRLEdBQUdNLElBQTVCLEdBQW1DLEtBQUtrRCxNQUEzRDs7QUFDQSxTQUFLLElBQUk1SCxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxJQUFJb0UsUUFBdkIsRUFBaUNwRSxFQUFFLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQUlrRCxFQUFFLENBQUM5UyxLQUFELEVBQVE0UCxFQUFSLEVBQVksSUFBWixDQUFGLEtBQXdCLEtBQTVCLEVBQW1DO0FBQ2pDLGVBQU9BLEVBQUUsR0FBRyxDQUFaO0FBQ0Q7O0FBQ0Q1UCxXQUFLLElBQUkrUyxPQUFPLEdBQUcsQ0FBQ3VCLElBQUosR0FBV0EsSUFBM0I7QUFDRDs7QUFDRCxXQUFPMUUsRUFBUDtBQUNELEdBWEQ7O0FBYUF5SCxPQUFLLENBQUN4UyxTQUFOLENBQWdCb08sVUFBaEIsR0FBNkIsVUFBU2haLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFDbkQsUUFBSWlCLFFBQVEsR0FBRyxLQUFLOVksSUFBTCxHQUFZLENBQTNCO0FBQ0EsUUFBSW9aLElBQUksR0FBRyxLQUFLb0QsS0FBaEI7QUFDQSxRQUFJMVgsS0FBSyxHQUFHK1MsT0FBTyxHQUFHLEtBQUt5RSxNQUFMLEdBQWN4RCxRQUFRLEdBQUdNLElBQTVCLEdBQW1DLEtBQUtrRCxNQUEzRDtBQUNBLFFBQUk1SCxFQUFFLEdBQUcsQ0FBVDtBQUNBLFdBQU8sSUFBSXNCLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFVBQUlTLENBQUMsR0FBRzNSLEtBQVI7QUFDQUEsV0FBSyxJQUFJK1MsT0FBTyxHQUFHLENBQUN1QixJQUFKLEdBQVdBLElBQTNCO0FBQ0EsYUFBTzFFLEVBQUUsR0FBR29FLFFBQUwsR0FBZ0JsQyxZQUFZLEVBQTVCLEdBQWlDTCxhQUFhLENBQUN4WCxJQUFELEVBQU8yVixFQUFFLEVBQVQsRUFBYStCLENBQWIsQ0FBckQ7QUFDRCxLQUpNLENBQVA7QUFLRCxHQVZEOztBQVlBMEYsT0FBSyxDQUFDeFMsU0FBTixDQUFnQm1SLE1BQWhCLEdBQXlCLFVBQVNrQixLQUFULEVBQWdCO0FBQ3ZDLFdBQU9BLEtBQUssWUFBWUcsS0FBakIsR0FDTCxLQUFLRyxNQUFMLEtBQWdCTixLQUFLLENBQUNNLE1BQXRCLElBQ0EsS0FBS0MsSUFBTCxLQUFjUCxLQUFLLENBQUNPLElBRHBCLElBRUEsS0FBS0MsS0FBTCxLQUFlUixLQUFLLENBQUNRLEtBSGhCLEdBSUx6QixTQUFTLENBQUMsSUFBRCxFQUFPaUIsS0FBUCxDQUpYO0FBS0QsR0FORDs7QUFTRixNQUFJVSxXQUFKO0FBRUE3SyxhQUFXLENBQUNnTCxVQUFELEVBQWEzSyxRQUFiLENBQVg7O0FBQ0UsV0FBUzJLLFVBQVQsR0FBc0I7QUFDcEIsVUFBTS9DLFNBQVMsQ0FBQyxVQUFELENBQWY7QUFDRDs7QUFHSGpJLGFBQVcsQ0FBQ2lMLGVBQUQsRUFBa0JELFVBQWxCLENBQVg7O0FBQXlDLFdBQVNDLGVBQVQsR0FBMkIsQ0FBRTs7QUFFdEVqTCxhQUFXLENBQUNrTCxpQkFBRCxFQUFvQkYsVUFBcEIsQ0FBWDs7QUFBMkMsV0FBU0UsaUJBQVQsR0FBNkIsQ0FBRTs7QUFFMUVsTCxhQUFXLENBQUNtTCxhQUFELEVBQWdCSCxVQUFoQixDQUFYOztBQUF1QyxXQUFTRyxhQUFULEdBQXlCLENBQUU7O0FBR2xFSCxZQUFVLENBQUNySixLQUFYLEdBQW1Cc0osZUFBbkI7QUFDQUQsWUFBVSxDQUFDcEosT0FBWCxHQUFxQnNKLGlCQUFyQjtBQUNBRixZQUFVLENBQUNqYyxHQUFYLEdBQWlCb2MsYUFBakI7QUFFQSxNQUFJQyxJQUFJLEdBQ04sT0FBT3RiLElBQUksQ0FBQ3NiLElBQVosS0FBcUIsVUFBckIsSUFBbUN0YixJQUFJLENBQUNzYixJQUFMLENBQVUsVUFBVixFQUFzQixDQUF0QixNQUE2QixDQUFDLENBQWpFLEdBQ0F0YixJQUFJLENBQUNzYixJQURMLEdBRUEsU0FBU0EsSUFBVCxDQUFjeFIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0I7QUFDbEJELEtBQUMsR0FBR0EsQ0FBQyxHQUFHLENBQVIsQ0FEa0IsQ0FDUDs7QUFDWEMsS0FBQyxHQUFHQSxDQUFDLEdBQUcsQ0FBUixDQUZrQixDQUVQOztBQUNYLFFBQUl3UixDQUFDLEdBQUd6UixDQUFDLEdBQUcsTUFBWjtBQUNBLFFBQUkwUixDQUFDLEdBQUd6UixDQUFDLEdBQUcsTUFBWixDQUprQixDQUtsQjs7QUFDQSxXQUFRd1IsQ0FBQyxHQUFHQyxDQUFMLElBQWEsQ0FBQzFSLENBQUMsS0FBSyxFQUFQLElBQWEwUixDQUFiLEdBQWlCRCxDQUFDLElBQUl4UixDQUFDLEtBQUssRUFBVixDQUFuQixJQUFxQyxFQUF0QyxLQUE4QyxDQUF6RCxJQUE4RCxDQUFyRSxDQU5rQixDQU1zRDtBQUN6RSxHQVZILENBLzlCa0IsQ0EyK0JsQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxXQUFTMFIsR0FBVCxDQUFhQyxHQUFiLEVBQWtCO0FBQ2hCLFdBQVNBLEdBQUcsS0FBSyxDQUFULEdBQWMsVUFBZixHQUE4QkEsR0FBRyxHQUFHLFVBQTNDO0FBQ0Q7O0FBRUQsV0FBU0MsSUFBVCxDQUFjQyxDQUFkLEVBQWlCO0FBQ2YsUUFBSUEsQ0FBQyxLQUFLLEtBQU4sSUFBZUEsQ0FBQyxLQUFLLElBQXJCLElBQTZCQSxDQUFDLEtBQUs1WixTQUF2QyxFQUFrRDtBQUNoRCxhQUFPLENBQVA7QUFDRDs7QUFDRCxRQUFJLE9BQU80WixDQUFDLENBQUMxQyxPQUFULEtBQXFCLFVBQXpCLEVBQXFDO0FBQ25DMEMsT0FBQyxHQUFHQSxDQUFDLENBQUMxQyxPQUFGLEVBQUo7O0FBQ0EsVUFBSTBDLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxJQUFyQixJQUE2QkEsQ0FBQyxLQUFLNVosU0FBdkMsRUFBa0Q7QUFDaEQsZUFBTyxDQUFQO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJNFosQ0FBQyxLQUFLLElBQVYsRUFBZ0I7QUFDZCxhQUFPLENBQVA7QUFDRDs7QUFDRCxRQUFJeGUsSUFBSSxHQUFHLE9BQU93ZSxDQUFsQjs7QUFDQSxRQUFJeGUsSUFBSSxLQUFLLFFBQWIsRUFBdUI7QUFDckIsVUFBSXdlLENBQUMsS0FBS0EsQ0FBTixJQUFXQSxDQUFDLEtBQUs3QixRQUFyQixFQUErQjtBQUM3QixlQUFPLENBQVA7QUFDRDs7QUFDRCxVQUFJOEIsQ0FBQyxHQUFHRCxDQUFDLEdBQUcsQ0FBWjs7QUFDQSxVQUFJQyxDQUFDLEtBQUtELENBQVYsRUFBYTtBQUNYQyxTQUFDLElBQUlELENBQUMsR0FBRyxVQUFUO0FBQ0Q7O0FBQ0QsYUFBT0EsQ0FBQyxHQUFHLFVBQVgsRUFBdUI7QUFDckJBLFNBQUMsSUFBSSxVQUFMO0FBQ0FDLFNBQUMsSUFBSUQsQ0FBTDtBQUNEOztBQUNELGFBQU9ILEdBQUcsQ0FBQ0ksQ0FBRCxDQUFWO0FBQ0Q7O0FBQ0QsUUFBSXplLElBQUksS0FBSyxRQUFiLEVBQXVCO0FBQ3JCLGFBQU93ZSxDQUFDLENBQUMzWixNQUFGLEdBQVc2Wiw0QkFBWCxHQUEwQ0MsZ0JBQWdCLENBQUNILENBQUQsQ0FBMUQsR0FBZ0VJLFVBQVUsQ0FBQ0osQ0FBRCxDQUFqRjtBQUNEOztBQUNELFFBQUksT0FBT0EsQ0FBQyxDQUFDSyxRQUFULEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDLGFBQU9MLENBQUMsQ0FBQ0ssUUFBRixFQUFQO0FBQ0Q7O0FBQ0QsUUFBSTdlLElBQUksS0FBSyxRQUFiLEVBQXVCO0FBQ3JCLGFBQU84ZSxTQUFTLENBQUNOLENBQUQsQ0FBaEI7QUFDRDs7QUFDRCxRQUFJLE9BQU9BLENBQUMsQ0FBQ3hTLFFBQVQsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEMsYUFBTzRTLFVBQVUsQ0FBQ0osQ0FBQyxDQUFDeFMsUUFBRixFQUFELENBQWpCO0FBQ0Q7O0FBQ0QsVUFBTSxJQUFJOEIsS0FBSixDQUFVLGdCQUFnQjlOLElBQWhCLEdBQXVCLG9CQUFqQyxDQUFOO0FBQ0Q7O0FBRUQsV0FBUzJlLGdCQUFULENBQTBCcFYsTUFBMUIsRUFBa0M7QUFDaEMsUUFBSWdWLElBQUksR0FBR1EsZUFBZSxDQUFDeFYsTUFBRCxDQUExQjs7QUFDQSxRQUFJZ1YsSUFBSSxLQUFLM1osU0FBYixFQUF3QjtBQUN0QjJaLFVBQUksR0FBR0ssVUFBVSxDQUFDclYsTUFBRCxDQUFqQjs7QUFDQSxVQUFJeVYsc0JBQXNCLEtBQUtDLDBCQUEvQixFQUEyRDtBQUN6REQsOEJBQXNCLEdBQUcsQ0FBekI7QUFDQUQsdUJBQWUsR0FBRyxFQUFsQjtBQUNEOztBQUNEQyw0QkFBc0I7QUFDdEJELHFCQUFlLENBQUN4VixNQUFELENBQWYsR0FBMEJnVixJQUExQjtBQUNEOztBQUNELFdBQU9BLElBQVA7QUFDRCxHQTFpQ2lCLENBNGlDbEI7OztBQUNBLFdBQVNLLFVBQVQsQ0FBb0JyVixNQUFwQixFQUE0QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJZ1YsSUFBSSxHQUFHLENBQVg7O0FBQ0EsU0FBSyxJQUFJNUksRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR3BNLE1BQU0sQ0FBQzFFLE1BQTdCLEVBQXFDOFEsRUFBRSxFQUF2QyxFQUEyQztBQUN6QzRJLFVBQUksR0FBRyxLQUFLQSxJQUFMLEdBQVloVixNQUFNLENBQUMyVixVQUFQLENBQWtCdkosRUFBbEIsQ0FBWixHQUFvQyxDQUEzQztBQUNEOztBQUNELFdBQU8wSSxHQUFHLENBQUNFLElBQUQsQ0FBVjtBQUNEOztBQUVELFdBQVNPLFNBQVQsQ0FBbUJLLEdBQW5CLEVBQXdCO0FBQ3RCLFFBQUlaLElBQUo7O0FBQ0EsUUFBSWEsWUFBSixFQUFrQjtBQUNoQmIsVUFBSSxHQUFHYyxPQUFPLENBQUN6RixHQUFSLENBQVl1RixHQUFaLENBQVA7O0FBQ0EsVUFBSVosSUFBSSxLQUFLM1osU0FBYixFQUF3QjtBQUN0QixlQUFPMlosSUFBUDtBQUNEO0FBQ0Y7O0FBRURBLFFBQUksR0FBR1ksR0FBRyxDQUFDRyxZQUFELENBQVY7O0FBQ0EsUUFBSWYsSUFBSSxLQUFLM1osU0FBYixFQUF3QjtBQUN0QixhQUFPMlosSUFBUDtBQUNEOztBQUVELFFBQUksQ0FBQ2dCLGlCQUFMLEVBQXdCO0FBQ3RCaEIsVUFBSSxHQUFHWSxHQUFHLENBQUNLLG9CQUFKLElBQTRCTCxHQUFHLENBQUNLLG9CQUFKLENBQXlCRixZQUF6QixDQUFuQzs7QUFDQSxVQUFJZixJQUFJLEtBQUszWixTQUFiLEVBQXdCO0FBQ3RCLGVBQU8yWixJQUFQO0FBQ0Q7O0FBRURBLFVBQUksR0FBR2tCLGFBQWEsQ0FBQ04sR0FBRCxDQUFwQjs7QUFDQSxVQUFJWixJQUFJLEtBQUszWixTQUFiLEVBQXdCO0FBQ3RCLGVBQU8yWixJQUFQO0FBQ0Q7QUFDRjs7QUFFREEsUUFBSSxHQUFHLEVBQUVtQixVQUFUOztBQUNBLFFBQUlBLFVBQVUsR0FBRyxVQUFqQixFQUE2QjtBQUMzQkEsZ0JBQVUsR0FBRyxDQUFiO0FBQ0Q7O0FBRUQsUUFBSU4sWUFBSixFQUFrQjtBQUNoQkMsYUFBTyxDQUFDTSxHQUFSLENBQVlSLEdBQVosRUFBaUJaLElBQWpCO0FBQ0QsS0FGRCxNQUVPLElBQUlxQixZQUFZLEtBQUtoYixTQUFqQixJQUE4QmdiLFlBQVksQ0FBQ1QsR0FBRCxDQUFaLEtBQXNCLEtBQXhELEVBQStEO0FBQ3BFLFlBQU0sSUFBSXJSLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0QsS0FGTSxNQUVBLElBQUl5UixpQkFBSixFQUF1QjtBQUM1QnpULFlBQU0sQ0FBQ21ELGNBQVAsQ0FBc0JrUSxHQUF0QixFQUEyQkcsWUFBM0IsRUFBeUM7QUFDdkMsc0JBQWMsS0FEeUI7QUFFdkMsd0JBQWdCLEtBRnVCO0FBR3ZDLG9CQUFZLEtBSDJCO0FBSXZDLGlCQUFTZjtBQUo4QixPQUF6QztBQU1ELEtBUE0sTUFPQSxJQUFJWSxHQUFHLENBQUNLLG9CQUFKLEtBQTZCNWEsU0FBN0IsSUFDQXVhLEdBQUcsQ0FBQ0ssb0JBQUosS0FBNkJMLEdBQUcsQ0FBQ2pNLFdBQUosQ0FBZ0J0SSxTQUFoQixDQUEwQjRVLG9CQUQzRCxFQUNpRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBTCxTQUFHLENBQUNLLG9CQUFKLEdBQTJCLFlBQVc7QUFDcEMsZUFBTyxLQUFLdE0sV0FBTCxDQUFpQnRJLFNBQWpCLENBQTJCNFUsb0JBQTNCLENBQWdEL1UsS0FBaEQsQ0FBc0QsSUFBdEQsRUFBNERtRCxTQUE1RCxDQUFQO0FBQ0QsT0FGRDs7QUFHQXVSLFNBQUcsQ0FBQ0ssb0JBQUosQ0FBeUJGLFlBQXpCLElBQXlDZixJQUF6QztBQUNELEtBVk0sTUFVQSxJQUFJWSxHQUFHLENBQUNVLFFBQUosS0FBaUJqYixTQUFyQixFQUFnQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBdWEsU0FBRyxDQUFDRyxZQUFELENBQUgsR0FBb0JmLElBQXBCO0FBQ0QsS0FOTSxNQU1BO0FBQ0wsWUFBTSxJQUFJelEsS0FBSixDQUFVLG9EQUFWLENBQU47QUFDRDs7QUFFRCxXQUFPeVEsSUFBUDtBQUNELEdBMW5DaUIsQ0E0bkNsQjs7O0FBQ0EsTUFBSXFCLFlBQVksR0FBRzlULE1BQU0sQ0FBQzhULFlBQTFCLENBN25Da0IsQ0ErbkNsQjs7QUFDQSxNQUFJTCxpQkFBaUIsR0FBSSxZQUFXO0FBQ2xDLFFBQUk7QUFDRnpULFlBQU0sQ0FBQ21ELGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0IsRUFBL0I7QUFDQSxhQUFPLElBQVA7QUFDRCxLQUhELENBR0UsT0FBT2xCLENBQVAsRUFBVTtBQUNWLGFBQU8sS0FBUDtBQUNEO0FBQ0YsR0FQd0IsRUFBekIsQ0Fob0NrQixDQXlvQ2xCO0FBQ0E7OztBQUNBLFdBQVMwUixhQUFULENBQXVCM2IsSUFBdkIsRUFBNkI7QUFDM0IsUUFBSUEsSUFBSSxJQUFJQSxJQUFJLENBQUMrYixRQUFMLEdBQWdCLENBQTVCLEVBQStCO0FBQzdCLGNBQVEvYixJQUFJLENBQUMrYixRQUFiO0FBQ0UsYUFBSyxDQUFMO0FBQVE7QUFDTixpQkFBTy9iLElBQUksQ0FBQ2djLFFBQVo7O0FBQ0YsYUFBSyxDQUFMO0FBQVE7QUFDTixpQkFBT2hjLElBQUksQ0FBQ2ljLGVBQUwsSUFBd0JqYyxJQUFJLENBQUNpYyxlQUFMLENBQXFCRCxRQUFwRDtBQUpKO0FBTUQ7QUFDRixHQXBwQ2lCLENBc3BDbEI7OztBQUNBLE1BQUlWLFlBQVksR0FBRyxPQUFPWSxPQUFQLEtBQW1CLFVBQXRDO0FBQ0EsTUFBSVgsT0FBSjs7QUFDQSxNQUFJRCxZQUFKLEVBQWtCO0FBQ2hCQyxXQUFPLEdBQUcsSUFBSVcsT0FBSixFQUFWO0FBQ0Q7O0FBRUQsTUFBSU4sVUFBVSxHQUFHLENBQWpCO0FBRUEsTUFBSUosWUFBWSxHQUFHLG1CQUFuQjs7QUFDQSxNQUFJLE9BQU9uVCxNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQ2hDbVQsZ0JBQVksR0FBR25ULE1BQU0sQ0FBQ21ULFlBQUQsQ0FBckI7QUFDRDs7QUFFRCxNQUFJWiw0QkFBNEIsR0FBRyxFQUFuQztBQUNBLE1BQUlPLDBCQUEwQixHQUFHLEdBQWpDO0FBQ0EsTUFBSUQsc0JBQXNCLEdBQUcsQ0FBN0I7QUFDQSxNQUFJRCxlQUFlLEdBQUcsRUFBdEI7O0FBRUEsV0FBU2tCLGlCQUFULENBQTJCaGYsSUFBM0IsRUFBaUM7QUFDL0JpYyxhQUFTLENBQ1BqYyxJQUFJLEtBQUswYixRQURGLEVBRVAsbURBRk8sQ0FBVDtBQUlEOztBQUVEN0osYUFBVyxDQUFDb04sR0FBRCxFQUFNbkMsZUFBTixDQUFYLENBaHJDa0IsQ0FrckNoQjs7QUFFQSxXQUFTbUMsR0FBVCxDQUFhbmEsS0FBYixFQUFvQjtBQUNsQixXQUFPQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLbkIsU0FBNUIsR0FBd0N1YixRQUFRLEVBQWhELEdBQ0xDLEtBQUssQ0FBQ3JhLEtBQUQsQ0FBTCxJQUFnQixDQUFDdU8sU0FBUyxDQUFDdk8sS0FBRCxDQUExQixHQUFvQ0EsS0FBcEMsR0FDQW9hLFFBQVEsR0FBR0UsYUFBWCxDQUF5QixVQUFTaGIsR0FBVCxFQUFlO0FBQ3RDLFVBQUl3USxJQUFJLEdBQUd2QyxhQUFhLENBQUN2TixLQUFELENBQXhCO0FBQ0FrYSx1QkFBaUIsQ0FBQ3BLLElBQUksQ0FBQzVVLElBQU4sQ0FBakI7QUFDQTRVLFVBQUksQ0FBQ3JSLE9BQUwsQ0FBYSxVQUFTa1QsQ0FBVCxFQUFZRCxDQUFaLEVBQWdCO0FBQUMsZUFBT3BTLEdBQUcsQ0FBQ3NhLEdBQUosQ0FBUWxJLENBQVIsRUFBV0MsQ0FBWCxDQUFQO0FBQXFCLE9BQW5EO0FBQ0QsS0FKRCxDQUZGO0FBT0Q7O0FBRUR3SSxLQUFHLENBQUM1USxFQUFKLEdBQVMsWUFBVztBQUFDLFFBQUlnUixTQUFTLEdBQUd6TixPQUFPLENBQUM1RyxJQUFSLENBQWEyQixTQUFiLEVBQXdCLENBQXhCLENBQWhCO0FBQ25CLFdBQU91UyxRQUFRLEdBQUdFLGFBQVgsQ0FBeUIsVUFBU2hiLEdBQVQsRUFBZTtBQUM3QyxXQUFLLElBQUlrSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK1MsU0FBUyxDQUFDemIsTUFBOUIsRUFBc0MwSSxDQUFDLElBQUksQ0FBM0MsRUFBOEM7QUFDNUMsWUFBSUEsQ0FBQyxHQUFHLENBQUosSUFBUytTLFNBQVMsQ0FBQ3piLE1BQXZCLEVBQStCO0FBQzdCLGdCQUFNLElBQUlpSixLQUFKLENBQVUsNEJBQTRCd1MsU0FBUyxDQUFDL1MsQ0FBRCxDQUEvQyxDQUFOO0FBQ0Q7O0FBQ0RsSSxXQUFHLENBQUNzYSxHQUFKLENBQVFXLFNBQVMsQ0FBQy9TLENBQUQsQ0FBakIsRUFBc0IrUyxTQUFTLENBQUMvUyxDQUFDLEdBQUcsQ0FBTCxDQUEvQjtBQUNEO0FBQ0YsS0FQTSxDQUFQO0FBUUQsR0FURDs7QUFXQTJTLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY29CLFFBQWQsR0FBeUIsWUFBVztBQUNsQyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLE9BQWhCLEVBQXlCLEdBQXpCLENBQVA7QUFDRCxHQUZELENBenNDZ0IsQ0E2c0NoQjs7O0FBRUEwSCxLQUFHLENBQUN0VixTQUFKLENBQWNnUCxHQUFkLEdBQW9CLFVBQVNuQyxDQUFULEVBQVlvQyxXQUFaLEVBQXlCO0FBQzNDLFdBQU8sS0FBSzBHLEtBQUwsR0FDTCxLQUFLQSxLQUFMLENBQVczRyxHQUFYLENBQWUsQ0FBZixFQUFrQmhWLFNBQWxCLEVBQTZCNlMsQ0FBN0IsRUFBZ0NvQyxXQUFoQyxDQURLLEdBRUxBLFdBRkY7QUFHRCxHQUpELENBL3NDZ0IsQ0FxdENoQjs7O0FBRUFxRyxLQUFHLENBQUN0VixTQUFKLENBQWMrVSxHQUFkLEdBQW9CLFVBQVNsSSxDQUFULEVBQVlDLENBQVosRUFBZTtBQUNqQyxXQUFPOEksU0FBUyxDQUFDLElBQUQsRUFBTy9JLENBQVAsRUFBVUMsQ0FBVixDQUFoQjtBQUNELEdBRkQ7O0FBSUF3SSxLQUFHLENBQUN0VixTQUFKLENBQWM2VixLQUFkLEdBQXNCLFVBQVNDLE9BQVQsRUFBa0JoSixDQUFsQixFQUFxQjtBQUN6QyxXQUFPLEtBQUtpSixRQUFMLENBQWNELE9BQWQsRUFBdUIzTCxPQUF2QixFQUFnQyxZQUFZO0FBQUMsYUFBTzJDLENBQVA7QUFBUyxLQUF0RCxDQUFQO0FBQ0QsR0FGRDs7QUFJQXdJLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY2dXLE1BQWQsR0FBdUIsVUFBU25KLENBQVQsRUFBWTtBQUNqQyxXQUFPK0ksU0FBUyxDQUFDLElBQUQsRUFBTy9JLENBQVAsRUFBVTFDLE9BQVYsQ0FBaEI7QUFDRCxHQUZEOztBQUlBbUwsS0FBRyxDQUFDdFYsU0FBSixDQUFjaVcsUUFBZCxHQUF5QixVQUFTSCxPQUFULEVBQWtCO0FBQ3pDLFdBQU8sS0FBS0MsUUFBTCxDQUFjRCxPQUFkLEVBQXVCLFlBQVk7QUFBQyxhQUFPM0wsT0FBUDtBQUFlLEtBQW5ELENBQVA7QUFDRCxHQUZEOztBQUlBbUwsS0FBRyxDQUFDdFYsU0FBSixDQUFjdkcsTUFBZCxHQUF1QixVQUFTb1QsQ0FBVCxFQUFZb0MsV0FBWixFQUF5QmlILE9BQXpCLEVBQWtDO0FBQ3ZELFdBQU9sVCxTQUFTLENBQUMvSSxNQUFWLEtBQXFCLENBQXJCLEdBQ0w0UyxDQUFDLENBQUMsSUFBRCxDQURJLEdBRUwsS0FBS2tKLFFBQUwsQ0FBYyxDQUFDbEosQ0FBRCxDQUFkLEVBQW1Cb0MsV0FBbkIsRUFBZ0NpSCxPQUFoQyxDQUZGO0FBR0QsR0FKRDs7QUFNQVosS0FBRyxDQUFDdFYsU0FBSixDQUFjK1YsUUFBZCxHQUF5QixVQUFTRCxPQUFULEVBQWtCN0csV0FBbEIsRUFBK0JpSCxPQUEvQixFQUF3QztBQUMvRCxRQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaQSxhQUFPLEdBQUdqSCxXQUFWO0FBQ0FBLGlCQUFXLEdBQUdqVixTQUFkO0FBQ0Q7O0FBQ0QsUUFBSW1jLFlBQVksR0FBR0MsZUFBZSxDQUNoQyxJQURnQyxFQUVoQ0MsYUFBYSxDQUFDUCxPQUFELENBRm1CLEVBR2hDN0csV0FIZ0MsRUFJaENpSCxPQUpnQyxDQUFsQztBQU1BLFdBQU9DLFlBQVksS0FBS2hNLE9BQWpCLEdBQTJCblEsU0FBM0IsR0FBdUNtYyxZQUE5QztBQUNELEdBWkQ7O0FBY0FiLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY3NXLEtBQWQsR0FBc0IsWUFBVztBQUMvQixRQUFJLEtBQUtqZ0IsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUksS0FBS2tnQixTQUFULEVBQW9CO0FBQ2xCLFdBQUtsZ0IsSUFBTCxHQUFZLENBQVo7QUFDQSxXQUFLc2YsS0FBTCxHQUFhLElBQWI7QUFDQSxXQUFLdEUsTUFBTCxHQUFjclgsU0FBZDtBQUNBLFdBQUt3YyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBT2pCLFFBQVEsRUFBZjtBQUNELEdBWkQsQ0EzdkNnQixDQXl3Q2hCOzs7QUFFQUQsS0FBRyxDQUFDdFYsU0FBSixDQUFjeVcsS0FBZCxHQUFzQixZQUF1QjtBQUMzQyxXQUFPQyxnQkFBZ0IsQ0FBQyxJQUFELEVBQU8xYyxTQUFQLEVBQWtCZ0osU0FBbEIsQ0FBdkI7QUFDRCxHQUZEOztBQUlBc1MsS0FBRyxDQUFDdFYsU0FBSixDQUFjMlcsU0FBZCxHQUEwQixVQUFTQyxNQUFULEVBQWlCO0FBQUMsUUFBSUMsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaO0FBQzFDLFdBQU8wVCxnQkFBZ0IsQ0FBQyxJQUFELEVBQU9FLE1BQVAsRUFBZUMsS0FBZixDQUF2QjtBQUNELEdBRkQ7O0FBSUF2QixLQUFHLENBQUN0VixTQUFKLENBQWM4VyxPQUFkLEdBQXdCLFVBQVNoQixPQUFULEVBQWtCO0FBQUMsUUFBSWUsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaO0FBQ3pDLFdBQU8sS0FBSytTLFFBQUwsQ0FDTEQsT0FESyxFQUVMUCxRQUFRLEVBRkgsRUFHTCxVQUFTd0IsQ0FBVCxFQUFhO0FBQUMsYUFBTyxPQUFPQSxDQUFDLENBQUNOLEtBQVQsS0FBbUIsVUFBbkIsR0FDbkJNLENBQUMsQ0FBQ04sS0FBRixDQUFRNVcsS0FBUixDQUFja1gsQ0FBZCxFQUFpQkYsS0FBakIsQ0FEbUIsR0FFbkJBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDNWMsTUFBTixHQUFlLENBQWhCLENBRk87QUFFWSxLQUxyQixDQUFQO0FBT0QsR0FSRDs7QUFVQXFiLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY2dYLFNBQWQsR0FBMEIsWUFBdUI7QUFDL0MsV0FBT04sZ0JBQWdCLENBQUMsSUFBRCxFQUFPTyxVQUFQLEVBQW1CalUsU0FBbkIsQ0FBdkI7QUFDRCxHQUZEOztBQUlBc1MsS0FBRyxDQUFDdFYsU0FBSixDQUFja1gsYUFBZCxHQUE4QixVQUFTTixNQUFULEVBQWlCO0FBQUMsUUFBSUMsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaO0FBQzlDLFdBQU8wVCxnQkFBZ0IsQ0FBQyxJQUFELEVBQU9TLGNBQWMsQ0FBQ1AsTUFBRCxDQUFyQixFQUErQkMsS0FBL0IsQ0FBdkI7QUFDRCxHQUZEOztBQUlBdkIsS0FBRyxDQUFDdFYsU0FBSixDQUFjb1gsV0FBZCxHQUE0QixVQUFTdEIsT0FBVCxFQUFrQjtBQUFDLFFBQUllLEtBQUssR0FBRzVPLE9BQU8sQ0FBQzVHLElBQVIsQ0FBYTJCLFNBQWIsRUFBd0IsQ0FBeEIsQ0FBWjtBQUM3QyxXQUFPLEtBQUsrUyxRQUFMLENBQ0xELE9BREssRUFFTFAsUUFBUSxFQUZILEVBR0wsVUFBU3dCLENBQVQsRUFBYTtBQUFDLGFBQU8sT0FBT0EsQ0FBQyxDQUFDQyxTQUFULEtBQXVCLFVBQXZCLEdBQ25CRCxDQUFDLENBQUNDLFNBQUYsQ0FBWW5YLEtBQVosQ0FBa0JrWCxDQUFsQixFQUFxQkYsS0FBckIsQ0FEbUIsR0FFbkJBLEtBQUssQ0FBQ0EsS0FBSyxDQUFDNWMsTUFBTixHQUFlLENBQWhCLENBRk87QUFFWSxLQUxyQixDQUFQO0FBT0QsR0FSRDs7QUFVQXFiLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY3FYLElBQWQsR0FBcUIsVUFBU0MsVUFBVCxFQUFxQjtBQUN4QztBQUNBLFdBQU9DLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDLElBQUQsRUFBT0YsVUFBUCxDQUFaLENBQWpCO0FBQ0QsR0FIRDs7QUFLQWhDLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY2pJLE1BQWQsR0FBdUIsVUFBUzBmLE1BQVQsRUFBaUJILFVBQWpCLEVBQTZCO0FBQ2xEO0FBQ0EsV0FBT0MsVUFBVSxDQUFDQyxXQUFXLENBQUMsSUFBRCxFQUFPRixVQUFQLEVBQW1CRyxNQUFuQixDQUFaLENBQWpCO0FBQ0QsR0FIRCxDQXB6Q2dCLENBeXpDaEI7OztBQUVBbkMsS0FBRyxDQUFDdFYsU0FBSixDQUFjeVYsYUFBZCxHQUE4QixVQUFTeEgsRUFBVCxFQUFhO0FBQ3pDLFFBQUl5SixPQUFPLEdBQUcsS0FBS0MsU0FBTCxFQUFkO0FBQ0ExSixNQUFFLENBQUN5SixPQUFELENBQUY7QUFDQSxXQUFPQSxPQUFPLENBQUNFLFVBQVIsS0FBdUJGLE9BQU8sQ0FBQ0csYUFBUixDQUFzQixLQUFLdEIsU0FBM0IsQ0FBdkIsR0FBK0QsSUFBdEU7QUFDRCxHQUpEOztBQU1BakIsS0FBRyxDQUFDdFYsU0FBSixDQUFjMlgsU0FBZCxHQUEwQixZQUFXO0FBQ25DLFdBQU8sS0FBS3BCLFNBQUwsR0FBaUIsSUFBakIsR0FBd0IsS0FBS3NCLGFBQUwsQ0FBbUIsSUFBSXBOLE9BQUosRUFBbkIsQ0FBL0I7QUFDRCxHQUZEOztBQUlBNkssS0FBRyxDQUFDdFYsU0FBSixDQUFjOFgsV0FBZCxHQUE0QixZQUFXO0FBQ3JDLFdBQU8sS0FBS0QsYUFBTCxFQUFQO0FBQ0QsR0FGRDs7QUFJQXZDLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBYzRYLFVBQWQsR0FBMkIsWUFBVztBQUNwQyxXQUFPLEtBQUtwQixTQUFaO0FBQ0QsR0FGRDs7QUFJQWxCLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBY29PLFVBQWQsR0FBMkIsVUFBU2haLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFDakQsV0FBTyxJQUFJNkosV0FBSixDQUFnQixJQUFoQixFQUFzQjNpQixJQUF0QixFQUE0QjhZLE9BQTVCLENBQVA7QUFDRCxHQUZEOztBQUlBb0gsS0FBRyxDQUFDdFYsU0FBSixDQUFja0wsU0FBZCxHQUEwQixVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQUMsUUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQy9DLFFBQUluWixVQUFVLEdBQUcsQ0FBakI7QUFDQSxTQUFLMGMsS0FBTCxJQUFjLEtBQUtBLEtBQUwsQ0FBV3FDLE9BQVgsQ0FBbUIsVUFBUzFILEtBQVQsRUFBaUI7QUFDaERyWCxnQkFBVTtBQUNWLGFBQU9nVixFQUFFLENBQUNxQyxLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVdBLEtBQUssQ0FBQyxDQUFELENBQWhCLEVBQXFCOEIsTUFBckIsQ0FBVDtBQUNELEtBSGEsRUFHWGxFLE9BSFcsQ0FBZDtBQUlBLFdBQU9qVixVQUFQO0FBQ0QsR0FQRDs7QUFTQXFjLEtBQUcsQ0FBQ3RWLFNBQUosQ0FBYzZYLGFBQWQsR0FBOEIsVUFBU0ksT0FBVCxFQUFrQjtBQUM5QyxRQUFJQSxPQUFPLEtBQUssS0FBSzFCLFNBQXJCLEVBQWdDO0FBQzlCLGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUksQ0FBQzBCLE9BQUwsRUFBYztBQUNaLFdBQUsxQixTQUFMLEdBQWlCMEIsT0FBakI7QUFDQSxXQUFLekIsU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU8wQixPQUFPLENBQUMsS0FBSzdoQixJQUFOLEVBQVksS0FBS3NmLEtBQWpCLEVBQXdCc0MsT0FBeEIsRUFBaUMsS0FBSzVHLE1BQXRDLENBQWQ7QUFDRCxHQVZEOztBQWFGLFdBQVNtRSxLQUFULENBQWUyQyxRQUFmLEVBQXlCO0FBQ3ZCLFdBQU8sQ0FBQyxFQUFFQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsZUFBRCxDQUF0QixDQUFSO0FBQ0Q7O0FBRUQ5QyxLQUFHLENBQUNFLEtBQUosR0FBWUEsS0FBWjtBQUVBLE1BQUk0QyxlQUFlLEdBQUcsdUJBQXRCO0FBRUEsTUFBSUMsWUFBWSxHQUFHL0MsR0FBRyxDQUFDdFYsU0FBdkI7QUFDQXFZLGNBQVksQ0FBQ0QsZUFBRCxDQUFaLEdBQWdDLElBQWhDO0FBQ0FDLGNBQVksQ0FBQ3RPLE1BQUQsQ0FBWixHQUF1QnNPLFlBQVksQ0FBQ3JDLE1BQXBDO0FBQ0FxQyxjQUFZLENBQUNDLFFBQWIsR0FBd0JELFlBQVksQ0FBQ3BDLFFBQXJDLENBbDNDa0IsQ0FxM0NsQjs7QUFJRSxXQUFTc0MsWUFBVCxDQUFzQk4sT0FBdEIsRUFBK0IxRyxPQUEvQixFQUF3QztBQUN0QyxTQUFLMEcsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBSzFHLE9BQUwsR0FBZUEsT0FBZjtBQUNEOztBQUVEZ0gsY0FBWSxDQUFDdlksU0FBYixDQUF1QmdQLEdBQXZCLEdBQTZCLFVBQVM3SyxLQUFULEVBQWdCcVUsT0FBaEIsRUFBeUJqVyxHQUF6QixFQUE4QjBNLFdBQTlCLEVBQTJDO0FBQ3RFLFFBQUlzQyxPQUFPLEdBQUcsS0FBS0EsT0FBbkI7O0FBQ0EsU0FBSyxJQUFJeEcsRUFBRSxHQUFHLENBQVQsRUFBWUgsR0FBRyxHQUFHMkcsT0FBTyxDQUFDdFgsTUFBL0IsRUFBdUM4USxFQUFFLEdBQUdILEdBQTVDLEVBQWlERyxFQUFFLEVBQW5ELEVBQXVEO0FBQ3JELFVBQUlnRyxFQUFFLENBQUN4TyxHQUFELEVBQU1nUCxPQUFPLENBQUN4RyxFQUFELENBQVAsQ0FBWSxDQUFaLENBQU4sQ0FBTixFQUE2QjtBQUMzQixlQUFPd0csT0FBTyxDQUFDeEcsRUFBRCxDQUFQLENBQVksQ0FBWixDQUFQO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPa0UsV0FBUDtBQUNELEdBUkQ7O0FBVUFzSixjQUFZLENBQUN2WSxTQUFiLENBQXVCdkcsTUFBdkIsR0FBZ0MsVUFBU3dlLE9BQVQsRUFBa0I5VCxLQUFsQixFQUF5QnFVLE9BQXpCLEVBQWtDalcsR0FBbEMsRUFBdUNwSCxLQUF2QyxFQUE4Q3NkLGFBQTlDLEVBQTZEQyxRQUE3RCxFQUF1RTtBQUNyRyxRQUFJQyxPQUFPLEdBQUd4ZCxLQUFLLEtBQUtnUCxPQUF4QjtBQUVBLFFBQUlvSCxPQUFPLEdBQUcsS0FBS0EsT0FBbkI7QUFDQSxRQUFJcUgsR0FBRyxHQUFHLENBQVY7O0FBQ0EsU0FBSyxJQUFJaE8sR0FBRyxHQUFHMkcsT0FBTyxDQUFDdFgsTUFBdkIsRUFBK0IyZSxHQUFHLEdBQUdoTyxHQUFyQyxFQUEwQ2dPLEdBQUcsRUFBN0MsRUFBaUQ7QUFDL0MsVUFBSTdILEVBQUUsQ0FBQ3hPLEdBQUQsRUFBTWdQLE9BQU8sQ0FBQ3FILEdBQUQsQ0FBUCxDQUFhLENBQWIsQ0FBTixDQUFOLEVBQThCO0FBQzVCO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJQyxNQUFNLEdBQUdELEdBQUcsR0FBR2hPLEdBQW5COztBQUVBLFFBQUlpTyxNQUFNLEdBQUd0SCxPQUFPLENBQUNxSCxHQUFELENBQVAsQ0FBYSxDQUFiLE1BQW9CemQsS0FBdkIsR0FBK0J3ZCxPQUF6QyxFQUFrRDtBQUNoRCxhQUFPLElBQVA7QUFDRDs7QUFFRG5PLFVBQU0sQ0FBQ2tPLFFBQUQsQ0FBTjtBQUNBLEtBQUNDLE9BQU8sSUFBSSxDQUFDRSxNQUFiLEtBQXdCck8sTUFBTSxDQUFDaU8sYUFBRCxDQUE5Qjs7QUFFQSxRQUFJRSxPQUFPLElBQUlwSCxPQUFPLENBQUN0WCxNQUFSLEtBQW1CLENBQWxDLEVBQXFDO0FBQ25DLGFBRG1DLENBQzNCO0FBQ1Q7O0FBRUQsUUFBSSxDQUFDNGUsTUFBRCxJQUFXLENBQUNGLE9BQVosSUFBdUJwSCxPQUFPLENBQUN0WCxNQUFSLElBQWtCNmUsa0JBQTdDLEVBQWlFO0FBQy9ELGFBQU9DLFdBQVcsQ0FBQ2QsT0FBRCxFQUFVMUcsT0FBVixFQUFtQmhQLEdBQW5CLEVBQXdCcEgsS0FBeEIsQ0FBbEI7QUFDRDs7QUFFRCxRQUFJNmQsVUFBVSxHQUFHZixPQUFPLElBQUlBLE9BQU8sS0FBSyxLQUFLQSxPQUE3QztBQUNBLFFBQUlnQixVQUFVLEdBQUdELFVBQVUsR0FBR3pILE9BQUgsR0FBYTdHLE9BQU8sQ0FBQzZHLE9BQUQsQ0FBL0M7O0FBRUEsUUFBSXNILE1BQUosRUFBWTtBQUNWLFVBQUlGLE9BQUosRUFBYTtBQUNYQyxXQUFHLEtBQUtoTyxHQUFHLEdBQUcsQ0FBZCxHQUFrQnFPLFVBQVUsQ0FBQzdVLEdBQVgsRUFBbEIsR0FBc0M2VSxVQUFVLENBQUNMLEdBQUQsQ0FBVixHQUFrQkssVUFBVSxDQUFDN1UsR0FBWCxFQUF4RDtBQUNELE9BRkQsTUFFTztBQUNMNlUsa0JBQVUsQ0FBQ0wsR0FBRCxDQUFWLEdBQWtCLENBQUNyVyxHQUFELEVBQU1wSCxLQUFOLENBQWxCO0FBQ0Q7QUFDRixLQU5ELE1BTU87QUFDTDhkLGdCQUFVLENBQUM3VCxJQUFYLENBQWdCLENBQUM3QyxHQUFELEVBQU1wSCxLQUFOLENBQWhCO0FBQ0Q7O0FBRUQsUUFBSTZkLFVBQUosRUFBZ0I7QUFDZCxXQUFLekgsT0FBTCxHQUFlMEgsVUFBZjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sSUFBSVYsWUFBSixDQUFpQk4sT0FBakIsRUFBMEJnQixVQUExQixDQUFQO0FBQ0QsR0E5Q0Q7O0FBbURBLFdBQVNDLGlCQUFULENBQTJCakIsT0FBM0IsRUFBb0NrQixNQUFwQyxFQUE0Q0MsS0FBNUMsRUFBbUQ7QUFDakQsU0FBS25CLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtrQixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7QUFFREYsbUJBQWlCLENBQUNsWixTQUFsQixDQUE0QmdQLEdBQTVCLEdBQWtDLFVBQVM3SyxLQUFULEVBQWdCcVUsT0FBaEIsRUFBeUJqVyxHQUF6QixFQUE4QjBNLFdBQTlCLEVBQTJDO0FBQzNFLFFBQUl1SixPQUFPLEtBQUt4ZSxTQUFoQixFQUEyQjtBQUN6QndlLGFBQU8sR0FBRzdFLElBQUksQ0FBQ3BSLEdBQUQsQ0FBZDtBQUNEOztBQUNELFFBQUk4VyxHQUFHLEdBQUksTUFBTSxDQUFDbFYsS0FBSyxLQUFLLENBQVYsR0FBY3FVLE9BQWQsR0FBd0JBLE9BQU8sS0FBS3JVLEtBQXJDLElBQThDK0YsSUFBcEQsQ0FBWDtBQUNBLFFBQUlpUCxNQUFNLEdBQUcsS0FBS0EsTUFBbEI7QUFDQSxXQUFPLENBQUNBLE1BQU0sR0FBR0UsR0FBVixNQUFtQixDQUFuQixHQUF1QnBLLFdBQXZCLEdBQ0wsS0FBS21LLEtBQUwsQ0FBV0UsUUFBUSxDQUFDSCxNQUFNLEdBQUlFLEdBQUcsR0FBRyxDQUFqQixDQUFuQixFQUF5Q3JLLEdBQXpDLENBQTZDN0ssS0FBSyxHQUFHNkYsS0FBckQsRUFBNER3TyxPQUE1RCxFQUFxRWpXLEdBQXJFLEVBQTBFME0sV0FBMUUsQ0FERjtBQUVELEdBUkQ7O0FBVUFpSyxtQkFBaUIsQ0FBQ2xaLFNBQWxCLENBQTRCdkcsTUFBNUIsR0FBcUMsVUFBU3dlLE9BQVQsRUFBa0I5VCxLQUFsQixFQUF5QnFVLE9BQXpCLEVBQWtDalcsR0FBbEMsRUFBdUNwSCxLQUF2QyxFQUE4Q3NkLGFBQTlDLEVBQTZEQyxRQUE3RCxFQUF1RTtBQUMxRyxRQUFJRixPQUFPLEtBQUt4ZSxTQUFoQixFQUEyQjtBQUN6QndlLGFBQU8sR0FBRzdFLElBQUksQ0FBQ3BSLEdBQUQsQ0FBZDtBQUNEOztBQUNELFFBQUlnWCxXQUFXLEdBQUcsQ0FBQ3BWLEtBQUssS0FBSyxDQUFWLEdBQWNxVSxPQUFkLEdBQXdCQSxPQUFPLEtBQUtyVSxLQUFyQyxJQUE4QytGLElBQWhFO0FBQ0EsUUFBSW1QLEdBQUcsR0FBRyxLQUFLRSxXQUFmO0FBQ0EsUUFBSUosTUFBTSxHQUFHLEtBQUtBLE1BQWxCO0FBQ0EsUUFBSU4sTUFBTSxHQUFHLENBQUNNLE1BQU0sR0FBR0UsR0FBVixNQUFtQixDQUFoQzs7QUFFQSxRQUFJLENBQUNSLE1BQUQsSUFBVzFkLEtBQUssS0FBS2dQLE9BQXpCLEVBQWtDO0FBQ2hDLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUl5TyxHQUFHLEdBQUdVLFFBQVEsQ0FBQ0gsTUFBTSxHQUFJRSxHQUFHLEdBQUcsQ0FBakIsQ0FBbEI7QUFDQSxRQUFJRCxLQUFLLEdBQUcsS0FBS0EsS0FBakI7QUFDQSxRQUFJbGdCLElBQUksR0FBRzJmLE1BQU0sR0FBR08sS0FBSyxDQUFDUixHQUFELENBQVIsR0FBZ0I1ZSxTQUFqQztBQUNBLFFBQUl3ZixPQUFPLEdBQUdDLFVBQVUsQ0FBQ3ZnQixJQUFELEVBQU8rZSxPQUFQLEVBQWdCOVQsS0FBSyxHQUFHNkYsS0FBeEIsRUFBK0J3TyxPQUEvQixFQUF3Q2pXLEdBQXhDLEVBQTZDcEgsS0FBN0MsRUFBb0RzZCxhQUFwRCxFQUFtRUMsUUFBbkUsQ0FBeEI7O0FBRUEsUUFBSWMsT0FBTyxLQUFLdGdCLElBQWhCLEVBQXNCO0FBQ3BCLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUksQ0FBQzJmLE1BQUQsSUFBV1csT0FBWCxJQUFzQkosS0FBSyxDQUFDbmYsTUFBTixJQUFnQnlmLHVCQUExQyxFQUFtRTtBQUNqRSxhQUFPQyxXQUFXLENBQUMxQixPQUFELEVBQVVtQixLQUFWLEVBQWlCRCxNQUFqQixFQUF5QkksV0FBekIsRUFBc0NDLE9BQXRDLENBQWxCO0FBQ0Q7O0FBRUQsUUFBSVgsTUFBTSxJQUFJLENBQUNXLE9BQVgsSUFBc0JKLEtBQUssQ0FBQ25mLE1BQU4sS0FBaUIsQ0FBdkMsSUFBNEMyZixVQUFVLENBQUNSLEtBQUssQ0FBQ1IsR0FBRyxHQUFHLENBQVAsQ0FBTixDQUExRCxFQUE0RTtBQUMxRSxhQUFPUSxLQUFLLENBQUNSLEdBQUcsR0FBRyxDQUFQLENBQVo7QUFDRDs7QUFFRCxRQUFJQyxNQUFNLElBQUlXLE9BQVYsSUFBcUJKLEtBQUssQ0FBQ25mLE1BQU4sS0FBaUIsQ0FBdEMsSUFBMkMyZixVQUFVLENBQUNKLE9BQUQsQ0FBekQsRUFBb0U7QUFDbEUsYUFBT0EsT0FBUDtBQUNEOztBQUVELFFBQUlSLFVBQVUsR0FBR2YsT0FBTyxJQUFJQSxPQUFPLEtBQUssS0FBS0EsT0FBN0M7QUFDQSxRQUFJNEIsU0FBUyxHQUFHaEIsTUFBTSxHQUFHVyxPQUFPLEdBQUdMLE1BQUgsR0FBWUEsTUFBTSxHQUFHRSxHQUEvQixHQUFxQ0YsTUFBTSxHQUFHRSxHQUFwRTtBQUNBLFFBQUlTLFFBQVEsR0FBR2pCLE1BQU0sR0FBR1csT0FBTyxHQUM3QjNELEtBQUssQ0FBQ3VELEtBQUQsRUFBUVIsR0FBUixFQUFhWSxPQUFiLEVBQXNCUixVQUF0QixDQUR3QixHQUU3QmUsU0FBUyxDQUFDWCxLQUFELEVBQVFSLEdBQVIsRUFBYUksVUFBYixDQUZVLEdBR25CZ0IsUUFBUSxDQUFDWixLQUFELEVBQVFSLEdBQVIsRUFBYVksT0FBYixFQUFzQlIsVUFBdEIsQ0FIVjs7QUFLQSxRQUFJQSxVQUFKLEVBQWdCO0FBQ2QsV0FBS0csTUFBTCxHQUFjVSxTQUFkO0FBQ0EsV0FBS1QsS0FBTCxHQUFhVSxRQUFiO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTyxJQUFJWixpQkFBSixDQUFzQmpCLE9BQXRCLEVBQStCNEIsU0FBL0IsRUFBMENDLFFBQTFDLENBQVA7QUFDRCxHQWhERDs7QUFxREEsV0FBU0csZ0JBQVQsQ0FBMEJoQyxPQUExQixFQUFtQ2lDLEtBQW5DLEVBQTBDZCxLQUExQyxFQUFpRDtBQUMvQyxTQUFLbkIsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS2lDLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtkLEtBQUwsR0FBYUEsS0FBYjtBQUNEOztBQUVEYSxrQkFBZ0IsQ0FBQ2phLFNBQWpCLENBQTJCZ1AsR0FBM0IsR0FBaUMsVUFBUzdLLEtBQVQsRUFBZ0JxVSxPQUFoQixFQUF5QmpXLEdBQXpCLEVBQThCME0sV0FBOUIsRUFBMkM7QUFDMUUsUUFBSXVKLE9BQU8sS0FBS3hlLFNBQWhCLEVBQTJCO0FBQ3pCd2UsYUFBTyxHQUFHN0UsSUFBSSxDQUFDcFIsR0FBRCxDQUFkO0FBQ0Q7O0FBQ0QsUUFBSXFXLEdBQUcsR0FBRyxDQUFDelUsS0FBSyxLQUFLLENBQVYsR0FBY3FVLE9BQWQsR0FBd0JBLE9BQU8sS0FBS3JVLEtBQXJDLElBQThDK0YsSUFBeEQ7QUFDQSxRQUFJaFIsSUFBSSxHQUFHLEtBQUtrZ0IsS0FBTCxDQUFXUixHQUFYLENBQVg7QUFDQSxXQUFPMWYsSUFBSSxHQUFHQSxJQUFJLENBQUM4VixHQUFMLENBQVM3SyxLQUFLLEdBQUc2RixLQUFqQixFQUF3QndPLE9BQXhCLEVBQWlDalcsR0FBakMsRUFBc0MwTSxXQUF0QyxDQUFILEdBQXdEQSxXQUFuRTtBQUNELEdBUEQ7O0FBU0FnTCxrQkFBZ0IsQ0FBQ2phLFNBQWpCLENBQTJCdkcsTUFBM0IsR0FBb0MsVUFBU3dlLE9BQVQsRUFBa0I5VCxLQUFsQixFQUF5QnFVLE9BQXpCLEVBQWtDalcsR0FBbEMsRUFBdUNwSCxLQUF2QyxFQUE4Q3NkLGFBQTlDLEVBQTZEQyxRQUE3RCxFQUF1RTtBQUN6RyxRQUFJRixPQUFPLEtBQUt4ZSxTQUFoQixFQUEyQjtBQUN6QndlLGFBQU8sR0FBRzdFLElBQUksQ0FBQ3BSLEdBQUQsQ0FBZDtBQUNEOztBQUNELFFBQUlxVyxHQUFHLEdBQUcsQ0FBQ3pVLEtBQUssS0FBSyxDQUFWLEdBQWNxVSxPQUFkLEdBQXdCQSxPQUFPLEtBQUtyVSxLQUFyQyxJQUE4QytGLElBQXhEO0FBQ0EsUUFBSXlPLE9BQU8sR0FBR3hkLEtBQUssS0FBS2dQLE9BQXhCO0FBQ0EsUUFBSWlQLEtBQUssR0FBRyxLQUFLQSxLQUFqQjtBQUNBLFFBQUlsZ0IsSUFBSSxHQUFHa2dCLEtBQUssQ0FBQ1IsR0FBRCxDQUFoQjs7QUFFQSxRQUFJRCxPQUFPLElBQUksQ0FBQ3pmLElBQWhCLEVBQXNCO0FBQ3BCLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUlzZ0IsT0FBTyxHQUFHQyxVQUFVLENBQUN2Z0IsSUFBRCxFQUFPK2UsT0FBUCxFQUFnQjlULEtBQUssR0FBRzZGLEtBQXhCLEVBQStCd08sT0FBL0IsRUFBd0NqVyxHQUF4QyxFQUE2Q3BILEtBQTdDLEVBQW9Ec2QsYUFBcEQsRUFBbUVDLFFBQW5FLENBQXhCOztBQUNBLFFBQUljLE9BQU8sS0FBS3RnQixJQUFoQixFQUFzQjtBQUNwQixhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJaWhCLFFBQVEsR0FBRyxLQUFLRCxLQUFwQjs7QUFDQSxRQUFJLENBQUNoaEIsSUFBTCxFQUFXO0FBQ1RpaEIsY0FBUTtBQUNULEtBRkQsTUFFTyxJQUFJLENBQUNYLE9BQUwsRUFBYztBQUNuQlcsY0FBUTs7QUFDUixVQUFJQSxRQUFRLEdBQUdDLHVCQUFmLEVBQXdDO0FBQ3RDLGVBQU9DLFNBQVMsQ0FBQ3BDLE9BQUQsRUFBVW1CLEtBQVYsRUFBaUJlLFFBQWpCLEVBQTJCdkIsR0FBM0IsQ0FBaEI7QUFDRDtBQUNGOztBQUVELFFBQUlJLFVBQVUsR0FBR2YsT0FBTyxJQUFJQSxPQUFPLEtBQUssS0FBS0EsT0FBN0M7QUFDQSxRQUFJNkIsUUFBUSxHQUFHakUsS0FBSyxDQUFDdUQsS0FBRCxFQUFRUixHQUFSLEVBQWFZLE9BQWIsRUFBc0JSLFVBQXRCLENBQXBCOztBQUVBLFFBQUlBLFVBQUosRUFBZ0I7QUFDZCxXQUFLa0IsS0FBTCxHQUFhQyxRQUFiO0FBQ0EsV0FBS2YsS0FBTCxHQUFhVSxRQUFiO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTyxJQUFJRyxnQkFBSixDQUFxQmhDLE9BQXJCLEVBQThCa0MsUUFBOUIsRUFBd0NMLFFBQXhDLENBQVA7QUFDRCxHQXRDRDs7QUEyQ0EsV0FBU1EsaUJBQVQsQ0FBMkJyQyxPQUEzQixFQUFvQ08sT0FBcEMsRUFBNkNqSCxPQUE3QyxFQUFzRDtBQUNwRCxTQUFLMEcsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS08sT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS2pILE9BQUwsR0FBZUEsT0FBZjtBQUNEOztBQUVEK0ksbUJBQWlCLENBQUN0YSxTQUFsQixDQUE0QmdQLEdBQTVCLEdBQWtDLFVBQVM3SyxLQUFULEVBQWdCcVUsT0FBaEIsRUFBeUJqVyxHQUF6QixFQUE4QjBNLFdBQTlCLEVBQTJDO0FBQzNFLFFBQUlzQyxPQUFPLEdBQUcsS0FBS0EsT0FBbkI7O0FBQ0EsU0FBSyxJQUFJeEcsRUFBRSxHQUFHLENBQVQsRUFBWUgsR0FBRyxHQUFHMkcsT0FBTyxDQUFDdFgsTUFBL0IsRUFBdUM4USxFQUFFLEdBQUdILEdBQTVDLEVBQWlERyxFQUFFLEVBQW5ELEVBQXVEO0FBQ3JELFVBQUlnRyxFQUFFLENBQUN4TyxHQUFELEVBQU1nUCxPQUFPLENBQUN4RyxFQUFELENBQVAsQ0FBWSxDQUFaLENBQU4sQ0FBTixFQUE2QjtBQUMzQixlQUFPd0csT0FBTyxDQUFDeEcsRUFBRCxDQUFQLENBQVksQ0FBWixDQUFQO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPa0UsV0FBUDtBQUNELEdBUkQ7O0FBVUFxTCxtQkFBaUIsQ0FBQ3RhLFNBQWxCLENBQTRCdkcsTUFBNUIsR0FBcUMsVUFBU3dlLE9BQVQsRUFBa0I5VCxLQUFsQixFQUF5QnFVLE9BQXpCLEVBQWtDalcsR0FBbEMsRUFBdUNwSCxLQUF2QyxFQUE4Q3NkLGFBQTlDLEVBQTZEQyxRQUE3RCxFQUF1RTtBQUMxRyxRQUFJRixPQUFPLEtBQUt4ZSxTQUFoQixFQUEyQjtBQUN6QndlLGFBQU8sR0FBRzdFLElBQUksQ0FBQ3BSLEdBQUQsQ0FBZDtBQUNEOztBQUVELFFBQUlvVyxPQUFPLEdBQUd4ZCxLQUFLLEtBQUtnUCxPQUF4Qjs7QUFFQSxRQUFJcU8sT0FBTyxLQUFLLEtBQUtBLE9BQXJCLEVBQThCO0FBQzVCLFVBQUlHLE9BQUosRUFBYTtBQUNYLGVBQU8sSUFBUDtBQUNEOztBQUNEbk8sWUFBTSxDQUFDa08sUUFBRCxDQUFOO0FBQ0FsTyxZQUFNLENBQUNpTyxhQUFELENBQU47QUFDQSxhQUFPOEIsYUFBYSxDQUFDLElBQUQsRUFBT3RDLE9BQVAsRUFBZ0I5VCxLQUFoQixFQUF1QnFVLE9BQXZCLEVBQWdDLENBQUNqVyxHQUFELEVBQU1wSCxLQUFOLENBQWhDLENBQXBCO0FBQ0Q7O0FBRUQsUUFBSW9XLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtBQUNBLFFBQUlxSCxHQUFHLEdBQUcsQ0FBVjs7QUFDQSxTQUFLLElBQUloTyxHQUFHLEdBQUcyRyxPQUFPLENBQUN0WCxNQUF2QixFQUErQjJlLEdBQUcsR0FBR2hPLEdBQXJDLEVBQTBDZ08sR0FBRyxFQUE3QyxFQUFpRDtBQUMvQyxVQUFJN0gsRUFBRSxDQUFDeE8sR0FBRCxFQUFNZ1AsT0FBTyxDQUFDcUgsR0FBRCxDQUFQLENBQWEsQ0FBYixDQUFOLENBQU4sRUFBOEI7QUFDNUI7QUFDRDtBQUNGOztBQUNELFFBQUlDLE1BQU0sR0FBR0QsR0FBRyxHQUFHaE8sR0FBbkI7O0FBRUEsUUFBSWlPLE1BQU0sR0FBR3RILE9BQU8sQ0FBQ3FILEdBQUQsQ0FBUCxDQUFhLENBQWIsTUFBb0J6ZCxLQUF2QixHQUErQndkLE9BQXpDLEVBQWtEO0FBQ2hELGFBQU8sSUFBUDtBQUNEOztBQUVEbk8sVUFBTSxDQUFDa08sUUFBRCxDQUFOO0FBQ0EsS0FBQ0MsT0FBTyxJQUFJLENBQUNFLE1BQWIsS0FBd0JyTyxNQUFNLENBQUNpTyxhQUFELENBQTlCOztBQUVBLFFBQUlFLE9BQU8sSUFBSS9OLEdBQUcsS0FBSyxDQUF2QixFQUEwQjtBQUN4QixhQUFPLElBQUk0UCxTQUFKLENBQWN2QyxPQUFkLEVBQXVCLEtBQUtPLE9BQTVCLEVBQXFDakgsT0FBTyxDQUFDcUgsR0FBRyxHQUFHLENBQVAsQ0FBNUMsQ0FBUDtBQUNEOztBQUVELFFBQUlJLFVBQVUsR0FBR2YsT0FBTyxJQUFJQSxPQUFPLEtBQUssS0FBS0EsT0FBN0M7QUFDQSxRQUFJZ0IsVUFBVSxHQUFHRCxVQUFVLEdBQUd6SCxPQUFILEdBQWE3RyxPQUFPLENBQUM2RyxPQUFELENBQS9DOztBQUVBLFFBQUlzSCxNQUFKLEVBQVk7QUFDVixVQUFJRixPQUFKLEVBQWE7QUFDWEMsV0FBRyxLQUFLaE8sR0FBRyxHQUFHLENBQWQsR0FBa0JxTyxVQUFVLENBQUM3VSxHQUFYLEVBQWxCLEdBQXNDNlUsVUFBVSxDQUFDTCxHQUFELENBQVYsR0FBa0JLLFVBQVUsQ0FBQzdVLEdBQVgsRUFBeEQ7QUFDRCxPQUZELE1BRU87QUFDTDZVLGtCQUFVLENBQUNMLEdBQUQsQ0FBVixHQUFrQixDQUFDclcsR0FBRCxFQUFNcEgsS0FBTixDQUFsQjtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0w4ZCxnQkFBVSxDQUFDN1QsSUFBWCxDQUFnQixDQUFDN0MsR0FBRCxFQUFNcEgsS0FBTixDQUFoQjtBQUNEOztBQUVELFFBQUk2ZCxVQUFKLEVBQWdCO0FBQ2QsV0FBS3pILE9BQUwsR0FBZTBILFVBQWY7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLElBQUlxQixpQkFBSixDQUFzQnJDLE9BQXRCLEVBQStCLEtBQUtPLE9BQXBDLEVBQTZDUyxVQUE3QyxDQUFQO0FBQ0QsR0F2REQ7O0FBNERBLFdBQVN1QixTQUFULENBQW1CdkMsT0FBbkIsRUFBNEJPLE9BQTVCLEVBQXFDbEksS0FBckMsRUFBNEM7QUFDMUMsU0FBSzJILE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtPLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtsSSxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7QUFFRGtLLFdBQVMsQ0FBQ3hhLFNBQVYsQ0FBb0JnUCxHQUFwQixHQUEwQixVQUFTN0ssS0FBVCxFQUFnQnFVLE9BQWhCLEVBQXlCalcsR0FBekIsRUFBOEIwTSxXQUE5QixFQUEyQztBQUNuRSxXQUFPOEIsRUFBRSxDQUFDeE8sR0FBRCxFQUFNLEtBQUsrTixLQUFMLENBQVcsQ0FBWCxDQUFOLENBQUYsR0FBeUIsS0FBS0EsS0FBTCxDQUFXLENBQVgsQ0FBekIsR0FBeUNyQixXQUFoRDtBQUNELEdBRkQ7O0FBSUF1TCxXQUFTLENBQUN4YSxTQUFWLENBQW9CdkcsTUFBcEIsR0FBNkIsVUFBU3dlLE9BQVQsRUFBa0I5VCxLQUFsQixFQUF5QnFVLE9BQXpCLEVBQWtDalcsR0FBbEMsRUFBdUNwSCxLQUF2QyxFQUE4Q3NkLGFBQTlDLEVBQTZEQyxRQUE3RCxFQUF1RTtBQUNsRyxRQUFJQyxPQUFPLEdBQUd4ZCxLQUFLLEtBQUtnUCxPQUF4QjtBQUNBLFFBQUlzUSxRQUFRLEdBQUcxSixFQUFFLENBQUN4TyxHQUFELEVBQU0sS0FBSytOLEtBQUwsQ0FBVyxDQUFYLENBQU4sQ0FBakI7O0FBQ0EsUUFBSW1LLFFBQVEsR0FBR3RmLEtBQUssS0FBSyxLQUFLbVYsS0FBTCxDQUFXLENBQVgsQ0FBYixHQUE2QnFJLE9BQXpDLEVBQWtEO0FBQ2hELGFBQU8sSUFBUDtBQUNEOztBQUVEbk8sVUFBTSxDQUFDa08sUUFBRCxDQUFOOztBQUVBLFFBQUlDLE9BQUosRUFBYTtBQUNYbk8sWUFBTSxDQUFDaU8sYUFBRCxDQUFOO0FBQ0EsYUFGVyxDQUVIO0FBQ1Q7O0FBRUQsUUFBSWdDLFFBQUosRUFBYztBQUNaLFVBQUl4QyxPQUFPLElBQUlBLE9BQU8sS0FBSyxLQUFLQSxPQUFoQyxFQUF5QztBQUN2QyxhQUFLM0gsS0FBTCxDQUFXLENBQVgsSUFBZ0JuVixLQUFoQjtBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUNELGFBQU8sSUFBSXFmLFNBQUosQ0FBY3ZDLE9BQWQsRUFBdUIsS0FBS08sT0FBNUIsRUFBcUMsQ0FBQ2pXLEdBQUQsRUFBTXBILEtBQU4sQ0FBckMsQ0FBUDtBQUNEOztBQUVEcVAsVUFBTSxDQUFDaU8sYUFBRCxDQUFOO0FBQ0EsV0FBTzhCLGFBQWEsQ0FBQyxJQUFELEVBQU90QyxPQUFQLEVBQWdCOVQsS0FBaEIsRUFBdUJ3UCxJQUFJLENBQUNwUixHQUFELENBQTNCLEVBQWtDLENBQUNBLEdBQUQsRUFBTXBILEtBQU4sQ0FBbEMsQ0FBcEI7QUFDRCxHQXhCRCxDQWhwRGdCLENBNHFEbEI7OztBQUVBb2QsY0FBWSxDQUFDdlksU0FBYixDQUF1QmdZLE9BQXZCLEdBQ0FzQyxpQkFBaUIsQ0FBQ3RhLFNBQWxCLENBQTRCZ1ksT0FBNUIsR0FBc0MsVUFBVS9KLEVBQVYsRUFBY0MsT0FBZCxFQUF1QjtBQUMzRCxRQUFJcUQsT0FBTyxHQUFHLEtBQUtBLE9BQW5COztBQUNBLFNBQUssSUFBSXhHLEVBQUUsR0FBRyxDQUFULEVBQVlvRSxRQUFRLEdBQUdvQyxPQUFPLENBQUN0WCxNQUFSLEdBQWlCLENBQTdDLEVBQWdEOFEsRUFBRSxJQUFJb0UsUUFBdEQsRUFBZ0VwRSxFQUFFLEVBQWxFLEVBQXNFO0FBQ3BFLFVBQUlrRCxFQUFFLENBQUNzRCxPQUFPLENBQUNyRCxPQUFPLEdBQUdpQixRQUFRLEdBQUdwRSxFQUFkLEdBQW1CQSxFQUEzQixDQUFSLENBQUYsS0FBOEMsS0FBbEQsRUFBeUQ7QUFDdkQsZUFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGLEdBUkQ7O0FBVUFtTyxtQkFBaUIsQ0FBQ2xaLFNBQWxCLENBQTRCZ1ksT0FBNUIsR0FDQWlDLGdCQUFnQixDQUFDamEsU0FBakIsQ0FBMkJnWSxPQUEzQixHQUFxQyxVQUFVL0osRUFBVixFQUFjQyxPQUFkLEVBQXVCO0FBQzFELFFBQUlrTCxLQUFLLEdBQUcsS0FBS0EsS0FBakI7O0FBQ0EsU0FBSyxJQUFJck8sRUFBRSxHQUFHLENBQVQsRUFBWW9FLFFBQVEsR0FBR2lLLEtBQUssQ0FBQ25mLE1BQU4sR0FBZSxDQUEzQyxFQUE4QzhRLEVBQUUsSUFBSW9FLFFBQXBELEVBQThEcEUsRUFBRSxFQUFoRSxFQUFvRTtBQUNsRSxVQUFJN1IsSUFBSSxHQUFHa2dCLEtBQUssQ0FBQ2xMLE9BQU8sR0FBR2lCLFFBQVEsR0FBR3BFLEVBQWQsR0FBbUJBLEVBQTNCLENBQWhCOztBQUNBLFVBQUk3UixJQUFJLElBQUlBLElBQUksQ0FBQzhlLE9BQUwsQ0FBYS9KLEVBQWIsRUFBaUJDLE9BQWpCLE1BQThCLEtBQTFDLEVBQWlEO0FBQy9DLGVBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRixHQVREOztBQVdBc00sV0FBUyxDQUFDeGEsU0FBVixDQUFvQmdZLE9BQXBCLEdBQThCLFVBQVUvSixFQUFWLEVBQWNDLE9BQWQsRUFBdUI7QUFDbkQsV0FBT0QsRUFBRSxDQUFDLEtBQUtxQyxLQUFOLENBQVQ7QUFDRCxHQUZEOztBQUlBcEksYUFBVyxDQUFDNlAsV0FBRCxFQUFjMUwsUUFBZCxDQUFYOztBQUVFLFdBQVMwTCxXQUFULENBQXFCdGQsR0FBckIsRUFBMEJyRixJQUExQixFQUFnQzhZLE9BQWhDLEVBQXlDO0FBQ3ZDLFNBQUt3TSxLQUFMLEdBQWF0bEIsSUFBYjtBQUNBLFNBQUt1bEIsUUFBTCxHQUFnQnpNLE9BQWhCO0FBQ0EsU0FBSzBNLE1BQUwsR0FBY25nQixHQUFHLENBQUNrYixLQUFKLElBQWFrRixnQkFBZ0IsQ0FBQ3BnQixHQUFHLENBQUNrYixLQUFMLENBQTNDO0FBQ0Q7O0FBRURvQyxhQUFXLENBQUMvWCxTQUFaLENBQXNCc00sSUFBdEIsR0FBNkIsWUFBVztBQUN0QyxRQUFJbFgsSUFBSSxHQUFHLEtBQUtzbEIsS0FBaEI7QUFDQSxRQUFJSSxLQUFLLEdBQUcsS0FBS0YsTUFBakI7O0FBQ0EsV0FBT0UsS0FBUCxFQUFjO0FBQ1osVUFBSTVoQixJQUFJLEdBQUc0aEIsS0FBSyxDQUFDNWhCLElBQWpCO0FBQ0EsVUFBSWlKLEtBQUssR0FBRzJZLEtBQUssQ0FBQzNZLEtBQU4sRUFBWjtBQUNBLFVBQUlnTixRQUFKOztBQUNBLFVBQUlqVyxJQUFJLENBQUNvWCxLQUFULEVBQWdCO0FBQ2QsWUFBSW5PLEtBQUssS0FBSyxDQUFkLEVBQWlCO0FBQ2YsaUJBQU80WSxnQkFBZ0IsQ0FBQzNsQixJQUFELEVBQU84RCxJQUFJLENBQUNvWCxLQUFaLENBQXZCO0FBQ0Q7QUFDRixPQUpELE1BSU8sSUFBSXBYLElBQUksQ0FBQ3FZLE9BQVQsRUFBa0I7QUFDdkJwQyxnQkFBUSxHQUFHalcsSUFBSSxDQUFDcVksT0FBTCxDQUFhdFgsTUFBYixHQUFzQixDQUFqQzs7QUFDQSxZQUFJa0ksS0FBSyxJQUFJZ04sUUFBYixFQUF1QjtBQUNyQixpQkFBTzRMLGdCQUFnQixDQUFDM2xCLElBQUQsRUFBTzhELElBQUksQ0FBQ3FZLE9BQUwsQ0FBYSxLQUFLb0osUUFBTCxHQUFnQnhMLFFBQVEsR0FBR2hOLEtBQTNCLEdBQW1DQSxLQUFoRCxDQUFQLENBQXZCO0FBQ0Q7QUFDRixPQUxNLE1BS0E7QUFDTGdOLGdCQUFRLEdBQUdqVyxJQUFJLENBQUNrZ0IsS0FBTCxDQUFXbmYsTUFBWCxHQUFvQixDQUEvQjs7QUFDQSxZQUFJa0ksS0FBSyxJQUFJZ04sUUFBYixFQUF1QjtBQUNyQixjQUFJNkwsT0FBTyxHQUFHOWhCLElBQUksQ0FBQ2tnQixLQUFMLENBQVcsS0FBS3VCLFFBQUwsR0FBZ0J4TCxRQUFRLEdBQUdoTixLQUEzQixHQUFtQ0EsS0FBOUMsQ0FBZDs7QUFDQSxjQUFJNlksT0FBSixFQUFhO0FBQ1gsZ0JBQUlBLE9BQU8sQ0FBQzFLLEtBQVosRUFBbUI7QUFDakIscUJBQU95SyxnQkFBZ0IsQ0FBQzNsQixJQUFELEVBQU80bEIsT0FBTyxDQUFDMUssS0FBZixDQUF2QjtBQUNEOztBQUNEd0ssaUJBQUssR0FBRyxLQUFLRixNQUFMLEdBQWNDLGdCQUFnQixDQUFDRyxPQUFELEVBQVVGLEtBQVYsQ0FBdEM7QUFDRDs7QUFDRDtBQUNEO0FBQ0Y7O0FBQ0RBLFdBQUssR0FBRyxLQUFLRixNQUFMLEdBQWMsS0FBS0EsTUFBTCxDQUFZSyxNQUFsQztBQUNEOztBQUNELFdBQU9oTyxZQUFZLEVBQW5CO0FBQ0QsR0FoQ0Q7O0FBbUNGLFdBQVM4TixnQkFBVCxDQUEwQjNsQixJQUExQixFQUFnQ2tiLEtBQWhDLEVBQXVDO0FBQ3JDLFdBQU8xRCxhQUFhLENBQUN4WCxJQUFELEVBQU9rYixLQUFLLENBQUMsQ0FBRCxDQUFaLEVBQWlCQSxLQUFLLENBQUMsQ0FBRCxDQUF0QixDQUFwQjtBQUNEOztBQUVELFdBQVN1SyxnQkFBVCxDQUEwQjNoQixJQUExQixFQUFnQ2dpQixJQUFoQyxFQUFzQztBQUNwQyxXQUFPO0FBQ0xoaUIsVUFBSSxFQUFFQSxJQUREO0FBRUxpSixXQUFLLEVBQUUsQ0FGRjtBQUdMOFksWUFBTSxFQUFFQztBQUhILEtBQVA7QUFLRDs7QUFFRCxXQUFTaEQsT0FBVCxDQUFpQjdoQixJQUFqQixFQUF1QjhrQixJQUF2QixFQUE2QmxELE9BQTdCLEVBQXNDdEUsSUFBdEMsRUFBNEM7QUFDMUMsUUFBSWxaLEdBQUcsR0FBR3lHLE1BQU0sQ0FBQ21ILE1BQVAsQ0FBY2dRLFlBQWQsQ0FBVjtBQUNBNWQsT0FBRyxDQUFDcEUsSUFBSixHQUFXQSxJQUFYO0FBQ0FvRSxPQUFHLENBQUNrYixLQUFKLEdBQVl3RixJQUFaO0FBQ0ExZ0IsT0FBRyxDQUFDOGIsU0FBSixHQUFnQjBCLE9BQWhCO0FBQ0F4ZCxPQUFHLENBQUM0VyxNQUFKLEdBQWFzQyxJQUFiO0FBQ0FsWixPQUFHLENBQUMrYixTQUFKLEdBQWdCLEtBQWhCO0FBQ0EsV0FBTy9iLEdBQVA7QUFDRDs7QUFFRCxNQUFJMmdCLFNBQUo7O0FBQ0EsV0FBUzdGLFFBQVQsR0FBb0I7QUFDbEIsV0FBTzZGLFNBQVMsS0FBS0EsU0FBUyxHQUFHbEQsT0FBTyxDQUFDLENBQUQsQ0FBeEIsQ0FBaEI7QUFDRDs7QUFFRCxXQUFTdEMsU0FBVCxDQUFtQm5iLEdBQW5CLEVBQXdCb1MsQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCO0FBQzVCLFFBQUl1TyxPQUFKO0FBQ0EsUUFBSUMsT0FBSjs7QUFDQSxRQUFJLENBQUM3Z0IsR0FBRyxDQUFDa2IsS0FBVCxFQUFnQjtBQUNkLFVBQUk3SSxDQUFDLEtBQUszQyxPQUFWLEVBQW1CO0FBQ2pCLGVBQU8xUCxHQUFQO0FBQ0Q7O0FBQ0Q2Z0IsYUFBTyxHQUFHLENBQVY7QUFDQUQsYUFBTyxHQUFHLElBQUk5QyxZQUFKLENBQWlCOWQsR0FBRyxDQUFDOGIsU0FBckIsRUFBZ0MsQ0FBQyxDQUFDMUosQ0FBRCxFQUFJQyxDQUFKLENBQUQsQ0FBaEMsQ0FBVjtBQUNELEtBTkQsTUFNTztBQUNMLFVBQUkyTCxhQUFhLEdBQUduTyxPQUFPLENBQUNGLGFBQUQsQ0FBM0I7QUFDQSxVQUFJc08sUUFBUSxHQUFHcE8sT0FBTyxDQUFDRCxTQUFELENBQXRCO0FBQ0FnUixhQUFPLEdBQUc1QixVQUFVLENBQUNoZixHQUFHLENBQUNrYixLQUFMLEVBQVlsYixHQUFHLENBQUM4YixTQUFoQixFQUEyQixDQUEzQixFQUE4QnZjLFNBQTlCLEVBQXlDNlMsQ0FBekMsRUFBNENDLENBQTVDLEVBQStDMkwsYUFBL0MsRUFBOERDLFFBQTlELENBQXBCOztBQUNBLFVBQUksQ0FBQ0EsUUFBUSxDQUFDdmQsS0FBZCxFQUFxQjtBQUNuQixlQUFPVixHQUFQO0FBQ0Q7O0FBQ0Q2Z0IsYUFBTyxHQUFHN2dCLEdBQUcsQ0FBQ3BFLElBQUosSUFBWW9pQixhQUFhLENBQUN0ZCxLQUFkLEdBQXNCMlIsQ0FBQyxLQUFLM0MsT0FBTixHQUFnQixDQUFDLENBQWpCLEdBQXFCLENBQTNDLEdBQStDLENBQTNELENBQVY7QUFDRDs7QUFDRCxRQUFJMVAsR0FBRyxDQUFDOGIsU0FBUixFQUFtQjtBQUNqQjliLFNBQUcsQ0FBQ3BFLElBQUosR0FBV2lsQixPQUFYO0FBQ0E3Z0IsU0FBRyxDQUFDa2IsS0FBSixHQUFZMEYsT0FBWjtBQUNBNWdCLFNBQUcsQ0FBQzRXLE1BQUosR0FBYXJYLFNBQWI7QUFDQVMsU0FBRyxDQUFDK2IsU0FBSixHQUFnQixJQUFoQjtBQUNBLGFBQU8vYixHQUFQO0FBQ0Q7O0FBQ0QsV0FBTzRnQixPQUFPLEdBQUduRCxPQUFPLENBQUNvRCxPQUFELEVBQVVELE9BQVYsQ0FBVixHQUErQjlGLFFBQVEsRUFBckQ7QUFDRDs7QUFFRCxXQUFTa0UsVUFBVCxDQUFvQnZnQixJQUFwQixFQUEwQitlLE9BQTFCLEVBQW1DOVQsS0FBbkMsRUFBMENxVSxPQUExQyxFQUFtRGpXLEdBQW5ELEVBQXdEcEgsS0FBeEQsRUFBK0RzZCxhQUEvRCxFQUE4RUMsUUFBOUUsRUFBd0Y7QUFDdEYsUUFBSSxDQUFDeGYsSUFBTCxFQUFXO0FBQ1QsVUFBSWlDLEtBQUssS0FBS2dQLE9BQWQsRUFBdUI7QUFDckIsZUFBT2pSLElBQVA7QUFDRDs7QUFDRHNSLFlBQU0sQ0FBQ2tPLFFBQUQsQ0FBTjtBQUNBbE8sWUFBTSxDQUFDaU8sYUFBRCxDQUFOO0FBQ0EsYUFBTyxJQUFJK0IsU0FBSixDQUFjdkMsT0FBZCxFQUF1Qk8sT0FBdkIsRUFBZ0MsQ0FBQ2pXLEdBQUQsRUFBTXBILEtBQU4sQ0FBaEMsQ0FBUDtBQUNEOztBQUNELFdBQU9qQyxJQUFJLENBQUNPLE1BQUwsQ0FBWXdlLE9BQVosRUFBcUI5VCxLQUFyQixFQUE0QnFVLE9BQTVCLEVBQXFDalcsR0FBckMsRUFBMENwSCxLQUExQyxFQUFpRHNkLGFBQWpELEVBQWdFQyxRQUFoRSxDQUFQO0FBQ0Q7O0FBRUQsV0FBU2tCLFVBQVQsQ0FBb0IxZ0IsSUFBcEIsRUFBMEI7QUFDeEIsV0FBT0EsSUFBSSxDQUFDb1AsV0FBTCxLQUFxQmtTLFNBQXJCLElBQWtDdGhCLElBQUksQ0FBQ29QLFdBQUwsS0FBcUJnUyxpQkFBOUQ7QUFDRDs7QUFFRCxXQUFTQyxhQUFULENBQXVCcmhCLElBQXZCLEVBQTZCK2UsT0FBN0IsRUFBc0M5VCxLQUF0QyxFQUE2Q3FVLE9BQTdDLEVBQXNEbEksS0FBdEQsRUFBNkQ7QUFDM0QsUUFBSXBYLElBQUksQ0FBQ3NmLE9BQUwsS0FBaUJBLE9BQXJCLEVBQThCO0FBQzVCLGFBQU8sSUFBSThCLGlCQUFKLENBQXNCckMsT0FBdEIsRUFBK0JPLE9BQS9CLEVBQXdDLENBQUN0ZixJQUFJLENBQUNvWCxLQUFOLEVBQWFBLEtBQWIsQ0FBeEMsQ0FBUDtBQUNEOztBQUVELFFBQUlpTCxJQUFJLEdBQUcsQ0FBQ3BYLEtBQUssS0FBSyxDQUFWLEdBQWNqTCxJQUFJLENBQUNzZixPQUFuQixHQUE2QnRmLElBQUksQ0FBQ3NmLE9BQUwsS0FBaUJyVSxLQUEvQyxJQUF3RCtGLElBQW5FO0FBQ0EsUUFBSXNSLElBQUksR0FBRyxDQUFDclgsS0FBSyxLQUFLLENBQVYsR0FBY3FVLE9BQWQsR0FBd0JBLE9BQU8sS0FBS3JVLEtBQXJDLElBQThDK0YsSUFBekQ7QUFFQSxRQUFJc1AsT0FBSjtBQUNBLFFBQUlKLEtBQUssR0FBR21DLElBQUksS0FBS0MsSUFBVCxHQUNWLENBQUNqQixhQUFhLENBQUNyaEIsSUFBRCxFQUFPK2UsT0FBUCxFQUFnQjlULEtBQUssR0FBRzZGLEtBQXhCLEVBQStCd08sT0FBL0IsRUFBd0NsSSxLQUF4QyxDQUFkLENBRFUsSUFFUmtKLE9BQU8sR0FBRyxJQUFJZ0IsU0FBSixDQUFjdkMsT0FBZCxFQUF1Qk8sT0FBdkIsRUFBZ0NsSSxLQUFoQyxDQUFYLEVBQW9EaUwsSUFBSSxHQUFHQyxJQUFQLEdBQWMsQ0FBQ3RpQixJQUFELEVBQU9zZ0IsT0FBUCxDQUFkLEdBQWdDLENBQUNBLE9BQUQsRUFBVXRnQixJQUFWLENBRjNFLENBQVo7QUFJQSxXQUFPLElBQUlnZ0IsaUJBQUosQ0FBc0JqQixPQUF0QixFQUFnQyxLQUFLc0QsSUFBTixHQUFlLEtBQUtDLElBQW5ELEVBQTBEcEMsS0FBMUQsQ0FBUDtBQUNEOztBQUVELFdBQVNMLFdBQVQsQ0FBcUJkLE9BQXJCLEVBQThCMUcsT0FBOUIsRUFBdUNoUCxHQUF2QyxFQUE0Q3BILEtBQTVDLEVBQW1EO0FBQ2pELFFBQUksQ0FBQzhjLE9BQUwsRUFBYztBQUNaQSxhQUFPLEdBQUcsSUFBSXhOLE9BQUosRUFBVjtBQUNEOztBQUNELFFBQUl2UixJQUFJLEdBQUcsSUFBSXNoQixTQUFKLENBQWN2QyxPQUFkLEVBQXVCdEUsSUFBSSxDQUFDcFIsR0FBRCxDQUEzQixFQUFrQyxDQUFDQSxHQUFELEVBQU1wSCxLQUFOLENBQWxDLENBQVg7O0FBQ0EsU0FBSyxJQUFJNFAsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR3dHLE9BQU8sQ0FBQ3RYLE1BQTlCLEVBQXNDOFEsRUFBRSxFQUF4QyxFQUE0QztBQUMxQyxVQUFJdUYsS0FBSyxHQUFHaUIsT0FBTyxDQUFDeEcsRUFBRCxDQUFuQjtBQUNBN1IsVUFBSSxHQUFHQSxJQUFJLENBQUNPLE1BQUwsQ0FBWXdlLE9BQVosRUFBcUIsQ0FBckIsRUFBd0JqZSxTQUF4QixFQUFtQ3NXLEtBQUssQ0FBQyxDQUFELENBQXhDLEVBQTZDQSxLQUFLLENBQUMsQ0FBRCxDQUFsRCxDQUFQO0FBQ0Q7O0FBQ0QsV0FBT3BYLElBQVA7QUFDRDs7QUFFRCxXQUFTbWhCLFNBQVQsQ0FBbUJwQyxPQUFuQixFQUE0Qm1CLEtBQTVCLEVBQW1DYyxLQUFuQyxFQUEwQ3VCLFNBQTFDLEVBQXFEO0FBQ25ELFFBQUl0QyxNQUFNLEdBQUcsQ0FBYjtBQUNBLFFBQUl1QyxRQUFRLEdBQUcsQ0FBZjtBQUNBLFFBQUlDLFdBQVcsR0FBRyxJQUFJOWpCLEtBQUosQ0FBVXFpQixLQUFWLENBQWxCOztBQUNBLFNBQUssSUFBSW5QLEVBQUUsR0FBRyxDQUFULEVBQVlzTyxHQUFHLEdBQUcsQ0FBbEIsRUFBcUJ6TyxHQUFHLEdBQUd3TyxLQUFLLENBQUNuZixNQUF0QyxFQUE4QzhRLEVBQUUsR0FBR0gsR0FBbkQsRUFBd0RHLEVBQUUsSUFBSXNPLEdBQUcsS0FBSyxDQUF0RSxFQUF5RTtBQUN2RSxVQUFJbmdCLElBQUksR0FBR2tnQixLQUFLLENBQUNyTyxFQUFELENBQWhCOztBQUNBLFVBQUk3UixJQUFJLEtBQUtjLFNBQVQsSUFBc0IrUSxFQUFFLEtBQUswUSxTQUFqQyxFQUE0QztBQUMxQ3RDLGNBQU0sSUFBSUUsR0FBVjtBQUNBc0MsbUJBQVcsQ0FBQ0QsUUFBUSxFQUFULENBQVgsR0FBMEJ4aUIsSUFBMUI7QUFDRDtBQUNGOztBQUNELFdBQU8sSUFBSWdnQixpQkFBSixDQUFzQmpCLE9BQXRCLEVBQStCa0IsTUFBL0IsRUFBdUN3QyxXQUF2QyxDQUFQO0FBQ0Q7O0FBRUQsV0FBU2hDLFdBQVQsQ0FBcUIxQixPQUFyQixFQUE4Qm1CLEtBQTlCLEVBQXFDRCxNQUFyQyxFQUE2Q3lDLFNBQTdDLEVBQXdEMWlCLElBQXhELEVBQThEO0FBQzVELFFBQUlnaEIsS0FBSyxHQUFHLENBQVo7QUFDQSxRQUFJMkIsYUFBYSxHQUFHLElBQUloa0IsS0FBSixDQUFVb1MsSUFBVixDQUFwQjs7QUFDQSxTQUFLLElBQUljLEVBQUUsR0FBRyxDQUFkLEVBQWlCb08sTUFBTSxLQUFLLENBQTVCLEVBQStCcE8sRUFBRSxJQUFJb08sTUFBTSxNQUFNLENBQWpELEVBQW9EO0FBQ2xEMEMsbUJBQWEsQ0FBQzlRLEVBQUQsQ0FBYixHQUFvQm9PLE1BQU0sR0FBRyxDQUFULEdBQWFDLEtBQUssQ0FBQ2MsS0FBSyxFQUFOLENBQWxCLEdBQThCbGdCLFNBQWxEO0FBQ0Q7O0FBQ0Q2aEIsaUJBQWEsQ0FBQ0QsU0FBRCxDQUFiLEdBQTJCMWlCLElBQTNCO0FBQ0EsV0FBTyxJQUFJK2dCLGdCQUFKLENBQXFCaEMsT0FBckIsRUFBOEJpQyxLQUFLLEdBQUcsQ0FBdEMsRUFBeUMyQixhQUF6QyxDQUFQO0FBQ0Q7O0FBRUQsV0FBU25GLGdCQUFULENBQTBCamMsR0FBMUIsRUFBK0JtYyxNQUEvQixFQUF1Q2tGLFNBQXZDLEVBQWtEO0FBQ2hELFFBQUlqRixLQUFLLEdBQUcsRUFBWjs7QUFDQSxTQUFLLElBQUk5TCxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHK1EsU0FBUyxDQUFDN2hCLE1BQWhDLEVBQXdDOFEsRUFBRSxFQUExQyxFQUE4QztBQUM1QyxVQUFJNVAsS0FBSyxHQUFHMmdCLFNBQVMsQ0FBQy9RLEVBQUQsQ0FBckI7QUFDQSxVQUFJRSxJQUFJLEdBQUd2QyxhQUFhLENBQUN2TixLQUFELENBQXhCOztBQUNBLFVBQUksQ0FBQ3FOLFVBQVUsQ0FBQ3JOLEtBQUQsQ0FBZixFQUF3QjtBQUN0QjhQLFlBQUksR0FBR0EsSUFBSSxDQUFDeFEsR0FBTCxDQUFTLFVBQVNxUyxDQUFULEVBQWE7QUFBQyxpQkFBT2hRLE1BQU0sQ0FBQ2dRLENBQUQsQ0FBYjtBQUFpQixTQUF4QyxDQUFQO0FBQ0Q7O0FBQ0QrSixXQUFLLENBQUN6UixJQUFOLENBQVc2RixJQUFYO0FBQ0Q7O0FBQ0QsV0FBTzhRLHVCQUF1QixDQUFDdGhCLEdBQUQsRUFBTW1jLE1BQU4sRUFBY0MsS0FBZCxDQUE5QjtBQUNEOztBQUVELFdBQVNJLFVBQVQsQ0FBb0IrRSxRQUFwQixFQUE4QjdnQixLQUE5QixFQUFxQ29ILEdBQXJDLEVBQTBDO0FBQ3hDLFdBQU95WixRQUFRLElBQUlBLFFBQVEsQ0FBQ2hGLFNBQXJCLElBQWtDeE8sVUFBVSxDQUFDck4sS0FBRCxDQUE1QyxHQUNMNmdCLFFBQVEsQ0FBQ2hGLFNBQVQsQ0FBbUI3YixLQUFuQixDQURLLEdBRUw0VixFQUFFLENBQUNpTCxRQUFELEVBQVc3Z0IsS0FBWCxDQUFGLEdBQXNCNmdCLFFBQXRCLEdBQWlDN2dCLEtBRm5DO0FBR0Q7O0FBRUQsV0FBU2djLGNBQVQsQ0FBd0JQLE1BQXhCLEVBQWdDO0FBQzlCLFdBQU8sVUFBU29GLFFBQVQsRUFBbUI3Z0IsS0FBbkIsRUFBMEJvSCxHQUExQixFQUFnQztBQUNyQyxVQUFJeVosUUFBUSxJQUFJQSxRQUFRLENBQUM5RSxhQUFyQixJQUFzQzFPLFVBQVUsQ0FBQ3JOLEtBQUQsQ0FBcEQsRUFBNkQ7QUFDM0QsZUFBTzZnQixRQUFRLENBQUM5RSxhQUFULENBQXVCTixNQUF2QixFQUErQnpiLEtBQS9CLENBQVA7QUFDRDs7QUFDRCxVQUFJOGdCLFNBQVMsR0FBR3JGLE1BQU0sQ0FBQ29GLFFBQUQsRUFBVzdnQixLQUFYLEVBQWtCb0gsR0FBbEIsQ0FBdEI7QUFDQSxhQUFPd08sRUFBRSxDQUFDaUwsUUFBRCxFQUFXQyxTQUFYLENBQUYsR0FBMEJELFFBQTFCLEdBQXFDQyxTQUE1QztBQUNELEtBTkQ7QUFPRDs7QUFFRCxXQUFTRix1QkFBVCxDQUFpQ25ZLFVBQWpDLEVBQTZDZ1QsTUFBN0MsRUFBcURDLEtBQXJELEVBQTREO0FBQzFEQSxTQUFLLEdBQUdBLEtBQUssQ0FBQ3JRLE1BQU4sQ0FBYSxVQUFTdkwsQ0FBVCxFQUFhO0FBQUMsYUFBT0EsQ0FBQyxDQUFDNUUsSUFBRixLQUFXLENBQWxCO0FBQW9CLEtBQS9DLENBQVI7O0FBQ0EsUUFBSXdnQixLQUFLLENBQUM1YyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGFBQU8ySixVQUFQO0FBQ0Q7O0FBQ0QsUUFBSUEsVUFBVSxDQUFDdk4sSUFBWCxLQUFvQixDQUFwQixJQUF5QixDQUFDdU4sVUFBVSxDQUFDMlMsU0FBckMsSUFBa0RNLEtBQUssQ0FBQzVjLE1BQU4sS0FBaUIsQ0FBdkUsRUFBMEU7QUFDeEUsYUFBTzJKLFVBQVUsQ0FBQzBFLFdBQVgsQ0FBdUJ1TyxLQUFLLENBQUMsQ0FBRCxDQUE1QixDQUFQO0FBQ0Q7O0FBQ0QsV0FBT2pULFVBQVUsQ0FBQzZSLGFBQVgsQ0FBeUIsVUFBUzdSLFVBQVQsRUFBc0I7QUFDcEQsVUFBSXNZLFlBQVksR0FBR3RGLE1BQU0sR0FDdkIsVUFBU3piLEtBQVQsRUFBZ0JvSCxHQUFoQixFQUFzQjtBQUNwQnFCLGtCQUFVLENBQUNuSyxNQUFYLENBQWtCOEksR0FBbEIsRUFBdUI0SCxPQUF2QixFQUFnQyxVQUFTNlIsUUFBVCxFQUM5QjtBQUFDLGlCQUFPQSxRQUFRLEtBQUs3UixPQUFiLEdBQXVCaFAsS0FBdkIsR0FBK0J5YixNQUFNLENBQUNvRixRQUFELEVBQVc3Z0IsS0FBWCxFQUFrQm9ILEdBQWxCLENBQTVDO0FBQW1FLFNBRHRFO0FBR0QsT0FMc0IsR0FNdkIsVUFBU3BILEtBQVQsRUFBZ0JvSCxHQUFoQixFQUFzQjtBQUNwQnFCLGtCQUFVLENBQUNtUixHQUFYLENBQWV4UyxHQUFmLEVBQW9CcEgsS0FBcEI7QUFDRCxPQVJIOztBQVNBLFdBQUssSUFBSTRQLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUc4TCxLQUFLLENBQUM1YyxNQUE1QixFQUFvQzhRLEVBQUUsRUFBdEMsRUFBMEM7QUFDeEM4TCxhQUFLLENBQUM5TCxFQUFELENBQUwsQ0FBVW5SLE9BQVYsQ0FBa0JzaUIsWUFBbEI7QUFDRDtBQUNGLEtBYk0sQ0FBUDtBQWNEOztBQUVELFdBQVM5RixlQUFULENBQXlCNEYsUUFBekIsRUFBbUNHLFdBQW5DLEVBQWdEbE4sV0FBaEQsRUFBNkRpSCxPQUE3RCxFQUFzRTtBQUNwRSxRQUFJa0csUUFBUSxHQUFHSixRQUFRLEtBQUs3UixPQUE1QjtBQUNBLFFBQUlzRixJQUFJLEdBQUcwTSxXQUFXLENBQUM3UCxJQUFaLEVBQVg7O0FBQ0EsUUFBSW1ELElBQUksQ0FBQ3pDLElBQVQsRUFBZTtBQUNiLFVBQUlxUCxhQUFhLEdBQUdELFFBQVEsR0FBR25OLFdBQUgsR0FBaUIrTSxRQUE3QztBQUNBLFVBQUlNLFFBQVEsR0FBR3BHLE9BQU8sQ0FBQ21HLGFBQUQsQ0FBdEI7QUFDQSxhQUFPQyxRQUFRLEtBQUtELGFBQWIsR0FBNkJMLFFBQTdCLEdBQXdDTSxRQUEvQztBQUNEOztBQUNEaEssYUFBUyxDQUNQOEosUUFBUSxJQUFLSixRQUFRLElBQUlBLFFBQVEsQ0FBQ2pILEdBRDNCLEVBRVAsaUJBRk8sQ0FBVDtBQUlBLFFBQUl4UyxHQUFHLEdBQUdrTixJQUFJLENBQUN0VSxLQUFmO0FBQ0EsUUFBSW9oQixZQUFZLEdBQUdILFFBQVEsR0FBR2pTLE9BQUgsR0FBYTZSLFFBQVEsQ0FBQ2hOLEdBQVQsQ0FBYXpNLEdBQWIsRUFBa0I0SCxPQUFsQixDQUF4QztBQUNBLFFBQUlxUyxXQUFXLEdBQUdwRyxlQUFlLENBQy9CbUcsWUFEK0IsRUFFL0JKLFdBRitCLEVBRy9CbE4sV0FIK0IsRUFJL0JpSCxPQUorQixDQUFqQztBQU1BLFdBQU9zRyxXQUFXLEtBQUtELFlBQWhCLEdBQStCUCxRQUEvQixHQUNMUSxXQUFXLEtBQUtyUyxPQUFoQixHQUEwQjZSLFFBQVEsQ0FBQ2hHLE1BQVQsQ0FBZ0J6VCxHQUFoQixDQUExQixHQUNBLENBQUM2WixRQUFRLEdBQUc3RyxRQUFRLEVBQVgsR0FBZ0J5RyxRQUF6QixFQUFtQ2pILEdBQW5DLENBQXVDeFMsR0FBdkMsRUFBNENpYSxXQUE1QyxDQUZGO0FBR0Q7O0FBRUQsV0FBU2xELFFBQVQsQ0FBa0JyZSxDQUFsQixFQUFxQjtBQUNuQkEsS0FBQyxHQUFHQSxDQUFDLElBQUtBLENBQUMsSUFBSSxDQUFOLEdBQVcsVUFBZixDQUFMO0FBQ0FBLEtBQUMsR0FBRyxDQUFDQSxDQUFDLEdBQUcsVUFBTCxLQUFxQkEsQ0FBQyxJQUFJLENBQU4sR0FBVyxVQUEvQixDQUFKO0FBQ0FBLEtBQUMsR0FBSUEsQ0FBQyxJQUFJQSxDQUFDLElBQUksQ0FBVCxDQUFGLEdBQWlCLFVBQXJCO0FBQ0FBLEtBQUMsR0FBR0EsQ0FBQyxJQUFJQSxDQUFDLElBQUksQ0FBVCxDQUFMO0FBQ0FBLEtBQUMsR0FBR0EsQ0FBQyxJQUFJQSxDQUFDLElBQUksRUFBVCxDQUFMO0FBQ0EsV0FBT0EsQ0FBQyxHQUFHLElBQVg7QUFDRDs7QUFFRCxXQUFTNGEsS0FBVCxDQUFlMVgsS0FBZixFQUFzQnlhLEdBQXRCLEVBQTJCN0ksR0FBM0IsRUFBZ0MwTSxPQUFoQyxFQUF5QztBQUN2QyxRQUFJQyxRQUFRLEdBQUdELE9BQU8sR0FBR3RlLEtBQUgsR0FBV3VNLE9BQU8sQ0FBQ3ZNLEtBQUQsQ0FBeEM7QUFDQXVlLFlBQVEsQ0FBQzlELEdBQUQsQ0FBUixHQUFnQjdJLEdBQWhCO0FBQ0EsV0FBTzJNLFFBQVA7QUFDRDs7QUFFRCxXQUFTMUMsUUFBVCxDQUFrQjdiLEtBQWxCLEVBQXlCeWEsR0FBekIsRUFBOEI3SSxHQUE5QixFQUFtQzBNLE9BQW5DLEVBQTRDO0FBQzFDLFFBQUlFLE1BQU0sR0FBR3hlLEtBQUssQ0FBQ2xFLE1BQU4sR0FBZSxDQUE1Qjs7QUFDQSxRQUFJd2lCLE9BQU8sSUFBSTdELEdBQUcsR0FBRyxDQUFOLEtBQVkrRCxNQUEzQixFQUFtQztBQUNqQ3hlLFdBQUssQ0FBQ3lhLEdBQUQsQ0FBTCxHQUFhN0ksR0FBYjtBQUNBLGFBQU81UixLQUFQO0FBQ0Q7O0FBQ0QsUUFBSXVlLFFBQVEsR0FBRyxJQUFJN2tCLEtBQUosQ0FBVThrQixNQUFWLENBQWY7QUFDQSxRQUFJQyxLQUFLLEdBQUcsQ0FBWjs7QUFDQSxTQUFLLElBQUk3UixFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHNFIsTUFBdEIsRUFBOEI1UixFQUFFLEVBQWhDLEVBQW9DO0FBQ2xDLFVBQUlBLEVBQUUsS0FBSzZOLEdBQVgsRUFBZ0I7QUFDZDhELGdCQUFRLENBQUMzUixFQUFELENBQVIsR0FBZWdGLEdBQWY7QUFDQTZNLGFBQUssR0FBRyxDQUFDLENBQVQ7QUFDRCxPQUhELE1BR087QUFDTEYsZ0JBQVEsQ0FBQzNSLEVBQUQsQ0FBUixHQUFlNU0sS0FBSyxDQUFDNE0sRUFBRSxHQUFHNlIsS0FBTixDQUFwQjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT0YsUUFBUDtBQUNEOztBQUVELFdBQVMzQyxTQUFULENBQW1CNWIsS0FBbkIsRUFBMEJ5YSxHQUExQixFQUErQjZELE9BQS9CLEVBQXdDO0FBQ3RDLFFBQUlFLE1BQU0sR0FBR3hlLEtBQUssQ0FBQ2xFLE1BQU4sR0FBZSxDQUE1Qjs7QUFDQSxRQUFJd2lCLE9BQU8sSUFBSTdELEdBQUcsS0FBSytELE1BQXZCLEVBQStCO0FBQzdCeGUsV0FBSyxDQUFDaUcsR0FBTjtBQUNBLGFBQU9qRyxLQUFQO0FBQ0Q7O0FBQ0QsUUFBSXVlLFFBQVEsR0FBRyxJQUFJN2tCLEtBQUosQ0FBVThrQixNQUFWLENBQWY7QUFDQSxRQUFJQyxLQUFLLEdBQUcsQ0FBWjs7QUFDQSxTQUFLLElBQUk3UixFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHNFIsTUFBdEIsRUFBOEI1UixFQUFFLEVBQWhDLEVBQW9DO0FBQ2xDLFVBQUlBLEVBQUUsS0FBSzZOLEdBQVgsRUFBZ0I7QUFDZGdFLGFBQUssR0FBRyxDQUFSO0FBQ0Q7O0FBQ0RGLGNBQVEsQ0FBQzNSLEVBQUQsQ0FBUixHQUFlNU0sS0FBSyxDQUFDNE0sRUFBRSxHQUFHNlIsS0FBTixDQUFwQjtBQUNEOztBQUNELFdBQU9GLFFBQVA7QUFDRDs7QUFFRCxNQUFJNUQsa0JBQWtCLEdBQUc3TyxJQUFJLEdBQUcsQ0FBaEM7QUFDQSxNQUFJeVAsdUJBQXVCLEdBQUd6UCxJQUFJLEdBQUcsQ0FBckM7QUFDQSxNQUFJbVEsdUJBQXVCLEdBQUduUSxJQUFJLEdBQUcsQ0FBckM7QUFFQS9CLGFBQVcsQ0FBQzJVLElBQUQsRUFBT3pKLGlCQUFQLENBQVgsQ0FsL0RrQixDQW8vRGhCOztBQUVBLFdBQVN5SixJQUFULENBQWMxaEIsS0FBZCxFQUFxQjtBQUNuQixRQUFJMmhCLEtBQUssR0FBR0MsU0FBUyxFQUFyQjs7QUFDQSxRQUFJNWhCLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUtuQixTQUFoQyxFQUEyQztBQUN6QyxhQUFPOGlCLEtBQVA7QUFDRDs7QUFDRCxRQUFJRSxNQUFNLENBQUM3aEIsS0FBRCxDQUFWLEVBQW1CO0FBQ2pCLGFBQU9BLEtBQVA7QUFDRDs7QUFDRCxRQUFJOFAsSUFBSSxHQUFHcEMsZUFBZSxDQUFDMU4sS0FBRCxDQUExQjtBQUNBLFFBQUk5RSxJQUFJLEdBQUc0VSxJQUFJLENBQUM1VSxJQUFoQjs7QUFDQSxRQUFJQSxJQUFJLEtBQUssQ0FBYixFQUFnQjtBQUNkLGFBQU95bUIsS0FBUDtBQUNEOztBQUNEekgscUJBQWlCLENBQUNoZixJQUFELENBQWpCOztBQUNBLFFBQUlBLElBQUksR0FBRyxDQUFQLElBQVlBLElBQUksR0FBRzRULElBQXZCLEVBQTZCO0FBQzNCLGFBQU9nVCxRQUFRLENBQUMsQ0FBRCxFQUFJNW1CLElBQUosRUFBVTJULEtBQVYsRUFBaUIsSUFBakIsRUFBdUIsSUFBSWtULEtBQUosQ0FBVWpTLElBQUksQ0FBQ3pRLE9BQUwsRUFBVixDQUF2QixDQUFmO0FBQ0Q7O0FBQ0QsV0FBT3NpQixLQUFLLENBQUNySCxhQUFOLENBQW9CLFVBQVMwSCxJQUFULEVBQWdCO0FBQ3pDQSxVQUFJLENBQUNDLE9BQUwsQ0FBYS9tQixJQUFiO0FBQ0E0VSxVQUFJLENBQUNyUixPQUFMLENBQWEsVUFBU2tULENBQVQsRUFBWW5LLENBQVosRUFBZ0I7QUFBQyxlQUFPd2EsSUFBSSxDQUFDcEksR0FBTCxDQUFTcFMsQ0FBVCxFQUFZbUssQ0FBWixDQUFQO0FBQXNCLE9BQXBEO0FBQ0QsS0FITSxDQUFQO0FBSUQ7O0FBRUQrUCxNQUFJLENBQUNuWSxFQUFMLEdBQVUsWUFBd0I7QUFDaEMsV0FBTyxLQUFLMUIsU0FBTCxDQUFQO0FBQ0QsR0FGRDs7QUFJQTZaLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZW9CLFFBQWYsR0FBMEIsWUFBVztBQUNuQyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLFFBQWhCLEVBQTBCLEdBQTFCLENBQVA7QUFDRCxHQUZELENBamhFZ0IsQ0FxaEVoQjs7O0FBRUFpUCxNQUFJLENBQUM3YyxTQUFMLENBQWVnUCxHQUFmLEdBQXFCLFVBQVM3TSxLQUFULEVBQWdCOE0sV0FBaEIsRUFBNkI7QUFDaEQ5TSxTQUFLLEdBQUdpSixTQUFTLENBQUMsSUFBRCxFQUFPakosS0FBUCxDQUFqQjs7QUFDQSxRQUFJQSxLQUFLLElBQUksQ0FBVCxJQUFjQSxLQUFLLEdBQUcsS0FBSzlMLElBQS9CLEVBQXFDO0FBQ25DOEwsV0FBSyxJQUFJLEtBQUtrYixPQUFkO0FBQ0EsVUFBSW5rQixJQUFJLEdBQUdva0IsV0FBVyxDQUFDLElBQUQsRUFBT25iLEtBQVAsQ0FBdEI7QUFDQSxhQUFPakosSUFBSSxJQUFJQSxJQUFJLENBQUNpRixLQUFMLENBQVdnRSxLQUFLLEdBQUcrSCxJQUFuQixDQUFmO0FBQ0Q7O0FBQ0QsV0FBTytFLFdBQVA7QUFDRCxHQVJELENBdmhFZ0IsQ0FpaUVoQjs7O0FBRUE0TixNQUFJLENBQUM3YyxTQUFMLENBQWUrVSxHQUFmLEdBQXFCLFVBQVM1UyxLQUFULEVBQWdCaEgsS0FBaEIsRUFBdUI7QUFDMUMsV0FBT29pQixVQUFVLENBQUMsSUFBRCxFQUFPcGIsS0FBUCxFQUFjaEgsS0FBZCxDQUFqQjtBQUNELEdBRkQ7O0FBSUEwaEIsTUFBSSxDQUFDN2MsU0FBTCxDQUFlZ1csTUFBZixHQUF3QixVQUFTN1QsS0FBVCxFQUFnQjtBQUN0QyxXQUFPLENBQUMsS0FBSytNLEdBQUwsQ0FBUy9NLEtBQVQsQ0FBRCxHQUFtQixJQUFuQixHQUNMQSxLQUFLLEtBQUssQ0FBVixHQUFjLEtBQUtnQyxLQUFMLEVBQWQsR0FDQWhDLEtBQUssS0FBSyxLQUFLOUwsSUFBTCxHQUFZLENBQXRCLEdBQTBCLEtBQUsrTixHQUFMLEVBQTFCLEdBQ0EsS0FBS29aLE1BQUwsQ0FBWXJiLEtBQVosRUFBbUIsQ0FBbkIsQ0FIRjtBQUlELEdBTEQ7O0FBT0EwYSxNQUFJLENBQUM3YyxTQUFMLENBQWV5ZCxNQUFmLEdBQXdCLFVBQVN0YixLQUFULEVBQWdCaEgsS0FBaEIsRUFBdUI7QUFDN0MsV0FBTyxLQUFLcWlCLE1BQUwsQ0FBWXJiLEtBQVosRUFBbUIsQ0FBbkIsRUFBc0JoSCxLQUF0QixDQUFQO0FBQ0QsR0FGRDs7QUFJQTBoQixNQUFJLENBQUM3YyxTQUFMLENBQWVzVyxLQUFmLEdBQXVCLFlBQVc7QUFDaEMsUUFBSSxLQUFLamdCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJLEtBQUtrZ0IsU0FBVCxFQUFvQjtBQUNsQixXQUFLbGdCLElBQUwsR0FBWSxLQUFLZ25CLE9BQUwsR0FBZSxLQUFLSyxTQUFMLEdBQWlCLENBQTVDO0FBQ0EsV0FBS0MsTUFBTCxHQUFjM1QsS0FBZDtBQUNBLFdBQUsyTCxLQUFMLEdBQWEsS0FBS2lJLEtBQUwsR0FBYSxJQUExQjtBQUNBLFdBQUt2TSxNQUFMLEdBQWNyWCxTQUFkO0FBQ0EsV0FBS3djLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPdUcsU0FBUyxFQUFoQjtBQUNELEdBYkQ7O0FBZUFGLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZW9GLElBQWYsR0FBc0IsWUFBd0I7QUFDNUMsUUFBSXlZLE1BQU0sR0FBRzdhLFNBQWI7QUFDQSxRQUFJOGEsT0FBTyxHQUFHLEtBQUt6bkIsSUFBbkI7QUFDQSxXQUFPLEtBQUtvZixhQUFMLENBQW1CLFVBQVMwSCxJQUFULEVBQWdCO0FBQ3hDWSxtQkFBYSxDQUFDWixJQUFELEVBQU8sQ0FBUCxFQUFVVyxPQUFPLEdBQUdELE1BQU0sQ0FBQzVqQixNQUEzQixDQUFiOztBQUNBLFdBQUssSUFBSThRLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUc4UyxNQUFNLENBQUM1akIsTUFBN0IsRUFBcUM4USxFQUFFLEVBQXZDLEVBQTJDO0FBQ3pDb1MsWUFBSSxDQUFDcEksR0FBTCxDQUFTK0ksT0FBTyxHQUFHL1MsRUFBbkIsRUFBdUI4UyxNQUFNLENBQUM5UyxFQUFELENBQTdCO0FBQ0Q7QUFDRixLQUxNLENBQVA7QUFNRCxHQVREOztBQVdBOFIsTUFBSSxDQUFDN2MsU0FBTCxDQUFlb0UsR0FBZixHQUFxQixZQUFXO0FBQzlCLFdBQU8yWixhQUFhLENBQUMsSUFBRCxFQUFPLENBQVAsRUFBVSxDQUFDLENBQVgsQ0FBcEI7QUFDRCxHQUZEOztBQUlBbEIsTUFBSSxDQUFDN2MsU0FBTCxDQUFlZ2UsT0FBZixHQUF5QixZQUF3QjtBQUMvQyxRQUFJSCxNQUFNLEdBQUc3YSxTQUFiO0FBQ0EsV0FBTyxLQUFLeVMsYUFBTCxDQUFtQixVQUFTMEgsSUFBVCxFQUFnQjtBQUN4Q1ksbUJBQWEsQ0FBQ1osSUFBRCxFQUFPLENBQUNVLE1BQU0sQ0FBQzVqQixNQUFmLENBQWI7O0FBQ0EsV0FBSyxJQUFJOFEsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBRzhTLE1BQU0sQ0FBQzVqQixNQUE3QixFQUFxQzhRLEVBQUUsRUFBdkMsRUFBMkM7QUFDekNvUyxZQUFJLENBQUNwSSxHQUFMLENBQVNoSyxFQUFULEVBQWE4UyxNQUFNLENBQUM5UyxFQUFELENBQW5CO0FBQ0Q7QUFDRixLQUxNLENBQVA7QUFNRCxHQVJEOztBQVVBOFIsTUFBSSxDQUFDN2MsU0FBTCxDQUFlbUUsS0FBZixHQUF1QixZQUFXO0FBQ2hDLFdBQU80WixhQUFhLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBcEI7QUFDRCxHQUZELENBMWxFZ0IsQ0E4bEVoQjs7O0FBRUFsQixNQUFJLENBQUM3YyxTQUFMLENBQWV5VyxLQUFmLEdBQXVCLFlBQXVCO0FBQzVDLFdBQU93SCxpQkFBaUIsQ0FBQyxJQUFELEVBQU9qa0IsU0FBUCxFQUFrQmdKLFNBQWxCLENBQXhCO0FBQ0QsR0FGRDs7QUFJQTZaLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZTJXLFNBQWYsR0FBMkIsVUFBU0MsTUFBVCxFQUFpQjtBQUFDLFFBQUlDLEtBQUssR0FBRzVPLE9BQU8sQ0FBQzVHLElBQVIsQ0FBYTJCLFNBQWIsRUFBd0IsQ0FBeEIsQ0FBWjtBQUMzQyxXQUFPaWIsaUJBQWlCLENBQUMsSUFBRCxFQUFPckgsTUFBUCxFQUFlQyxLQUFmLENBQXhCO0FBQ0QsR0FGRDs7QUFJQWdHLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZWdYLFNBQWYsR0FBMkIsWUFBdUI7QUFDaEQsV0FBT2lILGlCQUFpQixDQUFDLElBQUQsRUFBT2hILFVBQVAsRUFBbUJqVSxTQUFuQixDQUF4QjtBQUNELEdBRkQ7O0FBSUE2WixNQUFJLENBQUM3YyxTQUFMLENBQWVrWCxhQUFmLEdBQStCLFVBQVNOLE1BQVQsRUFBaUI7QUFBQyxRQUFJQyxLQUFLLEdBQUc1TyxPQUFPLENBQUM1RyxJQUFSLENBQWEyQixTQUFiLEVBQXdCLENBQXhCLENBQVo7QUFDL0MsV0FBT2liLGlCQUFpQixDQUFDLElBQUQsRUFBTzlHLGNBQWMsQ0FBQ1AsTUFBRCxDQUFyQixFQUErQkMsS0FBL0IsQ0FBeEI7QUFDRCxHQUZEOztBQUlBZ0csTUFBSSxDQUFDN2MsU0FBTCxDQUFlb2QsT0FBZixHQUF5QixVQUFTL21CLElBQVQsRUFBZTtBQUN0QyxXQUFPMG5CLGFBQWEsQ0FBQyxJQUFELEVBQU8sQ0FBUCxFQUFVMW5CLElBQVYsQ0FBcEI7QUFDRCxHQUZELENBaG5FZ0IsQ0FvbkVoQjs7O0FBRUF3bUIsTUFBSSxDQUFDN2MsU0FBTCxDQUFlckMsS0FBZixHQUF1QixVQUFTNk4sS0FBVCxFQUFnQkMsR0FBaEIsRUFBcUI7QUFDMUMsUUFBSXBWLElBQUksR0FBRyxLQUFLQSxJQUFoQjs7QUFDQSxRQUFJa1YsVUFBVSxDQUFDQyxLQUFELEVBQVFDLEdBQVIsRUFBYXBWLElBQWIsQ0FBZCxFQUFrQztBQUNoQyxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPMG5CLGFBQWEsQ0FDbEIsSUFEa0IsRUFFbEJyUyxZQUFZLENBQUNGLEtBQUQsRUFBUW5WLElBQVIsQ0FGTSxFQUdsQnVWLFVBQVUsQ0FBQ0gsR0FBRCxFQUFNcFYsSUFBTixDQUhRLENBQXBCO0FBS0QsR0FWRDs7QUFZQXdtQixNQUFJLENBQUM3YyxTQUFMLENBQWVvTyxVQUFmLEdBQTRCLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ2xELFFBQUkvTCxLQUFLLEdBQUcsQ0FBWjtBQUNBLFFBQUkwYixNQUFNLEdBQUdLLFdBQVcsQ0FBQyxJQUFELEVBQU9oUSxPQUFQLENBQXhCO0FBQ0EsV0FBTyxJQUFJN0IsUUFBSixDQUFhLFlBQVk7QUFDOUIsVUFBSWxSLEtBQUssR0FBRzBpQixNQUFNLEVBQWxCO0FBQ0EsYUFBTzFpQixLQUFLLEtBQUtnakIsSUFBVixHQUNMbFIsWUFBWSxFQURQLEdBRUxMLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTytNLEtBQUssRUFBWixFQUFnQmhILEtBQWhCLENBRmY7QUFHRCxLQUxNLENBQVA7QUFNRCxHQVREOztBQVdBMGhCLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZWtMLFNBQWYsR0FBMkIsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUMvQyxRQUFJL0wsS0FBSyxHQUFHLENBQVo7QUFDQSxRQUFJMGIsTUFBTSxHQUFHSyxXQUFXLENBQUMsSUFBRCxFQUFPaFEsT0FBUCxDQUF4QjtBQUNBLFFBQUkvUyxLQUFKOztBQUNBLFdBQU8sQ0FBQ0EsS0FBSyxHQUFHMGlCLE1BQU0sRUFBZixNQUF1Qk0sSUFBOUIsRUFBb0M7QUFDbEMsVUFBSWxRLEVBQUUsQ0FBQzlTLEtBQUQsRUFBUWdILEtBQUssRUFBYixFQUFpQixJQUFqQixDQUFGLEtBQTZCLEtBQWpDLEVBQXdDO0FBQ3RDO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPQSxLQUFQO0FBQ0QsR0FWRDs7QUFZQTBhLE1BQUksQ0FBQzdjLFNBQUwsQ0FBZTZYLGFBQWYsR0FBK0IsVUFBU0ksT0FBVCxFQUFrQjtBQUMvQyxRQUFJQSxPQUFPLEtBQUssS0FBSzFCLFNBQXJCLEVBQWdDO0FBQzlCLGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUksQ0FBQzBCLE9BQUwsRUFBYztBQUNaLFdBQUsxQixTQUFMLEdBQWlCMEIsT0FBakI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPZ0YsUUFBUSxDQUFDLEtBQUtJLE9BQU4sRUFBZSxLQUFLSyxTQUFwQixFQUErQixLQUFLQyxNQUFwQyxFQUE0QyxLQUFLaEksS0FBakQsRUFBd0QsS0FBS2lJLEtBQTdELEVBQW9FM0YsT0FBcEUsRUFBNkUsS0FBSzVHLE1BQWxGLENBQWY7QUFDRCxHQVREOztBQVlGLFdBQVMyTCxNQUFULENBQWdCb0IsU0FBaEIsRUFBMkI7QUFDekIsV0FBTyxDQUFDLEVBQUVBLFNBQVMsSUFBSUEsU0FBUyxDQUFDQyxnQkFBRCxDQUF4QixDQUFSO0FBQ0Q7O0FBRUR4QixNQUFJLENBQUNHLE1BQUwsR0FBY0EsTUFBZDtBQUVBLE1BQUlxQixnQkFBZ0IsR0FBRyx3QkFBdkI7QUFFQSxNQUFJQyxhQUFhLEdBQUd6QixJQUFJLENBQUM3YyxTQUF6QjtBQUNBc2UsZUFBYSxDQUFDRCxnQkFBRCxDQUFiLEdBQWtDLElBQWxDO0FBQ0FDLGVBQWEsQ0FBQ3ZVLE1BQUQsQ0FBYixHQUF3QnVVLGFBQWEsQ0FBQ3RJLE1BQXRDO0FBQ0FzSSxlQUFhLENBQUN6SSxLQUFkLEdBQXNCd0MsWUFBWSxDQUFDeEMsS0FBbkM7QUFDQXlJLGVBQWEsQ0FBQ3JJLFFBQWQsR0FDQXFJLGFBQWEsQ0FBQ2hHLFFBQWQsR0FBeUJELFlBQVksQ0FBQ0MsUUFEdEM7QUFFQWdHLGVBQWEsQ0FBQzdrQixNQUFkLEdBQXVCNGUsWUFBWSxDQUFDNWUsTUFBcEM7QUFDQTZrQixlQUFhLENBQUN2SSxRQUFkLEdBQXlCc0MsWUFBWSxDQUFDdEMsUUFBdEM7QUFDQXVJLGVBQWEsQ0FBQ3hILE9BQWQsR0FBd0J1QixZQUFZLENBQUN2QixPQUFyQztBQUNBd0gsZUFBYSxDQUFDbEgsV0FBZCxHQUE0QmlCLFlBQVksQ0FBQ2pCLFdBQXpDO0FBQ0FrSCxlQUFhLENBQUM3SSxhQUFkLEdBQThCNEMsWUFBWSxDQUFDNUMsYUFBM0M7QUFDQTZJLGVBQWEsQ0FBQzNHLFNBQWQsR0FBMEJVLFlBQVksQ0FBQ1YsU0FBdkM7QUFDQTJHLGVBQWEsQ0FBQ3hHLFdBQWQsR0FBNEJPLFlBQVksQ0FBQ1AsV0FBekM7QUFDQXdHLGVBQWEsQ0FBQzFHLFVBQWQsR0FBMkJTLFlBQVksQ0FBQ1QsVUFBeEM7O0FBSUUsV0FBU3NGLEtBQVQsQ0FBZS9lLEtBQWYsRUFBc0I4WixPQUF0QixFQUErQjtBQUM3QixTQUFLOVosS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBSzhaLE9BQUwsR0FBZUEsT0FBZjtBQUNELEdBanNFZSxDQW1zRWhCOzs7QUFFQWlGLE9BQUssQ0FBQ2xkLFNBQU4sQ0FBZ0J1ZSxZQUFoQixHQUErQixVQUFTdEcsT0FBVCxFQUFrQnVHLEtBQWxCLEVBQXlCcmMsS0FBekIsRUFBZ0M7QUFDN0QsUUFBSUEsS0FBSyxLQUFLcWMsS0FBVixHQUFrQixLQUFLQSxLQUF2QixHQUErQixNQUFDLElBQUksS0FBS3JnQixLQUFMLENBQVdsRSxNQUFYLEtBQXNCLENBQTlELEVBQWlFO0FBQy9ELGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUl3a0IsV0FBVyxHQUFJdGMsS0FBSyxLQUFLcWMsS0FBWCxHQUFvQnRVLElBQXRDOztBQUNBLFFBQUl1VSxXQUFXLElBQUksS0FBS3RnQixLQUFMLENBQVdsRSxNQUE5QixFQUFzQztBQUNwQyxhQUFPLElBQUlpakIsS0FBSixDQUFVLEVBQVYsRUFBY2pGLE9BQWQsQ0FBUDtBQUNEOztBQUNELFFBQUl5RyxhQUFhLEdBQUdELFdBQVcsS0FBSyxDQUFwQztBQUNBLFFBQUlFLFFBQUo7O0FBQ0EsUUFBSUgsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNiLFVBQUlJLFFBQVEsR0FBRyxLQUFLemdCLEtBQUwsQ0FBV3NnQixXQUFYLENBQWY7QUFDQUUsY0FBUSxHQUFHQyxRQUFRLElBQUlBLFFBQVEsQ0FBQ0wsWUFBVCxDQUFzQnRHLE9BQXRCLEVBQStCdUcsS0FBSyxHQUFHeFUsS0FBdkMsRUFBOEM3SCxLQUE5QyxDQUF2Qjs7QUFDQSxVQUFJd2MsUUFBUSxLQUFLQyxRQUFiLElBQXlCRixhQUE3QixFQUE0QztBQUMxQyxlQUFPLElBQVA7QUFDRDtBQUNGOztBQUNELFFBQUlBLGFBQWEsSUFBSSxDQUFDQyxRQUF0QixFQUFnQztBQUM5QixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJRSxRQUFRLEdBQUdDLGFBQWEsQ0FBQyxJQUFELEVBQU83RyxPQUFQLENBQTVCOztBQUNBLFFBQUksQ0FBQ3lHLGFBQUwsRUFBb0I7QUFDbEIsV0FBSyxJQUFJM1QsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBRzBULFdBQXRCLEVBQW1DMVQsRUFBRSxFQUFyQyxFQUF5QztBQUN2QzhULGdCQUFRLENBQUMxZ0IsS0FBVCxDQUFlNE0sRUFBZixJQUFxQi9RLFNBQXJCO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJMmtCLFFBQUosRUFBYztBQUNaRSxjQUFRLENBQUMxZ0IsS0FBVCxDQUFlc2dCLFdBQWYsSUFBOEJFLFFBQTlCO0FBQ0Q7O0FBQ0QsV0FBT0UsUUFBUDtBQUNELEdBOUJEOztBQWdDQTNCLE9BQUssQ0FBQ2xkLFNBQU4sQ0FBZ0IrZSxXQUFoQixHQUE4QixVQUFTOUcsT0FBVCxFQUFrQnVHLEtBQWxCLEVBQXlCcmMsS0FBekIsRUFBZ0M7QUFDNUQsUUFBSUEsS0FBSyxNQUFNcWMsS0FBSyxHQUFHLEtBQUtBLEtBQVIsR0FBZ0IsQ0FBM0IsQ0FBTCxJQUFzQyxLQUFLcmdCLEtBQUwsQ0FBV2xFLE1BQVgsS0FBc0IsQ0FBaEUsRUFBbUU7QUFDakUsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSStrQixTQUFTLEdBQUs3YyxLQUFLLEdBQUcsQ0FBVCxLQUFnQnFjLEtBQWpCLEdBQTBCdFUsSUFBMUM7O0FBQ0EsUUFBSThVLFNBQVMsSUFBSSxLQUFLN2dCLEtBQUwsQ0FBV2xFLE1BQTVCLEVBQW9DO0FBQ2xDLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUkwa0IsUUFBSjs7QUFDQSxRQUFJSCxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2IsVUFBSUksUUFBUSxHQUFHLEtBQUt6Z0IsS0FBTCxDQUFXNmdCLFNBQVgsQ0FBZjtBQUNBTCxjQUFRLEdBQUdDLFFBQVEsSUFBSUEsUUFBUSxDQUFDRyxXQUFULENBQXFCOUcsT0FBckIsRUFBOEJ1RyxLQUFLLEdBQUd4VSxLQUF0QyxFQUE2QzdILEtBQTdDLENBQXZCOztBQUNBLFVBQUl3YyxRQUFRLEtBQUtDLFFBQWIsSUFBeUJJLFNBQVMsS0FBSyxLQUFLN2dCLEtBQUwsQ0FBV2xFLE1BQVgsR0FBb0IsQ0FBL0QsRUFBa0U7QUFDaEUsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJNGtCLFFBQVEsR0FBR0MsYUFBYSxDQUFDLElBQUQsRUFBTzdHLE9BQVAsQ0FBNUI7QUFDQTRHLFlBQVEsQ0FBQzFnQixLQUFULENBQWVxZixNQUFmLENBQXNCd0IsU0FBUyxHQUFHLENBQWxDOztBQUNBLFFBQUlMLFFBQUosRUFBYztBQUNaRSxjQUFRLENBQUMxZ0IsS0FBVCxDQUFlNmdCLFNBQWYsSUFBNEJMLFFBQTVCO0FBQ0Q7O0FBQ0QsV0FBT0UsUUFBUDtBQUNELEdBeEJEOztBQTRCRixNQUFJVixJQUFJLEdBQUcsRUFBWDs7QUFFQSxXQUFTRCxXQUFULENBQXFCZixJQUFyQixFQUEyQmpQLE9BQTNCLEVBQW9DO0FBQ2xDLFFBQUkrUSxJQUFJLEdBQUc5QixJQUFJLENBQUNFLE9BQWhCO0FBQ0EsUUFBSTZCLEtBQUssR0FBRy9CLElBQUksQ0FBQ08sU0FBakI7QUFDQSxRQUFJeUIsT0FBTyxHQUFHQyxhQUFhLENBQUNGLEtBQUQsQ0FBM0I7QUFDQSxRQUFJRyxJQUFJLEdBQUdsQyxJQUFJLENBQUNTLEtBQWhCO0FBRUEsV0FBTzBCLGlCQUFpQixDQUFDbkMsSUFBSSxDQUFDeEgsS0FBTixFQUFhd0gsSUFBSSxDQUFDUSxNQUFsQixFQUEwQixDQUExQixDQUF4Qjs7QUFFQSxhQUFTMkIsaUJBQVQsQ0FBMkJwbUIsSUFBM0IsRUFBaUNzbEIsS0FBakMsRUFBd0NyWSxNQUF4QyxFQUFnRDtBQUM5QyxhQUFPcVksS0FBSyxLQUFLLENBQVYsR0FDTGUsV0FBVyxDQUFDcm1CLElBQUQsRUFBT2lOLE1BQVAsQ0FETixHQUVMcVosV0FBVyxDQUFDdG1CLElBQUQsRUFBT3NsQixLQUFQLEVBQWNyWSxNQUFkLENBRmI7QUFHRDs7QUFFRCxhQUFTb1osV0FBVCxDQUFxQnJtQixJQUFyQixFQUEyQmlOLE1BQTNCLEVBQW1DO0FBQ2pDLFVBQUloSSxLQUFLLEdBQUdnSSxNQUFNLEtBQUtnWixPQUFYLEdBQXFCRSxJQUFJLElBQUlBLElBQUksQ0FBQ2xoQixLQUFsQyxHQUEwQ2pGLElBQUksSUFBSUEsSUFBSSxDQUFDaUYsS0FBbkU7QUFDQSxVQUFJckcsSUFBSSxHQUFHcU8sTUFBTSxHQUFHOFksSUFBVCxHQUFnQixDQUFoQixHQUFvQkEsSUFBSSxHQUFHOVksTUFBdEM7QUFDQSxVQUFJc1osRUFBRSxHQUFHUCxLQUFLLEdBQUcvWSxNQUFqQjs7QUFDQSxVQUFJc1osRUFBRSxHQUFHeFYsSUFBVCxFQUFlO0FBQ2J3VixVQUFFLEdBQUd4VixJQUFMO0FBQ0Q7O0FBQ0QsYUFBTyxZQUFZO0FBQ2pCLFlBQUluUyxJQUFJLEtBQUsybkIsRUFBYixFQUFpQjtBQUNmLGlCQUFPdEIsSUFBUDtBQUNEOztBQUNELFlBQUl2RixHQUFHLEdBQUcxSyxPQUFPLEdBQUcsRUFBRXVSLEVBQUwsR0FBVTNuQixJQUFJLEVBQS9CO0FBQ0EsZUFBT3FHLEtBQUssSUFBSUEsS0FBSyxDQUFDeWEsR0FBRCxDQUFyQjtBQUNELE9BTkQ7QUFPRDs7QUFFRCxhQUFTNEcsV0FBVCxDQUFxQnRtQixJQUFyQixFQUEyQnNsQixLQUEzQixFQUFrQ3JZLE1BQWxDLEVBQTBDO0FBQ3hDLFVBQUkwWCxNQUFKO0FBQ0EsVUFBSTFmLEtBQUssR0FBR2pGLElBQUksSUFBSUEsSUFBSSxDQUFDaUYsS0FBekI7QUFDQSxVQUFJckcsSUFBSSxHQUFHcU8sTUFBTSxHQUFHOFksSUFBVCxHQUFnQixDQUFoQixHQUFxQkEsSUFBSSxHQUFHOVksTUFBUixJQUFtQnFZLEtBQWxEO0FBQ0EsVUFBSWlCLEVBQUUsR0FBRyxDQUFFUCxLQUFLLEdBQUcvWSxNQUFULElBQW9CcVksS0FBckIsSUFBOEIsQ0FBdkM7O0FBQ0EsVUFBSWlCLEVBQUUsR0FBR3hWLElBQVQsRUFBZTtBQUNid1YsVUFBRSxHQUFHeFYsSUFBTDtBQUNEOztBQUNELGFBQU8sWUFBWTtBQUNqQixXQUFHO0FBQ0QsY0FBSTRULE1BQUosRUFBWTtBQUNWLGdCQUFJMWlCLEtBQUssR0FBRzBpQixNQUFNLEVBQWxCOztBQUNBLGdCQUFJMWlCLEtBQUssS0FBS2dqQixJQUFkLEVBQW9CO0FBQ2xCLHFCQUFPaGpCLEtBQVA7QUFDRDs7QUFDRDBpQixrQkFBTSxHQUFHLElBQVQ7QUFDRDs7QUFDRCxjQUFJL2xCLElBQUksS0FBSzJuQixFQUFiLEVBQWlCO0FBQ2YsbUJBQU90QixJQUFQO0FBQ0Q7O0FBQ0QsY0FBSXZGLEdBQUcsR0FBRzFLLE9BQU8sR0FBRyxFQUFFdVIsRUFBTCxHQUFVM25CLElBQUksRUFBL0I7QUFDQStsQixnQkFBTSxHQUFHeUIsaUJBQWlCLENBQ3hCbmhCLEtBQUssSUFBSUEsS0FBSyxDQUFDeWEsR0FBRCxDQURVLEVBQ0g0RixLQUFLLEdBQUd4VSxLQURMLEVBQ1k3RCxNQUFNLElBQUl5UyxHQUFHLElBQUk0RixLQUFYLENBRGxCLENBQTFCO0FBR0QsU0FmRCxRQWVTLElBZlQ7QUFnQkQsT0FqQkQ7QUFrQkQ7QUFDRjs7QUFFRCxXQUFTdkIsUUFBVCxDQUFrQnlDLE1BQWxCLEVBQTBCQyxRQUExQixFQUFvQ25CLEtBQXBDLEVBQTJDckQsSUFBM0MsRUFBaURrRSxJQUFqRCxFQUF1RHBILE9BQXZELEVBQWdFdEUsSUFBaEUsRUFBc0U7QUFDcEUsUUFBSXdKLElBQUksR0FBR2pjLE1BQU0sQ0FBQ21ILE1BQVAsQ0FBY2lXLGFBQWQsQ0FBWDtBQUNBbkIsUUFBSSxDQUFDOW1CLElBQUwsR0FBWXNwQixRQUFRLEdBQUdELE1BQXZCO0FBQ0F2QyxRQUFJLENBQUNFLE9BQUwsR0FBZXFDLE1BQWY7QUFDQXZDLFFBQUksQ0FBQ08sU0FBTCxHQUFpQmlDLFFBQWpCO0FBQ0F4QyxRQUFJLENBQUNRLE1BQUwsR0FBY2EsS0FBZDtBQUNBckIsUUFBSSxDQUFDeEgsS0FBTCxHQUFhd0YsSUFBYjtBQUNBZ0MsUUFBSSxDQUFDUyxLQUFMLEdBQWF5QixJQUFiO0FBQ0FsQyxRQUFJLENBQUM1RyxTQUFMLEdBQWlCMEIsT0FBakI7QUFDQWtGLFFBQUksQ0FBQzlMLE1BQUwsR0FBY3NDLElBQWQ7QUFDQXdKLFFBQUksQ0FBQzNHLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxXQUFPMkcsSUFBUDtBQUNEOztBQUVELE1BQUl5QyxVQUFKOztBQUNBLFdBQVM3QyxTQUFULEdBQXFCO0FBQ25CLFdBQU82QyxVQUFVLEtBQUtBLFVBQVUsR0FBRzNDLFFBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPalQsS0FBUCxDQUExQixDQUFqQjtBQUNEOztBQUVELFdBQVN1VCxVQUFULENBQW9CSixJQUFwQixFQUEwQmhiLEtBQTFCLEVBQWlDaEgsS0FBakMsRUFBd0M7QUFDdENnSCxTQUFLLEdBQUdpSixTQUFTLENBQUMrUixJQUFELEVBQU9oYixLQUFQLENBQWpCOztBQUVBLFFBQUlBLEtBQUssS0FBS0EsS0FBZCxFQUFxQjtBQUNuQixhQUFPZ2IsSUFBUDtBQUNEOztBQUVELFFBQUloYixLQUFLLElBQUlnYixJQUFJLENBQUM5bUIsSUFBZCxJQUFzQjhMLEtBQUssR0FBRyxDQUFsQyxFQUFxQztBQUNuQyxhQUFPZ2IsSUFBSSxDQUFDMUgsYUFBTCxDQUFtQixVQUFTMEgsSUFBVCxFQUFnQjtBQUN4Q2hiLGFBQUssR0FBRyxDQUFSLEdBQ0U0YixhQUFhLENBQUNaLElBQUQsRUFBT2hiLEtBQVAsQ0FBYixDQUEyQjRTLEdBQTNCLENBQStCLENBQS9CLEVBQWtDNVosS0FBbEMsQ0FERixHQUVFNGlCLGFBQWEsQ0FBQ1osSUFBRCxFQUFPLENBQVAsRUFBVWhiLEtBQUssR0FBRyxDQUFsQixDQUFiLENBQWtDNFMsR0FBbEMsQ0FBc0M1UyxLQUF0QyxFQUE2Q2hILEtBQTdDLENBRkY7QUFHRCxPQUpNLENBQVA7QUFLRDs7QUFFRGdILFNBQUssSUFBSWdiLElBQUksQ0FBQ0UsT0FBZDtBQUVBLFFBQUl3QyxPQUFPLEdBQUcxQyxJQUFJLENBQUNTLEtBQW5CO0FBQ0EsUUFBSXZDLE9BQU8sR0FBRzhCLElBQUksQ0FBQ3hILEtBQW5CO0FBQ0EsUUFBSStDLFFBQVEsR0FBR3BPLE9BQU8sQ0FBQ0QsU0FBRCxDQUF0Qjs7QUFDQSxRQUFJbEksS0FBSyxJQUFJaWQsYUFBYSxDQUFDakMsSUFBSSxDQUFDTyxTQUFOLENBQTFCLEVBQTRDO0FBQzFDbUMsYUFBTyxHQUFHQyxXQUFXLENBQUNELE9BQUQsRUFBVTFDLElBQUksQ0FBQzVHLFNBQWYsRUFBMEIsQ0FBMUIsRUFBNkJwVSxLQUE3QixFQUFvQ2hILEtBQXBDLEVBQTJDdWQsUUFBM0MsQ0FBckI7QUFDRCxLQUZELE1BRU87QUFDTDJDLGFBQU8sR0FBR3lFLFdBQVcsQ0FBQ3pFLE9BQUQsRUFBVThCLElBQUksQ0FBQzVHLFNBQWYsRUFBMEI0RyxJQUFJLENBQUNRLE1BQS9CLEVBQXVDeGIsS0FBdkMsRUFBOENoSCxLQUE5QyxFQUFxRHVkLFFBQXJELENBQXJCO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDQSxRQUFRLENBQUN2ZCxLQUFkLEVBQXFCO0FBQ25CLGFBQU9naUIsSUFBUDtBQUNEOztBQUVELFFBQUlBLElBQUksQ0FBQzVHLFNBQVQsRUFBb0I7QUFDbEI0RyxVQUFJLENBQUN4SCxLQUFMLEdBQWEwRixPQUFiO0FBQ0E4QixVQUFJLENBQUNTLEtBQUwsR0FBYWlDLE9BQWI7QUFDQTFDLFVBQUksQ0FBQzlMLE1BQUwsR0FBY3JYLFNBQWQ7QUFDQW1qQixVQUFJLENBQUMzRyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBTzJHLElBQVA7QUFDRDs7QUFDRCxXQUFPRixRQUFRLENBQUNFLElBQUksQ0FBQ0UsT0FBTixFQUFlRixJQUFJLENBQUNPLFNBQXBCLEVBQStCUCxJQUFJLENBQUNRLE1BQXBDLEVBQTRDdEMsT0FBNUMsRUFBcUR3RSxPQUFyRCxDQUFmO0FBQ0Q7O0FBRUQsV0FBU0MsV0FBVCxDQUFxQjVtQixJQUFyQixFQUEyQitlLE9BQTNCLEVBQW9DdUcsS0FBcEMsRUFBMkNyYyxLQUEzQyxFQUFrRGhILEtBQWxELEVBQXlEdWQsUUFBekQsRUFBbUU7QUFDakUsUUFBSUUsR0FBRyxHQUFJelcsS0FBSyxLQUFLcWMsS0FBWCxHQUFvQnRVLElBQTlCO0FBQ0EsUUFBSTZWLE9BQU8sR0FBRzdtQixJQUFJLElBQUkwZixHQUFHLEdBQUcxZixJQUFJLENBQUNpRixLQUFMLENBQVdsRSxNQUF2Qzs7QUFDQSxRQUFJLENBQUM4bEIsT0FBRCxJQUFZNWtCLEtBQUssS0FBS25CLFNBQTFCLEVBQXFDO0FBQ25DLGFBQU9kLElBQVA7QUFDRDs7QUFFRCxRQUFJc2dCLE9BQUo7O0FBRUEsUUFBSWdGLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYixVQUFJd0IsU0FBUyxHQUFHOW1CLElBQUksSUFBSUEsSUFBSSxDQUFDaUYsS0FBTCxDQUFXeWEsR0FBWCxDQUF4QjtBQUNBLFVBQUlxSCxZQUFZLEdBQUdILFdBQVcsQ0FBQ0UsU0FBRCxFQUFZL0gsT0FBWixFQUFxQnVHLEtBQUssR0FBR3hVLEtBQTdCLEVBQW9DN0gsS0FBcEMsRUFBMkNoSCxLQUEzQyxFQUFrRHVkLFFBQWxELENBQTlCOztBQUNBLFVBQUl1SCxZQUFZLEtBQUtELFNBQXJCLEVBQWdDO0FBQzlCLGVBQU85bUIsSUFBUDtBQUNEOztBQUNEc2dCLGFBQU8sR0FBR3NGLGFBQWEsQ0FBQzVsQixJQUFELEVBQU8rZSxPQUFQLENBQXZCO0FBQ0F1QixhQUFPLENBQUNyYixLQUFSLENBQWN5YSxHQUFkLElBQXFCcUgsWUFBckI7QUFDQSxhQUFPekcsT0FBUDtBQUNEOztBQUVELFFBQUl1RyxPQUFPLElBQUk3bUIsSUFBSSxDQUFDaUYsS0FBTCxDQUFXeWEsR0FBWCxNQUFvQnpkLEtBQW5DLEVBQTBDO0FBQ3hDLGFBQU9qQyxJQUFQO0FBQ0Q7O0FBRURzUixVQUFNLENBQUNrTyxRQUFELENBQU47QUFFQWMsV0FBTyxHQUFHc0YsYUFBYSxDQUFDNWxCLElBQUQsRUFBTytlLE9BQVAsQ0FBdkI7O0FBQ0EsUUFBSTljLEtBQUssS0FBS25CLFNBQVYsSUFBdUI0ZSxHQUFHLEtBQUtZLE9BQU8sQ0FBQ3JiLEtBQVIsQ0FBY2xFLE1BQWQsR0FBdUIsQ0FBMUQsRUFBNkQ7QUFDM0R1ZixhQUFPLENBQUNyYixLQUFSLENBQWNpRyxHQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0xvVixhQUFPLENBQUNyYixLQUFSLENBQWN5YSxHQUFkLElBQXFCemQsS0FBckI7QUFDRDs7QUFDRCxXQUFPcWUsT0FBUDtBQUNEOztBQUVELFdBQVNzRixhQUFULENBQXVCNWxCLElBQXZCLEVBQTZCK2UsT0FBN0IsRUFBc0M7QUFDcEMsUUFBSUEsT0FBTyxJQUFJL2UsSUFBWCxJQUFtQitlLE9BQU8sS0FBSy9lLElBQUksQ0FBQytlLE9BQXhDLEVBQWlEO0FBQy9DLGFBQU8vZSxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFJZ2tCLEtBQUosQ0FBVWhrQixJQUFJLEdBQUdBLElBQUksQ0FBQ2lGLEtBQUwsQ0FBV1IsS0FBWCxFQUFILEdBQXdCLEVBQXRDLEVBQTBDc2EsT0FBMUMsQ0FBUDtBQUNEOztBQUVELFdBQVNxRixXQUFULENBQXFCSCxJQUFyQixFQUEyQitDLFFBQTNCLEVBQXFDO0FBQ25DLFFBQUlBLFFBQVEsSUFBSWQsYUFBYSxDQUFDakMsSUFBSSxDQUFDTyxTQUFOLENBQTdCLEVBQStDO0FBQzdDLGFBQU9QLElBQUksQ0FBQ1MsS0FBWjtBQUNEOztBQUNELFFBQUlzQyxRQUFRLEdBQUcsS0FBTS9DLElBQUksQ0FBQ1EsTUFBTCxHQUFjM1QsS0FBbkMsRUFBMkM7QUFDekMsVUFBSTlRLElBQUksR0FBR2lrQixJQUFJLENBQUN4SCxLQUFoQjtBQUNBLFVBQUk2SSxLQUFLLEdBQUdyQixJQUFJLENBQUNRLE1BQWpCOztBQUNBLGFBQU96a0IsSUFBSSxJQUFJc2xCLEtBQUssR0FBRyxDQUF2QixFQUEwQjtBQUN4QnRsQixZQUFJLEdBQUdBLElBQUksQ0FBQ2lGLEtBQUwsQ0FBWStoQixRQUFRLEtBQUsxQixLQUFkLEdBQXVCdFUsSUFBbEMsQ0FBUDtBQUNBc1UsYUFBSyxJQUFJeFUsS0FBVDtBQUNEOztBQUNELGFBQU85USxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTNmtCLGFBQVQsQ0FBdUJaLElBQXZCLEVBQTZCM1IsS0FBN0IsRUFBb0NDLEdBQXBDLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFJRCxLQUFLLEtBQUt4UixTQUFkLEVBQXlCO0FBQ3ZCd1IsV0FBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7QUFDRDs7QUFDRCxRQUFJQyxHQUFHLEtBQUt6UixTQUFaLEVBQXVCO0FBQ3JCeVIsU0FBRyxHQUFHQSxHQUFHLEdBQUcsQ0FBWjtBQUNEOztBQUNELFFBQUkwVSxLQUFLLEdBQUdoRCxJQUFJLENBQUM1RyxTQUFMLElBQWtCLElBQUk5TCxPQUFKLEVBQTlCO0FBQ0EsUUFBSTJWLFNBQVMsR0FBR2pELElBQUksQ0FBQ0UsT0FBckI7QUFDQSxRQUFJZ0QsV0FBVyxHQUFHbEQsSUFBSSxDQUFDTyxTQUF2QjtBQUNBLFFBQUk0QyxTQUFTLEdBQUdGLFNBQVMsR0FBRzVVLEtBQTVCO0FBQ0EsUUFBSStVLFdBQVcsR0FBRzlVLEdBQUcsS0FBS3pSLFNBQVIsR0FBb0JxbUIsV0FBcEIsR0FBa0M1VSxHQUFHLEdBQUcsQ0FBTixHQUFVNFUsV0FBVyxHQUFHNVUsR0FBeEIsR0FBOEIyVSxTQUFTLEdBQUczVSxHQUE5Rjs7QUFDQSxRQUFJNlUsU0FBUyxLQUFLRixTQUFkLElBQTJCRyxXQUFXLEtBQUtGLFdBQS9DLEVBQTREO0FBQzFELGFBQU9sRCxJQUFQO0FBQ0QsS0FoQnNDLENBa0J2Qzs7O0FBQ0EsUUFBSW1ELFNBQVMsSUFBSUMsV0FBakIsRUFBOEI7QUFDNUIsYUFBT3BELElBQUksQ0FBQzdHLEtBQUwsRUFBUDtBQUNEOztBQUVELFFBQUlrSyxRQUFRLEdBQUdyRCxJQUFJLENBQUNRLE1BQXBCO0FBQ0EsUUFBSXRDLE9BQU8sR0FBRzhCLElBQUksQ0FBQ3hILEtBQW5CLENBeEJ1QyxDQTBCdkM7O0FBQ0EsUUFBSThLLFdBQVcsR0FBRyxDQUFsQjs7QUFDQSxXQUFPSCxTQUFTLEdBQUdHLFdBQVosR0FBMEIsQ0FBakMsRUFBb0M7QUFDbENwRixhQUFPLEdBQUcsSUFBSTZCLEtBQUosQ0FBVTdCLE9BQU8sSUFBSUEsT0FBTyxDQUFDbGQsS0FBUixDQUFjbEUsTUFBekIsR0FBa0MsQ0FBQ0QsU0FBRCxFQUFZcWhCLE9BQVosQ0FBbEMsR0FBeUQsRUFBbkUsRUFBdUU4RSxLQUF2RSxDQUFWO0FBQ0FLLGNBQVEsSUFBSXhXLEtBQVo7QUFDQXlXLGlCQUFXLElBQUksS0FBS0QsUUFBcEI7QUFDRDs7QUFDRCxRQUFJQyxXQUFKLEVBQWlCO0FBQ2ZILGVBQVMsSUFBSUcsV0FBYjtBQUNBTCxlQUFTLElBQUlLLFdBQWI7QUFDQUYsaUJBQVcsSUFBSUUsV0FBZjtBQUNBSixpQkFBVyxJQUFJSSxXQUFmO0FBQ0Q7O0FBRUQsUUFBSUMsYUFBYSxHQUFHdEIsYUFBYSxDQUFDaUIsV0FBRCxDQUFqQztBQUNBLFFBQUlNLGFBQWEsR0FBR3ZCLGFBQWEsQ0FBQ21CLFdBQUQsQ0FBakMsQ0F6Q3VDLENBMkN2Qzs7QUFDQSxXQUFPSSxhQUFhLElBQUksS0FBTUgsUUFBUSxHQUFHeFcsS0FBekMsRUFBaUQ7QUFDL0NxUixhQUFPLEdBQUcsSUFBSTZCLEtBQUosQ0FBVTdCLE9BQU8sSUFBSUEsT0FBTyxDQUFDbGQsS0FBUixDQUFjbEUsTUFBekIsR0FBa0MsQ0FBQ29oQixPQUFELENBQWxDLEdBQThDLEVBQXhELEVBQTREOEUsS0FBNUQsQ0FBVjtBQUNBSyxjQUFRLElBQUl4VyxLQUFaO0FBQ0QsS0EvQ3NDLENBaUR2Qzs7O0FBQ0EsUUFBSTRXLE9BQU8sR0FBR3pELElBQUksQ0FBQ1MsS0FBbkI7QUFDQSxRQUFJaUMsT0FBTyxHQUFHYyxhQUFhLEdBQUdELGFBQWhCLEdBQ1pwRCxXQUFXLENBQUNILElBQUQsRUFBT29ELFdBQVcsR0FBRyxDQUFyQixDQURDLEdBRVpJLGFBQWEsR0FBR0QsYUFBaEIsR0FBZ0MsSUFBSXhELEtBQUosQ0FBVSxFQUFWLEVBQWNpRCxLQUFkLENBQWhDLEdBQXVEUyxPQUZ6RCxDQW5EdUMsQ0F1RHZDOztBQUNBLFFBQUlBLE9BQU8sSUFBSUQsYUFBYSxHQUFHRCxhQUEzQixJQUE0Q0osU0FBUyxHQUFHRCxXQUF4RCxJQUF1RU8sT0FBTyxDQUFDemlCLEtBQVIsQ0FBY2xFLE1BQXpGLEVBQWlHO0FBQy9Gb2hCLGFBQU8sR0FBR3lELGFBQWEsQ0FBQ3pELE9BQUQsRUFBVThFLEtBQVYsQ0FBdkI7QUFDQSxVQUFJam5CLElBQUksR0FBR21pQixPQUFYOztBQUNBLFdBQUssSUFBSW1ELEtBQUssR0FBR2dDLFFBQWpCLEVBQTJCaEMsS0FBSyxHQUFHeFUsS0FBbkMsRUFBMEN3VSxLQUFLLElBQUl4VSxLQUFuRCxFQUEwRDtBQUN4RCxZQUFJNE8sR0FBRyxHQUFJOEgsYUFBYSxLQUFLbEMsS0FBbkIsR0FBNEJ0VSxJQUF0QztBQUNBaFIsWUFBSSxHQUFHQSxJQUFJLENBQUNpRixLQUFMLENBQVd5YSxHQUFYLElBQWtCa0csYUFBYSxDQUFDNWxCLElBQUksQ0FBQ2lGLEtBQUwsQ0FBV3lhLEdBQVgsQ0FBRCxFQUFrQnVILEtBQWxCLENBQXRDO0FBQ0Q7O0FBQ0RqbkIsVUFBSSxDQUFDaUYsS0FBTCxDQUFZdWlCLGFBQWEsS0FBSzFXLEtBQW5CLEdBQTRCRSxJQUF2QyxJQUErQzBXLE9BQS9DO0FBQ0QsS0FoRXNDLENBa0V2Qzs7O0FBQ0EsUUFBSUwsV0FBVyxHQUFHRixXQUFsQixFQUErQjtBQUM3QlIsYUFBTyxHQUFHQSxPQUFPLElBQUlBLE9BQU8sQ0FBQ2QsV0FBUixDQUFvQm9CLEtBQXBCLEVBQTJCLENBQTNCLEVBQThCSSxXQUE5QixDQUFyQjtBQUNELEtBckVzQyxDQXVFdkM7OztBQUNBLFFBQUlELFNBQVMsSUFBSUssYUFBakIsRUFBZ0M7QUFDOUJMLGVBQVMsSUFBSUssYUFBYjtBQUNBSixpQkFBVyxJQUFJSSxhQUFmO0FBQ0FILGNBQVEsR0FBR3hXLEtBQVg7QUFDQXFSLGFBQU8sR0FBRyxJQUFWO0FBQ0F3RSxhQUFPLEdBQUdBLE9BQU8sSUFBSUEsT0FBTyxDQUFDdEIsWUFBUixDQUFxQjRCLEtBQXJCLEVBQTRCLENBQTVCLEVBQStCRyxTQUEvQixDQUFyQixDQUw4QixDQU9oQztBQUNDLEtBUkQsTUFRTyxJQUFJQSxTQUFTLEdBQUdGLFNBQVosSUFBeUJPLGFBQWEsR0FBR0QsYUFBN0MsRUFBNEQ7QUFDakVELGlCQUFXLEdBQUcsQ0FBZCxDQURpRSxDQUdqRTs7QUFDQSxhQUFPcEYsT0FBUCxFQUFnQjtBQUNkLFlBQUl3RixVQUFVLEdBQUlQLFNBQVMsS0FBS0UsUUFBZixHQUEyQnRXLElBQTVDOztBQUNBLFlBQUkyVyxVQUFVLEtBQU1GLGFBQWEsS0FBS0gsUUFBbEMsR0FBOEN0VyxJQUFsRCxFQUF3RDtBQUN0RDtBQUNEOztBQUNELFlBQUkyVyxVQUFKLEVBQWdCO0FBQ2RKLHFCQUFXLElBQUksQ0FBQyxLQUFLRCxRQUFOLElBQWtCSyxVQUFqQztBQUNEOztBQUNETCxnQkFBUSxJQUFJeFcsS0FBWjtBQUNBcVIsZUFBTyxHQUFHQSxPQUFPLENBQUNsZCxLQUFSLENBQWMwaUIsVUFBZCxDQUFWO0FBQ0QsT0FkZ0UsQ0FnQmpFOzs7QUFDQSxVQUFJeEYsT0FBTyxJQUFJaUYsU0FBUyxHQUFHRixTQUEzQixFQUFzQztBQUNwQy9FLGVBQU8sR0FBR0EsT0FBTyxDQUFDa0QsWUFBUixDQUFxQjRCLEtBQXJCLEVBQTRCSyxRQUE1QixFQUFzQ0YsU0FBUyxHQUFHRyxXQUFsRCxDQUFWO0FBQ0Q7O0FBQ0QsVUFBSXBGLE9BQU8sSUFBSXNGLGFBQWEsR0FBR0QsYUFBL0IsRUFBOEM7QUFDNUNyRixlQUFPLEdBQUdBLE9BQU8sQ0FBQzBELFdBQVIsQ0FBb0JvQixLQUFwQixFQUEyQkssUUFBM0IsRUFBcUNHLGFBQWEsR0FBR0YsV0FBckQsQ0FBVjtBQUNEOztBQUNELFVBQUlBLFdBQUosRUFBaUI7QUFDZkgsaUJBQVMsSUFBSUcsV0FBYjtBQUNBRixtQkFBVyxJQUFJRSxXQUFmO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJdEQsSUFBSSxDQUFDNUcsU0FBVCxFQUFvQjtBQUNsQjRHLFVBQUksQ0FBQzltQixJQUFMLEdBQVlrcUIsV0FBVyxHQUFHRCxTQUExQjtBQUNBbkQsVUFBSSxDQUFDRSxPQUFMLEdBQWVpRCxTQUFmO0FBQ0FuRCxVQUFJLENBQUNPLFNBQUwsR0FBaUI2QyxXQUFqQjtBQUNBcEQsVUFBSSxDQUFDUSxNQUFMLEdBQWM2QyxRQUFkO0FBQ0FyRCxVQUFJLENBQUN4SCxLQUFMLEdBQWEwRixPQUFiO0FBQ0E4QixVQUFJLENBQUNTLEtBQUwsR0FBYWlDLE9BQWI7QUFDQTFDLFVBQUksQ0FBQzlMLE1BQUwsR0FBY3JYLFNBQWQ7QUFDQW1qQixVQUFJLENBQUMzRyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBTzJHLElBQVA7QUFDRDs7QUFDRCxXQUFPRixRQUFRLENBQUNxRCxTQUFELEVBQVlDLFdBQVosRUFBeUJDLFFBQXpCLEVBQW1DbkYsT0FBbkMsRUFBNEN3RSxPQUE1QyxDQUFmO0FBQ0Q7O0FBRUQsV0FBUzVCLGlCQUFULENBQTJCZCxJQUEzQixFQUFpQ3ZHLE1BQWpDLEVBQXlDa0YsU0FBekMsRUFBb0Q7QUFDbEQsUUFBSWpGLEtBQUssR0FBRyxFQUFaO0FBQ0EsUUFBSWlLLE9BQU8sR0FBRyxDQUFkOztBQUNBLFNBQUssSUFBSS9WLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUcrUSxTQUFTLENBQUM3aEIsTUFBaEMsRUFBd0M4USxFQUFFLEVBQTFDLEVBQThDO0FBQzVDLFVBQUk1UCxLQUFLLEdBQUcyZ0IsU0FBUyxDQUFDL1EsRUFBRCxDQUFyQjtBQUNBLFVBQUlFLElBQUksR0FBR3BDLGVBQWUsQ0FBQzFOLEtBQUQsQ0FBMUI7O0FBQ0EsVUFBSThQLElBQUksQ0FBQzVVLElBQUwsR0FBWXlxQixPQUFoQixFQUF5QjtBQUN2QkEsZUFBTyxHQUFHN1YsSUFBSSxDQUFDNVUsSUFBZjtBQUNEOztBQUNELFVBQUksQ0FBQ21TLFVBQVUsQ0FBQ3JOLEtBQUQsQ0FBZixFQUF3QjtBQUN0QjhQLFlBQUksR0FBR0EsSUFBSSxDQUFDeFEsR0FBTCxDQUFTLFVBQVNxUyxDQUFULEVBQWE7QUFBQyxpQkFBT2hRLE1BQU0sQ0FBQ2dRLENBQUQsQ0FBYjtBQUFpQixTQUF4QyxDQUFQO0FBQ0Q7O0FBQ0QrSixXQUFLLENBQUN6UixJQUFOLENBQVc2RixJQUFYO0FBQ0Q7O0FBQ0QsUUFBSTZWLE9BQU8sR0FBRzNELElBQUksQ0FBQzltQixJQUFuQixFQUF5QjtBQUN2QjhtQixVQUFJLEdBQUdBLElBQUksQ0FBQ0MsT0FBTCxDQUFhMEQsT0FBYixDQUFQO0FBQ0Q7O0FBQ0QsV0FBTy9FLHVCQUF1QixDQUFDb0IsSUFBRCxFQUFPdkcsTUFBUCxFQUFlQyxLQUFmLENBQTlCO0FBQ0Q7O0FBRUQsV0FBU3VJLGFBQVQsQ0FBdUIvb0IsSUFBdkIsRUFBNkI7QUFDM0IsV0FBT0EsSUFBSSxHQUFHNFQsSUFBUCxHQUFjLENBQWQsR0FBcUI1VCxJQUFJLEdBQUcsQ0FBUixLQUFlMlQsS0FBaEIsSUFBMEJBLEtBQXBEO0FBQ0Q7O0FBRUQ5QixhQUFXLENBQUNxUCxVQUFELEVBQWFqQyxHQUFiLENBQVgsQ0Fya0ZrQixDQXVrRmhCOztBQUVBLFdBQVNpQyxVQUFULENBQW9CcGMsS0FBcEIsRUFBMkI7QUFDekIsV0FBT0EsS0FBSyxLQUFLLElBQVYsSUFBa0JBLEtBQUssS0FBS25CLFNBQTVCLEdBQXdDK21CLGVBQWUsRUFBdkQsR0FDTEMsWUFBWSxDQUFDN2xCLEtBQUQsQ0FBWixHQUFzQkEsS0FBdEIsR0FDQTRsQixlQUFlLEdBQUd0TCxhQUFsQixDQUFnQyxVQUFTaGIsR0FBVCxFQUFlO0FBQzdDLFVBQUl3USxJQUFJLEdBQUd2QyxhQUFhLENBQUN2TixLQUFELENBQXhCO0FBQ0FrYSx1QkFBaUIsQ0FBQ3BLLElBQUksQ0FBQzVVLElBQU4sQ0FBakI7QUFDQTRVLFVBQUksQ0FBQ3JSLE9BQUwsQ0FBYSxVQUFTa1QsQ0FBVCxFQUFZRCxDQUFaLEVBQWdCO0FBQUMsZUFBT3BTLEdBQUcsQ0FBQ3NhLEdBQUosQ0FBUWxJLENBQVIsRUFBV0MsQ0FBWCxDQUFQO0FBQXFCLE9BQW5EO0FBQ0QsS0FKRCxDQUZGO0FBT0Q7O0FBRUR5SyxZQUFVLENBQUM3UyxFQUFYLEdBQWdCLFlBQXdCO0FBQ3RDLFdBQU8sS0FBSzFCLFNBQUwsQ0FBUDtBQUNELEdBRkQ7O0FBSUF1VSxZQUFVLENBQUN2WCxTQUFYLENBQXFCb0IsUUFBckIsR0FBZ0MsWUFBVztBQUN6QyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLGNBQWhCLEVBQWdDLEdBQWhDLENBQVA7QUFDRCxHQUZELENBdmxGZ0IsQ0EybEZoQjs7O0FBRUEySixZQUFVLENBQUN2WCxTQUFYLENBQXFCZ1AsR0FBckIsR0FBMkIsVUFBU25DLENBQVQsRUFBWW9DLFdBQVosRUFBeUI7QUFDbEQsUUFBSTlNLEtBQUssR0FBRyxLQUFLOGUsSUFBTCxDQUFValMsR0FBVixDQUFjbkMsQ0FBZCxDQUFaOztBQUNBLFdBQU8xSyxLQUFLLEtBQUtuSSxTQUFWLEdBQXNCLEtBQUtrbkIsS0FBTCxDQUFXbFMsR0FBWCxDQUFlN00sS0FBZixFQUFzQixDQUF0QixDQUF0QixHQUFpRDhNLFdBQXhEO0FBQ0QsR0FIRCxDQTdsRmdCLENBa21GaEI7OztBQUVBc0ksWUFBVSxDQUFDdlgsU0FBWCxDQUFxQnNXLEtBQXJCLEdBQTZCLFlBQVc7QUFDdEMsUUFBSSxLQUFLamdCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJLEtBQUtrZ0IsU0FBVCxFQUFvQjtBQUNsQixXQUFLbGdCLElBQUwsR0FBWSxDQUFaOztBQUNBLFdBQUs0cUIsSUFBTCxDQUFVM0ssS0FBVjs7QUFDQSxXQUFLNEssS0FBTCxDQUFXNUssS0FBWDs7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPeUssZUFBZSxFQUF0QjtBQUNELEdBWEQ7O0FBYUF4SixZQUFVLENBQUN2WCxTQUFYLENBQXFCK1UsR0FBckIsR0FBMkIsVUFBU2xJLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQ3hDLFdBQU9xVSxnQkFBZ0IsQ0FBQyxJQUFELEVBQU90VSxDQUFQLEVBQVVDLENBQVYsQ0FBdkI7QUFDRCxHQUZEOztBQUlBeUssWUFBVSxDQUFDdlgsU0FBWCxDQUFxQmdXLE1BQXJCLEdBQThCLFVBQVNuSixDQUFULEVBQVk7QUFDeEMsV0FBT3NVLGdCQUFnQixDQUFDLElBQUQsRUFBT3RVLENBQVAsRUFBVTFDLE9BQVYsQ0FBdkI7QUFDRCxHQUZEOztBQUlBb04sWUFBVSxDQUFDdlgsU0FBWCxDQUFxQjRYLFVBQXJCLEdBQWtDLFlBQVc7QUFDM0MsV0FBTyxLQUFLcUosSUFBTCxDQUFVckosVUFBVixNQUEwQixLQUFLc0osS0FBTCxDQUFXdEosVUFBWCxFQUFqQztBQUNELEdBRkQ7O0FBSUFMLFlBQVUsQ0FBQ3ZYLFNBQVgsQ0FBcUJrTCxTQUFyQixHQUFpQyxVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQUMsUUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ3RELFdBQU8sS0FBSzhPLEtBQUwsQ0FBV2hXLFNBQVgsQ0FDTCxVQUFTb0YsS0FBVCxFQUFpQjtBQUFDLGFBQU9BLEtBQUssSUFBSXJDLEVBQUUsQ0FBQ3FDLEtBQUssQ0FBQyxDQUFELENBQU4sRUFBV0EsS0FBSyxDQUFDLENBQUQsQ0FBaEIsRUFBcUI4QixNQUFyQixDQUFsQjtBQUErQyxLQUQ1RCxFQUVMbEUsT0FGSyxDQUFQO0FBSUQsR0FMRDs7QUFPQXFKLFlBQVUsQ0FBQ3ZYLFNBQVgsQ0FBcUJvTyxVQUFyQixHQUFrQyxVQUFTaFosSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUN4RCxXQUFPLEtBQUtnVCxLQUFMLENBQVczUyxZQUFYLEdBQTBCSCxVQUExQixDQUFxQ2haLElBQXJDLEVBQTJDOFksT0FBM0MsQ0FBUDtBQUNELEdBRkQ7O0FBSUFxSixZQUFVLENBQUN2WCxTQUFYLENBQXFCNlgsYUFBckIsR0FBcUMsVUFBU0ksT0FBVCxFQUFrQjtBQUNyRCxRQUFJQSxPQUFPLEtBQUssS0FBSzFCLFNBQXJCLEVBQWdDO0FBQzlCLGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUk2SyxNQUFNLEdBQUcsS0FBS0gsSUFBTCxDQUFVcEosYUFBVixDQUF3QkksT0FBeEIsQ0FBYjs7QUFDQSxRQUFJb0osT0FBTyxHQUFHLEtBQUtILEtBQUwsQ0FBV3JKLGFBQVgsQ0FBeUJJLE9BQXpCLENBQWQ7O0FBQ0EsUUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixXQUFLMUIsU0FBTCxHQUFpQjBCLE9BQWpCO0FBQ0EsV0FBS2dKLElBQUwsR0FBWUcsTUFBWjtBQUNBLFdBQUtGLEtBQUwsR0FBYUcsT0FBYjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU9DLGNBQWMsQ0FBQ0YsTUFBRCxFQUFTQyxPQUFULEVBQWtCcEosT0FBbEIsRUFBMkIsS0FBSzVHLE1BQWhDLENBQXJCO0FBQ0QsR0FiRDs7QUFnQkYsV0FBUzJQLFlBQVQsQ0FBc0JPLGVBQXRCLEVBQXVDO0FBQ3JDLFdBQU8vTCxLQUFLLENBQUMrTCxlQUFELENBQUwsSUFBMEI3WCxTQUFTLENBQUM2WCxlQUFELENBQTFDO0FBQ0Q7O0FBRURoSyxZQUFVLENBQUN5SixZQUFYLEdBQTBCQSxZQUExQjtBQUVBekosWUFBVSxDQUFDdlgsU0FBWCxDQUFxQjRKLG1CQUFyQixJQUE0QyxJQUE1QztBQUNBMk4sWUFBVSxDQUFDdlgsU0FBWCxDQUFxQitKLE1BQXJCLElBQStCd04sVUFBVSxDQUFDdlgsU0FBWCxDQUFxQmdXLE1BQXBEOztBQUlBLFdBQVNzTCxjQUFULENBQXdCN21CLEdBQXhCLEVBQTZCMGlCLElBQTdCLEVBQW1DbEYsT0FBbkMsRUFBNEN0RSxJQUE1QyxFQUFrRDtBQUNoRCxRQUFJNk4sSUFBSSxHQUFHdGdCLE1BQU0sQ0FBQ21ILE1BQVAsQ0FBY2tQLFVBQVUsQ0FBQ3ZYLFNBQXpCLENBQVg7QUFDQXdoQixRQUFJLENBQUNuckIsSUFBTCxHQUFZb0UsR0FBRyxHQUFHQSxHQUFHLENBQUNwRSxJQUFQLEdBQWMsQ0FBN0I7QUFDQW1yQixRQUFJLENBQUNQLElBQUwsR0FBWXhtQixHQUFaO0FBQ0ErbUIsUUFBSSxDQUFDTixLQUFMLEdBQWEvRCxJQUFiO0FBQ0FxRSxRQUFJLENBQUNqTCxTQUFMLEdBQWlCMEIsT0FBakI7QUFDQXVKLFFBQUksQ0FBQ25RLE1BQUwsR0FBY3NDLElBQWQ7QUFDQSxXQUFPNk4sSUFBUDtBQUNEOztBQUVELE1BQUlDLGlCQUFKOztBQUNBLFdBQVNWLGVBQVQsR0FBMkI7QUFDekIsV0FBT1UsaUJBQWlCLEtBQUtBLGlCQUFpQixHQUFHSCxjQUFjLENBQUMvTCxRQUFRLEVBQVQsRUFBYXdILFNBQVMsRUFBdEIsQ0FBdkMsQ0FBeEI7QUFDRDs7QUFFRCxXQUFTb0UsZ0JBQVQsQ0FBMEJLLElBQTFCLEVBQWdDM1UsQ0FBaEMsRUFBbUNDLENBQW5DLEVBQXNDO0FBQ3BDLFFBQUlyUyxHQUFHLEdBQUcrbUIsSUFBSSxDQUFDUCxJQUFmO0FBQ0EsUUFBSTlELElBQUksR0FBR3FFLElBQUksQ0FBQ04sS0FBaEI7QUFDQSxRQUFJdmUsQ0FBQyxHQUFHbEksR0FBRyxDQUFDdVUsR0FBSixDQUFRbkMsQ0FBUixDQUFSO0FBQ0EsUUFBSXFDLEdBQUcsR0FBR3ZNLENBQUMsS0FBSzNJLFNBQWhCO0FBQ0EsUUFBSW9uQixNQUFKO0FBQ0EsUUFBSUMsT0FBSjs7QUFDQSxRQUFJdlUsQ0FBQyxLQUFLM0MsT0FBVixFQUFtQjtBQUFFO0FBQ25CLFVBQUksQ0FBQytFLEdBQUwsRUFBVTtBQUNSLGVBQU9zUyxJQUFQO0FBQ0Q7O0FBQ0QsVUFBSXJFLElBQUksQ0FBQzltQixJQUFMLElBQWE0VCxJQUFiLElBQXFCa1QsSUFBSSxDQUFDOW1CLElBQUwsSUFBYW9FLEdBQUcsQ0FBQ3BFLElBQUosR0FBVyxDQUFqRCxFQUFvRDtBQUNsRGdyQixlQUFPLEdBQUdsRSxJQUFJLENBQUMzVyxNQUFMLENBQVksVUFBUzhKLEtBQVQsRUFBZ0JzSSxHQUFoQixFQUFzQjtBQUFDLGlCQUFPdEksS0FBSyxLQUFLdFcsU0FBVixJQUF1QjJJLENBQUMsS0FBS2lXLEdBQXBDO0FBQXdDLFNBQTNFLENBQVY7QUFDQXdJLGNBQU0sR0FBR0MsT0FBTyxDQUFDL1MsVUFBUixHQUFxQjdULEdBQXJCLENBQXlCLFVBQVM2VixLQUFULEVBQWlCO0FBQUMsaUJBQU9BLEtBQUssQ0FBQyxDQUFELENBQVo7QUFBZ0IsU0FBM0QsRUFBNkRvUixJQUE3RCxHQUFvRTVRLEtBQXBFLEVBQVQ7O0FBQ0EsWUFBSTBRLElBQUksQ0FBQ2pMLFNBQVQsRUFBb0I7QUFDbEI2SyxnQkFBTSxDQUFDN0ssU0FBUCxHQUFtQjhLLE9BQU8sQ0FBQzlLLFNBQVIsR0FBb0JpTCxJQUFJLENBQUNqTCxTQUE1QztBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0w2SyxjQUFNLEdBQUczbUIsR0FBRyxDQUFDdWIsTUFBSixDQUFXbkosQ0FBWCxDQUFUO0FBQ0F3VSxlQUFPLEdBQUcxZSxDQUFDLEtBQUt3YSxJQUFJLENBQUM5bUIsSUFBTCxHQUFZLENBQWxCLEdBQXNCOG1CLElBQUksQ0FBQy9ZLEdBQUwsRUFBdEIsR0FBbUMrWSxJQUFJLENBQUNwSSxHQUFMLENBQVNwUyxDQUFULEVBQVkzSSxTQUFaLENBQTdDO0FBQ0Q7QUFDRixLQWRELE1BY087QUFDTCxVQUFJa1YsR0FBSixFQUFTO0FBQ1AsWUFBSXBDLENBQUMsS0FBS3FRLElBQUksQ0FBQ25PLEdBQUwsQ0FBU3JNLENBQVQsRUFBWSxDQUFaLENBQVYsRUFBMEI7QUFDeEIsaUJBQU82ZSxJQUFQO0FBQ0Q7O0FBQ0RKLGNBQU0sR0FBRzNtQixHQUFUO0FBQ0E0bUIsZUFBTyxHQUFHbEUsSUFBSSxDQUFDcEksR0FBTCxDQUFTcFMsQ0FBVCxFQUFZLENBQUNrSyxDQUFELEVBQUlDLENBQUosQ0FBWixDQUFWO0FBQ0QsT0FORCxNQU1PO0FBQ0xzVSxjQUFNLEdBQUczbUIsR0FBRyxDQUFDc2EsR0FBSixDQUFRbEksQ0FBUixFQUFXc1EsSUFBSSxDQUFDOW1CLElBQWhCLENBQVQ7QUFDQWdyQixlQUFPLEdBQUdsRSxJQUFJLENBQUNwSSxHQUFMLENBQVNvSSxJQUFJLENBQUM5bUIsSUFBZCxFQUFvQixDQUFDd1csQ0FBRCxFQUFJQyxDQUFKLENBQXBCLENBQVY7QUFDRDtBQUNGOztBQUNELFFBQUkwVSxJQUFJLENBQUNqTCxTQUFULEVBQW9CO0FBQ2xCaUwsVUFBSSxDQUFDbnJCLElBQUwsR0FBWStxQixNQUFNLENBQUMvcUIsSUFBbkI7QUFDQW1yQixVQUFJLENBQUNQLElBQUwsR0FBWUcsTUFBWjtBQUNBSSxVQUFJLENBQUNOLEtBQUwsR0FBYUcsT0FBYjtBQUNBRyxVQUFJLENBQUNuUSxNQUFMLEdBQWNyWCxTQUFkO0FBQ0EsYUFBT3duQixJQUFQO0FBQ0Q7O0FBQ0QsV0FBT0YsY0FBYyxDQUFDRixNQUFELEVBQVNDLE9BQVQsQ0FBckI7QUFDRDs7QUFFRG5aLGFBQVcsQ0FBQ3laLGVBQUQsRUFBa0IvWSxRQUFsQixDQUFYOztBQUNFLFdBQVMrWSxlQUFULENBQXlCQyxPQUF6QixFQUFrQ3ZSLE9BQWxDLEVBQTJDO0FBQ3pDLFNBQUt3UixLQUFMLEdBQWFELE9BQWI7QUFDQSxTQUFLRSxRQUFMLEdBQWdCelIsT0FBaEI7QUFDQSxTQUFLaGEsSUFBTCxHQUFZdXJCLE9BQU8sQ0FBQ3ZyQixJQUFwQjtBQUNEOztBQUVEc3JCLGlCQUFlLENBQUMzaEIsU0FBaEIsQ0FBMEJnUCxHQUExQixHQUFnQyxVQUFTek0sR0FBVCxFQUFjME0sV0FBZCxFQUEyQjtBQUN6RCxXQUFPLEtBQUs0UyxLQUFMLENBQVc3UyxHQUFYLENBQWV6TSxHQUFmLEVBQW9CME0sV0FBcEIsQ0FBUDtBQUNELEdBRkQ7O0FBSUEwUyxpQkFBZSxDQUFDM2hCLFNBQWhCLENBQTBCa1AsR0FBMUIsR0FBZ0MsVUFBUzNNLEdBQVQsRUFBYztBQUM1QyxXQUFPLEtBQUtzZixLQUFMLENBQVczUyxHQUFYLENBQWUzTSxHQUFmLENBQVA7QUFDRCxHQUZEOztBQUlBb2YsaUJBQWUsQ0FBQzNoQixTQUFoQixDQUEwQitoQixRQUExQixHQUFxQyxZQUFXO0FBQzlDLFdBQU8sS0FBS0YsS0FBTCxDQUFXRSxRQUFYLEVBQVA7QUFDRCxHQUZEOztBQUlBSixpQkFBZSxDQUFDM2hCLFNBQWhCLENBQTBCa08sT0FBMUIsR0FBb0MsWUFBVztBQUFDLFFBQUlrRSxNQUFNLEdBQUcsSUFBYjtBQUM5QyxRQUFJNFAsZ0JBQWdCLEdBQUdDLGNBQWMsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFyQzs7QUFDQSxRQUFJLENBQUMsS0FBS0gsUUFBVixFQUFvQjtBQUNsQkUsc0JBQWdCLENBQUNELFFBQWpCLEdBQTRCLFlBQVk7QUFBQyxlQUFPM1AsTUFBTSxDQUFDeVAsS0FBUCxDQUFhblUsS0FBYixHQUFxQlEsT0FBckIsRUFBUDtBQUFzQyxPQUEvRTtBQUNEOztBQUNELFdBQU84VCxnQkFBUDtBQUNELEdBTkQ7O0FBUUFMLGlCQUFlLENBQUMzaEIsU0FBaEIsQ0FBMEJ2RixHQUExQixHQUFnQyxVQUFTZ2QsTUFBVCxFQUFpQnlLLE9BQWpCLEVBQTBCO0FBQUMsUUFBSTlQLE1BQU0sR0FBRyxJQUFiO0FBQ3pELFFBQUkrUCxjQUFjLEdBQUdDLFVBQVUsQ0FBQyxJQUFELEVBQU8zSyxNQUFQLEVBQWV5SyxPQUFmLENBQS9COztBQUNBLFFBQUksQ0FBQyxLQUFLSixRQUFWLEVBQW9CO0FBQ2xCSyxvQkFBYyxDQUFDSixRQUFmLEdBQTBCLFlBQVk7QUFBQyxlQUFPM1AsTUFBTSxDQUFDeVAsS0FBUCxDQUFhblUsS0FBYixHQUFxQmpULEdBQXJCLENBQXlCZ2QsTUFBekIsRUFBaUN5SyxPQUFqQyxDQUFQO0FBQWlELE9BQXhGO0FBQ0Q7O0FBQ0QsV0FBT0MsY0FBUDtBQUNELEdBTkQ7O0FBUUFSLGlCQUFlLENBQUMzaEIsU0FBaEIsQ0FBMEJrTCxTQUExQixHQUFzQyxVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQUMsUUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQzNELFFBQUlySCxFQUFKO0FBQ0EsV0FBTyxLQUFLOFcsS0FBTCxDQUFXM1csU0FBWCxDQUNMLEtBQUs0VyxRQUFMLEdBQ0UsVUFBU2hWLENBQVQsRUFBWUQsQ0FBWixFQUFnQjtBQUFDLGFBQU9vQixFQUFFLENBQUNuQixDQUFELEVBQUlELENBQUosRUFBT3VGLE1BQVAsQ0FBVDtBQUF3QixLQUQzQyxJQUVJckgsRUFBRSxHQUFHbUQsT0FBTyxHQUFHbVUsV0FBVyxDQUFDLElBQUQsQ0FBZCxHQUF1QixDQUFwQyxFQUNDLFVBQVN2VixDQUFULEVBQWE7QUFBQyxhQUFPbUIsRUFBRSxDQUFDbkIsQ0FBRCxFQUFJb0IsT0FBTyxHQUFHLEVBQUVuRCxFQUFMLEdBQVVBLEVBQUUsRUFBdkIsRUFBMkJxSCxNQUEzQixDQUFUO0FBQTRDLEtBSDlELENBREssRUFLTGxFLE9BTEssQ0FBUDtBQU9ELEdBVEQ7O0FBV0F5VCxpQkFBZSxDQUFDM2hCLFNBQWhCLENBQTBCb08sVUFBMUIsR0FBdUMsVUFBU2haLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFDN0QsUUFBSSxLQUFLNFQsUUFBVCxFQUFtQjtBQUNqQixhQUFPLEtBQUtELEtBQUwsQ0FBV3pULFVBQVgsQ0FBc0JoWixJQUF0QixFQUE0QjhZLE9BQTVCLENBQVA7QUFDRDs7QUFDRCxRQUFJMU0sUUFBUSxHQUFHLEtBQUtxZ0IsS0FBTCxDQUFXelQsVUFBWCxDQUFzQnBDLGNBQXRCLEVBQXNDa0MsT0FBdEMsQ0FBZjs7QUFDQSxRQUFJbkQsRUFBRSxHQUFHbUQsT0FBTyxHQUFHbVUsV0FBVyxDQUFDLElBQUQsQ0FBZCxHQUF1QixDQUF2QztBQUNBLFdBQU8sSUFBSWhXLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFVBQUlvRCxJQUFJLEdBQUdqTyxRQUFRLENBQUM4SyxJQUFULEVBQVg7QUFDQSxhQUFPbUQsSUFBSSxDQUFDekMsSUFBTCxHQUFZeUMsSUFBWixHQUNMN0MsYUFBYSxDQUFDeFgsSUFBRCxFQUFPOFksT0FBTyxHQUFHLEVBQUVuRCxFQUFMLEdBQVVBLEVBQUUsRUFBMUIsRUFBOEIwRSxJQUFJLENBQUN0VSxLQUFuQyxFQUEwQ3NVLElBQTFDLENBRGY7QUFFRCxLQUpNLENBQVA7QUFLRCxHQVhEOztBQWFGa1MsaUJBQWUsQ0FBQzNoQixTQUFoQixDQUEwQjRKLG1CQUExQixJQUFpRCxJQUFqRDtBQUdBMUIsYUFBVyxDQUFDb2EsaUJBQUQsRUFBb0J2WixVQUFwQixDQUFYOztBQUNFLFdBQVN1WixpQkFBVCxDQUEyQnJYLElBQTNCLEVBQWlDO0FBQy9CLFNBQUs0VyxLQUFMLEdBQWE1VyxJQUFiO0FBQ0EsU0FBSzVVLElBQUwsR0FBWTRVLElBQUksQ0FBQzVVLElBQWpCO0FBQ0Q7O0FBRURpc0IsbUJBQWlCLENBQUN0aUIsU0FBbEIsQ0FBNEJpUyxRQUE1QixHQUF1QyxVQUFTOVcsS0FBVCxFQUFnQjtBQUNyRCxXQUFPLEtBQUswbUIsS0FBTCxDQUFXNVAsUUFBWCxDQUFvQjlXLEtBQXBCLENBQVA7QUFDRCxHQUZEOztBQUlBbW5CLG1CQUFpQixDQUFDdGlCLFNBQWxCLENBQTRCa0wsU0FBNUIsR0FBd0MsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUFDLFFBQUlrRSxNQUFNLEdBQUcsSUFBYjtBQUM3RCxRQUFJblosVUFBVSxHQUFHLENBQWpCO0FBQ0EsV0FBTyxLQUFLNG9CLEtBQUwsQ0FBVzNXLFNBQVgsQ0FBcUIsVUFBUzRCLENBQVQsRUFBYTtBQUFDLGFBQU9tQixFQUFFLENBQUNuQixDQUFELEVBQUk3VCxVQUFVLEVBQWQsRUFBa0JtWixNQUFsQixDQUFUO0FBQW1DLEtBQXRFLEVBQXdFbEUsT0FBeEUsQ0FBUDtBQUNELEdBSEQ7O0FBS0FvVSxtQkFBaUIsQ0FBQ3RpQixTQUFsQixDQUE0Qm9PLFVBQTVCLEdBQXlDLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQy9ELFFBQUkxTSxRQUFRLEdBQUcsS0FBS3FnQixLQUFMLENBQVd6VCxVQUFYLENBQXNCcEMsY0FBdEIsRUFBc0NrQyxPQUF0QyxDQUFmOztBQUNBLFFBQUlqVixVQUFVLEdBQUcsQ0FBakI7QUFDQSxXQUFPLElBQUlvVCxRQUFKLENBQWEsWUFBWTtBQUM5QixVQUFJb0QsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYO0FBQ0EsYUFBT21ELElBQUksQ0FBQ3pDLElBQUwsR0FBWXlDLElBQVosR0FDTDdDLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTzZELFVBQVUsRUFBakIsRUFBcUJ3VyxJQUFJLENBQUN0VSxLQUExQixFQUFpQ3NVLElBQWpDLENBRGY7QUFFRCxLQUpNLENBQVA7QUFLRCxHQVJEOztBQVlGdkgsYUFBVyxDQUFDcWEsYUFBRCxFQUFnQnJaLE1BQWhCLENBQVg7O0FBQ0UsV0FBU3FaLGFBQVQsQ0FBdUJ0WCxJQUF2QixFQUE2QjtBQUMzQixTQUFLNFcsS0FBTCxHQUFhNVcsSUFBYjtBQUNBLFNBQUs1VSxJQUFMLEdBQVk0VSxJQUFJLENBQUM1VSxJQUFqQjtBQUNEOztBQUVEa3NCLGVBQWEsQ0FBQ3ZpQixTQUFkLENBQXdCa1AsR0FBeEIsR0FBOEIsVUFBUzNNLEdBQVQsRUFBYztBQUMxQyxXQUFPLEtBQUtzZixLQUFMLENBQVc1UCxRQUFYLENBQW9CMVAsR0FBcEIsQ0FBUDtBQUNELEdBRkQ7O0FBSUFnZ0IsZUFBYSxDQUFDdmlCLFNBQWQsQ0FBd0JrTCxTQUF4QixHQUFvQyxVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQUMsUUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ3pELFdBQU8sS0FBS3lQLEtBQUwsQ0FBVzNXLFNBQVgsQ0FBcUIsVUFBUzRCLENBQVQsRUFBYTtBQUFDLGFBQU9tQixFQUFFLENBQUNuQixDQUFELEVBQUlBLENBQUosRUFBT3NGLE1BQVAsQ0FBVDtBQUF3QixLQUEzRCxFQUE2RGxFLE9BQTdELENBQVA7QUFDRCxHQUZEOztBQUlBcVUsZUFBYSxDQUFDdmlCLFNBQWQsQ0FBd0JvTyxVQUF4QixHQUFxQyxVQUFTaFosSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUMzRCxRQUFJMU0sUUFBUSxHQUFHLEtBQUtxZ0IsS0FBTCxDQUFXelQsVUFBWCxDQUFzQnBDLGNBQXRCLEVBQXNDa0MsT0FBdEMsQ0FBZjs7QUFDQSxXQUFPLElBQUk3QixRQUFKLENBQWEsWUFBWTtBQUM5QixVQUFJb0QsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYO0FBQ0EsYUFBT21ELElBQUksQ0FBQ3pDLElBQUwsR0FBWXlDLElBQVosR0FDTDdDLGFBQWEsQ0FBQ3hYLElBQUQsRUFBT3FhLElBQUksQ0FBQ3RVLEtBQVosRUFBbUJzVSxJQUFJLENBQUN0VSxLQUF4QixFQUErQnNVLElBQS9CLENBRGY7QUFFRCxLQUpNLENBQVA7QUFLRCxHQVBEOztBQVdGdkgsYUFBVyxDQUFDc2EsbUJBQUQsRUFBc0I1WixRQUF0QixDQUFYOztBQUNFLFdBQVM0WixtQkFBVCxDQUE2QmpSLE9BQTdCLEVBQXNDO0FBQ3BDLFNBQUtzUSxLQUFMLEdBQWF0USxPQUFiO0FBQ0EsU0FBS2xiLElBQUwsR0FBWWtiLE9BQU8sQ0FBQ2xiLElBQXBCO0FBQ0Q7O0FBRURtc0IscUJBQW1CLENBQUN4aUIsU0FBcEIsQ0FBOEJnTyxRQUE5QixHQUF5QyxZQUFXO0FBQ2xELFdBQU8sS0FBSzZULEtBQUwsQ0FBV25VLEtBQVgsRUFBUDtBQUNELEdBRkQ7O0FBSUE4VSxxQkFBbUIsQ0FBQ3hpQixTQUFwQixDQUE4QmtMLFNBQTlCLEdBQTBDLFVBQVMrQyxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFBQyxRQUFJa0UsTUFBTSxHQUFHLElBQWI7QUFDL0QsV0FBTyxLQUFLeVAsS0FBTCxDQUFXM1csU0FBWCxDQUFxQixVQUFTb0YsS0FBVCxFQUFpQjtBQUMzQztBQUNBO0FBQ0EsVUFBSUEsS0FBSixFQUFXO0FBQ1RtUyxxQkFBYSxDQUFDblMsS0FBRCxDQUFiO0FBQ0EsWUFBSW9TLGVBQWUsR0FBR2xhLFVBQVUsQ0FBQzhILEtBQUQsQ0FBaEM7QUFDQSxlQUFPckMsRUFBRSxDQUNQeVUsZUFBZSxHQUFHcFMsS0FBSyxDQUFDdEIsR0FBTixDQUFVLENBQVYsQ0FBSCxHQUFrQnNCLEtBQUssQ0FBQyxDQUFELENBRC9CLEVBRVBvUyxlQUFlLEdBQUdwUyxLQUFLLENBQUN0QixHQUFOLENBQVUsQ0FBVixDQUFILEdBQWtCc0IsS0FBSyxDQUFDLENBQUQsQ0FGL0IsRUFHUDhCLE1BSE8sQ0FBVDtBQUtEO0FBQ0YsS0FaTSxFQVlKbEUsT0FaSSxDQUFQO0FBYUQsR0FkRDs7QUFnQkFzVSxxQkFBbUIsQ0FBQ3hpQixTQUFwQixDQUE4Qm9PLFVBQTlCLEdBQTJDLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ2pFLFFBQUkxTSxRQUFRLEdBQUcsS0FBS3FnQixLQUFMLENBQVd6VCxVQUFYLENBQXNCcEMsY0FBdEIsRUFBc0NrQyxPQUF0QyxDQUFmOztBQUNBLFdBQU8sSUFBSTdCLFFBQUosQ0FBYSxZQUFZO0FBQzlCLGFBQU8sSUFBUCxFQUFhO0FBQ1gsWUFBSW9ELElBQUksR0FBR2pPLFFBQVEsQ0FBQzhLLElBQVQsRUFBWDs7QUFDQSxZQUFJbUQsSUFBSSxDQUFDekMsSUFBVCxFQUFlO0FBQ2IsaUJBQU95QyxJQUFQO0FBQ0Q7O0FBQ0QsWUFBSWEsS0FBSyxHQUFHYixJQUFJLENBQUN0VSxLQUFqQixDQUxXLENBTVg7QUFDQTs7QUFDQSxZQUFJbVYsS0FBSixFQUFXO0FBQ1RtUyx1QkFBYSxDQUFDblMsS0FBRCxDQUFiO0FBQ0EsY0FBSW9TLGVBQWUsR0FBR2xhLFVBQVUsQ0FBQzhILEtBQUQsQ0FBaEM7QUFDQSxpQkFBTzFELGFBQWEsQ0FDbEJ4WCxJQURrQixFQUVsQnN0QixlQUFlLEdBQUdwUyxLQUFLLENBQUN0QixHQUFOLENBQVUsQ0FBVixDQUFILEdBQWtCc0IsS0FBSyxDQUFDLENBQUQsQ0FGcEIsRUFHbEJvUyxlQUFlLEdBQUdwUyxLQUFLLENBQUN0QixHQUFOLENBQVUsQ0FBVixDQUFILEdBQWtCc0IsS0FBSyxDQUFDLENBQUQsQ0FIcEIsRUFJbEJiLElBSmtCLENBQXBCO0FBTUQ7QUFDRjtBQUNGLEtBcEJNLENBQVA7QUFxQkQsR0F2QkQ7O0FBMEJGNlMsbUJBQWlCLENBQUN0aUIsU0FBbEIsQ0FBNEI2TixXQUE1QixHQUNBOFQsZUFBZSxDQUFDM2hCLFNBQWhCLENBQTBCNk4sV0FBMUIsR0FDQTBVLGFBQWEsQ0FBQ3ZpQixTQUFkLENBQXdCNk4sV0FBeEIsR0FDQTJVLG1CQUFtQixDQUFDeGlCLFNBQXBCLENBQThCNk4sV0FBOUIsR0FDRThVLGtCQUpGOztBQU9BLFdBQVNDLFdBQVQsQ0FBcUJ2a0IsUUFBckIsRUFBK0I7QUFDN0IsUUFBSXdrQixZQUFZLEdBQUdDLFlBQVksQ0FBQ3prQixRQUFELENBQS9CO0FBQ0F3a0IsZ0JBQVksQ0FBQ2hCLEtBQWIsR0FBcUJ4akIsUUFBckI7QUFDQXdrQixnQkFBWSxDQUFDeHNCLElBQWIsR0FBb0JnSSxRQUFRLENBQUNoSSxJQUE3Qjs7QUFDQXdzQixnQkFBWSxDQUFDbkIsSUFBYixHQUFvQixZQUFZO0FBQUMsYUFBT3JqQixRQUFQO0FBQWdCLEtBQWpEOztBQUNBd2tCLGdCQUFZLENBQUMzVSxPQUFiLEdBQXVCLFlBQVk7QUFDakMsVUFBSThULGdCQUFnQixHQUFHM2pCLFFBQVEsQ0FBQzZQLE9BQVQsQ0FBaUJyTyxLQUFqQixDQUF1QixJQUF2QixDQUF2QixDQURpQyxDQUNvQjs7QUFDckRtaUIsc0JBQWdCLENBQUNOLElBQWpCLEdBQXdCLFlBQVk7QUFBQyxlQUFPcmpCLFFBQVEsQ0FBQzZQLE9BQVQsRUFBUDtBQUEwQixPQUEvRDs7QUFDQSxhQUFPOFQsZ0JBQVA7QUFDRCxLQUpEOztBQUtBYSxnQkFBWSxDQUFDM1QsR0FBYixHQUFtQixVQUFTM00sR0FBVCxFQUFlO0FBQUMsYUFBT2xFLFFBQVEsQ0FBQzRULFFBQVQsQ0FBa0IxUCxHQUFsQixDQUFQO0FBQThCLEtBQWpFOztBQUNBc2dCLGdCQUFZLENBQUM1USxRQUFiLEdBQXdCLFVBQVMxUCxHQUFULEVBQWU7QUFBQyxhQUFPbEUsUUFBUSxDQUFDNlEsR0FBVCxDQUFhM00sR0FBYixDQUFQO0FBQXlCLEtBQWpFOztBQUNBc2dCLGdCQUFZLENBQUNoVixXQUFiLEdBQTJCOFUsa0JBQTNCOztBQUNBRSxnQkFBWSxDQUFDOVUsaUJBQWIsR0FBaUMsVUFBVUUsRUFBVixFQUFjQyxPQUFkLEVBQXVCO0FBQUMsVUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ3ZELGFBQU8vVCxRQUFRLENBQUM2TSxTQUFULENBQW1CLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBQyxlQUFPb0IsRUFBRSxDQUFDcEIsQ0FBRCxFQUFJQyxDQUFKLEVBQU9zRixNQUFQLENBQUYsS0FBcUIsS0FBNUI7QUFBa0MsT0FBdEUsRUFBd0VsRSxPQUF4RSxDQUFQO0FBQ0QsS0FGRDs7QUFHQTJVLGdCQUFZLENBQUNuVCxrQkFBYixHQUFrQyxVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUN4RCxVQUFJOVksSUFBSSxLQUFLNlcsZUFBYixFQUE4QjtBQUM1QixZQUFJekssUUFBUSxHQUFHbkQsUUFBUSxDQUFDK1AsVUFBVCxDQUFvQmhaLElBQXBCLEVBQTBCOFksT0FBMUIsQ0FBZjs7QUFDQSxlQUFPLElBQUk3QixRQUFKLENBQWEsWUFBWTtBQUM5QixjQUFJb0QsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYOztBQUNBLGNBQUksQ0FBQ21ELElBQUksQ0FBQ3pDLElBQVYsRUFBZ0I7QUFDZCxnQkFBSUgsQ0FBQyxHQUFHNEMsSUFBSSxDQUFDdFUsS0FBTCxDQUFXLENBQVgsQ0FBUjtBQUNBc1UsZ0JBQUksQ0FBQ3RVLEtBQUwsQ0FBVyxDQUFYLElBQWdCc1UsSUFBSSxDQUFDdFUsS0FBTCxDQUFXLENBQVgsQ0FBaEI7QUFDQXNVLGdCQUFJLENBQUN0VSxLQUFMLENBQVcsQ0FBWCxJQUFnQjBSLENBQWhCO0FBQ0Q7O0FBQ0QsaUJBQU80QyxJQUFQO0FBQ0QsU0FSTSxDQUFQO0FBU0Q7O0FBQ0QsYUFBT3BSLFFBQVEsQ0FBQytQLFVBQVQsQ0FDTGhaLElBQUksS0FBSzRXLGNBQVQsR0FBMEJELFlBQTFCLEdBQXlDQyxjQURwQyxFQUVMa0MsT0FGSyxDQUFQO0FBSUQsS0FqQkQ7O0FBa0JBLFdBQU8yVSxZQUFQO0FBQ0Q7O0FBR0QsV0FBU1QsVUFBVCxDQUFvQi9qQixRQUFwQixFQUE4Qm9aLE1BQTlCLEVBQXNDeUssT0FBdEMsRUFBK0M7QUFDN0MsUUFBSUMsY0FBYyxHQUFHVyxZQUFZLENBQUN6a0IsUUFBRCxDQUFqQztBQUNBOGpCLGtCQUFjLENBQUM5ckIsSUFBZixHQUFzQmdJLFFBQVEsQ0FBQ2hJLElBQS9COztBQUNBOHJCLGtCQUFjLENBQUNqVCxHQUFmLEdBQXFCLFVBQVMzTSxHQUFULEVBQWU7QUFBQyxhQUFPbEUsUUFBUSxDQUFDNlEsR0FBVCxDQUFhM00sR0FBYixDQUFQO0FBQXlCLEtBQTlEOztBQUNBNGYsa0JBQWMsQ0FBQ25ULEdBQWYsR0FBcUIsVUFBU3pNLEdBQVQsRUFBYzBNLFdBQWQsRUFBNEI7QUFDL0MsVUFBSW5DLENBQUMsR0FBR3pPLFFBQVEsQ0FBQzJRLEdBQVQsQ0FBYXpNLEdBQWIsRUFBa0I0SCxPQUFsQixDQUFSO0FBQ0EsYUFBTzJDLENBQUMsS0FBSzNDLE9BQU4sR0FDTDhFLFdBREssR0FFTHdJLE1BQU0sQ0FBQ3BXLElBQVAsQ0FBWTZnQixPQUFaLEVBQXFCcFYsQ0FBckIsRUFBd0J2SyxHQUF4QixFQUE2QmxFLFFBQTdCLENBRkY7QUFHRCxLQUxEOztBQU1BOGpCLGtCQUFjLENBQUNwVSxpQkFBZixHQUFtQyxVQUFVRSxFQUFWLEVBQWNDLE9BQWQsRUFBdUI7QUFBQyxVQUFJa0UsTUFBTSxHQUFHLElBQWI7QUFDekQsYUFBTy9ULFFBQVEsQ0FBQzZNLFNBQVQsQ0FDTCxVQUFTNEIsQ0FBVCxFQUFZRCxDQUFaLEVBQWUwRyxDQUFmLEVBQW1CO0FBQUMsZUFBT3RGLEVBQUUsQ0FBQ3dKLE1BQU0sQ0FBQ3BXLElBQVAsQ0FBWTZnQixPQUFaLEVBQXFCcFYsQ0FBckIsRUFBd0JELENBQXhCLEVBQTJCMEcsQ0FBM0IsQ0FBRCxFQUFnQzFHLENBQWhDLEVBQW1DdUYsTUFBbkMsQ0FBRixLQUFpRCxLQUF4RDtBQUE4RCxPQUQ3RSxFQUVMbEUsT0FGSyxDQUFQO0FBSUQsS0FMRDs7QUFNQWlVLGtCQUFjLENBQUN6UyxrQkFBZixHQUFvQyxVQUFVdGEsSUFBVixFQUFnQjhZLE9BQWhCLEVBQXlCO0FBQzNELFVBQUkxTSxRQUFRLEdBQUduRCxRQUFRLENBQUMrUCxVQUFULENBQW9CbkMsZUFBcEIsRUFBcUNpQyxPQUFyQyxDQUFmOztBQUNBLGFBQU8sSUFBSTdCLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFlBQUlvRCxJQUFJLEdBQUdqTyxRQUFRLENBQUM4SyxJQUFULEVBQVg7O0FBQ0EsWUFBSW1ELElBQUksQ0FBQ3pDLElBQVQsRUFBZTtBQUNiLGlCQUFPeUMsSUFBUDtBQUNEOztBQUNELFlBQUlhLEtBQUssR0FBR2IsSUFBSSxDQUFDdFUsS0FBakI7QUFDQSxZQUFJb0gsR0FBRyxHQUFHK04sS0FBSyxDQUFDLENBQUQsQ0FBZjtBQUNBLGVBQU8xRCxhQUFhLENBQ2xCeFgsSUFEa0IsRUFFbEJtTixHQUZrQixFQUdsQmtWLE1BQU0sQ0FBQ3BXLElBQVAsQ0FBWTZnQixPQUFaLEVBQXFCNVIsS0FBSyxDQUFDLENBQUQsQ0FBMUIsRUFBK0IvTixHQUEvQixFQUFvQ2xFLFFBQXBDLENBSGtCLEVBSWxCb1IsSUFKa0IsQ0FBcEI7QUFNRCxPQWJNLENBQVA7QUFjRCxLQWhCRDs7QUFpQkEsV0FBTzBTLGNBQVA7QUFDRDs7QUFHRCxXQUFTRixjQUFULENBQXdCNWpCLFFBQXhCLEVBQWtDZ1MsT0FBbEMsRUFBMkM7QUFDekMsUUFBSTJSLGdCQUFnQixHQUFHYyxZQUFZLENBQUN6a0IsUUFBRCxDQUFuQztBQUNBMmpCLG9CQUFnQixDQUFDSCxLQUFqQixHQUF5QnhqQixRQUF6QjtBQUNBMmpCLG9CQUFnQixDQUFDM3JCLElBQWpCLEdBQXdCZ0ksUUFBUSxDQUFDaEksSUFBakM7O0FBQ0EyckIsb0JBQWdCLENBQUM5VCxPQUFqQixHQUEyQixZQUFZO0FBQUMsYUFBTzdQLFFBQVA7QUFBZ0IsS0FBeEQ7O0FBQ0EsUUFBSUEsUUFBUSxDQUFDcWpCLElBQWIsRUFBbUI7QUFDakJNLHNCQUFnQixDQUFDTixJQUFqQixHQUF3QixZQUFZO0FBQ2xDLFlBQUltQixZQUFZLEdBQUdELFdBQVcsQ0FBQ3ZrQixRQUFELENBQTlCOztBQUNBd2tCLG9CQUFZLENBQUMzVSxPQUFiLEdBQXVCLFlBQVk7QUFBQyxpQkFBTzdQLFFBQVEsQ0FBQ3FqQixJQUFULEVBQVA7QUFBdUIsU0FBM0Q7O0FBQ0EsZUFBT21CLFlBQVA7QUFDRCxPQUpEO0FBS0Q7O0FBQ0RiLG9CQUFnQixDQUFDaFQsR0FBakIsR0FBdUIsVUFBU3pNLEdBQVQsRUFBYzBNLFdBQWQsRUFDckI7QUFBQyxhQUFPNVEsUUFBUSxDQUFDMlEsR0FBVCxDQUFhcUIsT0FBTyxHQUFHOU4sR0FBSCxHQUFTLENBQUMsQ0FBRCxHQUFLQSxHQUFsQyxFQUF1QzBNLFdBQXZDLENBQVA7QUFBMkQsS0FEOUQ7O0FBRUErUyxvQkFBZ0IsQ0FBQzlTLEdBQWpCLEdBQXVCLFVBQVMzTSxHQUFULEVBQ3JCO0FBQUMsYUFBT2xFLFFBQVEsQ0FBQzZRLEdBQVQsQ0FBYW1CLE9BQU8sR0FBRzlOLEdBQUgsR0FBUyxDQUFDLENBQUQsR0FBS0EsR0FBbEMsQ0FBUDtBQUE4QyxLQURqRDs7QUFFQXlmLG9CQUFnQixDQUFDL1AsUUFBakIsR0FBNEIsVUFBUzlXLEtBQVQsRUFBaUI7QUFBQyxhQUFPa0QsUUFBUSxDQUFDNFQsUUFBVCxDQUFrQjlXLEtBQWxCLENBQVA7QUFBZ0MsS0FBOUU7O0FBQ0E2bUIsb0JBQWdCLENBQUNuVSxXQUFqQixHQUErQjhVLGtCQUEvQjs7QUFDQVgsb0JBQWdCLENBQUM5VyxTQUFqQixHQUE2QixVQUFVK0MsRUFBVixFQUFjQyxPQUFkLEVBQXVCO0FBQUMsVUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ25ELGFBQU8vVCxRQUFRLENBQUM2TSxTQUFULENBQW1CLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBQyxlQUFPb0IsRUFBRSxDQUFDbkIsQ0FBRCxFQUFJRCxDQUFKLEVBQU91RixNQUFQLENBQVQ7QUFBd0IsT0FBNUQsRUFBOEQsQ0FBQ2xFLE9BQS9ELENBQVA7QUFDRCxLQUZEOztBQUdBOFQsb0JBQWdCLENBQUM1VCxVQUFqQixHQUNFLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXlCO0FBQUMsYUFBTzdQLFFBQVEsQ0FBQytQLFVBQVQsQ0FBb0JoWixJQUFwQixFQUEwQixDQUFDOFksT0FBM0IsQ0FBUDtBQUEyQyxLQUR2RTs7QUFFQSxXQUFPOFQsZ0JBQVA7QUFDRDs7QUFHRCxXQUFTZSxhQUFULENBQXVCMWtCLFFBQXZCLEVBQWlDaUUsU0FBakMsRUFBNEM0ZixPQUE1QyxFQUFxRDdSLE9BQXJELEVBQThEO0FBQzVELFFBQUkyUyxjQUFjLEdBQUdGLFlBQVksQ0FBQ3prQixRQUFELENBQWpDOztBQUNBLFFBQUlnUyxPQUFKLEVBQWE7QUFDWDJTLG9CQUFjLENBQUM5VCxHQUFmLEdBQXFCLFVBQVMzTSxHQUFULEVBQWU7QUFDbEMsWUFBSXVLLENBQUMsR0FBR3pPLFFBQVEsQ0FBQzJRLEdBQVQsQ0FBYXpNLEdBQWIsRUFBa0I0SCxPQUFsQixDQUFSO0FBQ0EsZUFBTzJDLENBQUMsS0FBSzNDLE9BQU4sSUFBaUIsQ0FBQyxDQUFDN0gsU0FBUyxDQUFDakIsSUFBVixDQUFlNmdCLE9BQWYsRUFBd0JwVixDQUF4QixFQUEyQnZLLEdBQTNCLEVBQWdDbEUsUUFBaEMsQ0FBMUI7QUFDRCxPQUhEOztBQUlBMmtCLG9CQUFjLENBQUNoVSxHQUFmLEdBQXFCLFVBQVN6TSxHQUFULEVBQWMwTSxXQUFkLEVBQTRCO0FBQy9DLFlBQUluQyxDQUFDLEdBQUd6TyxRQUFRLENBQUMyUSxHQUFULENBQWF6TSxHQUFiLEVBQWtCNEgsT0FBbEIsQ0FBUjtBQUNBLGVBQU8yQyxDQUFDLEtBQUszQyxPQUFOLElBQWlCN0gsU0FBUyxDQUFDakIsSUFBVixDQUFlNmdCLE9BQWYsRUFBd0JwVixDQUF4QixFQUEyQnZLLEdBQTNCLEVBQWdDbEUsUUFBaEMsQ0FBakIsR0FDTHlPLENBREssR0FDRG1DLFdBRE47QUFFRCxPQUpEO0FBS0Q7O0FBQ0QrVCxrQkFBYyxDQUFDalYsaUJBQWYsR0FBbUMsVUFBVUUsRUFBVixFQUFjQyxPQUFkLEVBQXVCO0FBQUMsVUFBSWtFLE1BQU0sR0FBRyxJQUFiO0FBQ3pELFVBQUluWixVQUFVLEdBQUcsQ0FBakI7O0FBQ0FvRixjQUFRLENBQUM2TSxTQUFULENBQW1CLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZTBHLENBQWYsRUFBbUI7QUFDcEMsWUFBSWpSLFNBQVMsQ0FBQ2pCLElBQVYsQ0FBZTZnQixPQUFmLEVBQXdCcFYsQ0FBeEIsRUFBMkJELENBQTNCLEVBQThCMEcsQ0FBOUIsQ0FBSixFQUFzQztBQUNwQ3RhLG9CQUFVO0FBQ1YsaUJBQU9nVixFQUFFLENBQUNuQixDQUFELEVBQUl1RCxPQUFPLEdBQUd4RCxDQUFILEdBQU81VCxVQUFVLEdBQUcsQ0FBL0IsRUFBa0NtWixNQUFsQyxDQUFUO0FBQ0Q7QUFDRixPQUxELEVBS0dsRSxPQUxIOztBQU1BLGFBQU9qVixVQUFQO0FBQ0QsS0FURDs7QUFVQStwQixrQkFBYyxDQUFDdFQsa0JBQWYsR0FBb0MsVUFBVXRhLElBQVYsRUFBZ0I4WSxPQUFoQixFQUF5QjtBQUMzRCxVQUFJMU0sUUFBUSxHQUFHbkQsUUFBUSxDQUFDK1AsVUFBVCxDQUFvQm5DLGVBQXBCLEVBQXFDaUMsT0FBckMsQ0FBZjs7QUFDQSxVQUFJalYsVUFBVSxHQUFHLENBQWpCO0FBQ0EsYUFBTyxJQUFJb1QsUUFBSixDQUFhLFlBQVk7QUFDOUIsZUFBTyxJQUFQLEVBQWE7QUFDWCxjQUFJb0QsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYOztBQUNBLGNBQUltRCxJQUFJLENBQUN6QyxJQUFULEVBQWU7QUFDYixtQkFBT3lDLElBQVA7QUFDRDs7QUFDRCxjQUFJYSxLQUFLLEdBQUdiLElBQUksQ0FBQ3RVLEtBQWpCO0FBQ0EsY0FBSW9ILEdBQUcsR0FBRytOLEtBQUssQ0FBQyxDQUFELENBQWY7QUFDQSxjQUFJblYsS0FBSyxHQUFHbVYsS0FBSyxDQUFDLENBQUQsQ0FBakI7O0FBQ0EsY0FBSWhPLFNBQVMsQ0FBQ2pCLElBQVYsQ0FBZTZnQixPQUFmLEVBQXdCL21CLEtBQXhCLEVBQStCb0gsR0FBL0IsRUFBb0NsRSxRQUFwQyxDQUFKLEVBQW1EO0FBQ2pELG1CQUFPdU8sYUFBYSxDQUFDeFgsSUFBRCxFQUFPaWIsT0FBTyxHQUFHOU4sR0FBSCxHQUFTdEosVUFBVSxFQUFqQyxFQUFxQ2tDLEtBQXJDLEVBQTRDc1UsSUFBNUMsQ0FBcEI7QUFDRDtBQUNGO0FBQ0YsT0FiTSxDQUFQO0FBY0QsS0FqQkQ7O0FBa0JBLFdBQU91VCxjQUFQO0FBQ0Q7O0FBR0QsV0FBU0MsY0FBVCxDQUF3QjVrQixRQUF4QixFQUFrQzZrQixPQUFsQyxFQUEyQ2hCLE9BQTNDLEVBQW9EO0FBQ2xELFFBQUlpQixNQUFNLEdBQUc3TixHQUFHLEdBQUdxQyxTQUFOLEVBQWI7O0FBQ0F0WixZQUFRLENBQUM2TSxTQUFULENBQW1CLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFDakNzVyxZQUFNLENBQUMxcEIsTUFBUCxDQUNFeXBCLE9BQU8sQ0FBQzdoQixJQUFSLENBQWE2Z0IsT0FBYixFQUFzQnBWLENBQXRCLEVBQXlCRCxDQUF6QixFQUE0QnhPLFFBQTVCLENBREYsRUFFRSxDQUZGLEVBR0UsVUFBU3lELENBQVQsRUFBYTtBQUFDLGVBQU9BLENBQUMsR0FBRyxDQUFYO0FBQWEsT0FIN0I7QUFLRCxLQU5EOztBQU9BLFdBQU9xaEIsTUFBTSxDQUFDckwsV0FBUCxFQUFQO0FBQ0Q7O0FBR0QsV0FBU3NMLGNBQVQsQ0FBd0Iva0IsUUFBeEIsRUFBa0M2a0IsT0FBbEMsRUFBMkNoQixPQUEzQyxFQUFvRDtBQUNsRCxRQUFJbUIsV0FBVyxHQUFHMWEsT0FBTyxDQUFDdEssUUFBRCxDQUF6QjtBQUNBLFFBQUk4a0IsTUFBTSxHQUFHLENBQUN6WixTQUFTLENBQUNyTCxRQUFELENBQVQsR0FBc0JrWixVQUFVLEVBQWhDLEdBQXFDakMsR0FBRyxFQUF6QyxFQUE2Q3FDLFNBQTdDLEVBQWI7O0FBQ0F0WixZQUFRLENBQUM2TSxTQUFULENBQW1CLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFDakNzVyxZQUFNLENBQUMxcEIsTUFBUCxDQUNFeXBCLE9BQU8sQ0FBQzdoQixJQUFSLENBQWE2Z0IsT0FBYixFQUFzQnBWLENBQXRCLEVBQXlCRCxDQUF6QixFQUE0QnhPLFFBQTVCLENBREYsRUFFRSxVQUFTeUQsQ0FBVCxFQUFhO0FBQUMsZUFBUUEsQ0FBQyxHQUFHQSxDQUFDLElBQUksRUFBVCxFQUFhQSxDQUFDLENBQUNzRCxJQUFGLENBQU9pZSxXQUFXLEdBQUcsQ0FBQ3hXLENBQUQsRUFBSUMsQ0FBSixDQUFILEdBQVlBLENBQTlCLENBQWIsRUFBK0NoTCxDQUF2RDtBQUEwRCxPQUYxRTtBQUlELEtBTEQ7O0FBTUEsUUFBSXdoQixNQUFNLEdBQUdDLGFBQWEsQ0FBQ2xsQixRQUFELENBQTFCO0FBQ0EsV0FBTzhrQixNQUFNLENBQUMxb0IsR0FBUCxDQUFXLFVBQVNrUSxHQUFULEVBQWU7QUFBQyxhQUFPNlksS0FBSyxDQUFDbmxCLFFBQUQsRUFBV2lsQixNQUFNLENBQUMzWSxHQUFELENBQWpCLENBQVo7QUFBb0MsS0FBL0QsQ0FBUDtBQUNEOztBQUdELFdBQVM4WSxZQUFULENBQXNCcGxCLFFBQXRCLEVBQWdDbU4sS0FBaEMsRUFBdUNDLEdBQXZDLEVBQTRDNEUsT0FBNUMsRUFBcUQ7QUFDbkQsUUFBSXFULFlBQVksR0FBR3JsQixRQUFRLENBQUNoSSxJQUE1QixDQURtRCxDQUduRDtBQUNBOztBQUNBLFFBQUltVixLQUFLLEtBQUt4UixTQUFkLEVBQXlCO0FBQ3ZCd1IsV0FBSyxHQUFHQSxLQUFLLEdBQUcsQ0FBaEI7QUFDRDs7QUFDRCxRQUFJQyxHQUFHLEtBQUt6UixTQUFaLEVBQXVCO0FBQ3JCLFVBQUl5UixHQUFHLEtBQUtzRyxRQUFaLEVBQXNCO0FBQ3BCdEcsV0FBRyxHQUFHaVksWUFBTjtBQUNELE9BRkQsTUFFTztBQUNMalksV0FBRyxHQUFHQSxHQUFHLEdBQUcsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSUYsVUFBVSxDQUFDQyxLQUFELEVBQVFDLEdBQVIsRUFBYWlZLFlBQWIsQ0FBZCxFQUEwQztBQUN4QyxhQUFPcmxCLFFBQVA7QUFDRDs7QUFFRCxRQUFJc2xCLGFBQWEsR0FBR2pZLFlBQVksQ0FBQ0YsS0FBRCxFQUFRa1ksWUFBUixDQUFoQztBQUNBLFFBQUlFLFdBQVcsR0FBR2hZLFVBQVUsQ0FBQ0gsR0FBRCxFQUFNaVksWUFBTixDQUE1QixDQXJCbUQsQ0F1Qm5EO0FBQ0E7QUFDQTs7QUFDQSxRQUFJQyxhQUFhLEtBQUtBLGFBQWxCLElBQW1DQyxXQUFXLEtBQUtBLFdBQXZELEVBQW9FO0FBQ2xFLGFBQU9ILFlBQVksQ0FBQ3BsQixRQUFRLENBQUNxUCxLQUFULEdBQWlCRyxXQUFqQixFQUFELEVBQWlDckMsS0FBakMsRUFBd0NDLEdBQXhDLEVBQTZDNEUsT0FBN0MsQ0FBbkI7QUFDRCxLQTVCa0QsQ0E4Qm5EO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJd1QsWUFBWSxHQUFHRCxXQUFXLEdBQUdELGFBQWpDO0FBQ0EsUUFBSUcsU0FBSjs7QUFDQSxRQUFJRCxZQUFZLEtBQUtBLFlBQXJCLEVBQW1DO0FBQ2pDQyxlQUFTLEdBQUdELFlBQVksR0FBRyxDQUFmLEdBQW1CLENBQW5CLEdBQXVCQSxZQUFuQztBQUNEOztBQUVELFFBQUlFLFFBQVEsR0FBR2pCLFlBQVksQ0FBQ3prQixRQUFELENBQTNCLENBeENtRCxDQTBDbkQ7QUFDQTs7QUFDQTBsQixZQUFRLENBQUMxdEIsSUFBVCxHQUFnQnl0QixTQUFTLEtBQUssQ0FBZCxHQUFrQkEsU0FBbEIsR0FBOEJ6bEIsUUFBUSxDQUFDaEksSUFBVCxJQUFpQnl0QixTQUFqQixJQUE4QjlwQixTQUE1RTs7QUFFQSxRQUFJLENBQUNxVyxPQUFELElBQVl6QixLQUFLLENBQUN2USxRQUFELENBQWpCLElBQStCeWxCLFNBQVMsSUFBSSxDQUFoRCxFQUFtRDtBQUNqREMsY0FBUSxDQUFDL1UsR0FBVCxHQUFlLFVBQVU3TSxLQUFWLEVBQWlCOE0sV0FBakIsRUFBOEI7QUFDM0M5TSxhQUFLLEdBQUdpSixTQUFTLENBQUMsSUFBRCxFQUFPakosS0FBUCxDQUFqQjtBQUNBLGVBQU9BLEtBQUssSUFBSSxDQUFULElBQWNBLEtBQUssR0FBRzJoQixTQUF0QixHQUNMemxCLFFBQVEsQ0FBQzJRLEdBQVQsQ0FBYTdNLEtBQUssR0FBR3doQixhQUFyQixFQUFvQzFVLFdBQXBDLENBREssR0FFTEEsV0FGRjtBQUdELE9BTEQ7QUFNRDs7QUFFRDhVLFlBQVEsQ0FBQ2hXLGlCQUFULEdBQTZCLFVBQVNFLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUFDLFVBQUlrRSxNQUFNLEdBQUcsSUFBYjs7QUFDbEQsVUFBSTBSLFNBQVMsS0FBSyxDQUFsQixFQUFxQjtBQUNuQixlQUFPLENBQVA7QUFDRDs7QUFDRCxVQUFJNVYsT0FBSixFQUFhO0FBQ1gsZUFBTyxLQUFLTCxXQUFMLEdBQW1CM0MsU0FBbkIsQ0FBNkIrQyxFQUE3QixFQUFpQ0MsT0FBakMsQ0FBUDtBQUNEOztBQUNELFVBQUk4VixPQUFPLEdBQUcsQ0FBZDtBQUNBLFVBQUlDLFVBQVUsR0FBRyxJQUFqQjtBQUNBLFVBQUlockIsVUFBVSxHQUFHLENBQWpCOztBQUNBb0YsY0FBUSxDQUFDNk0sU0FBVCxDQUFtQixVQUFTNEIsQ0FBVCxFQUFZRCxDQUFaLEVBQWdCO0FBQ2pDLFlBQUksRUFBRW9YLFVBQVUsS0FBS0EsVUFBVSxHQUFHRCxPQUFPLEtBQUtMLGFBQTlCLENBQVosQ0FBSixFQUErRDtBQUM3RDFxQixvQkFBVTtBQUNWLGlCQUFPZ1YsRUFBRSxDQUFDbkIsQ0FBRCxFQUFJdUQsT0FBTyxHQUFHeEQsQ0FBSCxHQUFPNVQsVUFBVSxHQUFHLENBQS9CLEVBQWtDbVosTUFBbEMsQ0FBRixLQUFnRCxLQUFoRCxJQUNBblosVUFBVSxLQUFLNnFCLFNBRHRCO0FBRUQ7QUFDRixPQU5EOztBQU9BLGFBQU83cUIsVUFBUDtBQUNELEtBbEJEOztBQW9CQThxQixZQUFRLENBQUNyVSxrQkFBVCxHQUE4QixVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUNwRCxVQUFJNFYsU0FBUyxLQUFLLENBQWQsSUFBbUI1VixPQUF2QixFQUFnQztBQUM5QixlQUFPLEtBQUtMLFdBQUwsR0FBbUJPLFVBQW5CLENBQThCaFosSUFBOUIsRUFBb0M4WSxPQUFwQyxDQUFQO0FBQ0QsT0FIbUQsQ0FJcEQ7OztBQUNBLFVBQUkxTSxRQUFRLEdBQUdzaUIsU0FBUyxLQUFLLENBQWQsSUFBbUJ6bEIsUUFBUSxDQUFDK1AsVUFBVCxDQUFvQmhaLElBQXBCLEVBQTBCOFksT0FBMUIsQ0FBbEM7O0FBQ0EsVUFBSThWLE9BQU8sR0FBRyxDQUFkO0FBQ0EsVUFBSS9xQixVQUFVLEdBQUcsQ0FBakI7QUFDQSxhQUFPLElBQUlvVCxRQUFKLENBQWEsWUFBWTtBQUM5QixlQUFPMlgsT0FBTyxLQUFLTCxhQUFuQixFQUFrQztBQUNoQ25pQixrQkFBUSxDQUFDOEssSUFBVDtBQUNEOztBQUNELFlBQUksRUFBRXJULFVBQUYsR0FBZTZxQixTQUFuQixFQUE4QjtBQUM1QixpQkFBTzdXLFlBQVksRUFBbkI7QUFDRDs7QUFDRCxZQUFJd0MsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYOztBQUNBLFlBQUkrRCxPQUFPLElBQUlqYixJQUFJLEtBQUs0VyxjQUF4QixFQUF3QztBQUN0QyxpQkFBT3lELElBQVA7QUFDRCxTQUZELE1BRU8sSUFBSXJhLElBQUksS0FBSzJXLFlBQWIsRUFBMkI7QUFDaEMsaUJBQU9hLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTzZELFVBQVUsR0FBRyxDQUFwQixFQUF1QmUsU0FBdkIsRUFBa0N5VixJQUFsQyxDQUFwQjtBQUNELFNBRk0sTUFFQTtBQUNMLGlCQUFPN0MsYUFBYSxDQUFDeFgsSUFBRCxFQUFPNkQsVUFBVSxHQUFHLENBQXBCLEVBQXVCd1csSUFBSSxDQUFDdFUsS0FBTCxDQUFXLENBQVgsQ0FBdkIsRUFBc0NzVSxJQUF0QyxDQUFwQjtBQUNEO0FBQ0YsT0FmTSxDQUFQO0FBZ0JELEtBeEJEOztBQTBCQSxXQUFPc1UsUUFBUDtBQUNEOztBQUdELFdBQVNHLGdCQUFULENBQTBCN2xCLFFBQTFCLEVBQW9DaUUsU0FBcEMsRUFBK0M0ZixPQUEvQyxFQUF3RDtBQUN0RCxRQUFJaUMsWUFBWSxHQUFHckIsWUFBWSxDQUFDemtCLFFBQUQsQ0FBL0I7O0FBQ0E4bEIsZ0JBQVksQ0FBQ3BXLGlCQUFiLEdBQWlDLFVBQVNFLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUFDLFVBQUlrRSxNQUFNLEdBQUcsSUFBYjs7QUFDdEQsVUFBSWxFLE9BQUosRUFBYTtBQUNYLGVBQU8sS0FBS0wsV0FBTCxHQUFtQjNDLFNBQW5CLENBQTZCK0MsRUFBN0IsRUFBaUNDLE9BQWpDLENBQVA7QUFDRDs7QUFDRCxVQUFJalYsVUFBVSxHQUFHLENBQWpCOztBQUNBb0YsY0FBUSxDQUFDNk0sU0FBVCxDQUFtQixVQUFTNEIsQ0FBVCxFQUFZRCxDQUFaLEVBQWUwRyxDQUFmLEVBQ2pCO0FBQUMsZUFBT2pSLFNBQVMsQ0FBQ2pCLElBQVYsQ0FBZTZnQixPQUFmLEVBQXdCcFYsQ0FBeEIsRUFBMkJELENBQTNCLEVBQThCMEcsQ0FBOUIsS0FBb0MsRUFBRXRhLFVBQXRDLElBQW9EZ1YsRUFBRSxDQUFDbkIsQ0FBRCxFQUFJRCxDQUFKLEVBQU91RixNQUFQLENBQTdEO0FBQTRFLE9BRC9FOztBQUdBLGFBQU9uWixVQUFQO0FBQ0QsS0FURDs7QUFVQWtyQixnQkFBWSxDQUFDelUsa0JBQWIsR0FBa0MsVUFBU3RhLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFBQyxVQUFJa0UsTUFBTSxHQUFHLElBQWI7O0FBQ3pELFVBQUlsRSxPQUFKLEVBQWE7QUFDWCxlQUFPLEtBQUtMLFdBQUwsR0FBbUJPLFVBQW5CLENBQThCaFosSUFBOUIsRUFBb0M4WSxPQUFwQyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSTFNLFFBQVEsR0FBR25ELFFBQVEsQ0FBQytQLFVBQVQsQ0FBb0JuQyxlQUFwQixFQUFxQ2lDLE9BQXJDLENBQWY7O0FBQ0EsVUFBSWtXLFNBQVMsR0FBRyxJQUFoQjtBQUNBLGFBQU8sSUFBSS9YLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFlBQUksQ0FBQytYLFNBQUwsRUFBZ0I7QUFDZCxpQkFBT25YLFlBQVksRUFBbkI7QUFDRDs7QUFDRCxZQUFJd0MsSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYOztBQUNBLFlBQUltRCxJQUFJLENBQUN6QyxJQUFULEVBQWU7QUFDYixpQkFBT3lDLElBQVA7QUFDRDs7QUFDRCxZQUFJYSxLQUFLLEdBQUdiLElBQUksQ0FBQ3RVLEtBQWpCO0FBQ0EsWUFBSTBSLENBQUMsR0FBR3lELEtBQUssQ0FBQyxDQUFELENBQWI7QUFDQSxZQUFJeEQsQ0FBQyxHQUFHd0QsS0FBSyxDQUFDLENBQUQsQ0FBYjs7QUFDQSxZQUFJLENBQUNoTyxTQUFTLENBQUNqQixJQUFWLENBQWU2Z0IsT0FBZixFQUF3QnBWLENBQXhCLEVBQTJCRCxDQUEzQixFQUE4QnVGLE1BQTlCLENBQUwsRUFBNEM7QUFDMUNnUyxtQkFBUyxHQUFHLEtBQVo7QUFDQSxpQkFBT25YLFlBQVksRUFBbkI7QUFDRDs7QUFDRCxlQUFPN1gsSUFBSSxLQUFLNlcsZUFBVCxHQUEyQndELElBQTNCLEdBQ0w3QyxhQUFhLENBQUN4WCxJQUFELEVBQU95WCxDQUFQLEVBQVVDLENBQVYsRUFBYTJDLElBQWIsQ0FEZjtBQUVELE9BakJNLENBQVA7QUFrQkQsS0F4QkQ7O0FBeUJBLFdBQU8wVSxZQUFQO0FBQ0Q7O0FBR0QsV0FBU0UsZ0JBQVQsQ0FBMEJobUIsUUFBMUIsRUFBb0NpRSxTQUFwQyxFQUErQzRmLE9BQS9DLEVBQXdEN1IsT0FBeEQsRUFBaUU7QUFDL0QsUUFBSWlVLFlBQVksR0FBR3hCLFlBQVksQ0FBQ3prQixRQUFELENBQS9COztBQUNBaW1CLGdCQUFZLENBQUN2VyxpQkFBYixHQUFpQyxVQUFVRSxFQUFWLEVBQWNDLE9BQWQsRUFBdUI7QUFBQyxVQUFJa0UsTUFBTSxHQUFHLElBQWI7O0FBQ3ZELFVBQUlsRSxPQUFKLEVBQWE7QUFDWCxlQUFPLEtBQUtMLFdBQUwsR0FBbUIzQyxTQUFuQixDQUE2QitDLEVBQTdCLEVBQWlDQyxPQUFqQyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSStWLFVBQVUsR0FBRyxJQUFqQjtBQUNBLFVBQUlockIsVUFBVSxHQUFHLENBQWpCOztBQUNBb0YsY0FBUSxDQUFDNk0sU0FBVCxDQUFtQixVQUFTNEIsQ0FBVCxFQUFZRCxDQUFaLEVBQWUwRyxDQUFmLEVBQW1CO0FBQ3BDLFlBQUksRUFBRTBRLFVBQVUsS0FBS0EsVUFBVSxHQUFHM2hCLFNBQVMsQ0FBQ2pCLElBQVYsQ0FBZTZnQixPQUFmLEVBQXdCcFYsQ0FBeEIsRUFBMkJELENBQTNCLEVBQThCMEcsQ0FBOUIsQ0FBbEIsQ0FBWixDQUFKLEVBQXNFO0FBQ3BFdGEsb0JBQVU7QUFDVixpQkFBT2dWLEVBQUUsQ0FBQ25CLENBQUQsRUFBSXVELE9BQU8sR0FBR3hELENBQUgsR0FBTzVULFVBQVUsR0FBRyxDQUEvQixFQUFrQ21aLE1BQWxDLENBQVQ7QUFDRDtBQUNGLE9BTEQ7O0FBTUEsYUFBT25aLFVBQVA7QUFDRCxLQWJEOztBQWNBcXJCLGdCQUFZLENBQUM1VSxrQkFBYixHQUFrQyxVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUFDLFVBQUlrRSxNQUFNLEdBQUcsSUFBYjs7QUFDekQsVUFBSWxFLE9BQUosRUFBYTtBQUNYLGVBQU8sS0FBS0wsV0FBTCxHQUFtQk8sVUFBbkIsQ0FBOEJoWixJQUE5QixFQUFvQzhZLE9BQXBDLENBQVA7QUFDRDs7QUFDRCxVQUFJMU0sUUFBUSxHQUFHbkQsUUFBUSxDQUFDK1AsVUFBVCxDQUFvQm5DLGVBQXBCLEVBQXFDaUMsT0FBckMsQ0FBZjs7QUFDQSxVQUFJcVcsUUFBUSxHQUFHLElBQWY7QUFDQSxVQUFJdHJCLFVBQVUsR0FBRyxDQUFqQjtBQUNBLGFBQU8sSUFBSW9ULFFBQUosQ0FBYSxZQUFZO0FBQzlCLFlBQUlvRCxJQUFKLEVBQVU1QyxDQUFWLEVBQWFDLENBQWI7O0FBQ0EsV0FBRztBQUNEMkMsY0FBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFQOztBQUNBLGNBQUltRCxJQUFJLENBQUN6QyxJQUFULEVBQWU7QUFDYixnQkFBSXFELE9BQU8sSUFBSWpiLElBQUksS0FBSzRXLGNBQXhCLEVBQXdDO0FBQ3RDLHFCQUFPeUQsSUFBUDtBQUNELGFBRkQsTUFFTyxJQUFJcmEsSUFBSSxLQUFLMlcsWUFBYixFQUEyQjtBQUNoQyxxQkFBT2EsYUFBYSxDQUFDeFgsSUFBRCxFQUFPNkQsVUFBVSxFQUFqQixFQUFxQmUsU0FBckIsRUFBZ0N5VixJQUFoQyxDQUFwQjtBQUNELGFBRk0sTUFFQTtBQUNMLHFCQUFPN0MsYUFBYSxDQUFDeFgsSUFBRCxFQUFPNkQsVUFBVSxFQUFqQixFQUFxQndXLElBQUksQ0FBQ3RVLEtBQUwsQ0FBVyxDQUFYLENBQXJCLEVBQW9Dc1UsSUFBcEMsQ0FBcEI7QUFDRDtBQUNGOztBQUNELGNBQUlhLEtBQUssR0FBR2IsSUFBSSxDQUFDdFUsS0FBakI7QUFDQTBSLFdBQUMsR0FBR3lELEtBQUssQ0FBQyxDQUFELENBQVQ7QUFDQXhELFdBQUMsR0FBR3dELEtBQUssQ0FBQyxDQUFELENBQVQ7QUFDQWlVLGtCQUFRLEtBQUtBLFFBQVEsR0FBR2ppQixTQUFTLENBQUNqQixJQUFWLENBQWU2Z0IsT0FBZixFQUF3QnBWLENBQXhCLEVBQTJCRCxDQUEzQixFQUE4QnVGLE1BQTlCLENBQWhCLENBQVI7QUFDRCxTQWZELFFBZVNtUyxRQWZUOztBQWdCQSxlQUFPbnZCLElBQUksS0FBSzZXLGVBQVQsR0FBMkJ3RCxJQUEzQixHQUNMN0MsYUFBYSxDQUFDeFgsSUFBRCxFQUFPeVgsQ0FBUCxFQUFVQyxDQUFWLEVBQWEyQyxJQUFiLENBRGY7QUFFRCxPQXBCTSxDQUFQO0FBcUJELEtBNUJEOztBQTZCQSxXQUFPNlUsWUFBUDtBQUNEOztBQUdELFdBQVNFLGFBQVQsQ0FBdUJubUIsUUFBdkIsRUFBaUN3ZixNQUFqQyxFQUF5QztBQUN2QyxRQUFJNEcsZUFBZSxHQUFHOWIsT0FBTyxDQUFDdEssUUFBRCxDQUE3QjtBQUNBLFFBQUl3WSxLQUFLLEdBQUcsQ0FBQ3hZLFFBQUQsRUFBVzBGLE1BQVgsQ0FBa0I4WixNQUFsQixFQUEwQnBqQixHQUExQixDQUE4QixVQUFTcVMsQ0FBVCxFQUFhO0FBQ3JELFVBQUksQ0FBQ3RFLFVBQVUsQ0FBQ3NFLENBQUQsQ0FBZixFQUFvQjtBQUNsQkEsU0FBQyxHQUFHMlgsZUFBZSxHQUNqQmpXLGlCQUFpQixDQUFDMUIsQ0FBRCxDQURBLEdBRWpCMkIsbUJBQW1CLENBQUM1VyxLQUFLLENBQUN5SixPQUFOLENBQWN3TCxDQUFkLElBQW1CQSxDQUFuQixHQUF1QixDQUFDQSxDQUFELENBQXhCLENBRnJCO0FBR0QsT0FKRCxNQUlPLElBQUkyWCxlQUFKLEVBQXFCO0FBQzFCM1gsU0FBQyxHQUFHcEUsYUFBYSxDQUFDb0UsQ0FBRCxDQUFqQjtBQUNEOztBQUNELGFBQU9BLENBQVA7QUFDRCxLQVRXLEVBU1R0RyxNQVRTLENBU0YsVUFBU3NHLENBQVQsRUFBYTtBQUFDLGFBQU9BLENBQUMsQ0FBQ3pXLElBQUYsS0FBVyxDQUFsQjtBQUFvQixLQVRoQyxDQUFaOztBQVdBLFFBQUl3Z0IsS0FBSyxDQUFDNWMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixhQUFPb0UsUUFBUDtBQUNEOztBQUVELFFBQUl3WSxLQUFLLENBQUM1YyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLFVBQUl5cUIsU0FBUyxHQUFHN04sS0FBSyxDQUFDLENBQUQsQ0FBckI7O0FBQ0EsVUFBSTZOLFNBQVMsS0FBS3JtQixRQUFkLElBQ0FvbUIsZUFBZSxJQUFJOWIsT0FBTyxDQUFDK2IsU0FBRCxDQUQxQixJQUVBNWIsU0FBUyxDQUFDekssUUFBRCxDQUFULElBQXVCeUssU0FBUyxDQUFDNGIsU0FBRCxDQUZwQyxFQUVpRDtBQUMvQyxlQUFPQSxTQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJQyxTQUFTLEdBQUcsSUFBSTdWLFFBQUosQ0FBYStILEtBQWIsQ0FBaEI7O0FBQ0EsUUFBSTROLGVBQUosRUFBcUI7QUFDbkJFLGVBQVMsR0FBR0EsU0FBUyxDQUFDclcsVUFBVixFQUFaO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQ3hGLFNBQVMsQ0FBQ3pLLFFBQUQsQ0FBZCxFQUEwQjtBQUMvQnNtQixlQUFTLEdBQUdBLFNBQVMsQ0FBQ2hXLFFBQVYsRUFBWjtBQUNEOztBQUNEZ1csYUFBUyxHQUFHQSxTQUFTLENBQUNDLE9BQVYsQ0FBa0IsSUFBbEIsQ0FBWjtBQUNBRCxhQUFTLENBQUN0dUIsSUFBVixHQUFpQndnQixLQUFLLENBQUN4VCxNQUFOLENBQ2YsVUFBU3doQixHQUFULEVBQWMzVSxHQUFkLEVBQW9CO0FBQ2xCLFVBQUkyVSxHQUFHLEtBQUs3cUIsU0FBWixFQUF1QjtBQUNyQixZQUFJM0QsSUFBSSxHQUFHNlosR0FBRyxDQUFDN1osSUFBZjs7QUFDQSxZQUFJQSxJQUFJLEtBQUsyRCxTQUFiLEVBQXdCO0FBQ3RCLGlCQUFPNnFCLEdBQUcsR0FBR3h1QixJQUFiO0FBQ0Q7QUFDRjtBQUNGLEtBUmMsRUFTZixDQVRlLENBQWpCO0FBV0EsV0FBT3N1QixTQUFQO0FBQ0Q7O0FBR0QsV0FBU0csY0FBVCxDQUF3QnptQixRQUF4QixFQUFrQzBtQixLQUFsQyxFQUF5QzFVLE9BQXpDLEVBQWtEO0FBQ2hELFFBQUkyVSxZQUFZLEdBQUdsQyxZQUFZLENBQUN6a0IsUUFBRCxDQUEvQjs7QUFDQTJtQixnQkFBWSxDQUFDalgsaUJBQWIsR0FBaUMsVUFBU0UsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQ3JELFVBQUlqVixVQUFVLEdBQUcsQ0FBakI7QUFDQSxVQUFJZ3NCLE9BQU8sR0FBRyxLQUFkOztBQUNBLGVBQVNDLFFBQVQsQ0FBa0JqYSxJQUFsQixFQUF3QmthLFlBQXhCLEVBQXNDO0FBQUMsWUFBSS9TLE1BQU0sR0FBRyxJQUFiOztBQUNyQ25ILFlBQUksQ0FBQ0MsU0FBTCxDQUFlLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFDN0IsY0FBSSxDQUFDLENBQUNrWSxLQUFELElBQVVJLFlBQVksR0FBR0osS0FBMUIsS0FBb0N2YyxVQUFVLENBQUNzRSxDQUFELENBQWxELEVBQXVEO0FBQ3JEb1ksb0JBQVEsQ0FBQ3BZLENBQUQsRUFBSXFZLFlBQVksR0FBRyxDQUFuQixDQUFSO0FBQ0QsV0FGRCxNQUVPLElBQUlsWCxFQUFFLENBQUNuQixDQUFELEVBQUl1RCxPQUFPLEdBQUd4RCxDQUFILEdBQU81VCxVQUFVLEVBQTVCLEVBQWdDbVosTUFBaEMsQ0FBRixLQUE4QyxLQUFsRCxFQUF5RDtBQUM5RDZTLG1CQUFPLEdBQUcsSUFBVjtBQUNEOztBQUNELGlCQUFPLENBQUNBLE9BQVI7QUFDRCxTQVBELEVBT0cvVyxPQVBIO0FBUUQ7O0FBQ0RnWCxjQUFRLENBQUM3bUIsUUFBRCxFQUFXLENBQVgsQ0FBUjtBQUNBLGFBQU9wRixVQUFQO0FBQ0QsS0FmRDs7QUFnQkErckIsZ0JBQVksQ0FBQ3RWLGtCQUFiLEdBQWtDLFVBQVN0YSxJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ3hELFVBQUkxTSxRQUFRLEdBQUduRCxRQUFRLENBQUMrUCxVQUFULENBQW9CaFosSUFBcEIsRUFBMEI4WSxPQUExQixDQUFmOztBQUNBLFVBQUk0TSxLQUFLLEdBQUcsRUFBWjtBQUNBLFVBQUk3aEIsVUFBVSxHQUFHLENBQWpCO0FBQ0EsYUFBTyxJQUFJb1QsUUFBSixDQUFhLFlBQVk7QUFDOUIsZUFBTzdLLFFBQVAsRUFBaUI7QUFDZixjQUFJaU8sSUFBSSxHQUFHak8sUUFBUSxDQUFDOEssSUFBVCxFQUFYOztBQUNBLGNBQUltRCxJQUFJLENBQUN6QyxJQUFMLEtBQWMsS0FBbEIsRUFBeUI7QUFDdkJ4TCxvQkFBUSxHQUFHc1osS0FBSyxDQUFDMVcsR0FBTixFQUFYO0FBQ0E7QUFDRDs7QUFDRCxjQUFJMEksQ0FBQyxHQUFHMkMsSUFBSSxDQUFDdFUsS0FBYjs7QUFDQSxjQUFJL0YsSUFBSSxLQUFLNlcsZUFBYixFQUE4QjtBQUM1QmEsYUFBQyxHQUFHQSxDQUFDLENBQUMsQ0FBRCxDQUFMO0FBQ0Q7O0FBQ0QsY0FBSSxDQUFDLENBQUNpWSxLQUFELElBQVVqSyxLQUFLLENBQUM3Z0IsTUFBTixHQUFlOHFCLEtBQTFCLEtBQW9DdmMsVUFBVSxDQUFDc0UsQ0FBRCxDQUFsRCxFQUF1RDtBQUNyRGdPLGlCQUFLLENBQUMxVixJQUFOLENBQVc1RCxRQUFYO0FBQ0FBLG9CQUFRLEdBQUdzTCxDQUFDLENBQUNzQixVQUFGLENBQWFoWixJQUFiLEVBQW1COFksT0FBbkIsQ0FBWDtBQUNELFdBSEQsTUFHTztBQUNMLG1CQUFPbUMsT0FBTyxHQUFHWixJQUFILEdBQVU3QyxhQUFhLENBQUN4WCxJQUFELEVBQU82RCxVQUFVLEVBQWpCLEVBQXFCNlQsQ0FBckIsRUFBd0IyQyxJQUF4QixDQUFyQztBQUNEO0FBQ0Y7O0FBQ0QsZUFBT3hDLFlBQVksRUFBbkI7QUFDRCxPQW5CTSxDQUFQO0FBb0JELEtBeEJEOztBQXlCQSxXQUFPK1gsWUFBUDtBQUNEOztBQUdELFdBQVNJLGNBQVQsQ0FBd0IvbUIsUUFBeEIsRUFBa0NvWixNQUFsQyxFQUEwQ3lLLE9BQTFDLEVBQW1EO0FBQ2pELFFBQUlvQixNQUFNLEdBQUdDLGFBQWEsQ0FBQ2xsQixRQUFELENBQTFCO0FBQ0EsV0FBT0EsUUFBUSxDQUFDcVAsS0FBVCxHQUFpQmpULEdBQWpCLENBQ0wsVUFBU3FTLENBQVQsRUFBWUQsQ0FBWixFQUFnQjtBQUFDLGFBQU95VyxNQUFNLENBQUM3TCxNQUFNLENBQUNwVyxJQUFQLENBQVk2Z0IsT0FBWixFQUFxQnBWLENBQXJCLEVBQXdCRCxDQUF4QixFQUEyQnhPLFFBQTNCLENBQUQsQ0FBYjtBQUFvRCxLQURoRSxFQUVMdW1CLE9BRkssQ0FFRyxJQUZILENBQVA7QUFHRDs7QUFHRCxXQUFTUyxnQkFBVCxDQUEwQmhuQixRQUExQixFQUFvQ2luQixTQUFwQyxFQUErQztBQUM3QyxRQUFJQyxrQkFBa0IsR0FBR3pDLFlBQVksQ0FBQ3prQixRQUFELENBQXJDO0FBQ0FrbkIsc0JBQWtCLENBQUNsdkIsSUFBbkIsR0FBMEJnSSxRQUFRLENBQUNoSSxJQUFULElBQWlCZ0ksUUFBUSxDQUFDaEksSUFBVCxHQUFnQixDQUFoQixHQUFtQixDQUE5RDs7QUFDQWt2QixzQkFBa0IsQ0FBQ3hYLGlCQUFuQixHQUF1QyxVQUFTRSxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFBQyxVQUFJa0UsTUFBTSxHQUFHLElBQWI7QUFDNUQsVUFBSW5aLFVBQVUsR0FBRyxDQUFqQjs7QUFDQW9GLGNBQVEsQ0FBQzZNLFNBQVQsQ0FBbUIsVUFBUzRCLENBQVQsRUFBWUQsQ0FBWixFQUNqQjtBQUFDLGVBQU8sQ0FBQyxDQUFDNVQsVUFBRCxJQUFlZ1YsRUFBRSxDQUFDcVgsU0FBRCxFQUFZcnNCLFVBQVUsRUFBdEIsRUFBMEJtWixNQUExQixDQUFGLEtBQXdDLEtBQXhELEtBQ1JuRSxFQUFFLENBQUNuQixDQUFELEVBQUk3VCxVQUFVLEVBQWQsRUFBa0JtWixNQUFsQixDQUFGLEtBQWdDLEtBRC9CO0FBQ3FDLE9BRnhDLEVBR0VsRSxPQUhGOztBQUtBLGFBQU9qVixVQUFQO0FBQ0QsS0FSRDs7QUFTQXNzQixzQkFBa0IsQ0FBQzdWLGtCQUFuQixHQUF3QyxVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUM5RCxVQUFJMU0sUUFBUSxHQUFHbkQsUUFBUSxDQUFDK1AsVUFBVCxDQUFvQnBDLGNBQXBCLEVBQW9Da0MsT0FBcEMsQ0FBZjs7QUFDQSxVQUFJalYsVUFBVSxHQUFHLENBQWpCO0FBQ0EsVUFBSXdXLElBQUo7QUFDQSxhQUFPLElBQUlwRCxRQUFKLENBQWEsWUFBWTtBQUM5QixZQUFJLENBQUNvRCxJQUFELElBQVN4VyxVQUFVLEdBQUcsQ0FBMUIsRUFBNkI7QUFDM0J3VyxjQUFJLEdBQUdqTyxRQUFRLENBQUM4SyxJQUFULEVBQVA7O0FBQ0EsY0FBSW1ELElBQUksQ0FBQ3pDLElBQVQsRUFBZTtBQUNiLG1CQUFPeUMsSUFBUDtBQUNEO0FBQ0Y7O0FBQ0QsZUFBT3hXLFVBQVUsR0FBRyxDQUFiLEdBQ0wyVCxhQUFhLENBQUN4WCxJQUFELEVBQU82RCxVQUFVLEVBQWpCLEVBQXFCcXNCLFNBQXJCLENBRFIsR0FFTDFZLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTzZELFVBQVUsRUFBakIsRUFBcUJ3VyxJQUFJLENBQUN0VSxLQUExQixFQUFpQ3NVLElBQWpDLENBRmY7QUFHRCxPQVZNLENBQVA7QUFXRCxLQWZEOztBQWdCQSxXQUFPOFYsa0JBQVA7QUFDRDs7QUFHRCxXQUFTL04sV0FBVCxDQUFxQm5aLFFBQXJCLEVBQStCaVosVUFBL0IsRUFBMkNHLE1BQTNDLEVBQW1EO0FBQ2pELFFBQUksQ0FBQ0gsVUFBTCxFQUFpQjtBQUNmQSxnQkFBVSxHQUFHa08saUJBQWI7QUFDRDs7QUFDRCxRQUFJZixlQUFlLEdBQUc5YixPQUFPLENBQUN0SyxRQUFELENBQTdCO0FBQ0EsUUFBSThELEtBQUssR0FBRyxDQUFaO0FBQ0EsUUFBSW9QLE9BQU8sR0FBR2xULFFBQVEsQ0FBQ3FQLEtBQVQsR0FBaUJqVCxHQUFqQixDQUNaLFVBQVNxUyxDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBQyxhQUFPLENBQUNBLENBQUQsRUFBSUMsQ0FBSixFQUFPM0ssS0FBSyxFQUFaLEVBQWdCc1YsTUFBTSxHQUFHQSxNQUFNLENBQUMzSyxDQUFELEVBQUlELENBQUosRUFBT3hPLFFBQVAsQ0FBVCxHQUE0QnlPLENBQWxELENBQVA7QUFBNEQsS0FEakUsRUFFWnRTLE9BRlksRUFBZDtBQUdBK1csV0FBTyxDQUFDOEYsSUFBUixDQUFhLFVBQVN2VixDQUFULEVBQVlDLENBQVosRUFBZ0I7QUFBQyxhQUFPdVYsVUFBVSxDQUFDeFYsQ0FBQyxDQUFDLENBQUQsQ0FBRixFQUFPQyxDQUFDLENBQUMsQ0FBRCxDQUFSLENBQVYsSUFBMEJELENBQUMsQ0FBQyxDQUFELENBQUQsR0FBT0MsQ0FBQyxDQUFDLENBQUQsQ0FBekM7QUFBNkMsS0FBM0UsRUFBNkVuSSxPQUE3RSxDQUNFNnFCLGVBQWUsR0FDZixVQUFTM1gsQ0FBVCxFQUFZbkssQ0FBWixFQUFnQjtBQUFFNE8sYUFBTyxDQUFDNU8sQ0FBRCxDQUFQLENBQVcxSSxNQUFYLEdBQW9CLENBQXBCO0FBQXdCLEtBRDNCLEdBRWYsVUFBUzZTLENBQVQsRUFBWW5LLENBQVosRUFBZ0I7QUFBRTRPLGFBQU8sQ0FBQzVPLENBQUQsQ0FBUCxHQUFhbUssQ0FBQyxDQUFDLENBQUQsQ0FBZDtBQUFvQixLQUh4QztBQUtBLFdBQU8yWCxlQUFlLEdBQUc3YixRQUFRLENBQUMySSxPQUFELENBQVgsR0FDcEJ6SSxTQUFTLENBQUN6SyxRQUFELENBQVQsR0FBc0IwSyxVQUFVLENBQUN3SSxPQUFELENBQWhDLEdBQ0FySSxNQUFNLENBQUNxSSxPQUFELENBRlI7QUFHRDs7QUFHRCxXQUFTa1UsVUFBVCxDQUFvQnBuQixRQUFwQixFQUE4QmlaLFVBQTlCLEVBQTBDRyxNQUExQyxFQUFrRDtBQUNoRCxRQUFJLENBQUNILFVBQUwsRUFBaUI7QUFDZkEsZ0JBQVUsR0FBR2tPLGlCQUFiO0FBQ0Q7O0FBQ0QsUUFBSS9OLE1BQUosRUFBWTtBQUNWLFVBQUluSCxLQUFLLEdBQUdqUyxRQUFRLENBQUNxUCxLQUFULEdBQ1RqVCxHQURTLENBQ0wsVUFBU3FTLENBQVQsRUFBWUQsQ0FBWixFQUFnQjtBQUFDLGVBQU8sQ0FBQ0MsQ0FBRCxFQUFJMkssTUFBTSxDQUFDM0ssQ0FBRCxFQUFJRCxDQUFKLEVBQU94TyxRQUFQLENBQVYsQ0FBUDtBQUFtQyxPQUQvQyxFQUVUZ0YsTUFGUyxDQUVGLFVBQVN2QixDQUFULEVBQVlDLENBQVosRUFBZ0I7QUFBQyxlQUFPMmpCLFVBQVUsQ0FBQ3BPLFVBQUQsRUFBYXhWLENBQUMsQ0FBQyxDQUFELENBQWQsRUFBbUJDLENBQUMsQ0FBQyxDQUFELENBQXBCLENBQVYsR0FBcUNBLENBQXJDLEdBQXlDRCxDQUFoRDtBQUFrRCxPQUZqRSxDQUFaO0FBR0EsYUFBT3dPLEtBQUssSUFBSUEsS0FBSyxDQUFDLENBQUQsQ0FBckI7QUFDRCxLQUxELE1BS087QUFDTCxhQUFPalMsUUFBUSxDQUFDZ0YsTUFBVCxDQUFnQixVQUFTdkIsQ0FBVCxFQUFZQyxDQUFaLEVBQWdCO0FBQUMsZUFBTzJqQixVQUFVLENBQUNwTyxVQUFELEVBQWF4VixDQUFiLEVBQWdCQyxDQUFoQixDQUFWLEdBQStCQSxDQUEvQixHQUFtQ0QsQ0FBMUM7QUFBNEMsT0FBN0UsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzRqQixVQUFULENBQW9CcE8sVUFBcEIsRUFBZ0N4VixDQUFoQyxFQUFtQ0MsQ0FBbkMsRUFBc0M7QUFDcEMsUUFBSTRqQixJQUFJLEdBQUdyTyxVQUFVLENBQUN2VixDQUFELEVBQUlELENBQUosQ0FBckIsQ0FEb0MsQ0FFcEM7QUFDQTs7QUFDQSxXQUFRNmpCLElBQUksS0FBSyxDQUFULElBQWM1akIsQ0FBQyxLQUFLRCxDQUFwQixLQUEwQkMsQ0FBQyxLQUFLL0gsU0FBTixJQUFtQitILENBQUMsS0FBSyxJQUF6QixJQUFpQ0EsQ0FBQyxLQUFLQSxDQUFqRSxDQUFELElBQXlFNGpCLElBQUksR0FBRyxDQUF2RjtBQUNEOztBQUdELFdBQVNDLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDQyxNQUFqQyxFQUF5Q2pQLEtBQXpDLEVBQWdEO0FBQzlDLFFBQUlrUCxXQUFXLEdBQUdqRCxZQUFZLENBQUMrQyxPQUFELENBQTlCO0FBQ0FFLGVBQVcsQ0FBQzF2QixJQUFaLEdBQW1CLElBQUl5WSxRQUFKLENBQWErSCxLQUFiLEVBQW9CcGMsR0FBcEIsQ0FBd0IsVUFBU2tJLENBQVQsRUFBYTtBQUFDLGFBQU9BLENBQUMsQ0FBQ3RNLElBQVQ7QUFBYyxLQUFwRCxFQUFzRHlWLEdBQXRELEVBQW5CLENBRjhDLENBRzlDO0FBQ0E7O0FBQ0FpYSxlQUFXLENBQUM3YSxTQUFaLEdBQXdCLFVBQVMrQyxFQUFULEVBQWFDLE9BQWIsRUFBc0I7QUFDNUM7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ007QUFDQSxVQUFJMU0sUUFBUSxHQUFHLEtBQUs0TSxVQUFMLENBQWdCcEMsY0FBaEIsRUFBZ0NrQyxPQUFoQyxDQUFmOztBQUNBLFVBQUl1QixJQUFKO0FBQ0EsVUFBSXhXLFVBQVUsR0FBRyxDQUFqQjs7QUFDQSxhQUFPLENBQUMsQ0FBQ3dXLElBQUksR0FBR2pPLFFBQVEsQ0FBQzhLLElBQVQsRUFBUixFQUF5QlUsSUFBakMsRUFBdUM7QUFDckMsWUFBSWlCLEVBQUUsQ0FBQ3dCLElBQUksQ0FBQ3RVLEtBQU4sRUFBYWxDLFVBQVUsRUFBdkIsRUFBMkIsSUFBM0IsQ0FBRixLQUF1QyxLQUEzQyxFQUFrRDtBQUNoRDtBQUNEO0FBQ0Y7O0FBQ0QsYUFBT0EsVUFBUDtBQUNELEtBdkJEOztBQXdCQThzQixlQUFXLENBQUNyVyxrQkFBWixHQUFpQyxVQUFTdGEsSUFBVCxFQUFlOFksT0FBZixFQUF3QjtBQUN2RCxVQUFJOFgsU0FBUyxHQUFHblAsS0FBSyxDQUFDcGMsR0FBTixDQUFVLFVBQVNrSSxDQUFULEVBQ3hCO0FBQUMsZUFBUUEsQ0FBQyxHQUFHNEYsUUFBUSxDQUFDNUYsQ0FBRCxDQUFaLEVBQWlCMkssV0FBVyxDQUFDWSxPQUFPLEdBQUd2TCxDQUFDLENBQUN1TCxPQUFGLEVBQUgsR0FBaUJ2TCxDQUF6QixDQUFwQztBQUFpRSxPQURwRCxDQUFoQjtBQUdBLFVBQUkxSixVQUFVLEdBQUcsQ0FBakI7QUFDQSxVQUFJZ3RCLE1BQU0sR0FBRyxLQUFiO0FBQ0EsYUFBTyxJQUFJNVosUUFBSixDQUFhLFlBQVk7QUFDOUIsWUFBSTZaLEtBQUo7O0FBQ0EsWUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDWEMsZUFBSyxHQUFHRixTQUFTLENBQUN2ckIsR0FBVixDQUFjLFVBQVNrSSxDQUFULEVBQWE7QUFBQyxtQkFBT0EsQ0FBQyxDQUFDMkosSUFBRixFQUFQO0FBQWdCLFdBQTVDLENBQVI7QUFDQTJaLGdCQUFNLEdBQUdDLEtBQUssQ0FBQ0MsSUFBTixDQUFXLFVBQVNDLENBQVQsRUFBYTtBQUFDLG1CQUFPQSxDQUFDLENBQUNwWixJQUFUO0FBQWMsV0FBdkMsQ0FBVDtBQUNEOztBQUNELFlBQUlpWixNQUFKLEVBQVk7QUFDVixpQkFBT2haLFlBQVksRUFBbkI7QUFDRDs7QUFDRCxlQUFPTCxhQUFhLENBQ2xCeFgsSUFEa0IsRUFFbEI2RCxVQUFVLEVBRlEsRUFHbEI2c0IsTUFBTSxDQUFDam1CLEtBQVAsQ0FBYSxJQUFiLEVBQW1CcW1CLEtBQUssQ0FBQ3pyQixHQUFOLENBQVUsVUFBUzJyQixDQUFULEVBQWE7QUFBQyxpQkFBT0EsQ0FBQyxDQUFDanJCLEtBQVQ7QUFBZSxTQUF2QyxDQUFuQixDQUhrQixDQUFwQjtBQUtELE9BZE0sQ0FBUDtBQWVELEtBckJEOztBQXNCQSxXQUFPNHFCLFdBQVA7QUFDRCxHQWgrR2lCLENBbStHbEI7OztBQUVBLFdBQVN2QyxLQUFULENBQWV2WSxJQUFmLEVBQXFCaUYsR0FBckIsRUFBMEI7QUFDeEIsV0FBT3RCLEtBQUssQ0FBQzNELElBQUQsQ0FBTCxHQUFjaUYsR0FBZCxHQUFvQmpGLElBQUksQ0FBQzNDLFdBQUwsQ0FBaUI0SCxHQUFqQixDQUEzQjtBQUNEOztBQUVELFdBQVN1UyxhQUFULENBQXVCblMsS0FBdkIsRUFBOEI7QUFDNUIsUUFBSUEsS0FBSyxLQUFLcFAsTUFBTSxDQUFDb1AsS0FBRCxDQUFwQixFQUE2QjtBQUMzQixZQUFNLElBQUlILFNBQUosQ0FBYyw0QkFBNEJHLEtBQTFDLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVMrUixXQUFULENBQXFCcFgsSUFBckIsRUFBMkI7QUFDekJvSyxxQkFBaUIsQ0FBQ3BLLElBQUksQ0FBQzVVLElBQU4sQ0FBakI7QUFDQSxXQUFPMlUsVUFBVSxDQUFDQyxJQUFELENBQWpCO0FBQ0Q7O0FBRUQsV0FBU3NZLGFBQVQsQ0FBdUJsbEIsUUFBdkIsRUFBaUM7QUFDL0IsV0FBT3NLLE9BQU8sQ0FBQ3RLLFFBQUQsQ0FBUCxHQUFvQnFLLGFBQXBCLEdBQ0xJLFNBQVMsQ0FBQ3pLLFFBQUQsQ0FBVCxHQUFzQndLLGVBQXRCLEdBQ0FHLFdBRkY7QUFHRDs7QUFFRCxXQUFTOFosWUFBVCxDQUFzQnprQixRQUF0QixFQUFnQztBQUM5QixXQUFPNkMsTUFBTSxDQUFDbUgsTUFBUCxDQUNMLENBQ0VNLE9BQU8sQ0FBQ3RLLFFBQUQsQ0FBUCxHQUFvQnVLLFFBQXBCLEdBQ0FFLFNBQVMsQ0FBQ3pLLFFBQUQsQ0FBVCxHQUFzQjBLLFVBQXRCLEdBQ0FHLE1BSEYsRUFJRWxKLFNBTEcsQ0FBUDtBQU9EOztBQUVELFdBQVMyaUIsa0JBQVQsR0FBOEI7QUFDNUIsUUFBSSxLQUFLZCxLQUFMLENBQVdoVSxXQUFmLEVBQTRCO0FBQzFCLFdBQUtnVSxLQUFMLENBQVdoVSxXQUFYOztBQUNBLFdBQUt4WCxJQUFMLEdBQVksS0FBS3dyQixLQUFMLENBQVd4ckIsSUFBdkI7QUFDQSxhQUFPLElBQVA7QUFDRCxLQUpELE1BSU87QUFDTCxhQUFPb1MsR0FBRyxDQUFDekksU0FBSixDQUFjNk4sV0FBZCxDQUEwQnhNLElBQTFCLENBQStCLElBQS9CLENBQVA7QUFDRDtBQUNGOztBQUVELFdBQVNta0IsaUJBQVQsQ0FBMkIxakIsQ0FBM0IsRUFBOEJDLENBQTlCLEVBQWlDO0FBQy9CLFdBQU9ELENBQUMsR0FBR0MsQ0FBSixHQUFRLENBQVIsR0FBWUQsQ0FBQyxHQUFHQyxDQUFKLEdBQVEsQ0FBQyxDQUFULEdBQWEsQ0FBaEM7QUFDRDs7QUFFRCxXQUFTc1UsYUFBVCxDQUF1QlAsT0FBdkIsRUFBZ0M7QUFDOUIsUUFBSTdLLElBQUksR0FBR3FDLFdBQVcsQ0FBQ3dJLE9BQUQsQ0FBdEI7O0FBQ0EsUUFBSSxDQUFDN0ssSUFBTCxFQUFXO0FBQ1Q7QUFDQTtBQUNBLFVBQUksQ0FBQ3VDLFdBQVcsQ0FBQ3NJLE9BQUQsQ0FBaEIsRUFBMkI7QUFDekIsY0FBTSxJQUFJM0YsU0FBSixDQUFjLHNDQUFzQzJGLE9BQXBELENBQU47QUFDRDs7QUFDRDdLLFVBQUksR0FBR3FDLFdBQVcsQ0FBQy9FLFFBQVEsQ0FBQ3VOLE9BQUQsQ0FBVCxDQUFsQjtBQUNEOztBQUNELFdBQU83SyxJQUFQO0FBQ0Q7O0FBRUQvQyxhQUFXLENBQUNtZSxNQUFELEVBQVNsVCxlQUFULENBQVg7O0FBRUUsV0FBU2tULE1BQVQsQ0FBZ0JDLGFBQWhCLEVBQStCanNCLElBQS9CLEVBQXFDO0FBQ25DLFFBQUlrc0IsY0FBSjs7QUFFQSxRQUFJQyxVQUFVLEdBQUcsU0FBU0gsTUFBVCxDQUFnQnhJLE1BQWhCLEVBQXdCO0FBQ3ZDLFVBQUlBLE1BQU0sWUFBWTJJLFVBQXRCLEVBQWtDO0FBQ2hDLGVBQU8zSSxNQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxFQUFFLGdCQUFnQjJJLFVBQWxCLENBQUosRUFBbUM7QUFDakMsZUFBTyxJQUFJQSxVQUFKLENBQWUzSSxNQUFmLENBQVA7QUFDRDs7QUFDRCxVQUFJLENBQUMwSSxjQUFMLEVBQXFCO0FBQ25CQSxzQkFBYyxHQUFHLElBQWpCO0FBQ0EsWUFBSXBsQixJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBUCxDQUFZbWxCLGFBQVosQ0FBWDtBQUNBRyxnQkFBUSxDQUFDQyxtQkFBRCxFQUFzQnZsQixJQUF0QixDQUFSO0FBQ0F1bEIsMkJBQW1CLENBQUNyd0IsSUFBcEIsR0FBMkI4SyxJQUFJLENBQUNsSCxNQUFoQztBQUNBeXNCLDJCQUFtQixDQUFDQyxLQUFwQixHQUE0QnRzQixJQUE1QjtBQUNBcXNCLDJCQUFtQixDQUFDcFgsS0FBcEIsR0FBNEJuTyxJQUE1QjtBQUNBdWxCLDJCQUFtQixDQUFDRSxjQUFwQixHQUFxQ04sYUFBckM7QUFDRDs7QUFDRCxXQUFLckYsSUFBTCxHQUFZM0wsR0FBRyxDQUFDdUksTUFBRCxDQUFmO0FBQ0QsS0FqQkQ7O0FBbUJBLFFBQUk2SSxtQkFBbUIsR0FBR0YsVUFBVSxDQUFDeG1CLFNBQVgsR0FBdUJrQixNQUFNLENBQUNtSCxNQUFQLENBQWN3ZSxlQUFkLENBQWpEO0FBQ0FILHVCQUFtQixDQUFDcGUsV0FBcEIsR0FBa0NrZSxVQUFsQztBQUVBLFdBQU9BLFVBQVA7QUFDRDs7QUFFREgsUUFBTSxDQUFDcm1CLFNBQVAsQ0FBaUJvQixRQUFqQixHQUE0QixZQUFXO0FBQ3JDLFdBQU8sS0FBS3dNLFVBQUwsQ0FBZ0JrWixVQUFVLENBQUMsSUFBRCxDQUFWLEdBQW1CLElBQW5DLEVBQXlDLEdBQXpDLENBQVA7QUFDRCxHQUZELENBN2pIZ0IsQ0Fpa0hoQjs7O0FBRUFULFFBQU0sQ0FBQ3JtQixTQUFQLENBQWlCa1AsR0FBakIsR0FBdUIsVUFBU3JDLENBQVQsRUFBWTtBQUNqQyxXQUFPLEtBQUsrWixjQUFMLENBQW9CM2xCLGNBQXBCLENBQW1DNEwsQ0FBbkMsQ0FBUDtBQUNELEdBRkQ7O0FBSUF3WixRQUFNLENBQUNybUIsU0FBUCxDQUFpQmdQLEdBQWpCLEdBQXVCLFVBQVNuQyxDQUFULEVBQVlvQyxXQUFaLEVBQXlCO0FBQzlDLFFBQUksQ0FBQyxLQUFLQyxHQUFMLENBQVNyQyxDQUFULENBQUwsRUFBa0I7QUFDaEIsYUFBT29DLFdBQVA7QUFDRDs7QUFDRCxRQUFJOFgsVUFBVSxHQUFHLEtBQUtILGNBQUwsQ0FBb0IvWixDQUFwQixDQUFqQjtBQUNBLFdBQU8sS0FBS29VLElBQUwsR0FBWSxLQUFLQSxJQUFMLENBQVVqUyxHQUFWLENBQWNuQyxDQUFkLEVBQWlCa2EsVUFBakIsQ0FBWixHQUEyQ0EsVUFBbEQ7QUFDRCxHQU5ELENBdmtIZ0IsQ0Era0hoQjs7O0FBRUFWLFFBQU0sQ0FBQ3JtQixTQUFQLENBQWlCc1csS0FBakIsR0FBeUIsWUFBVztBQUNsQyxRQUFJLEtBQUtDLFNBQVQsRUFBb0I7QUFDbEIsV0FBSzBLLElBQUwsSUFBYSxLQUFLQSxJQUFMLENBQVUzSyxLQUFWLEVBQWI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJa1EsVUFBVSxHQUFHLEtBQUtsZSxXQUF0QjtBQUNBLFdBQU9rZSxVQUFVLENBQUNRLE1BQVgsS0FBc0JSLFVBQVUsQ0FBQ1EsTUFBWCxHQUFvQkMsVUFBVSxDQUFDLElBQUQsRUFBTzFSLFFBQVEsRUFBZixDQUFwRCxDQUFQO0FBQ0QsR0FQRDs7QUFTQThRLFFBQU0sQ0FBQ3JtQixTQUFQLENBQWlCK1UsR0FBakIsR0FBdUIsVUFBU2xJLENBQVQsRUFBWUMsQ0FBWixFQUFlO0FBQ3BDLFFBQUksQ0FBQyxLQUFLb0MsR0FBTCxDQUFTckMsQ0FBVCxDQUFMLEVBQWtCO0FBQ2hCLFlBQU0sSUFBSTNKLEtBQUosQ0FBVSw2QkFBNkIySixDQUE3QixHQUFpQyxPQUFqQyxHQUEyQ2lhLFVBQVUsQ0FBQyxJQUFELENBQS9ELENBQU47QUFDRDs7QUFDRCxRQUFJLEtBQUs3RixJQUFMLElBQWEsQ0FBQyxLQUFLQSxJQUFMLENBQVUvUixHQUFWLENBQWNyQyxDQUFkLENBQWxCLEVBQW9DO0FBQ2xDLFVBQUlrYSxVQUFVLEdBQUcsS0FBS0gsY0FBTCxDQUFvQi9aLENBQXBCLENBQWpCOztBQUNBLFVBQUlDLENBQUMsS0FBS2lhLFVBQVYsRUFBc0I7QUFDcEIsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJM0YsTUFBTSxHQUFHLEtBQUtILElBQUwsSUFBYSxLQUFLQSxJQUFMLENBQVVsTSxHQUFWLENBQWNsSSxDQUFkLEVBQWlCQyxDQUFqQixDQUExQjs7QUFDQSxRQUFJLEtBQUt5SixTQUFMLElBQWtCNkssTUFBTSxLQUFLLEtBQUtILElBQXRDLEVBQTRDO0FBQzFDLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU9nRyxVQUFVLENBQUMsSUFBRCxFQUFPN0YsTUFBUCxDQUFqQjtBQUNELEdBZkQ7O0FBaUJBaUYsUUFBTSxDQUFDcm1CLFNBQVAsQ0FBaUJnVyxNQUFqQixHQUEwQixVQUFTbkosQ0FBVCxFQUFZO0FBQ3BDLFFBQUksQ0FBQyxLQUFLcUMsR0FBTCxDQUFTckMsQ0FBVCxDQUFMLEVBQWtCO0FBQ2hCLGFBQU8sSUFBUDtBQUNEOztBQUNELFFBQUl1VSxNQUFNLEdBQUcsS0FBS0gsSUFBTCxJQUFhLEtBQUtBLElBQUwsQ0FBVWpMLE1BQVYsQ0FBaUJuSixDQUFqQixDQUExQjs7QUFDQSxRQUFJLEtBQUswSixTQUFMLElBQWtCNkssTUFBTSxLQUFLLEtBQUtILElBQXRDLEVBQTRDO0FBQzFDLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU9nRyxVQUFVLENBQUMsSUFBRCxFQUFPN0YsTUFBUCxDQUFqQjtBQUNELEdBVEQ7O0FBV0FpRixRQUFNLENBQUNybUIsU0FBUCxDQUFpQjRYLFVBQWpCLEdBQThCLFlBQVc7QUFDdkMsV0FBTyxLQUFLcUosSUFBTCxDQUFVckosVUFBVixFQUFQO0FBQ0QsR0FGRDs7QUFJQXlPLFFBQU0sQ0FBQ3JtQixTQUFQLENBQWlCb08sVUFBakIsR0FBOEIsVUFBU2haLElBQVQsRUFBZThZLE9BQWYsRUFBd0I7QUFBQyxRQUFJa0UsTUFBTSxHQUFHLElBQWI7QUFDckQsV0FBTzFKLGFBQWEsQ0FBQyxLQUFLa2UsY0FBTixDQUFiLENBQW1DbnNCLEdBQW5DLENBQXVDLFVBQVM3QyxDQUFULEVBQVlpVixDQUFaLEVBQWdCO0FBQUMsYUFBT3VGLE1BQU0sQ0FBQ3BELEdBQVAsQ0FBV25DLENBQVgsQ0FBUDtBQUFxQixLQUE3RSxFQUErRXVCLFVBQS9FLENBQTBGaFosSUFBMUYsRUFBZ0c4WSxPQUFoRyxDQUFQO0FBQ0QsR0FGRDs7QUFJQW1ZLFFBQU0sQ0FBQ3JtQixTQUFQLENBQWlCa0wsU0FBakIsR0FBNkIsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUFDLFFBQUlrRSxNQUFNLEdBQUcsSUFBYjtBQUNsRCxXQUFPMUosYUFBYSxDQUFDLEtBQUtrZSxjQUFOLENBQWIsQ0FBbUNuc0IsR0FBbkMsQ0FBdUMsVUFBUzdDLENBQVQsRUFBWWlWLENBQVosRUFBZ0I7QUFBQyxhQUFPdUYsTUFBTSxDQUFDcEQsR0FBUCxDQUFXbkMsQ0FBWCxDQUFQO0FBQXFCLEtBQTdFLEVBQStFM0IsU0FBL0UsQ0FBeUYrQyxFQUF6RixFQUE2RkMsT0FBN0YsQ0FBUDtBQUNELEdBRkQ7O0FBSUFtWSxRQUFNLENBQUNybUIsU0FBUCxDQUFpQjZYLGFBQWpCLEdBQWlDLFVBQVNJLE9BQVQsRUFBa0I7QUFDakQsUUFBSUEsT0FBTyxLQUFLLEtBQUsxQixTQUFyQixFQUFnQztBQUM5QixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJNkssTUFBTSxHQUFHLEtBQUtILElBQUwsSUFBYSxLQUFLQSxJQUFMLENBQVVwSixhQUFWLENBQXdCSSxPQUF4QixDQUExQjs7QUFDQSxRQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaLFdBQUsxQixTQUFMLEdBQWlCMEIsT0FBakI7QUFDQSxXQUFLZ0osSUFBTCxHQUFZRyxNQUFaO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTzZGLFVBQVUsQ0FBQyxJQUFELEVBQU83RixNQUFQLEVBQWVuSixPQUFmLENBQWpCO0FBQ0QsR0FYRDs7QUFjRixNQUFJNE8sZUFBZSxHQUFHUixNQUFNLENBQUNybUIsU0FBN0I7QUFDQTZtQixpQkFBZSxDQUFDOWMsTUFBRCxDQUFmLEdBQTBCOGMsZUFBZSxDQUFDN1EsTUFBMUM7QUFDQTZRLGlCQUFlLENBQUM1USxRQUFoQixHQUNBNFEsZUFBZSxDQUFDdk8sUUFBaEIsR0FBMkJELFlBQVksQ0FBQ0MsUUFEeEM7QUFFQXVPLGlCQUFlLENBQUNwUSxLQUFoQixHQUF3QjRCLFlBQVksQ0FBQzVCLEtBQXJDO0FBQ0FvUSxpQkFBZSxDQUFDbFEsU0FBaEIsR0FBNEIwQixZQUFZLENBQUMxQixTQUF6QztBQUNBa1EsaUJBQWUsQ0FBQy9QLE9BQWhCLEdBQTBCdUIsWUFBWSxDQUFDdkIsT0FBdkM7QUFDQStQLGlCQUFlLENBQUM3UCxTQUFoQixHQUE0QnFCLFlBQVksQ0FBQ3JCLFNBQXpDO0FBQ0E2UCxpQkFBZSxDQUFDM1AsYUFBaEIsR0FBZ0NtQixZQUFZLENBQUNuQixhQUE3QztBQUNBMlAsaUJBQWUsQ0FBQ3pQLFdBQWhCLEdBQThCaUIsWUFBWSxDQUFDakIsV0FBM0M7QUFDQXlQLGlCQUFlLENBQUNoUixLQUFoQixHQUF3QndDLFlBQVksQ0FBQ3hDLEtBQXJDO0FBQ0FnUixpQkFBZSxDQUFDcHRCLE1BQWhCLEdBQXlCNGUsWUFBWSxDQUFDNWUsTUFBdEM7QUFDQW90QixpQkFBZSxDQUFDOVEsUUFBaEIsR0FBMkJzQyxZQUFZLENBQUN0QyxRQUF4QztBQUNBOFEsaUJBQWUsQ0FBQ3BSLGFBQWhCLEdBQWdDNEMsWUFBWSxDQUFDNUMsYUFBN0M7QUFDQW9SLGlCQUFlLENBQUNsUCxTQUFoQixHQUE0QlUsWUFBWSxDQUFDVixTQUF6QztBQUNBa1AsaUJBQWUsQ0FBQy9PLFdBQWhCLEdBQThCTyxZQUFZLENBQUNQLFdBQTNDOztBQUdBLFdBQVNtUCxVQUFULENBQW9CQyxVQUFwQixFQUFnQ3pzQixHQUFoQyxFQUFxQ3dkLE9BQXJDLEVBQThDO0FBQzVDLFFBQUlrUCxNQUFNLEdBQUdqbUIsTUFBTSxDQUFDbUgsTUFBUCxDQUFjbkgsTUFBTSxDQUFDa21CLGNBQVAsQ0FBc0JGLFVBQXRCLENBQWQsQ0FBYjtBQUNBQyxVQUFNLENBQUNsRyxJQUFQLEdBQWN4bUIsR0FBZDtBQUNBMHNCLFVBQU0sQ0FBQzVRLFNBQVAsR0FBbUIwQixPQUFuQjtBQUNBLFdBQU9rUCxNQUFQO0FBQ0Q7O0FBRUQsV0FBU0wsVUFBVCxDQUFvQkssTUFBcEIsRUFBNEI7QUFDMUIsV0FBT0EsTUFBTSxDQUFDUixLQUFQLElBQWdCUSxNQUFNLENBQUM3ZSxXQUFQLENBQW1Cak8sSUFBbkMsSUFBMkMsUUFBbEQ7QUFDRDs7QUFFRCxXQUFTb3NCLFFBQVQsQ0FBa0J6bUIsU0FBbEIsRUFBNkJxbkIsS0FBN0IsRUFBb0M7QUFDbEMsUUFBSTtBQUNGQSxXQUFLLENBQUN6dEIsT0FBTixDQUFjMHRCLE9BQU8sQ0FBQzNpQixJQUFSLENBQWEzSyxTQUFiLEVBQXdCZ0csU0FBeEIsQ0FBZDtBQUNELEtBRkQsQ0FFRSxPQUFPekIsS0FBUCxFQUFjLENBQ2Q7QUFDRDtBQUNGOztBQUVELFdBQVMrb0IsT0FBVCxDQUFpQnRuQixTQUFqQixFQUE0QjNGLElBQTVCLEVBQWtDO0FBQ2hDNkcsVUFBTSxDQUFDbUQsY0FBUCxDQUFzQnJFLFNBQXRCLEVBQWlDM0YsSUFBakMsRUFBdUM7QUFDckMyVSxTQUFHLEVBQUUsWUFBVztBQUNkLGVBQU8sS0FBS0EsR0FBTCxDQUFTM1UsSUFBVCxDQUFQO0FBQ0QsT0FIb0M7QUFJckMwYSxTQUFHLEVBQUUsVUFBUzVaLEtBQVQsRUFBZ0I7QUFDbkJtWCxpQkFBUyxDQUFDLEtBQUtpRSxTQUFOLEVBQWlCLG9DQUFqQixDQUFUO0FBQ0EsYUFBS3hCLEdBQUwsQ0FBUzFhLElBQVQsRUFBZWMsS0FBZjtBQUNEO0FBUG9DLEtBQXZDO0FBU0Q7O0FBRUQrTSxhQUFXLENBQUNqUixHQUFELEVBQU1vYyxhQUFOLENBQVgsQ0Fqc0hrQixDQW1zSGhCOztBQUVBLFdBQVNwYyxHQUFULENBQWFrRSxLQUFiLEVBQW9CO0FBQ2xCLFdBQU9BLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUtuQixTQUE1QixHQUF3Q3V0QixRQUFRLEVBQWhELEdBQ0xDLEtBQUssQ0FBQ3JzQixLQUFELENBQUwsSUFBZ0IsQ0FBQ3VPLFNBQVMsQ0FBQ3ZPLEtBQUQsQ0FBMUIsR0FBb0NBLEtBQXBDLEdBQ0Fvc0IsUUFBUSxHQUFHOVIsYUFBWCxDQUF5QixVQUFTVixHQUFULEVBQWU7QUFDdEMsVUFBSTlKLElBQUksR0FBR2pDLFdBQVcsQ0FBQzdOLEtBQUQsQ0FBdEI7QUFDQWthLHVCQUFpQixDQUFDcEssSUFBSSxDQUFDNVUsSUFBTixDQUFqQjtBQUNBNFUsVUFBSSxDQUFDclIsT0FBTCxDQUFhLFVBQVNrVCxDQUFULEVBQWE7QUFBQyxlQUFPaUksR0FBRyxDQUFDcmQsR0FBSixDQUFRb1YsQ0FBUixDQUFQO0FBQWtCLE9BQTdDO0FBQ0QsS0FKRCxDQUZGO0FBT0Q7O0FBRUQ3VixLQUFHLENBQUN5TixFQUFKLEdBQVMsWUFBd0I7QUFDL0IsV0FBTyxLQUFLMUIsU0FBTCxDQUFQO0FBQ0QsR0FGRDs7QUFJQS9MLEtBQUcsQ0FBQ3d3QixRQUFKLEdBQWUsVUFBU3RzQixLQUFULEVBQWdCO0FBQzdCLFdBQU8sS0FBS3VOLGFBQWEsQ0FBQ3ZOLEtBQUQsQ0FBYixDQUFxQnVzQixNQUFyQixFQUFMLENBQVA7QUFDRCxHQUZEOztBQUlBendCLEtBQUcsQ0FBQytJLFNBQUosQ0FBY29CLFFBQWQsR0FBeUIsWUFBVztBQUNsQyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLE9BQWhCLEVBQXlCLEdBQXpCLENBQVA7QUFDRCxHQUZELENBdnRIZ0IsQ0EydEhoQjs7O0FBRUEzVyxLQUFHLENBQUMrSSxTQUFKLENBQWNrUCxHQUFkLEdBQW9CLFVBQVMvVCxLQUFULEVBQWdCO0FBQ2xDLFdBQU8sS0FBSzhsQixJQUFMLENBQVUvUixHQUFWLENBQWMvVCxLQUFkLENBQVA7QUFDRCxHQUZELENBN3RIZ0IsQ0FpdUhoQjs7O0FBRUFsRSxLQUFHLENBQUMrSSxTQUFKLENBQWN0SSxHQUFkLEdBQW9CLFVBQVN5RCxLQUFULEVBQWdCO0FBQ2xDLFdBQU93c0IsU0FBUyxDQUFDLElBQUQsRUFBTyxLQUFLMUcsSUFBTCxDQUFVbE0sR0FBVixDQUFjNVosS0FBZCxFQUFxQixJQUFyQixDQUFQLENBQWhCO0FBQ0QsR0FGRDs7QUFJQWxFLEtBQUcsQ0FBQytJLFNBQUosQ0FBY2dXLE1BQWQsR0FBdUIsVUFBUzdhLEtBQVQsRUFBZ0I7QUFDckMsV0FBT3dzQixTQUFTLENBQUMsSUFBRCxFQUFPLEtBQUsxRyxJQUFMLENBQVVqTCxNQUFWLENBQWlCN2EsS0FBakIsQ0FBUCxDQUFoQjtBQUNELEdBRkQ7O0FBSUFsRSxLQUFHLENBQUMrSSxTQUFKLENBQWNzVyxLQUFkLEdBQXNCLFlBQVc7QUFDL0IsV0FBT3FSLFNBQVMsQ0FBQyxJQUFELEVBQU8sS0FBSzFHLElBQUwsQ0FBVTNLLEtBQVYsRUFBUCxDQUFoQjtBQUNELEdBRkQsQ0EzdUhnQixDQSt1SGhCOzs7QUFFQXJmLEtBQUcsQ0FBQytJLFNBQUosQ0FBYzRuQixLQUFkLEdBQXNCLFlBQVc7QUFBQyxRQUFJL1EsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaO0FBQ2hDNlQsU0FBSyxHQUFHQSxLQUFLLENBQUNyUSxNQUFOLENBQWEsVUFBU3ZMLENBQVQsRUFBYTtBQUFDLGFBQU9BLENBQUMsQ0FBQzVFLElBQUYsS0FBVyxDQUFsQjtBQUFvQixLQUEvQyxDQUFSOztBQUNBLFFBQUl3Z0IsS0FBSyxDQUFDNWMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJLEtBQUs1RCxJQUFMLEtBQWMsQ0FBZCxJQUFtQixDQUFDLEtBQUtrZ0IsU0FBekIsSUFBc0NNLEtBQUssQ0FBQzVjLE1BQU4sS0FBaUIsQ0FBM0QsRUFBOEQ7QUFDNUQsYUFBTyxLQUFLcU8sV0FBTCxDQUFpQnVPLEtBQUssQ0FBQyxDQUFELENBQXRCLENBQVA7QUFDRDs7QUFDRCxXQUFPLEtBQUtwQixhQUFMLENBQW1CLFVBQVNWLEdBQVQsRUFBZTtBQUN2QyxXQUFLLElBQUloSyxFQUFFLEdBQUcsQ0FBZCxFQUFpQkEsRUFBRSxHQUFHOEwsS0FBSyxDQUFDNWMsTUFBNUIsRUFBb0M4USxFQUFFLEVBQXRDLEVBQTBDO0FBQ3hDL0IsbUJBQVcsQ0FBQzZOLEtBQUssQ0FBQzlMLEVBQUQsQ0FBTixDQUFYLENBQXVCblIsT0FBdkIsQ0FBK0IsVUFBU3VCLEtBQVQsRUFBaUI7QUFBQyxpQkFBTzRaLEdBQUcsQ0FBQ3JkLEdBQUosQ0FBUXlELEtBQVIsQ0FBUDtBQUFzQixTQUF2RTtBQUNEO0FBQ0YsS0FKTSxDQUFQO0FBS0QsR0FiRDs7QUFlQWxFLEtBQUcsQ0FBQytJLFNBQUosQ0FBYzZuQixTQUFkLEdBQTBCLFlBQVc7QUFBQyxRQUFJaFIsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaOztBQUNwQyxRQUFJNlQsS0FBSyxDQUFDNWMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixhQUFPLElBQVA7QUFDRDs7QUFDRDRjLFNBQUssR0FBR0EsS0FBSyxDQUFDcGMsR0FBTixDQUFVLFVBQVN3USxJQUFULEVBQWdCO0FBQUMsYUFBT2pDLFdBQVcsQ0FBQ2lDLElBQUQsQ0FBbEI7QUFBeUIsS0FBcEQsQ0FBUjtBQUNBLFFBQUk2YyxXQUFXLEdBQUcsSUFBbEI7QUFDQSxXQUFPLEtBQUtyUyxhQUFMLENBQW1CLFVBQVNWLEdBQVQsRUFBZTtBQUN2QytTLGlCQUFXLENBQUNsdUIsT0FBWixDQUFvQixVQUFTdUIsS0FBVCxFQUFpQjtBQUNuQyxZQUFJLENBQUMwYixLQUFLLENBQUNyRixLQUFOLENBQVksVUFBU3ZHLElBQVQsRUFBZ0I7QUFBQyxpQkFBT0EsSUFBSSxDQUFDZ0gsUUFBTCxDQUFjOVcsS0FBZCxDQUFQO0FBQTRCLFNBQXpELENBQUwsRUFBaUU7QUFDL0Q0WixhQUFHLENBQUNpQixNQUFKLENBQVc3YSxLQUFYO0FBQ0Q7QUFDRixPQUpEO0FBS0QsS0FOTSxDQUFQO0FBT0QsR0FiRDs7QUFlQWxFLEtBQUcsQ0FBQytJLFNBQUosQ0FBYytuQixRQUFkLEdBQXlCLFlBQVc7QUFBQyxRQUFJbFIsS0FBSyxHQUFHNU8sT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFaOztBQUNuQyxRQUFJNlQsS0FBSyxDQUFDNWMsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QixhQUFPLElBQVA7QUFDRDs7QUFDRDRjLFNBQUssR0FBR0EsS0FBSyxDQUFDcGMsR0FBTixDQUFVLFVBQVN3USxJQUFULEVBQWdCO0FBQUMsYUFBT2pDLFdBQVcsQ0FBQ2lDLElBQUQsQ0FBbEI7QUFBeUIsS0FBcEQsQ0FBUjtBQUNBLFFBQUk2YyxXQUFXLEdBQUcsSUFBbEI7QUFDQSxXQUFPLEtBQUtyUyxhQUFMLENBQW1CLFVBQVNWLEdBQVQsRUFBZTtBQUN2QytTLGlCQUFXLENBQUNsdUIsT0FBWixDQUFvQixVQUFTdUIsS0FBVCxFQUFpQjtBQUNuQyxZQUFJMGIsS0FBSyxDQUFDc1AsSUFBTixDQUFXLFVBQVNsYixJQUFULEVBQWdCO0FBQUMsaUJBQU9BLElBQUksQ0FBQ2dILFFBQUwsQ0FBYzlXLEtBQWQsQ0FBUDtBQUE0QixTQUF4RCxDQUFKLEVBQStEO0FBQzdENFosYUFBRyxDQUFDaUIsTUFBSixDQUFXN2EsS0FBWDtBQUNEO0FBQ0YsT0FKRDtBQUtELEtBTk0sQ0FBUDtBQU9ELEdBYkQ7O0FBZUFsRSxLQUFHLENBQUMrSSxTQUFKLENBQWN5VyxLQUFkLEdBQXNCLFlBQVc7QUFDL0IsV0FBTyxLQUFLbVIsS0FBTCxDQUFXL25CLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJtRCxTQUF2QixDQUFQO0FBQ0QsR0FGRDs7QUFJQS9MLEtBQUcsQ0FBQytJLFNBQUosQ0FBYzJXLFNBQWQsR0FBMEIsVUFBU0MsTUFBVCxFQUFpQjtBQUFDLFFBQUlDLEtBQUssR0FBRzVPLE9BQU8sQ0FBQzVHLElBQVIsQ0FBYTJCLFNBQWIsRUFBd0IsQ0FBeEIsQ0FBWjtBQUMxQyxXQUFPLEtBQUs0a0IsS0FBTCxDQUFXL25CLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJnWCxLQUF2QixDQUFQO0FBQ0QsR0FGRDs7QUFJQTVmLEtBQUcsQ0FBQytJLFNBQUosQ0FBY3FYLElBQWQsR0FBcUIsVUFBU0MsVUFBVCxFQUFxQjtBQUN4QztBQUNBLFdBQU8wUSxVQUFVLENBQUN4USxXQUFXLENBQUMsSUFBRCxFQUFPRixVQUFQLENBQVosQ0FBakI7QUFDRCxHQUhEOztBQUtBcmdCLEtBQUcsQ0FBQytJLFNBQUosQ0FBY2pJLE1BQWQsR0FBdUIsVUFBUzBmLE1BQVQsRUFBaUJILFVBQWpCLEVBQTZCO0FBQ2xEO0FBQ0EsV0FBTzBRLFVBQVUsQ0FBQ3hRLFdBQVcsQ0FBQyxJQUFELEVBQU9GLFVBQVAsRUFBbUJHLE1BQW5CLENBQVosQ0FBakI7QUFDRCxHQUhEOztBQUtBeGdCLEtBQUcsQ0FBQytJLFNBQUosQ0FBYzRYLFVBQWQsR0FBMkIsWUFBVztBQUNwQyxXQUFPLEtBQUtxSixJQUFMLENBQVVySixVQUFWLEVBQVA7QUFDRCxHQUZEOztBQUlBM2dCLEtBQUcsQ0FBQytJLFNBQUosQ0FBY2tMLFNBQWQsR0FBMEIsVUFBUytDLEVBQVQsRUFBYUMsT0FBYixFQUFzQjtBQUFDLFFBQUlrRSxNQUFNLEdBQUcsSUFBYjtBQUMvQyxXQUFPLEtBQUs2TyxJQUFMLENBQVUvVixTQUFWLENBQW9CLFVBQVN0VCxDQUFULEVBQVlpVixDQUFaLEVBQWdCO0FBQUMsYUFBT29CLEVBQUUsQ0FBQ3BCLENBQUQsRUFBSUEsQ0FBSixFQUFPdUYsTUFBUCxDQUFUO0FBQXdCLEtBQTdELEVBQStEbEUsT0FBL0QsQ0FBUDtBQUNELEdBRkQ7O0FBSUFqWCxLQUFHLENBQUMrSSxTQUFKLENBQWNvTyxVQUFkLEdBQTJCLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ2pELFdBQU8sS0FBSytTLElBQUwsQ0FBVXhtQixHQUFWLENBQWMsVUFBUzdDLENBQVQsRUFBWWlWLENBQVosRUFBZ0I7QUFBQyxhQUFPQSxDQUFQO0FBQVMsS0FBeEMsRUFBMEN1QixVQUExQyxDQUFxRGhaLElBQXJELEVBQTJEOFksT0FBM0QsQ0FBUDtBQUNELEdBRkQ7O0FBSUFqWCxLQUFHLENBQUMrSSxTQUFKLENBQWM2WCxhQUFkLEdBQThCLFVBQVNJLE9BQVQsRUFBa0I7QUFDOUMsUUFBSUEsT0FBTyxLQUFLLEtBQUsxQixTQUFyQixFQUFnQztBQUM5QixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJNkssTUFBTSxHQUFHLEtBQUtILElBQUwsQ0FBVXBKLGFBQVYsQ0FBd0JJLE9BQXhCLENBQWI7O0FBQ0EsUUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixXQUFLMUIsU0FBTCxHQUFpQjBCLE9BQWpCO0FBQ0EsV0FBS2dKLElBQUwsR0FBWUcsTUFBWjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU8sS0FBSzZHLE1BQUwsQ0FBWTdHLE1BQVosRUFBb0JuSixPQUFwQixDQUFQO0FBQ0QsR0FYRDs7QUFjRixXQUFTdVAsS0FBVCxDQUFlVSxRQUFmLEVBQXlCO0FBQ3ZCLFdBQU8sQ0FBQyxFQUFFQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsZUFBRCxDQUF0QixDQUFSO0FBQ0Q7O0FBRURseEIsS0FBRyxDQUFDdXdCLEtBQUosR0FBWUEsS0FBWjtBQUVBLE1BQUlXLGVBQWUsR0FBRyx1QkFBdEI7QUFFQSxNQUFJQyxZQUFZLEdBQUdueEIsR0FBRyxDQUFDK0ksU0FBdkI7QUFDQW9vQixjQUFZLENBQUNELGVBQUQsQ0FBWixHQUFnQyxJQUFoQztBQUNBQyxjQUFZLENBQUNyZSxNQUFELENBQVosR0FBdUJxZSxZQUFZLENBQUNwUyxNQUFwQztBQUNBb1MsY0FBWSxDQUFDcFIsU0FBYixHQUF5Qm9SLFlBQVksQ0FBQzNSLEtBQXRDO0FBQ0EyUixjQUFZLENBQUNsUixhQUFiLEdBQTZCa1IsWUFBWSxDQUFDelIsU0FBMUM7QUFDQXlSLGNBQVksQ0FBQzNTLGFBQWIsR0FBNkI0QyxZQUFZLENBQUM1QyxhQUExQztBQUNBMlMsY0FBWSxDQUFDelEsU0FBYixHQUF5QlUsWUFBWSxDQUFDVixTQUF0QztBQUNBeVEsY0FBWSxDQUFDdFEsV0FBYixHQUEyQk8sWUFBWSxDQUFDUCxXQUF4QztBQUVBc1EsY0FBWSxDQUFDQyxPQUFiLEdBQXVCZCxRQUF2QjtBQUNBYSxjQUFZLENBQUNILE1BQWIsR0FBc0JLLE9BQXRCOztBQUVBLFdBQVNYLFNBQVQsQ0FBbUI1UyxHQUFuQixFQUF3QnFNLE1BQXhCLEVBQWdDO0FBQzlCLFFBQUlyTSxHQUFHLENBQUN3QixTQUFSLEVBQW1CO0FBQ2pCeEIsU0FBRyxDQUFDMWUsSUFBSixHQUFXK3FCLE1BQU0sQ0FBQy9xQixJQUFsQjtBQUNBMGUsU0FBRyxDQUFDa00sSUFBSixHQUFXRyxNQUFYO0FBQ0EsYUFBT3JNLEdBQVA7QUFDRDs7QUFDRCxXQUFPcU0sTUFBTSxLQUFLck0sR0FBRyxDQUFDa00sSUFBZixHQUFzQmxNLEdBQXRCLEdBQ0xxTSxNQUFNLENBQUMvcUIsSUFBUCxLQUFnQixDQUFoQixHQUFvQjBlLEdBQUcsQ0FBQ3NULE9BQUosRUFBcEIsR0FDQXRULEdBQUcsQ0FBQ2tULE1BQUosQ0FBVzdHLE1BQVgsQ0FGRjtBQUdEOztBQUVELFdBQVNrSCxPQUFULENBQWlCN3RCLEdBQWpCLEVBQXNCd2QsT0FBdEIsRUFBK0I7QUFDN0IsUUFBSWxELEdBQUcsR0FBRzdULE1BQU0sQ0FBQ21ILE1BQVAsQ0FBYytmLFlBQWQsQ0FBVjtBQUNBclQsT0FBRyxDQUFDMWUsSUFBSixHQUFXb0UsR0FBRyxHQUFHQSxHQUFHLENBQUNwRSxJQUFQLEdBQWMsQ0FBNUI7QUFDQTBlLE9BQUcsQ0FBQ2tNLElBQUosR0FBV3htQixHQUFYO0FBQ0FzYSxPQUFHLENBQUN3QixTQUFKLEdBQWdCMEIsT0FBaEI7QUFDQSxXQUFPbEQsR0FBUDtBQUNEOztBQUVELE1BQUl3VCxTQUFKOztBQUNBLFdBQVNoQixRQUFULEdBQW9CO0FBQ2xCLFdBQU9nQixTQUFTLEtBQUtBLFNBQVMsR0FBR0QsT0FBTyxDQUFDL1MsUUFBUSxFQUFULENBQXhCLENBQWhCO0FBQ0Q7O0FBRURyTixhQUFXLENBQUM4ZixVQUFELEVBQWEvd0IsR0FBYixDQUFYLENBdDNIa0IsQ0F3M0hoQjs7QUFFQSxXQUFTK3dCLFVBQVQsQ0FBb0I3c0IsS0FBcEIsRUFBMkI7QUFDekIsV0FBT0EsS0FBSyxLQUFLLElBQVYsSUFBa0JBLEtBQUssS0FBS25CLFNBQTVCLEdBQXdDd3VCLGVBQWUsRUFBdkQsR0FDTEMsWUFBWSxDQUFDdHRCLEtBQUQsQ0FBWixHQUFzQkEsS0FBdEIsR0FDQXF0QixlQUFlLEdBQUcvUyxhQUFsQixDQUFnQyxVQUFTVixHQUFULEVBQWU7QUFDN0MsVUFBSTlKLElBQUksR0FBR2pDLFdBQVcsQ0FBQzdOLEtBQUQsQ0FBdEI7QUFDQWthLHVCQUFpQixDQUFDcEssSUFBSSxDQUFDNVUsSUFBTixDQUFqQjtBQUNBNFUsVUFBSSxDQUFDclIsT0FBTCxDQUFhLFVBQVNrVCxDQUFULEVBQWE7QUFBQyxlQUFPaUksR0FBRyxDQUFDcmQsR0FBSixDQUFRb1YsQ0FBUixDQUFQO0FBQWtCLE9BQTdDO0FBQ0QsS0FKRCxDQUZGO0FBT0Q7O0FBRURrYixZQUFVLENBQUN0akIsRUFBWCxHQUFnQixZQUF3QjtBQUN0QyxXQUFPLEtBQUsxQixTQUFMLENBQVA7QUFDRCxHQUZEOztBQUlBZ2xCLFlBQVUsQ0FBQ1AsUUFBWCxHQUFzQixVQUFTdHNCLEtBQVQsRUFBZ0I7QUFDcEMsV0FBTyxLQUFLdU4sYUFBYSxDQUFDdk4sS0FBRCxDQUFiLENBQXFCdXNCLE1BQXJCLEVBQUwsQ0FBUDtBQUNELEdBRkQ7O0FBSUFNLFlBQVUsQ0FBQ2hvQixTQUFYLENBQXFCb0IsUUFBckIsR0FBZ0MsWUFBVztBQUN6QyxXQUFPLEtBQUt3TSxVQUFMLENBQWdCLGNBQWhCLEVBQWdDLEdBQWhDLENBQVA7QUFDRCxHQUZEOztBQUtGLFdBQVM2YSxZQUFULENBQXNCQyxlQUF0QixFQUF1QztBQUNyQyxXQUFPbEIsS0FBSyxDQUFDa0IsZUFBRCxDQUFMLElBQTBCaGYsU0FBUyxDQUFDZ2YsZUFBRCxDQUExQztBQUNEOztBQUVEVixZQUFVLENBQUNTLFlBQVgsR0FBMEJBLFlBQTFCO0FBRUEsTUFBSUUsbUJBQW1CLEdBQUdYLFVBQVUsQ0FBQ2hvQixTQUFyQztBQUNBMm9CLHFCQUFtQixDQUFDL2UsbUJBQUQsQ0FBbkIsR0FBMkMsSUFBM0M7QUFFQStlLHFCQUFtQixDQUFDTixPQUFwQixHQUE4QkcsZUFBOUI7QUFDQUcscUJBQW1CLENBQUNWLE1BQXBCLEdBQTZCVyxjQUE3Qjs7QUFFQSxXQUFTQSxjQUFULENBQXdCbnVCLEdBQXhCLEVBQTZCd2QsT0FBN0IsRUFBc0M7QUFDcEMsUUFBSWxELEdBQUcsR0FBRzdULE1BQU0sQ0FBQ21ILE1BQVAsQ0FBY3NnQixtQkFBZCxDQUFWO0FBQ0E1VCxPQUFHLENBQUMxZSxJQUFKLEdBQVdvRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3BFLElBQVAsR0FBYyxDQUE1QjtBQUNBMGUsT0FBRyxDQUFDa00sSUFBSixHQUFXeG1CLEdBQVg7QUFDQXNhLE9BQUcsQ0FBQ3dCLFNBQUosR0FBZ0IwQixPQUFoQjtBQUNBLFdBQU9sRCxHQUFQO0FBQ0Q7O0FBRUQsTUFBSThULGlCQUFKOztBQUNBLFdBQVNMLGVBQVQsR0FBMkI7QUFDekIsV0FBT0ssaUJBQWlCLEtBQUtBLGlCQUFpQixHQUFHRCxjQUFjLENBQUM3SCxlQUFlLEVBQWhCLENBQXZDLENBQXhCO0FBQ0Q7O0FBRUQ3WSxhQUFXLENBQUM0Z0IsS0FBRCxFQUFRMVYsaUJBQVIsQ0FBWCxDQTE2SGtCLENBNDZIaEI7O0FBRUEsV0FBUzBWLEtBQVQsQ0FBZTN0QixLQUFmLEVBQXNCO0FBQ3BCLFdBQU9BLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUtuQixTQUE1QixHQUF3Qyt1QixVQUFVLEVBQWxELEdBQ0xDLE9BQU8sQ0FBQzd0QixLQUFELENBQVAsR0FBaUJBLEtBQWpCLEdBQ0E0dEIsVUFBVSxHQUFHRSxVQUFiLENBQXdCOXRCLEtBQXhCLENBRkY7QUFHRDs7QUFFRDJ0QixPQUFLLENBQUNwa0IsRUFBTixHQUFXLFlBQXdCO0FBQ2pDLFdBQU8sS0FBSzFCLFNBQUwsQ0FBUDtBQUNELEdBRkQ7O0FBSUE4bEIsT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JvQixRQUFoQixHQUEyQixZQUFXO0FBQ3BDLFdBQU8sS0FBS3dNLFVBQUwsQ0FBZ0IsU0FBaEIsRUFBMkIsR0FBM0IsQ0FBUDtBQUNELEdBRkQsQ0F4N0hnQixDQTQ3SGhCOzs7QUFFQWtiLE9BQUssQ0FBQzlvQixTQUFOLENBQWdCZ1AsR0FBaEIsR0FBc0IsVUFBUzdNLEtBQVQsRUFBZ0I4TSxXQUFoQixFQUE2QjtBQUNqRCxRQUFJaWEsSUFBSSxHQUFHLEtBQUtDLEtBQWhCO0FBQ0FobkIsU0FBSyxHQUFHaUosU0FBUyxDQUFDLElBQUQsRUFBT2pKLEtBQVAsQ0FBakI7O0FBQ0EsV0FBTyttQixJQUFJLElBQUkvbUIsS0FBSyxFQUFwQixFQUF3QjtBQUN0QittQixVQUFJLEdBQUdBLElBQUksQ0FBQzVjLElBQVo7QUFDRDs7QUFDRCxXQUFPNGMsSUFBSSxHQUFHQSxJQUFJLENBQUMvdEIsS0FBUixHQUFnQjhULFdBQTNCO0FBQ0QsR0FQRDs7QUFTQTZaLE9BQUssQ0FBQzlvQixTQUFOLENBQWdCb3BCLElBQWhCLEdBQXVCLFlBQVc7QUFDaEMsV0FBTyxLQUFLRCxLQUFMLElBQWMsS0FBS0EsS0FBTCxDQUFXaHVCLEtBQWhDO0FBQ0QsR0FGRCxDQXY4SGdCLENBMjhIaEI7OztBQUVBMnRCLE9BQUssQ0FBQzlvQixTQUFOLENBQWdCb0YsSUFBaEIsR0FBdUIsWUFBd0I7QUFDN0MsUUFBSXBDLFNBQVMsQ0FBQy9JLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSXFoQixPQUFPLEdBQUcsS0FBS2psQixJQUFMLEdBQVkyTSxTQUFTLENBQUMvSSxNQUFwQztBQUNBLFFBQUlpdkIsSUFBSSxHQUFHLEtBQUtDLEtBQWhCOztBQUNBLFNBQUssSUFBSXBlLEVBQUUsR0FBRy9ILFNBQVMsQ0FBQy9JLE1BQVYsR0FBbUIsQ0FBakMsRUFBb0M4USxFQUFFLElBQUksQ0FBMUMsRUFBNkNBLEVBQUUsRUFBL0MsRUFBbUQ7QUFDakRtZSxVQUFJLEdBQUc7QUFDTC90QixhQUFLLEVBQUU2SCxTQUFTLENBQUMrSCxFQUFELENBRFg7QUFFTHVCLFlBQUksRUFBRTRjO0FBRkQsT0FBUDtBQUlEOztBQUNELFFBQUksS0FBSzNTLFNBQVQsRUFBb0I7QUFDbEIsV0FBS2xnQixJQUFMLEdBQVlpbEIsT0FBWjtBQUNBLFdBQUs2TixLQUFMLEdBQWFELElBQWI7QUFDQSxXQUFLN1gsTUFBTCxHQUFjclgsU0FBZDtBQUNBLFdBQUt3YyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTzZTLFNBQVMsQ0FBQy9OLE9BQUQsRUFBVTROLElBQVYsQ0FBaEI7QUFDRCxHQXBCRDs7QUFzQkFKLE9BQUssQ0FBQzlvQixTQUFOLENBQWdCc3BCLE9BQWhCLEdBQTBCLFVBQVNyZSxJQUFULEVBQWU7QUFDdkNBLFFBQUksR0FBR3BDLGVBQWUsQ0FBQ29DLElBQUQsQ0FBdEI7O0FBQ0EsUUFBSUEsSUFBSSxDQUFDNVUsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLGFBQU8sSUFBUDtBQUNEOztBQUNEZ2YscUJBQWlCLENBQUNwSyxJQUFJLENBQUM1VSxJQUFOLENBQWpCO0FBQ0EsUUFBSWlsQixPQUFPLEdBQUcsS0FBS2psQixJQUFuQjtBQUNBLFFBQUk2eUIsSUFBSSxHQUFHLEtBQUtDLEtBQWhCO0FBQ0FsZSxRQUFJLENBQUNpRCxPQUFMLEdBQWV0VSxPQUFmLENBQXVCLFVBQVN1QixLQUFULEVBQWlCO0FBQ3RDbWdCLGFBQU87QUFDUDROLFVBQUksR0FBRztBQUNML3RCLGFBQUssRUFBRUEsS0FERjtBQUVMbVIsWUFBSSxFQUFFNGM7QUFGRCxPQUFQO0FBSUQsS0FORDs7QUFPQSxRQUFJLEtBQUszUyxTQUFULEVBQW9CO0FBQ2xCLFdBQUtsZ0IsSUFBTCxHQUFZaWxCLE9BQVo7QUFDQSxXQUFLNk4sS0FBTCxHQUFhRCxJQUFiO0FBQ0EsV0FBSzdYLE1BQUwsR0FBY3JYLFNBQWQ7QUFDQSxXQUFLd2MsU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU82UyxTQUFTLENBQUMvTixPQUFELEVBQVU0TixJQUFWLENBQWhCO0FBQ0QsR0F2QkQ7O0FBeUJBSixPQUFLLENBQUM5b0IsU0FBTixDQUFnQm9FLEdBQWhCLEdBQXNCLFlBQVc7QUFDL0IsV0FBTyxLQUFLekcsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNELEdBRkQ7O0FBSUFtckIsT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JnZSxPQUFoQixHQUEwQixZQUF3QjtBQUNoRCxXQUFPLEtBQUs1WSxJQUFMLENBQVV2RixLQUFWLENBQWdCLElBQWhCLEVBQXNCbUQsU0FBdEIsQ0FBUDtBQUNELEdBRkQ7O0FBSUE4bEIsT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JpcEIsVUFBaEIsR0FBNkIsVUFBU2hlLElBQVQsRUFBZTtBQUMxQyxXQUFPLEtBQUtxZSxPQUFMLENBQWFyZSxJQUFiLENBQVA7QUFDRCxHQUZEOztBQUlBNmQsT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JtRSxLQUFoQixHQUF3QixZQUFXO0FBQ2pDLFdBQU8sS0FBS0MsR0FBTCxDQUFTdkUsS0FBVCxDQUFlLElBQWYsRUFBcUJtRCxTQUFyQixDQUFQO0FBQ0QsR0FGRDs7QUFJQThsQixPQUFLLENBQUM5b0IsU0FBTixDQUFnQnNXLEtBQWhCLEdBQXdCLFlBQVc7QUFDakMsUUFBSSxLQUFLamdCLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPLElBQVA7QUFDRDs7QUFDRCxRQUFJLEtBQUtrZ0IsU0FBVCxFQUFvQjtBQUNsQixXQUFLbGdCLElBQUwsR0FBWSxDQUFaO0FBQ0EsV0FBSzh5QixLQUFMLEdBQWFudkIsU0FBYjtBQUNBLFdBQUtxWCxNQUFMLEdBQWNyWCxTQUFkO0FBQ0EsV0FBS3djLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPdVMsVUFBVSxFQUFqQjtBQUNELEdBWkQ7O0FBY0FELE9BQUssQ0FBQzlvQixTQUFOLENBQWdCckMsS0FBaEIsR0FBd0IsVUFBUzZOLEtBQVQsRUFBZ0JDLEdBQWhCLEVBQXFCO0FBQzNDLFFBQUlGLFVBQVUsQ0FBQ0MsS0FBRCxFQUFRQyxHQUFSLEVBQWEsS0FBS3BWLElBQWxCLENBQWQsRUFBdUM7QUFDckMsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSXN0QixhQUFhLEdBQUdqWSxZQUFZLENBQUNGLEtBQUQsRUFBUSxLQUFLblYsSUFBYixDQUFoQztBQUNBLFFBQUl1dEIsV0FBVyxHQUFHaFksVUFBVSxDQUFDSCxHQUFELEVBQU0sS0FBS3BWLElBQVgsQ0FBNUI7O0FBQ0EsUUFBSXV0QixXQUFXLEtBQUssS0FBS3Z0QixJQUF6QixFQUErQjtBQUM3QjtBQUNBLGFBQU8rYyxpQkFBaUIsQ0FBQ3BULFNBQWxCLENBQTRCckMsS0FBNUIsQ0FBa0MwRCxJQUFsQyxDQUF1QyxJQUF2QyxFQUE2Q21LLEtBQTdDLEVBQW9EQyxHQUFwRCxDQUFQO0FBQ0Q7O0FBQ0QsUUFBSTZQLE9BQU8sR0FBRyxLQUFLamxCLElBQUwsR0FBWXN0QixhQUExQjtBQUNBLFFBQUl1RixJQUFJLEdBQUcsS0FBS0MsS0FBaEI7O0FBQ0EsV0FBT3hGLGFBQWEsRUFBcEIsRUFBd0I7QUFDdEJ1RixVQUFJLEdBQUdBLElBQUksQ0FBQzVjLElBQVo7QUFDRDs7QUFDRCxRQUFJLEtBQUtpSyxTQUFULEVBQW9CO0FBQ2xCLFdBQUtsZ0IsSUFBTCxHQUFZaWxCLE9BQVo7QUFDQSxXQUFLNk4sS0FBTCxHQUFhRCxJQUFiO0FBQ0EsV0FBSzdYLE1BQUwsR0FBY3JYLFNBQWQ7QUFDQSxXQUFLd2MsU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU82UyxTQUFTLENBQUMvTixPQUFELEVBQVU0TixJQUFWLENBQWhCO0FBQ0QsR0F2QkQsQ0ExaElnQixDQW1qSWhCOzs7QUFFQUosT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0I2WCxhQUFoQixHQUFnQyxVQUFTSSxPQUFULEVBQWtCO0FBQ2hELFFBQUlBLE9BQU8sS0FBSyxLQUFLMUIsU0FBckIsRUFBZ0M7QUFDOUIsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDMEIsT0FBTCxFQUFjO0FBQ1osV0FBSzFCLFNBQUwsR0FBaUIwQixPQUFqQjtBQUNBLFdBQUt6QixTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTzZTLFNBQVMsQ0FBQyxLQUFLaHpCLElBQU4sRUFBWSxLQUFLOHlCLEtBQWpCLEVBQXdCbFIsT0FBeEIsRUFBaUMsS0FBSzVHLE1BQXRDLENBQWhCO0FBQ0QsR0FWRCxDQXJqSWdCLENBaWtJaEI7OztBQUVBeVgsT0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JrTCxTQUFoQixHQUE0QixVQUFTK0MsRUFBVCxFQUFhQyxPQUFiLEVBQXNCO0FBQ2hELFFBQUlBLE9BQUosRUFBYTtBQUNYLGFBQU8sS0FBS0EsT0FBTCxHQUFlaEQsU0FBZixDQUF5QitDLEVBQXpCLENBQVA7QUFDRDs7QUFDRCxRQUFJaFYsVUFBVSxHQUFHLENBQWpCO0FBQ0EsUUFBSUMsSUFBSSxHQUFHLEtBQUtpd0IsS0FBaEI7O0FBQ0EsV0FBT2p3QixJQUFQLEVBQWE7QUFDWCxVQUFJK1UsRUFBRSxDQUFDL1UsSUFBSSxDQUFDaUMsS0FBTixFQUFhbEMsVUFBVSxFQUF2QixFQUEyQixJQUEzQixDQUFGLEtBQXVDLEtBQTNDLEVBQWtEO0FBQ2hEO0FBQ0Q7O0FBQ0RDLFVBQUksR0FBR0EsSUFBSSxDQUFDb1QsSUFBWjtBQUNEOztBQUNELFdBQU9yVCxVQUFQO0FBQ0QsR0FiRDs7QUFlQTZ2QixPQUFLLENBQUM5b0IsU0FBTixDQUFnQm9PLFVBQWhCLEdBQTZCLFVBQVNoWixJQUFULEVBQWU4WSxPQUFmLEVBQXdCO0FBQ25ELFFBQUlBLE9BQUosRUFBYTtBQUNYLGFBQU8sS0FBS0EsT0FBTCxHQUFlRSxVQUFmLENBQTBCaFosSUFBMUIsQ0FBUDtBQUNEOztBQUNELFFBQUk2RCxVQUFVLEdBQUcsQ0FBakI7QUFDQSxRQUFJQyxJQUFJLEdBQUcsS0FBS2l3QixLQUFoQjtBQUNBLFdBQU8sSUFBSTljLFFBQUosQ0FBYSxZQUFZO0FBQzlCLFVBQUluVCxJQUFKLEVBQVU7QUFDUixZQUFJaUMsS0FBSyxHQUFHakMsSUFBSSxDQUFDaUMsS0FBakI7QUFDQWpDLFlBQUksR0FBR0EsSUFBSSxDQUFDb1QsSUFBWjtBQUNBLGVBQU9NLGFBQWEsQ0FBQ3hYLElBQUQsRUFBTzZELFVBQVUsRUFBakIsRUFBcUJrQyxLQUFyQixDQUFwQjtBQUNEOztBQUNELGFBQU84UixZQUFZLEVBQW5CO0FBQ0QsS0FQTSxDQUFQO0FBUUQsR0FkRDs7QUFpQkYsV0FBUytiLE9BQVQsQ0FBaUJPLFVBQWpCLEVBQTZCO0FBQzNCLFdBQU8sQ0FBQyxFQUFFQSxVQUFVLElBQUlBLFVBQVUsQ0FBQ0MsaUJBQUQsQ0FBMUIsQ0FBUjtBQUNEOztBQUVEVixPQUFLLENBQUNFLE9BQU4sR0FBZ0JBLE9BQWhCO0FBRUEsTUFBSVEsaUJBQWlCLEdBQUcseUJBQXhCO0FBRUEsTUFBSUMsY0FBYyxHQUFHWCxLQUFLLENBQUM5b0IsU0FBM0I7QUFDQXlwQixnQkFBYyxDQUFDRCxpQkFBRCxDQUFkLEdBQW9DLElBQXBDO0FBQ0FDLGdCQUFjLENBQUNoVSxhQUFmLEdBQStCNEMsWUFBWSxDQUFDNUMsYUFBNUM7QUFDQWdVLGdCQUFjLENBQUM5UixTQUFmLEdBQTJCVSxZQUFZLENBQUNWLFNBQXhDO0FBQ0E4UixnQkFBYyxDQUFDM1IsV0FBZixHQUE2Qk8sWUFBWSxDQUFDUCxXQUExQztBQUNBMlIsZ0JBQWMsQ0FBQzdSLFVBQWYsR0FBNEJTLFlBQVksQ0FBQ1QsVUFBekM7O0FBR0EsV0FBU3lSLFNBQVQsQ0FBbUJoekIsSUFBbkIsRUFBeUI2eUIsSUFBekIsRUFBK0JqUixPQUEvQixFQUF3Q3RFLElBQXhDLEVBQThDO0FBQzVDLFFBQUlsWixHQUFHLEdBQUd5RyxNQUFNLENBQUNtSCxNQUFQLENBQWNvaEIsY0FBZCxDQUFWO0FBQ0FodkIsT0FBRyxDQUFDcEUsSUFBSixHQUFXQSxJQUFYO0FBQ0FvRSxPQUFHLENBQUMwdUIsS0FBSixHQUFZRCxJQUFaO0FBQ0F6dUIsT0FBRyxDQUFDOGIsU0FBSixHQUFnQjBCLE9BQWhCO0FBQ0F4ZCxPQUFHLENBQUM0VyxNQUFKLEdBQWFzQyxJQUFiO0FBQ0FsWixPQUFHLENBQUMrYixTQUFKLEdBQWdCLEtBQWhCO0FBQ0EsV0FBTy9iLEdBQVA7QUFDRDs7QUFFRCxNQUFJaXZCLFdBQUo7O0FBQ0EsV0FBU1gsVUFBVCxHQUFzQjtBQUNwQixXQUFPVyxXQUFXLEtBQUtBLFdBQVcsR0FBR0wsU0FBUyxDQUFDLENBQUQsQ0FBNUIsQ0FBbEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0UsV0FBU3BwQixLQUFULENBQWVrSSxJQUFmLEVBQXFCd2hCLE9BQXJCLEVBQThCO0FBQzVCLFFBQUlDLFNBQVMsR0FBRyxVQUFTcm5CLEdBQVQsRUFBZTtBQUFFNEYsVUFBSSxDQUFDbkksU0FBTCxDQUFldUMsR0FBZixJQUFzQm9uQixPQUFPLENBQUNwbkIsR0FBRCxDQUE3QjtBQUFxQyxLQUF0RTs7QUFDQXJCLFVBQU0sQ0FBQ0MsSUFBUCxDQUFZd29CLE9BQVosRUFBcUIvdkIsT0FBckIsQ0FBNkJnd0IsU0FBN0I7QUFDQTFvQixVQUFNLENBQUMyb0IscUJBQVAsSUFDRTNvQixNQUFNLENBQUMyb0IscUJBQVAsQ0FBNkJGLE9BQTdCLEVBQXNDL3ZCLE9BQXRDLENBQThDZ3dCLFNBQTlDLENBREY7QUFFQSxXQUFPemhCLElBQVA7QUFDRDs7QUFFREksVUFBUSxDQUFDOEQsUUFBVCxHQUFvQkEsUUFBcEI7QUFFQXBNLE9BQUssQ0FBQ3NJLFFBQUQsRUFBVztBQUVkO0FBRUEvTixXQUFPLEVBQUUsWUFBVztBQUNsQjZhLHVCQUFpQixDQUFDLEtBQUtoZixJQUFOLENBQWpCO0FBQ0EsVUFBSThILEtBQUssR0FBRyxJQUFJdEcsS0FBSixDQUFVLEtBQUt4QixJQUFMLElBQWEsQ0FBdkIsQ0FBWjs7QUFDQSxXQUFLMHJCLFFBQUwsR0FBZ0I3VyxTQUFoQixDQUEwQixVQUFTNEIsQ0FBVCxFQUFZbkssQ0FBWixFQUFnQjtBQUFFeEUsYUFBSyxDQUFDd0UsQ0FBRCxDQUFMLEdBQVdtSyxDQUFYO0FBQWUsT0FBM0Q7O0FBQ0EsYUFBTzNPLEtBQVA7QUFDRCxLQVRhO0FBV2R1USxnQkFBWSxFQUFFLFlBQVc7QUFDdkIsYUFBTyxJQUFJNFQsaUJBQUosQ0FBc0IsSUFBdEIsQ0FBUDtBQUNELEtBYmE7QUFlZHdILFFBQUksRUFBRSxZQUFXO0FBQ2YsYUFBTyxLQUFLcGMsS0FBTCxHQUFhalQsR0FBYixDQUNMLFVBQVNVLEtBQVQsRUFBaUI7QUFBQyxlQUFPQSxLQUFLLElBQUksT0FBT0EsS0FBSyxDQUFDMnVCLElBQWIsS0FBc0IsVUFBL0IsR0FBNEMzdUIsS0FBSyxDQUFDMnVCLElBQU4sRUFBNUMsR0FBMkQzdUIsS0FBbEU7QUFBd0UsT0FEckYsRUFFTDR1QixNQUZLLEVBQVA7QUFHRCxLQW5CYTtBQXFCZEMsVUFBTSxFQUFFLFlBQVc7QUFDakIsYUFBTyxLQUFLdGMsS0FBTCxHQUFhalQsR0FBYixDQUNMLFVBQVNVLEtBQVQsRUFBaUI7QUFBQyxlQUFPQSxLQUFLLElBQUksT0FBT0EsS0FBSyxDQUFDNnVCLE1BQWIsS0FBd0IsVUFBakMsR0FBOEM3dUIsS0FBSyxDQUFDNnVCLE1BQU4sRUFBOUMsR0FBK0Q3dUIsS0FBdEU7QUFBNEUsT0FEekYsRUFFTDR1QixNQUZLLEVBQVA7QUFHRCxLQXpCYTtBQTJCZHpiLGNBQVUsRUFBRSxZQUFXO0FBQ3JCLGFBQU8sSUFBSXFULGVBQUosQ0FBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBUDtBQUNELEtBN0JhO0FBK0JkN1EsU0FBSyxFQUFFLFlBQVc7QUFDaEI7QUFDQSxhQUFPd0UsR0FBRyxDQUFDLEtBQUtoSCxVQUFMLEVBQUQsQ0FBVjtBQUNELEtBbENhO0FBb0NkelMsWUFBUSxFQUFFLFlBQVc7QUFDbkJ3Wix1QkFBaUIsQ0FBQyxLQUFLaGYsSUFBTixDQUFqQjtBQUNBLFVBQUkwSCxNQUFNLEdBQUcsRUFBYjs7QUFDQSxXQUFLbU4sU0FBTCxDQUFlLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZ0I7QUFBRTlPLGNBQU0sQ0FBQzhPLENBQUQsQ0FBTixHQUFZQyxDQUFaO0FBQWdCLE9BQWpEOztBQUNBLGFBQU8vTyxNQUFQO0FBQ0QsS0F6Q2E7QUEyQ2Rrc0IsZ0JBQVksRUFBRSxZQUFXO0FBQ3ZCO0FBQ0EsYUFBTzFTLFVBQVUsQ0FBQyxLQUFLakosVUFBTCxFQUFELENBQWpCO0FBQ0QsS0E5Q2E7QUFnRGQ0YixnQkFBWSxFQUFFLFlBQVc7QUFDdkI7QUFDQSxhQUFPbEMsVUFBVSxDQUFDcmYsT0FBTyxDQUFDLElBQUQsQ0FBUCxHQUFnQixLQUFLb1osUUFBTCxFQUFoQixHQUFrQyxJQUFuQyxDQUFqQjtBQUNELEtBbkRhO0FBcURkb0ksU0FBSyxFQUFFLFlBQVc7QUFDaEI7QUFDQSxhQUFPbHpCLEdBQUcsQ0FBQzBSLE9BQU8sQ0FBQyxJQUFELENBQVAsR0FBZ0IsS0FBS29aLFFBQUwsRUFBaEIsR0FBa0MsSUFBbkMsQ0FBVjtBQUNELEtBeERhO0FBMERkcFQsWUFBUSxFQUFFLFlBQVc7QUFDbkIsYUFBTyxJQUFJNFQsYUFBSixDQUFrQixJQUFsQixDQUFQO0FBQ0QsS0E1RGE7QUE4RGQ3VSxTQUFLLEVBQUUsWUFBVztBQUNoQixhQUFPNUUsU0FBUyxDQUFDLElBQUQsQ0FBVCxHQUFrQixLQUFLNEYsWUFBTCxFQUFsQixHQUNML0YsT0FBTyxDQUFDLElBQUQsQ0FBUCxHQUFnQixLQUFLMkYsVUFBTCxFQUFoQixHQUNBLEtBQUtLLFFBQUwsRUFGRjtBQUdELEtBbEVhO0FBb0VkeWIsV0FBTyxFQUFFLFlBQVc7QUFDbEI7QUFDQSxhQUFPdEIsS0FBSyxDQUFDbmdCLE9BQU8sQ0FBQyxJQUFELENBQVAsR0FBZ0IsS0FBS29aLFFBQUwsRUFBaEIsR0FBa0MsSUFBbkMsQ0FBWjtBQUNELEtBdkVhO0FBeUVkbFIsVUFBTSxFQUFFLFlBQVc7QUFDakI7QUFDQSxhQUFPZ00sSUFBSSxDQUFDbFUsT0FBTyxDQUFDLElBQUQsQ0FBUCxHQUFnQixLQUFLb1osUUFBTCxFQUFoQixHQUFrQyxJQUFuQyxDQUFYO0FBQ0QsS0E1RWE7QUErRWQ7QUFFQTNnQixZQUFRLEVBQUUsWUFBVztBQUNuQixhQUFPLFlBQVA7QUFDRCxLQW5GYTtBQXFGZHdNLGNBQVUsRUFBRSxVQUFTc2IsSUFBVCxFQUFlN0osSUFBZixFQUFxQjtBQUMvQixVQUFJLEtBQUtocEIsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQ25CLGVBQU82eUIsSUFBSSxHQUFHN0osSUFBZDtBQUNEOztBQUNELGFBQU82SixJQUFJLEdBQUcsR0FBUCxHQUFhLEtBQUt4YixLQUFMLEdBQWFqVCxHQUFiLENBQWlCLEtBQUs0dkIsZ0JBQXRCLEVBQXdDQyxJQUF4QyxDQUE2QyxJQUE3QyxDQUFiLEdBQWtFLEdBQWxFLEdBQXdFakwsSUFBL0U7QUFDRCxLQTFGYTtBQTZGZDtBQUVBdGIsVUFBTSxFQUFFLFlBQVc7QUFBQyxVQUFJOFosTUFBTSxHQUFHNVYsT0FBTyxDQUFDNUcsSUFBUixDQUFhMkIsU0FBYixFQUF3QixDQUF4QixDQUFiO0FBQ2xCLGFBQU93Z0IsS0FBSyxDQUFDLElBQUQsRUFBT2dCLGFBQWEsQ0FBQyxJQUFELEVBQU8zRyxNQUFQLENBQXBCLENBQVo7QUFDRCxLQWpHYTtBQW1HZDVMLFlBQVEsRUFBRSxVQUFTQyxXQUFULEVBQXNCO0FBQzlCLGFBQU8sS0FBS2lVLElBQUwsQ0FBVSxVQUFTaHJCLEtBQVQsRUFBaUI7QUFBQyxlQUFPNFYsRUFBRSxDQUFDNVYsS0FBRCxFQUFRK1csV0FBUixDQUFUO0FBQThCLE9BQTFELENBQVA7QUFDRCxLQXJHYTtBQXVHZFgsV0FBTyxFQUFFLFlBQVc7QUFDbEIsYUFBTyxLQUFLbkQsVUFBTCxDQUFnQm5DLGVBQWhCLENBQVA7QUFDRCxLQXpHYTtBQTJHZHVGLFNBQUssRUFBRSxVQUFTbFAsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCO0FBQ2xDN00sdUJBQWlCLENBQUMsS0FBS2hmLElBQU4sQ0FBakI7QUFDQSxVQUFJazBCLFdBQVcsR0FBRyxJQUFsQjs7QUFDQSxXQUFLcmYsU0FBTCxDQUFlLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZTBHLENBQWYsRUFBbUI7QUFDaEMsWUFBSSxDQUFDalIsU0FBUyxDQUFDakIsSUFBVixDQUFlNmdCLE9BQWYsRUFBd0JwVixDQUF4QixFQUEyQkQsQ0FBM0IsRUFBOEIwRyxDQUE5QixDQUFMLEVBQXVDO0FBQ3JDZ1gscUJBQVcsR0FBRyxLQUFkO0FBQ0EsaUJBQU8sS0FBUDtBQUNEO0FBQ0YsT0FMRDs7QUFNQSxhQUFPQSxXQUFQO0FBQ0QsS0FySGE7QUF1SGQvakIsVUFBTSxFQUFFLFVBQVNsRSxTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDbkMsYUFBT3NCLEtBQUssQ0FBQyxJQUFELEVBQU9ULGFBQWEsQ0FBQyxJQUFELEVBQU96Z0IsU0FBUCxFQUFrQjRmLE9BQWxCLEVBQTJCLElBQTNCLENBQXBCLENBQVo7QUFDRCxLQXpIYTtBQTJIZHNJLFFBQUksRUFBRSxVQUFTbG9CLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QmpULFdBQTdCLEVBQTBDO0FBQzlDLFVBQUlxQixLQUFLLEdBQUcsS0FBS21hLFNBQUwsQ0FBZW5vQixTQUFmLEVBQTBCNGYsT0FBMUIsQ0FBWjtBQUNBLGFBQU81UixLQUFLLEdBQUdBLEtBQUssQ0FBQyxDQUFELENBQVIsR0FBY3JCLFdBQTFCO0FBQ0QsS0E5SGE7QUFnSWRyVixXQUFPLEVBQUUsVUFBUzh3QixVQUFULEVBQXFCeEksT0FBckIsRUFBOEI7QUFDckM3TSx1QkFBaUIsQ0FBQyxLQUFLaGYsSUFBTixDQUFqQjtBQUNBLGFBQU8sS0FBSzZVLFNBQUwsQ0FBZWdYLE9BQU8sR0FBR3dJLFVBQVUsQ0FBQy9sQixJQUFYLENBQWdCdWQsT0FBaEIsQ0FBSCxHQUE4QndJLFVBQXBELENBQVA7QUFDRCxLQW5JYTtBQXFJZEosUUFBSSxFQUFFLFVBQVNoRixTQUFULEVBQW9CO0FBQ3hCalEsdUJBQWlCLENBQUMsS0FBS2hmLElBQU4sQ0FBakI7QUFDQWl2QixlQUFTLEdBQUdBLFNBQVMsS0FBS3RyQixTQUFkLEdBQTBCLEtBQUtzckIsU0FBL0IsR0FBMkMsR0FBdkQ7QUFDQSxVQUFJcUYsTUFBTSxHQUFHLEVBQWI7QUFDQSxVQUFJQyxPQUFPLEdBQUcsSUFBZDs7QUFDQSxXQUFLMWYsU0FBTCxDQUFlLFVBQVM0QixDQUFULEVBQWE7QUFDMUI4ZCxlQUFPLEdBQUlBLE9BQU8sR0FBRyxLQUFkLEdBQXdCRCxNQUFNLElBQUlyRixTQUF6QztBQUNBcUYsY0FBTSxJQUFJN2QsQ0FBQyxLQUFLLElBQU4sSUFBY0EsQ0FBQyxLQUFLOVMsU0FBcEIsR0FBZ0M4UyxDQUFDLENBQUMxTCxRQUFGLEVBQWhDLEdBQStDLEVBQXpEO0FBQ0QsT0FIRDs7QUFJQSxhQUFPdXBCLE1BQVA7QUFDRCxLQS9JYTtBQWlKZHhwQixRQUFJLEVBQUUsWUFBVztBQUNmLGFBQU8sS0FBS2lOLFVBQUwsQ0FBZ0JyQyxZQUFoQixDQUFQO0FBQ0QsS0FuSmE7QUFxSmR0UixPQUFHLEVBQUUsVUFBU2dkLE1BQVQsRUFBaUJ5SyxPQUFqQixFQUEwQjtBQUM3QixhQUFPc0IsS0FBSyxDQUFDLElBQUQsRUFBT3BCLFVBQVUsQ0FBQyxJQUFELEVBQU8zSyxNQUFQLEVBQWV5SyxPQUFmLENBQWpCLENBQVo7QUFDRCxLQXZKYTtBQXlKZDdlLFVBQU0sRUFBRSxVQUFTd25CLE9BQVQsRUFBa0JDLGdCQUFsQixFQUFvQzVJLE9BQXBDLEVBQTZDO0FBQ25EN00sdUJBQWlCLENBQUMsS0FBS2hmLElBQU4sQ0FBakI7QUFDQSxVQUFJMDBCLFNBQUo7QUFDQSxVQUFJQyxRQUFKOztBQUNBLFVBQUlob0IsU0FBUyxDQUFDL0ksTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4Qit3QixnQkFBUSxHQUFHLElBQVg7QUFDRCxPQUZELE1BRU87QUFDTEQsaUJBQVMsR0FBR0QsZ0JBQVo7QUFDRDs7QUFDRCxXQUFLNWYsU0FBTCxDQUFlLFVBQVM0QixDQUFULEVBQVlELENBQVosRUFBZTBHLENBQWYsRUFBbUI7QUFDaEMsWUFBSXlYLFFBQUosRUFBYztBQUNaQSxrQkFBUSxHQUFHLEtBQVg7QUFDQUQsbUJBQVMsR0FBR2plLENBQVo7QUFDRCxTQUhELE1BR087QUFDTGllLG1CQUFTLEdBQUdGLE9BQU8sQ0FBQ3hwQixJQUFSLENBQWE2Z0IsT0FBYixFQUFzQjZJLFNBQXRCLEVBQWlDamUsQ0FBakMsRUFBb0NELENBQXBDLEVBQXVDMEcsQ0FBdkMsQ0FBWjtBQUNEO0FBQ0YsT0FQRDs7QUFRQSxhQUFPd1gsU0FBUDtBQUNELEtBM0thO0FBNktkRSxlQUFXLEVBQUUsVUFBU0osT0FBVCxFQUFrQkMsZ0JBQWxCLEVBQW9DNUksT0FBcEMsRUFBNkM7QUFDeEQsVUFBSWdKLFFBQVEsR0FBRyxLQUFLNWMsVUFBTCxHQUFrQkosT0FBbEIsRUFBZjtBQUNBLGFBQU9nZCxRQUFRLENBQUM3bkIsTUFBVCxDQUFnQnhELEtBQWhCLENBQXNCcXJCLFFBQXRCLEVBQWdDbG9CLFNBQWhDLENBQVA7QUFDRCxLQWhMYTtBQWtMZGtMLFdBQU8sRUFBRSxZQUFXO0FBQ2xCLGFBQU9zVixLQUFLLENBQUMsSUFBRCxFQUFPdkIsY0FBYyxDQUFDLElBQUQsRUFBTyxJQUFQLENBQXJCLENBQVo7QUFDRCxLQXBMYTtBQXNMZHRrQixTQUFLLEVBQUUsVUFBUzZOLEtBQVQsRUFBZ0JDLEdBQWhCLEVBQXFCO0FBQzFCLGFBQU8rWCxLQUFLLENBQUMsSUFBRCxFQUFPQyxZQUFZLENBQUMsSUFBRCxFQUFPalksS0FBUCxFQUFjQyxHQUFkLEVBQW1CLElBQW5CLENBQW5CLENBQVo7QUFDRCxLQXhMYTtBQTBMZDBhLFFBQUksRUFBRSxVQUFTN2pCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QjtBQUNqQyxhQUFPLENBQUMsS0FBSzFRLEtBQUwsQ0FBV2pVLEdBQUcsQ0FBQytFLFNBQUQsQ0FBZCxFQUEyQjRmLE9BQTNCLENBQVI7QUFDRCxLQTVMYTtBQThMZDdLLFFBQUksRUFBRSxVQUFTQyxVQUFULEVBQXFCO0FBQ3pCLGFBQU9rTSxLQUFLLENBQUMsSUFBRCxFQUFPaE0sV0FBVyxDQUFDLElBQUQsRUFBT0YsVUFBUCxDQUFsQixDQUFaO0FBQ0QsS0FoTWE7QUFrTWR1RyxVQUFNLEVBQUUsWUFBVztBQUNqQixhQUFPLEtBQUt6UCxVQUFMLENBQWdCcEMsY0FBaEIsQ0FBUDtBQUNELEtBcE1hO0FBdU1kO0FBRUFtZixXQUFPLEVBQUUsWUFBVztBQUNsQixhQUFPLEtBQUt4dEIsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBUDtBQUNELEtBM01hO0FBNk1keXRCLFdBQU8sRUFBRSxZQUFXO0FBQ2xCLGFBQU8sS0FBSy8wQixJQUFMLEtBQWMyRCxTQUFkLEdBQTBCLEtBQUszRCxJQUFMLEtBQWMsQ0FBeEMsR0FBNEMsQ0FBQyxLQUFLOHZCLElBQUwsQ0FBVSxZQUFZO0FBQUMsZUFBTyxJQUFQO0FBQVksT0FBbkMsQ0FBcEQ7QUFDRCxLQS9NYTtBQWlOZGpNLFNBQUssRUFBRSxVQUFTNVgsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCO0FBQ2xDLGFBQU9sWCxVQUFVLENBQ2YxSSxTQUFTLEdBQUcsS0FBS29MLEtBQUwsR0FBYWxILE1BQWIsQ0FBb0JsRSxTQUFwQixFQUErQjRmLE9BQS9CLENBQUgsR0FBNkMsSUFEdkMsQ0FBakI7QUFHRCxLQXJOYTtBQXVOZG1KLFdBQU8sRUFBRSxVQUFTbkksT0FBVCxFQUFrQmhCLE9BQWxCLEVBQTJCO0FBQ2xDLGFBQU9lLGNBQWMsQ0FBQyxJQUFELEVBQU9DLE9BQVAsRUFBZ0JoQixPQUFoQixDQUFyQjtBQUNELEtBek5hO0FBMk5kL1EsVUFBTSxFQUFFLFVBQVNrQixLQUFULEVBQWdCO0FBQ3RCLGFBQU9qQixTQUFTLENBQUMsSUFBRCxFQUFPaUIsS0FBUCxDQUFoQjtBQUNELEtBN05hO0FBK05kckUsWUFBUSxFQUFFLFlBQVc7QUFDbkIsVUFBSTNQLFFBQVEsR0FBRyxJQUFmOztBQUNBLFVBQUlBLFFBQVEsQ0FBQ3lQLE1BQWIsRUFBcUI7QUFDbkI7QUFDQSxlQUFPLElBQUlnQixRQUFKLENBQWF6USxRQUFRLENBQUN5UCxNQUF0QixDQUFQO0FBQ0Q7O0FBQ0QsVUFBSXdkLGVBQWUsR0FBR2p0QixRQUFRLENBQUNxUCxLQUFULEdBQWlCalQsR0FBakIsQ0FBcUI4d0IsV0FBckIsRUFBa0M3YyxZQUFsQyxFQUF0Qjs7QUFDQTRjLHFCQUFlLENBQUMvYyxZQUFoQixHQUErQixZQUFZO0FBQUMsZUFBT2xRLFFBQVEsQ0FBQ3FQLEtBQVQsRUFBUDtBQUF3QixPQUFwRTs7QUFDQSxhQUFPNGQsZUFBUDtBQUNELEtBeE9hO0FBME9kRSxhQUFTLEVBQUUsVUFBU2xwQixTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDdEMsYUFBTyxLQUFLMWIsTUFBTCxDQUFZakosR0FBRyxDQUFDK0UsU0FBRCxDQUFmLEVBQTRCNGYsT0FBNUIsQ0FBUDtBQUNELEtBNU9hO0FBOE9kdUksYUFBUyxFQUFFLFVBQVNub0IsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCalQsV0FBN0IsRUFBMEM7QUFDbkQsVUFBSXdjLEtBQUssR0FBR3hjLFdBQVo7O0FBQ0EsV0FBSy9ELFNBQUwsQ0FBZSxVQUFTNEIsQ0FBVCxFQUFZRCxDQUFaLEVBQWUwRyxDQUFmLEVBQW1CO0FBQ2hDLFlBQUlqUixTQUFTLENBQUNqQixJQUFWLENBQWU2Z0IsT0FBZixFQUF3QnBWLENBQXhCLEVBQTJCRCxDQUEzQixFQUE4QjBHLENBQTlCLENBQUosRUFBc0M7QUFDcENrWSxlQUFLLEdBQUcsQ0FBQzVlLENBQUQsRUFBSUMsQ0FBSixDQUFSO0FBQ0EsaUJBQU8sS0FBUDtBQUNEO0FBQ0YsT0FMRDs7QUFNQSxhQUFPMmUsS0FBUDtBQUNELEtBdlBhO0FBeVBkQyxXQUFPLEVBQUUsVUFBU3BwQixTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDcEMsVUFBSTVSLEtBQUssR0FBRyxLQUFLbWEsU0FBTCxDQUFlbm9CLFNBQWYsRUFBMEI0ZixPQUExQixDQUFaO0FBQ0EsYUFBTzVSLEtBQUssSUFBSUEsS0FBSyxDQUFDLENBQUQsQ0FBckI7QUFDRCxLQTVQYTtBQThQZHFiLFlBQVEsRUFBRSxVQUFTcnBCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QmpULFdBQTdCLEVBQTBDO0FBQ2xELGFBQU8sS0FBS1gsVUFBTCxHQUFrQkosT0FBbEIsR0FBNEJzYyxJQUE1QixDQUFpQ2xvQixTQUFqQyxFQUE0QzRmLE9BQTVDLEVBQXFEalQsV0FBckQsQ0FBUDtBQUNELEtBaFFhO0FBa1FkMmMsaUJBQWEsRUFBRSxVQUFTdHBCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QmpULFdBQTdCLEVBQTBDO0FBQ3ZELGFBQU8sS0FBS1gsVUFBTCxHQUFrQkosT0FBbEIsR0FBNEJ1YyxTQUE1QixDQUFzQ25vQixTQUF0QyxFQUFpRDRmLE9BQWpELEVBQTBEalQsV0FBMUQsQ0FBUDtBQUNELEtBcFFhO0FBc1FkNGMsZUFBVyxFQUFFLFVBQVN2cEIsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCO0FBQ3hDLGFBQU8sS0FBSzVULFVBQUwsR0FBa0JKLE9BQWxCLEdBQTRCd2QsT0FBNUIsQ0FBb0NwcEIsU0FBcEMsRUFBK0M0ZixPQUEvQyxDQUFQO0FBQ0QsS0F4UWE7QUEwUWQ0SixTQUFLLEVBQUUsWUFBVztBQUNoQixhQUFPLEtBQUt0QixJQUFMLENBQVVyZixVQUFWLENBQVA7QUFDRCxLQTVRYTtBQThRZG5RLFdBQU8sRUFBRSxVQUFTeWMsTUFBVCxFQUFpQnlLLE9BQWpCLEVBQTBCO0FBQ2pDLGFBQU9zQixLQUFLLENBQUMsSUFBRCxFQUFPNEIsY0FBYyxDQUFDLElBQUQsRUFBTzNOLE1BQVAsRUFBZXlLLE9BQWYsQ0FBckIsQ0FBWjtBQUNELEtBaFJhO0FBa1JkMEMsV0FBTyxFQUFFLFVBQVNHLEtBQVQsRUFBZ0I7QUFDdkIsYUFBT3ZCLEtBQUssQ0FBQyxJQUFELEVBQU9zQixjQUFjLENBQUMsSUFBRCxFQUFPQyxLQUFQLEVBQWMsSUFBZCxDQUFyQixDQUFaO0FBQ0QsS0FwUmE7QUFzUmR4VyxnQkFBWSxFQUFFLFlBQVc7QUFDdkIsYUFBTyxJQUFJaVUsbUJBQUosQ0FBd0IsSUFBeEIsQ0FBUDtBQUNELEtBeFJhO0FBMFJkeFQsT0FBRyxFQUFFLFVBQVMrYyxTQUFULEVBQW9COWMsV0FBcEIsRUFBaUM7QUFDcEMsYUFBTyxLQUFLdWIsSUFBTCxDQUFVLFVBQVM1eUIsQ0FBVCxFQUFZMkssR0FBWixFQUFrQjtBQUFDLGVBQU93TyxFQUFFLENBQUN4TyxHQUFELEVBQU13cEIsU0FBTixDQUFUO0FBQTBCLE9BQXZELEVBQXlEL3hCLFNBQXpELEVBQW9FaVYsV0FBcEUsQ0FBUDtBQUNELEtBNVJhO0FBOFJkK2MsU0FBSyxFQUFFLFVBQVNDLGFBQVQsRUFBd0JoZCxXQUF4QixFQUFxQztBQUMxQyxVQUFJaWQsTUFBTSxHQUFHLElBQWIsQ0FEMEMsQ0FFMUM7QUFDQTs7QUFDQSxVQUFJamhCLElBQUksR0FBR29MLGFBQWEsQ0FBQzRWLGFBQUQsQ0FBeEI7QUFDQSxVQUFJeGMsSUFBSjs7QUFDQSxhQUFPLENBQUMsQ0FBQ0EsSUFBSSxHQUFHeEUsSUFBSSxDQUFDcUIsSUFBTCxFQUFSLEVBQXFCVSxJQUE3QixFQUFtQztBQUNqQyxZQUFJekssR0FBRyxHQUFHa04sSUFBSSxDQUFDdFUsS0FBZjtBQUNBK3dCLGNBQU0sR0FBR0EsTUFBTSxJQUFJQSxNQUFNLENBQUNsZCxHQUFqQixHQUF1QmtkLE1BQU0sQ0FBQ2xkLEdBQVAsQ0FBV3pNLEdBQVgsRUFBZ0I0SCxPQUFoQixDQUF2QixHQUFrREEsT0FBM0Q7O0FBQ0EsWUFBSStoQixNQUFNLEtBQUsvaEIsT0FBZixFQUF3QjtBQUN0QixpQkFBTzhFLFdBQVA7QUFDRDtBQUNGOztBQUNELGFBQU9pZCxNQUFQO0FBQ0QsS0E1U2E7QUE4U2RDLFdBQU8sRUFBRSxVQUFTakosT0FBVCxFQUFrQmhCLE9BQWxCLEVBQTJCO0FBQ2xDLGFBQU9rQixjQUFjLENBQUMsSUFBRCxFQUFPRixPQUFQLEVBQWdCaEIsT0FBaEIsQ0FBckI7QUFDRCxLQWhUYTtBQWtUZGhULE9BQUcsRUFBRSxVQUFTNmMsU0FBVCxFQUFvQjtBQUN2QixhQUFPLEtBQUsvYyxHQUFMLENBQVMrYyxTQUFULEVBQW9CNWhCLE9BQXBCLE1BQWlDQSxPQUF4QztBQUNELEtBcFRhO0FBc1RkaWlCLFNBQUssRUFBRSxVQUFTSCxhQUFULEVBQXdCO0FBQzdCLGFBQU8sS0FBS0QsS0FBTCxDQUFXQyxhQUFYLEVBQTBCOWhCLE9BQTFCLE1BQXVDQSxPQUE5QztBQUNELEtBeFRhO0FBMFRka2lCLFlBQVEsRUFBRSxVQUFTcGhCLElBQVQsRUFBZTtBQUN2QkEsVUFBSSxHQUFHLE9BQU9BLElBQUksQ0FBQ2dILFFBQVosS0FBeUIsVUFBekIsR0FBc0NoSCxJQUF0QyxHQUE2QzFDLFFBQVEsQ0FBQzBDLElBQUQsQ0FBNUQ7QUFDQSxhQUFPLEtBQUt1RyxLQUFMLENBQVcsVUFBU3JXLEtBQVQsRUFBaUI7QUFBQyxlQUFPOFAsSUFBSSxDQUFDZ0gsUUFBTCxDQUFjOVcsS0FBZCxDQUFQO0FBQTRCLE9BQXpELENBQVA7QUFDRCxLQTdUYTtBQStUZG14QixjQUFVLEVBQUUsVUFBU3JoQixJQUFULEVBQWU7QUFDekJBLFVBQUksR0FBRyxPQUFPQSxJQUFJLENBQUNvaEIsUUFBWixLQUF5QixVQUF6QixHQUFzQ3BoQixJQUF0QyxHQUE2QzFDLFFBQVEsQ0FBQzBDLElBQUQsQ0FBNUQ7QUFDQSxhQUFPQSxJQUFJLENBQUNvaEIsUUFBTCxDQUFjLElBQWQsQ0FBUDtBQUNELEtBbFVhO0FBb1VkRSxTQUFLLEVBQUUsVUFBU3JhLFdBQVQsRUFBc0I7QUFDM0IsYUFBTyxLQUFLd1osT0FBTCxDQUFhLFVBQVN2d0IsS0FBVCxFQUFpQjtBQUFDLGVBQU80VixFQUFFLENBQUM1VixLQUFELEVBQVErVyxXQUFSLENBQVQ7QUFBOEIsT0FBN0QsQ0FBUDtBQUNELEtBdFVhO0FBd1Vkd1YsVUFBTSxFQUFFLFlBQVc7QUFDakIsYUFBTyxLQUFLaGEsS0FBTCxHQUFhalQsR0FBYixDQUFpQit4QixTQUFqQixFQUE0QjlkLFlBQTVCLEVBQVA7QUFDRCxLQTFVYTtBQTRVZHZXLFFBQUksRUFBRSxZQUFXO0FBQ2YsYUFBTyxLQUFLdVYsS0FBTCxHQUFhUSxPQUFiLEdBQXVCNGQsS0FBdkIsRUFBUDtBQUNELEtBOVVhO0FBZ1ZkVyxhQUFTLEVBQUUsVUFBU3ZhLFdBQVQsRUFBc0I7QUFDL0IsYUFBTyxLQUFLNUQsVUFBTCxHQUFrQkosT0FBbEIsR0FBNEJxZSxLQUE1QixDQUFrQ3JhLFdBQWxDLENBQVA7QUFDRCxLQWxWYTtBQW9WZHJILE9BQUcsRUFBRSxVQUFTeU0sVUFBVCxFQUFxQjtBQUN4QixhQUFPbU8sVUFBVSxDQUFDLElBQUQsRUFBT25PLFVBQVAsQ0FBakI7QUFDRCxLQXRWYTtBQXdWZG9WLFNBQUssRUFBRSxVQUFTalYsTUFBVCxFQUFpQkgsVUFBakIsRUFBNkI7QUFDbEMsYUFBT21PLFVBQVUsQ0FBQyxJQUFELEVBQU9uTyxVQUFQLEVBQW1CRyxNQUFuQixDQUFqQjtBQUNELEtBMVZhO0FBNFZkM0wsT0FBRyxFQUFFLFVBQVN3TCxVQUFULEVBQXFCO0FBQ3hCLGFBQU9tTyxVQUFVLENBQUMsSUFBRCxFQUFPbk8sVUFBVSxHQUFHcVYsR0FBRyxDQUFDclYsVUFBRCxDQUFOLEdBQXFCc1Ysb0JBQXRDLENBQWpCO0FBQ0QsS0E5VmE7QUFnV2RDLFNBQUssRUFBRSxVQUFTcFYsTUFBVCxFQUFpQkgsVUFBakIsRUFBNkI7QUFDbEMsYUFBT21PLFVBQVUsQ0FBQyxJQUFELEVBQU9uTyxVQUFVLEdBQUdxVixHQUFHLENBQUNyVixVQUFELENBQU4sR0FBcUJzVixvQkFBdEMsRUFBNERuVixNQUE1RCxDQUFqQjtBQUNELEtBbFdhO0FBb1dkcVYsUUFBSSxFQUFFLFlBQVc7QUFDZixhQUFPLEtBQUtudkIsS0FBTCxDQUFXLENBQVgsQ0FBUDtBQUNELEtBdFdhO0FBd1dkb3ZCLFFBQUksRUFBRSxVQUFTQyxNQUFULEVBQWlCO0FBQ3JCLGFBQU8sS0FBS3J2QixLQUFMLENBQVczRixJQUFJLENBQUM2UyxHQUFMLENBQVMsQ0FBVCxFQUFZbWlCLE1BQVosQ0FBWCxDQUFQO0FBQ0QsS0ExV2E7QUE0V2RDLFlBQVEsRUFBRSxVQUFTRCxNQUFULEVBQWlCO0FBQ3pCLGFBQU94SixLQUFLLENBQUMsSUFBRCxFQUFPLEtBQUs5VixLQUFMLEdBQWFRLE9BQWIsR0FBdUI2ZSxJQUF2QixDQUE0QkMsTUFBNUIsRUFBb0M5ZSxPQUFwQyxFQUFQLENBQVo7QUFDRCxLQTlXYTtBQWdYZGdmLGFBQVMsRUFBRSxVQUFTNXFCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QjtBQUN0QyxhQUFPc0IsS0FBSyxDQUFDLElBQUQsRUFBT2EsZ0JBQWdCLENBQUMsSUFBRCxFQUFPL2hCLFNBQVAsRUFBa0I0ZixPQUFsQixFQUEyQixJQUEzQixDQUF2QixDQUFaO0FBQ0QsS0FsWGE7QUFvWGRpTCxhQUFTLEVBQUUsVUFBUzdxQixTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDdEMsYUFBTyxLQUFLZ0wsU0FBTCxDQUFlM3ZCLEdBQUcsQ0FBQytFLFNBQUQsQ0FBbEIsRUFBK0I0ZixPQUEvQixDQUFQO0FBQ0QsS0F0WGE7QUF3WGRucUIsVUFBTSxFQUFFLFVBQVMwZixNQUFULEVBQWlCSCxVQUFqQixFQUE2QjtBQUNuQyxhQUFPa00sS0FBSyxDQUFDLElBQUQsRUFBT2hNLFdBQVcsQ0FBQyxJQUFELEVBQU9GLFVBQVAsRUFBbUJHLE1BQW5CLENBQWxCLENBQVo7QUFDRCxLQTFYYTtBQTRYZDJWLFFBQUksRUFBRSxVQUFTSixNQUFULEVBQWlCO0FBQ3JCLGFBQU8sS0FBS3J2QixLQUFMLENBQVcsQ0FBWCxFQUFjM0YsSUFBSSxDQUFDNlMsR0FBTCxDQUFTLENBQVQsRUFBWW1pQixNQUFaLENBQWQsQ0FBUDtBQUNELEtBOVhhO0FBZ1lkSyxZQUFRLEVBQUUsVUFBU0wsTUFBVCxFQUFpQjtBQUN6QixhQUFPeEosS0FBSyxDQUFDLElBQUQsRUFBTyxLQUFLOVYsS0FBTCxHQUFhUSxPQUFiLEdBQXVCa2YsSUFBdkIsQ0FBNEJKLE1BQTVCLEVBQW9DOWUsT0FBcEMsRUFBUCxDQUFaO0FBQ0QsS0FsWWE7QUFvWWRvZixhQUFTLEVBQUUsVUFBU2hyQixTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDdEMsYUFBT3NCLEtBQUssQ0FBQyxJQUFELEVBQU9VLGdCQUFnQixDQUFDLElBQUQsRUFBTzVoQixTQUFQLEVBQWtCNGYsT0FBbEIsQ0FBdkIsQ0FBWjtBQUNELEtBdFlhO0FBd1lkcUwsYUFBUyxFQUFFLFVBQVNqckIsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCO0FBQ3RDLGFBQU8sS0FBS29MLFNBQUwsQ0FBZS92QixHQUFHLENBQUMrRSxTQUFELENBQWxCLEVBQStCNGYsT0FBL0IsQ0FBUDtBQUNELEtBMVlhO0FBNFlkSCxZQUFRLEVBQUUsWUFBVztBQUNuQixhQUFPLEtBQUtyVCxZQUFMLEVBQVA7QUFDRCxLQTlZYTtBQWlaZDtBQUVBdUYsWUFBUSxFQUFFLFlBQVc7QUFDbkIsYUFBTyxLQUFLNUMsTUFBTCxLQUFnQixLQUFLQSxNQUFMLEdBQWNtYyxZQUFZLENBQUMsSUFBRCxDQUExQyxDQUFQO0FBQ0QsS0FyWmEsQ0F3WmQ7QUFFQTtBQUVBOztBQTVaYyxHQUFYLENBQUwsQ0Evb0lrQixDQThpSmxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLGlCQUFpQixHQUFHbGxCLFFBQVEsQ0FBQ3ZJLFNBQWpDO0FBQ0F5dEIsbUJBQWlCLENBQUNya0Isb0JBQUQsQ0FBakIsR0FBMEMsSUFBMUM7QUFDQXFrQixtQkFBaUIsQ0FBQ3JoQixlQUFELENBQWpCLEdBQXFDcWhCLGlCQUFpQixDQUFDNVAsTUFBdkQ7QUFDQTRQLG1CQUFpQixDQUFDMUQsTUFBbEIsR0FBMkIwRCxpQkFBaUIsQ0FBQ2p6QixPQUE3QztBQUNBaXpCLG1CQUFpQixDQUFDcEQsZ0JBQWxCLEdBQXFDcUQsV0FBckM7O0FBQ0FELG1CQUFpQixDQUFDL2dCLE9BQWxCLEdBQ0ErZ0IsaUJBQWlCLENBQUM5Z0IsUUFBbEIsR0FBNkIsWUFBVztBQUFFLFdBQU8sS0FBS3ZMLFFBQUwsRUFBUDtBQUF5QixHQURuRTs7QUFFQXFzQixtQkFBaUIsQ0FBQzN5QixLQUFsQixHQUEwQjJ5QixpQkFBaUIsQ0FBQ3p5QixPQUE1QztBQUNBeXlCLG1CQUFpQixDQUFDbnhCLFFBQWxCLEdBQTZCbXhCLGlCQUFpQixDQUFDeGIsUUFBL0M7QUFFQWhTLE9BQUssQ0FBQ3lJLGFBQUQsRUFBZ0I7QUFFbkI7QUFFQWdaLFFBQUksRUFBRSxZQUFXO0FBQ2YsYUFBTzhCLEtBQUssQ0FBQyxJQUFELEVBQU9aLFdBQVcsQ0FBQyxJQUFELENBQWxCLENBQVo7QUFDRCxLQU5rQjtBQVFuQitLLGNBQVUsRUFBRSxVQUFTbFcsTUFBVCxFQUFpQnlLLE9BQWpCLEVBQTBCO0FBQUMsVUFBSTlQLE1BQU0sR0FBRyxJQUFiO0FBQ3JDLFVBQUluWixVQUFVLEdBQUcsQ0FBakI7QUFDQSxhQUFPdXFCLEtBQUssQ0FBQyxJQUFELEVBQ1YsS0FBSzlWLEtBQUwsR0FBYWpULEdBQWIsQ0FDRSxVQUFTcVMsQ0FBVCxFQUFZRCxDQUFaLEVBQWdCO0FBQUMsZUFBTzRLLE1BQU0sQ0FBQ3BXLElBQVAsQ0FBWTZnQixPQUFaLEVBQXFCLENBQUNyVixDQUFELEVBQUlDLENBQUosQ0FBckIsRUFBNkI3VCxVQUFVLEVBQXZDLEVBQTJDbVosTUFBM0MsQ0FBUDtBQUEwRCxPQUQ3RSxFQUVFN0QsWUFGRixFQURVLENBQVo7QUFLRCxLQWZrQjtBQWlCbkJxZixXQUFPLEVBQUUsVUFBU25XLE1BQVQsRUFBaUJ5SyxPQUFqQixFQUEwQjtBQUFDLFVBQUk5UCxNQUFNLEdBQUcsSUFBYjtBQUNsQyxhQUFPb1IsS0FBSyxDQUFDLElBQUQsRUFDVixLQUFLOVYsS0FBTCxHQUFhZ1UsSUFBYixHQUFvQmpuQixHQUFwQixDQUNFLFVBQVNvUyxDQUFULEVBQVlDLENBQVosRUFBZ0I7QUFBQyxlQUFPMkssTUFBTSxDQUFDcFcsSUFBUCxDQUFZNmdCLE9BQVosRUFBcUJyVixDQUFyQixFQUF3QkMsQ0FBeEIsRUFBMkJzRixNQUEzQixDQUFQO0FBQTBDLE9BRDdELEVBRUVzUCxJQUZGLEVBRFUsQ0FBWjtBQUtEO0FBdkJrQixHQUFoQixDQUFMO0FBMkJBLE1BQUltTSxzQkFBc0IsR0FBR25sQixhQUFhLENBQUMxSSxTQUEzQztBQUNBNnRCLHdCQUFzQixDQUFDdmtCLGlCQUFELENBQXRCLEdBQTRDLElBQTVDO0FBQ0F1a0Isd0JBQXNCLENBQUN6aEIsZUFBRCxDQUF0QixHQUEwQ3FoQixpQkFBaUIsQ0FBQ2xjLE9BQTVEO0FBQ0FzYyx3QkFBc0IsQ0FBQzlELE1BQXZCLEdBQWdDMEQsaUJBQWlCLENBQUM1eEIsUUFBbEQ7O0FBQ0FneUIsd0JBQXNCLENBQUN4RCxnQkFBdkIsR0FBMEMsVUFBU3ZkLENBQVQsRUFBWUQsQ0FBWixFQUFnQjtBQUFDLFdBQU9qUSxJQUFJLENBQUNreEIsU0FBTCxDQUFlamhCLENBQWYsSUFBb0IsSUFBcEIsR0FBMkI2Z0IsV0FBVyxDQUFDNWdCLENBQUQsQ0FBN0M7QUFBaUQsR0FBNUc7O0FBSUE3TSxPQUFLLENBQUM0SSxlQUFELEVBQWtCO0FBRXJCO0FBRUF5RixjQUFVLEVBQUUsWUFBVztBQUNyQixhQUFPLElBQUlxVCxlQUFKLENBQW9CLElBQXBCLEVBQTBCLEtBQTFCLENBQVA7QUFDRCxLQU5vQjtBQVNyQjtBQUVBbmIsVUFBTSxFQUFFLFVBQVNsRSxTQUFULEVBQW9CNGYsT0FBcEIsRUFBNkI7QUFDbkMsYUFBT3NCLEtBQUssQ0FBQyxJQUFELEVBQU9ULGFBQWEsQ0FBQyxJQUFELEVBQU96Z0IsU0FBUCxFQUFrQjRmLE9BQWxCLEVBQTJCLEtBQTNCLENBQXBCLENBQVo7QUFDRCxLQWJvQjtBQWVyQjZMLGFBQVMsRUFBRSxVQUFTenJCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QjtBQUN0QyxVQUFJNVIsS0FBSyxHQUFHLEtBQUttYSxTQUFMLENBQWVub0IsU0FBZixFQUEwQjRmLE9BQTFCLENBQVo7QUFDQSxhQUFPNVIsS0FBSyxHQUFHQSxLQUFLLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBQyxDQUEzQjtBQUNELEtBbEJvQjtBQW9CckJ6TyxXQUFPLEVBQUUsVUFBU3FRLFdBQVQsRUFBc0I7QUFDN0IsVUFBSTNQLEdBQUcsR0FBRyxLQUFLZ3FCLEtBQUwsQ0FBV3JhLFdBQVgsQ0FBVjtBQUNBLGFBQU8zUCxHQUFHLEtBQUt2SSxTQUFSLEdBQW9CLENBQUMsQ0FBckIsR0FBeUJ1SSxHQUFoQztBQUNELEtBdkJvQjtBQXlCckI0UCxlQUFXLEVBQUUsVUFBU0QsV0FBVCxFQUFzQjtBQUNqQyxVQUFJM1AsR0FBRyxHQUFHLEtBQUtrcUIsU0FBTCxDQUFldmEsV0FBZixDQUFWO0FBQ0EsYUFBTzNQLEdBQUcsS0FBS3ZJLFNBQVIsR0FBb0IsQ0FBQyxDQUFyQixHQUF5QnVJLEdBQWhDO0FBQ0QsS0E1Qm9CO0FBOEJyQjJMLFdBQU8sRUFBRSxZQUFXO0FBQ2xCLGFBQU9zVixLQUFLLENBQUMsSUFBRCxFQUFPdkIsY0FBYyxDQUFDLElBQUQsRUFBTyxLQUFQLENBQXJCLENBQVo7QUFDRCxLQWhDb0I7QUFrQ3JCdGtCLFNBQUssRUFBRSxVQUFTNk4sS0FBVCxFQUFnQkMsR0FBaEIsRUFBcUI7QUFDMUIsYUFBTytYLEtBQUssQ0FBQyxJQUFELEVBQU9DLFlBQVksQ0FBQyxJQUFELEVBQU9qWSxLQUFQLEVBQWNDLEdBQWQsRUFBbUIsS0FBbkIsQ0FBbkIsQ0FBWjtBQUNELEtBcENvQjtBQXNDckIrUixVQUFNLEVBQUUsVUFBU3JiLEtBQVQsRUFBZ0I2ckI7QUFBVTtBQUExQixNQUEyQztBQUNqRCxVQUFJQyxPQUFPLEdBQUdqckIsU0FBUyxDQUFDL0ksTUFBeEI7QUFDQSt6QixlQUFTLEdBQUdoMkIsSUFBSSxDQUFDNlMsR0FBTCxDQUFTbWpCLFNBQVMsR0FBRyxDQUFyQixFQUF3QixDQUF4QixDQUFaOztBQUNBLFVBQUlDLE9BQU8sS0FBSyxDQUFaLElBQWtCQSxPQUFPLEtBQUssQ0FBWixJQUFpQixDQUFDRCxTQUF4QyxFQUFvRDtBQUNsRCxlQUFPLElBQVA7QUFDRCxPQUxnRCxDQU1qRDtBQUNBO0FBQ0E7OztBQUNBN3JCLFdBQUssR0FBR3VKLFlBQVksQ0FBQ3ZKLEtBQUQsRUFBUUEsS0FBSyxHQUFHLENBQVIsR0FBWSxLQUFLK1gsS0FBTCxFQUFaLEdBQTJCLEtBQUs3akIsSUFBeEMsQ0FBcEI7QUFDQSxVQUFJNjNCLE9BQU8sR0FBRyxLQUFLdndCLEtBQUwsQ0FBVyxDQUFYLEVBQWN3RSxLQUFkLENBQWQ7QUFDQSxhQUFPcWhCLEtBQUssQ0FDVixJQURVLEVBRVZ5SyxPQUFPLEtBQUssQ0FBWixHQUNFQyxPQURGLEdBRUVBLE9BQU8sQ0FBQ25xQixNQUFSLENBQWUyRyxPQUFPLENBQUMxSCxTQUFELEVBQVksQ0FBWixDQUF0QixFQUFzQyxLQUFLckYsS0FBTCxDQUFXd0UsS0FBSyxHQUFHNnJCLFNBQW5CLENBQXRDLENBSlEsQ0FBWjtBQU1ELEtBdkRvQjtBQTBEckI7QUFFQUcsaUJBQWEsRUFBRSxVQUFTN3JCLFNBQVQsRUFBb0I0ZixPQUFwQixFQUE2QjtBQUMxQyxVQUFJNVIsS0FBSyxHQUFHLEtBQUtzYixhQUFMLENBQW1CdHBCLFNBQW5CLEVBQThCNGYsT0FBOUIsQ0FBWjtBQUNBLGFBQU81UixLQUFLLEdBQUdBLEtBQUssQ0FBQyxDQUFELENBQVIsR0FBYyxDQUFDLENBQTNCO0FBQ0QsS0EvRG9CO0FBaUVyQndiLFNBQUssRUFBRSxZQUFXO0FBQ2hCLGFBQU8sS0FBSzljLEdBQUwsQ0FBUyxDQUFULENBQVA7QUFDRCxLQW5Fb0I7QUFxRXJCNFYsV0FBTyxFQUFFLFVBQVNHLEtBQVQsRUFBZ0I7QUFDdkIsYUFBT3ZCLEtBQUssQ0FBQyxJQUFELEVBQU9zQixjQUFjLENBQUMsSUFBRCxFQUFPQyxLQUFQLEVBQWMsS0FBZCxDQUFyQixDQUFaO0FBQ0QsS0F2RW9CO0FBeUVyQi9WLE9BQUcsRUFBRSxVQUFTN00sS0FBVCxFQUFnQjhNLFdBQWhCLEVBQTZCO0FBQ2hDOU0sV0FBSyxHQUFHaUosU0FBUyxDQUFDLElBQUQsRUFBT2pKLEtBQVAsQ0FBakI7QUFDQSxhQUFRQSxLQUFLLEdBQUcsQ0FBUixJQUFjLEtBQUs5TCxJQUFMLEtBQWMwYixRQUFkLElBQ2pCLEtBQUsxYixJQUFMLEtBQWMyRCxTQUFkLElBQTJCbUksS0FBSyxHQUFHLEtBQUs5TCxJQUR0QyxHQUVMNFksV0FGSyxHQUdMLEtBQUt1YixJQUFMLENBQVUsVUFBUzV5QixDQUFULEVBQVkySyxHQUFaLEVBQWtCO0FBQUMsZUFBT0EsR0FBRyxLQUFLSixLQUFmO0FBQXFCLE9BQWxELEVBQW9EbkksU0FBcEQsRUFBK0RpVixXQUEvRCxDQUhGO0FBSUQsS0EvRW9CO0FBaUZyQkMsT0FBRyxFQUFFLFVBQVMvTSxLQUFULEVBQWdCO0FBQ25CQSxXQUFLLEdBQUdpSixTQUFTLENBQUMsSUFBRCxFQUFPakosS0FBUCxDQUFqQjtBQUNBLGFBQU9BLEtBQUssSUFBSSxDQUFULEtBQWUsS0FBSzlMLElBQUwsS0FBYzJELFNBQWQsR0FDcEIsS0FBSzNELElBQUwsS0FBYzBiLFFBQWQsSUFBMEI1UCxLQUFLLEdBQUcsS0FBSzlMLElBRG5CLEdBRXBCLEtBQUt3TCxPQUFMLENBQWFNLEtBQWIsTUFBd0IsQ0FBQyxDQUZwQixDQUFQO0FBSUQsS0F2Rm9CO0FBeUZyQmlzQixhQUFTLEVBQUUsVUFBUzlJLFNBQVQsRUFBb0I7QUFDN0IsYUFBTzlCLEtBQUssQ0FBQyxJQUFELEVBQU82QixnQkFBZ0IsQ0FBQyxJQUFELEVBQU9DLFNBQVAsQ0FBdkIsQ0FBWjtBQUNELEtBM0ZvQjtBQTZGckIrSSxjQUFVLEVBQUUsWUFBMkI7QUFDckMsVUFBSXZTLFNBQVMsR0FBRyxDQUFDLElBQUQsRUFBTy9YLE1BQVAsQ0FBYzJHLE9BQU8sQ0FBQzFILFNBQUQsQ0FBckIsQ0FBaEI7QUFDQSxVQUFJc3JCLE1BQU0sR0FBRzFJLGNBQWMsQ0FBQyxLQUFLbFksS0FBTCxFQUFELEVBQWUzRSxVQUFVLENBQUNyRSxFQUExQixFQUE4Qm9YLFNBQTlCLENBQTNCO0FBQ0EsVUFBSXlTLFdBQVcsR0FBR0QsTUFBTSxDQUFDMUosT0FBUCxDQUFlLElBQWYsQ0FBbEI7O0FBQ0EsVUFBSTBKLE1BQU0sQ0FBQ2o0QixJQUFYLEVBQWlCO0FBQ2ZrNEIsbUJBQVcsQ0FBQ2w0QixJQUFaLEdBQW1CaTRCLE1BQU0sQ0FBQ2o0QixJQUFQLEdBQWN5bEIsU0FBUyxDQUFDN2hCLE1BQTNDO0FBQ0Q7O0FBQ0QsYUFBT3VwQixLQUFLLENBQUMsSUFBRCxFQUFPK0ssV0FBUCxDQUFaO0FBQ0QsS0FyR29CO0FBdUdyQjdHLFVBQU0sRUFBRSxZQUFXO0FBQ2pCLGFBQU9sVixLQUFLLENBQUMsQ0FBRCxFQUFJLEtBQUtuYyxJQUFULENBQVo7QUFDRCxLQXpHb0I7QUEyR3JCOEIsUUFBSSxFQUFFLFlBQVc7QUFDZixhQUFPLEtBQUs2VyxHQUFMLENBQVMsQ0FBQyxDQUFWLENBQVA7QUFDRCxLQTdHb0I7QUErR3JCa2UsYUFBUyxFQUFFLFVBQVM1cUIsU0FBVCxFQUFvQjRmLE9BQXBCLEVBQTZCO0FBQ3RDLGFBQU9zQixLQUFLLENBQUMsSUFBRCxFQUFPYSxnQkFBZ0IsQ0FBQyxJQUFELEVBQU8vaEIsU0FBUCxFQUFrQjRmLE9BQWxCLEVBQTJCLEtBQTNCLENBQXZCLENBQVo7QUFDRCxLQWpIb0I7QUFtSHJCc00sT0FBRyxFQUFFLFlBQThCO0FBQ2pDLFVBQUkxUyxTQUFTLEdBQUcsQ0FBQyxJQUFELEVBQU8vWCxNQUFQLENBQWMyRyxPQUFPLENBQUMxSCxTQUFELENBQXJCLENBQWhCO0FBQ0EsYUFBT3dnQixLQUFLLENBQUMsSUFBRCxFQUFPb0MsY0FBYyxDQUFDLElBQUQsRUFBTzZJLGFBQVAsRUFBc0IzUyxTQUF0QixDQUFyQixDQUFaO0FBQ0QsS0F0SG9CO0FBd0hyQjRTLFdBQU8sRUFBRSxVQUFTNUk7QUFBTTtBQUFmLE1BQW9DO0FBQzNDLFVBQUloSyxTQUFTLEdBQUdwUixPQUFPLENBQUMxSCxTQUFELENBQXZCO0FBQ0E4WSxlQUFTLENBQUMsQ0FBRCxDQUFULEdBQWUsSUFBZjtBQUNBLGFBQU8wSCxLQUFLLENBQUMsSUFBRCxFQUFPb0MsY0FBYyxDQUFDLElBQUQsRUFBT0UsTUFBUCxFQUFlaEssU0FBZixDQUFyQixDQUFaO0FBQ0Q7QUE1SG9CLEdBQWxCLENBQUw7QUFnSUFqVCxpQkFBZSxDQUFDN0ksU0FBaEIsQ0FBMEJ3SixtQkFBMUIsSUFBaUQsSUFBakQ7QUFDQVgsaUJBQWUsQ0FBQzdJLFNBQWhCLENBQTBCNEosbUJBQTFCLElBQWlELElBQWpEO0FBSUEzSixPQUFLLENBQUMrSSxXQUFELEVBQWM7QUFFakI7QUFFQWdHLE9BQUcsRUFBRSxVQUFTN1QsS0FBVCxFQUFnQjhULFdBQWhCLEVBQTZCO0FBQ2hDLGFBQU8sS0FBS0MsR0FBTCxDQUFTL1QsS0FBVCxJQUFrQkEsS0FBbEIsR0FBMEI4VCxXQUFqQztBQUNELEtBTmdCO0FBUWpCZ0QsWUFBUSxFQUFFLFVBQVM5VyxLQUFULEVBQWdCO0FBQ3hCLGFBQU8sS0FBSytULEdBQUwsQ0FBUy9ULEtBQVQsQ0FBUDtBQUNELEtBVmdCO0FBYWpCO0FBRUF1c0IsVUFBTSxFQUFFLFlBQVc7QUFDakIsYUFBTyxLQUFLM0YsUUFBTCxFQUFQO0FBQ0Q7QUFqQmdCLEdBQWQsQ0FBTDtBQXFCQS9ZLGFBQVcsQ0FBQ2hKLFNBQVosQ0FBc0JrUCxHQUF0QixHQUE0QnVlLGlCQUFpQixDQUFDeGIsUUFBOUM7QUFDQWpKLGFBQVcsQ0FBQ2hKLFNBQVosQ0FBc0IxRCxRQUF0QixHQUFpQzBNLFdBQVcsQ0FBQ2hKLFNBQVosQ0FBc0JpUyxRQUF2RCxDQTN2SmtCLENBOHZKbEI7O0FBRUFoUyxPQUFLLENBQUMySSxRQUFELEVBQVdGLGFBQWEsQ0FBQzFJLFNBQXpCLENBQUw7QUFDQUMsT0FBSyxDQUFDOEksVUFBRCxFQUFhRixlQUFlLENBQUM3SSxTQUE3QixDQUFMO0FBQ0FDLE9BQUssQ0FBQ2lKLE1BQUQsRUFBU0YsV0FBVyxDQUFDaEosU0FBckIsQ0FBTDtBQUVBQyxPQUFLLENBQUNrVCxlQUFELEVBQWtCekssYUFBYSxDQUFDMUksU0FBaEMsQ0FBTDtBQUNBQyxPQUFLLENBQUNtVCxpQkFBRCxFQUFvQnZLLGVBQWUsQ0FBQzdJLFNBQXBDLENBQUw7QUFDQUMsT0FBSyxDQUFDb1QsYUFBRCxFQUFnQnJLLFdBQVcsQ0FBQ2hKLFNBQTVCLENBQUwsQ0F0d0prQixDQXl3SmxCOztBQUVBLFdBQVN3c0IsU0FBVCxDQUFtQjFmLENBQW5CLEVBQXNCRCxDQUF0QixFQUF5QjtBQUN2QixXQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsV0FBUzBlLFdBQVQsQ0FBcUJ6ZSxDQUFyQixFQUF3QkQsQ0FBeEIsRUFBMkI7QUFDekIsV0FBTyxDQUFDQSxDQUFELEVBQUlDLENBQUosQ0FBUDtBQUNEOztBQUVELFdBQVN2UCxHQUFULENBQWErRSxTQUFiLEVBQXdCO0FBQ3RCLFdBQU8sWUFBVztBQUNoQixhQUFPLENBQUNBLFNBQVMsQ0FBQ3pDLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0JtRCxTQUF0QixDQUFSO0FBQ0QsS0FGRDtBQUdEOztBQUVELFdBQVMycEIsR0FBVCxDQUFhcnFCLFNBQWIsRUFBd0I7QUFDdEIsV0FBTyxZQUFXO0FBQ2hCLGFBQU8sQ0FBQ0EsU0FBUyxDQUFDekMsS0FBVixDQUFnQixJQUFoQixFQUFzQm1ELFNBQXRCLENBQVI7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsV0FBUzBxQixXQUFULENBQXFCdnlCLEtBQXJCLEVBQTRCO0FBQzFCLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixHQUE0QnlCLElBQUksQ0FBQ2t4QixTQUFMLENBQWUzeUIsS0FBZixDQUE1QixHQUFvRHd6QixNQUFNLENBQUN4ekIsS0FBRCxDQUFqRTtBQUNEOztBQUVELFdBQVNzekIsYUFBVCxHQUF5QjtBQUN2QixXQUFPL2pCLE9BQU8sQ0FBQzFILFNBQUQsQ0FBZDtBQUNEOztBQUVELFdBQVM0cEIsb0JBQVQsQ0FBOEI5cUIsQ0FBOUIsRUFBaUNDLENBQWpDLEVBQW9DO0FBQ2xDLFdBQU9ELENBQUMsR0FBR0MsQ0FBSixHQUFRLENBQVIsR0FBWUQsQ0FBQyxHQUFHQyxDQUFKLEdBQVEsQ0FBQyxDQUFULEdBQWEsQ0FBaEM7QUFDRDs7QUFFRCxXQUFTeXJCLFlBQVQsQ0FBc0JudkIsUUFBdEIsRUFBZ0M7QUFDOUIsUUFBSUEsUUFBUSxDQUFDaEksSUFBVCxLQUFrQjBiLFFBQXRCLEVBQWdDO0FBQzlCLGFBQU8sQ0FBUDtBQUNEOztBQUNELFFBQUk2YyxPQUFPLEdBQUdsbEIsU0FBUyxDQUFDckwsUUFBRCxDQUF2QjtBQUNBLFFBQUl3d0IsS0FBSyxHQUFHbG1CLE9BQU8sQ0FBQ3RLLFFBQUQsQ0FBbkI7QUFDQSxRQUFJd1YsQ0FBQyxHQUFHK2EsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUF0Qjs7QUFDQSxRQUFJdjRCLElBQUksR0FBR2dJLFFBQVEsQ0FBQzZNLFNBQVQsQ0FDVDJqQixLQUFLLEdBQ0hELE9BQU8sR0FDTCxVQUFTOWhCLENBQVQsRUFBWUQsQ0FBWixFQUFnQjtBQUFFZ0gsT0FBQyxHQUFHLEtBQUtBLENBQUwsR0FBU2liLFNBQVMsQ0FBQ25iLElBQUksQ0FBQzdHLENBQUQsQ0FBTCxFQUFVNkcsSUFBSSxDQUFDOUcsQ0FBRCxDQUFkLENBQWxCLEdBQXVDLENBQTNDO0FBQStDLEtBRDVELEdBRUwsVUFBU0MsQ0FBVCxFQUFZRCxDQUFaLEVBQWdCO0FBQUVnSCxPQUFDLEdBQUdBLENBQUMsR0FBR2liLFNBQVMsQ0FBQ25iLElBQUksQ0FBQzdHLENBQUQsQ0FBTCxFQUFVNkcsSUFBSSxDQUFDOUcsQ0FBRCxDQUFkLENBQWIsR0FBa0MsQ0FBdEM7QUFBMEMsS0FIM0QsR0FJSCtoQixPQUFPLEdBQ0wsVUFBUzloQixDQUFULEVBQWE7QUFBRStHLE9BQUMsR0FBRyxLQUFLQSxDQUFMLEdBQVNGLElBQUksQ0FBQzdHLENBQUQsQ0FBYixHQUFtQixDQUF2QjtBQUEyQixLQURyQyxHQUVMLFVBQVNBLENBQVQsRUFBYTtBQUFFK0csT0FBQyxHQUFHQSxDQUFDLEdBQUdGLElBQUksQ0FBQzdHLENBQUQsQ0FBUixHQUFjLENBQWxCO0FBQXNCLEtBUGhDLENBQVg7O0FBU0EsV0FBT2lpQixnQkFBZ0IsQ0FBQzE0QixJQUFELEVBQU93ZCxDQUFQLENBQXZCO0FBQ0Q7O0FBRUQsV0FBU2tiLGdCQUFULENBQTBCMTRCLElBQTFCLEVBQWdDd2QsQ0FBaEMsRUFBbUM7QUFDakNBLEtBQUMsR0FBR1AsSUFBSSxDQUFDTyxDQUFELEVBQUksVUFBSixDQUFSO0FBQ0FBLEtBQUMsR0FBR1AsSUFBSSxDQUFDTyxDQUFDLElBQUksRUFBTCxHQUFVQSxDQUFDLEtBQUssQ0FBQyxFQUFsQixFQUFzQixVQUF0QixDQUFSO0FBQ0FBLEtBQUMsR0FBR1AsSUFBSSxDQUFDTyxDQUFDLElBQUksRUFBTCxHQUFVQSxDQUFDLEtBQUssQ0FBQyxFQUFsQixFQUFzQixDQUF0QixDQUFSO0FBQ0FBLEtBQUMsR0FBRyxDQUFDQSxDQUFDLEdBQUcsVUFBSixHQUFpQixDQUFsQixJQUF1QnhkLElBQTNCO0FBQ0F3ZCxLQUFDLEdBQUdQLElBQUksQ0FBQ08sQ0FBQyxHQUFHQSxDQUFDLEtBQUssRUFBWCxFQUFlLFVBQWYsQ0FBUjtBQUNBQSxLQUFDLEdBQUdQLElBQUksQ0FBQ08sQ0FBQyxHQUFHQSxDQUFDLEtBQUssRUFBWCxFQUFlLFVBQWYsQ0FBUjtBQUNBQSxLQUFDLEdBQUdKLEdBQUcsQ0FBQ0ksQ0FBQyxHQUFHQSxDQUFDLEtBQUssRUFBWCxDQUFQO0FBQ0EsV0FBT0EsQ0FBUDtBQUNEOztBQUVELFdBQVNpYixTQUFULENBQW1CaHRCLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QixXQUFPRCxDQUFDLEdBQUdDLENBQUMsR0FBRyxVQUFKLElBQWtCRCxDQUFDLElBQUksQ0FBdkIsS0FBNkJBLENBQUMsSUFBSSxDQUFsQyxDQUFKLEdBQTJDLENBQWxELENBRHVCLENBQzhCO0FBQ3REOztBQUVELE1BQUlrdEIsU0FBUyxHQUFHO0FBRWR6bUIsWUFBUSxFQUFFQSxRQUZJO0FBSWRFLE9BQUcsRUFBRUEsR0FKUztBQUtkeUssY0FBVSxFQUFFQSxVQUxFO0FBTWRvQyxPQUFHLEVBQUVBLEdBTlM7QUFPZGlDLGNBQVUsRUFBRUEsVUFQRTtBQVFkc0YsUUFBSSxFQUFFQSxJQVJRO0FBU2RpTSxTQUFLLEVBQUVBLEtBVE87QUFVZDd4QixPQUFHLEVBQUVBLEdBVlM7QUFXZCt3QixjQUFVLEVBQUVBLFVBWEU7QUFhZDNCLFVBQU0sRUFBRUEsTUFiTTtBQWNkN1QsU0FBSyxFQUFFQSxLQWRPO0FBZWRaLFVBQU0sRUFBRUEsTUFmTTtBQWlCZGIsTUFBRSxFQUFFQSxFQWpCVTtBQWtCZGpVLFVBQU0sRUFBRUE7QUFsQk0sR0FBaEI7QUFzQkEsU0FBT2t5QixTQUFQO0FBRUQsQ0F6MkpBLENBQUQsQzs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0EsQ0FBRSxXQUFXLENBRVgsd0VBQ0EsR0FBSWgxQixVQUFKLENBRUEsMkNBQ0EsR0FBSWkxQixRQUFPLENBQUcsU0FBZCxDQUVBLDREQUNBLEdBQUlDLGlCQUFnQixDQUFHLEdBQXZCLENBRUEsK0JBQ0EsR0FBSUMsZ0JBQWUsQ0FBRyxpRUFBdEIsQ0FDSUMsZUFBZSxDQUFHLHFCQUR0QixDQUVJQyw0QkFBNEIsQ0FBRyxvREFGbkMsQ0FJQSxvREFDQSxHQUFJQyxlQUFjLENBQUcsMkJBQXJCLENBRUEsOENBQ0EsR0FBSUMsaUJBQWdCLENBQUcsR0FBdkIsQ0FFQSxpREFDQSxHQUFJQyxZQUFXLENBQUcsd0JBQWxCLENBRUEsNENBQ0EsR0FBSUMsZ0JBQWUsQ0FBRyxDQUF0QixDQUNJQyxlQUFlLENBQUcsQ0FEdEIsQ0FFSUMsa0JBQWtCLENBQUcsQ0FGekIsQ0FJQSxzREFDQSxHQUFJQyxxQkFBb0IsQ0FBRyxDQUEzQixDQUNJQyxzQkFBc0IsQ0FBRyxDQUQ3QixDQUdBLHNEQUNBLEdBQUlDLGVBQWMsQ0FBRyxDQUFyQixDQUNJQyxrQkFBa0IsQ0FBRyxDQUR6QixDQUVJQyxxQkFBcUIsQ0FBRyxDQUY1QixDQUdJQyxlQUFlLENBQUcsQ0FIdEIsQ0FJSUMscUJBQXFCLENBQUcsRUFKNUIsQ0FLSUMsaUJBQWlCLENBQUcsRUFMeEIsQ0FNSUMsdUJBQXVCLENBQUcsRUFOOUIsQ0FPSUMsYUFBYSxDQUFHLEdBUHBCLENBUUlDLGVBQWUsQ0FBRyxHQVJ0QixDQVNJQyxjQUFjLENBQUcsR0FUckIsQ0FXQSxnREFDQSxHQUFJQyxxQkFBb0IsQ0FBRyxFQUEzQixDQUNJQyxzQkFBc0IsQ0FBRyxLQUQ3QixDQUdBLHFGQUNBLEdBQUlDLFVBQVMsQ0FBRyxHQUFoQixDQUNJQyxRQUFRLENBQUcsRUFEZixDQUdBLG1EQUNBLEdBQUlDLGlCQUFnQixDQUFHLENBQXZCLENBQ0lDLGFBQWEsQ0FBRyxDQURwQixDQUVJQyxlQUFlLENBQUcsQ0FGdEIsQ0FJQSx5REFDQSxHQUFJQyxTQUFRLENBQUcsRUFBSSxDQUFuQixDQUNJQyxnQkFBZ0IsQ0FBRyxnQkFEdkIsQ0FFSUMsV0FBVyxDQUFHLHVCQUZsQixDQUdJQyxHQUFHLENBQUcsRUFBSSxDQUhkLENBS0EsdUVBQ0EsR0FBSUMsaUJBQWdCLENBQUcsVUFBdkIsQ0FDSUMsZUFBZSxDQUFHRCxnQkFBZ0IsQ0FBRyxDQUR6QyxDQUVJRSxxQkFBcUIsQ0FBR0YsZ0JBQWdCLEdBQUssQ0FGakQsQ0FJQSwyREFDQSxHQUFJRyxVQUFTLENBQUcsQ0FDZCxDQUFDLEtBQUQsQ0FBUWpCLGFBQVIsQ0FEYyxDQUVkLENBQUMsTUFBRCxDQUFTUCxjQUFULENBRmMsQ0FHZCxDQUFDLFNBQUQsQ0FBWUMsa0JBQVosQ0FIYyxDQUlkLENBQUMsT0FBRCxDQUFVRSxlQUFWLENBSmMsQ0FLZCxDQUFDLFlBQUQsQ0FBZUMscUJBQWYsQ0FMYyxDQU1kLENBQUMsTUFBRCxDQUFTSyxjQUFULENBTmMsQ0FPZCxDQUFDLFNBQUQsQ0FBWUosaUJBQVosQ0FQYyxDQVFkLENBQUMsY0FBRCxDQUFpQkMsdUJBQWpCLENBUmMsQ0FTZCxDQUFDLE9BQUQsQ0FBVUUsZUFBVixDQVRjLENBQWhCLENBWUEsMkNBQ0EsR0FBSWlCLFFBQU8sQ0FBRyxvQkFBZCxDQUNJQyxRQUFRLENBQUcsZ0JBRGYsQ0FFSUMsUUFBUSxDQUFHLHdCQUZmLENBR0lDLE9BQU8sQ0FBRyxrQkFIZCxDQUlJQyxPQUFPLENBQUcsZUFKZCxDQUtJQyxTQUFTLENBQUcsdUJBTGhCLENBTUlDLFFBQVEsQ0FBRyxnQkFOZixDQU9JQyxPQUFPLENBQUcsbUJBUGQsQ0FRSUMsTUFBTSxDQUFHLDRCQVJiLENBU0lDLE1BQU0sQ0FBRyxjQVRiLENBVUlDLFNBQVMsQ0FBRyxpQkFWaEIsQ0FXSUMsT0FBTyxDQUFHLGVBWGQsQ0FZSUMsU0FBUyxDQUFHLGlCQVpoQixDQWFJQyxVQUFVLENBQUcsa0JBYmpCLENBY0lDLFFBQVEsQ0FBRyxnQkFkZixDQWVJQyxTQUFTLENBQUcsaUJBZmhCLENBZ0JJQyxNQUFNLENBQUcsY0FoQmIsQ0FpQklDLFNBQVMsQ0FBRyxpQkFqQmhCLENBa0JJQyxTQUFTLENBQUcsaUJBbEJoQixDQW1CSUMsWUFBWSxDQUFHLG9CQW5CbkIsQ0FvQklDLFVBQVUsQ0FBRyxrQkFwQmpCLENBcUJJQyxVQUFVLENBQUcsa0JBckJqQixDQXVCQSxHQUFJQyxlQUFjLENBQUcsc0JBQXJCLENBQ0lDLFdBQVcsQ0FBRyxtQkFEbEIsQ0FFSUMsVUFBVSxDQUFHLHVCQUZqQixDQUdJQyxVQUFVLENBQUcsdUJBSGpCLENBSUlDLE9BQU8sQ0FBRyxvQkFKZCxDQUtJQyxRQUFRLENBQUcscUJBTGYsQ0FNSUMsUUFBUSxDQUFHLHFCQU5mLENBT0lDLFFBQVEsQ0FBRyxxQkFQZixDQVFJQyxlQUFlLENBQUcsNEJBUnRCLENBU0lDLFNBQVMsQ0FBRyxzQkFUaEIsQ0FVSUMsU0FBUyxDQUFHLHNCQVZoQixDQVlBLHVFQUNBLEdBQUlDLHFCQUFvQixDQUFHLGdCQUEzQixDQUNJQyxtQkFBbUIsQ0FBRyxvQkFEMUIsQ0FFSUMscUJBQXFCLENBQUcsK0JBRjVCLENBSUEsdURBQ0EsR0FBSUMsY0FBYSxDQUFHLDJCQUFwQixDQUNJQyxlQUFlLENBQUcsVUFEdEIsQ0FFSUMsZ0JBQWdCLENBQUdDLE1BQU0sQ0FBQ0gsYUFBYSxDQUFDOXdCLE1BQWYsQ0FGN0IsQ0FHSWt4QixrQkFBa0IsQ0FBR0QsTUFBTSxDQUFDRixlQUFlLENBQUMvd0IsTUFBakIsQ0FIL0IsQ0FLQSx5Q0FDQSxHQUFJbXhCLFNBQVEsQ0FBRyxrQkFBZixDQUNJQyxVQUFVLENBQUcsaUJBRGpCLENBRUlDLGFBQWEsQ0FBRyxrQkFGcEIsQ0FJQSwwREFDQSxHQUFJQyxhQUFZLENBQUcsa0RBQW5CLENBQ0lDLGFBQWEsQ0FBRyxPQURwQixDQUVJQyxVQUFVLENBQUcsa0dBRmpCLENBSUE7QUFDRjtBQUNBO0FBQ0EsS0FDRSxHQUFJQyxhQUFZLENBQUcscUJBQW5CLENBQ0lDLGVBQWUsQ0FBR1QsTUFBTSxDQUFDUSxZQUFZLENBQUN6eEIsTUFBZCxDQUQ1QixDQUdBLHdDQUNBLEdBQUkyeEIsWUFBVyxDQUFHLE1BQWxCLENBRUEsbURBQ0EsR0FBSUMsYUFBWSxDQUFHLElBQW5CLENBRUEsMENBQ0EsR0FBSUMsY0FBYSxDQUFHLDJDQUFwQixDQUNJQyxhQUFhLENBQUcsbUNBRHBCLENBRUlDLGNBQWMsQ0FBRyxPQUZyQixDQUlBLCtEQUNBLEdBQUlDLFlBQVcsQ0FBRywyQ0FBbEIsQ0FFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEdBQUlDLDJCQUEwQixDQUFHLGtCQUFqQyxDQUVBLG1EQUNBLEdBQUlDLGFBQVksQ0FBRyxVQUFuQixDQUVBO0FBQ0Y7QUFDQTtBQUNBLEtBQ0UsR0FBSUMsYUFBWSxDQUFHLGlDQUFuQixDQUVBLHFFQUNBLEdBQUlDLFFBQU8sQ0FBRyxNQUFkLENBRUEsMkRBQ0EsR0FBSUMsV0FBVSxDQUFHLG9CQUFqQixDQUVBLDJDQUNBLEdBQUlDLFdBQVUsQ0FBRyxZQUFqQixDQUVBLGlEQUNBLEdBQUlDLGFBQVksQ0FBRyw2QkFBbkIsQ0FFQSwwQ0FDQSxHQUFJQyxVQUFTLENBQUcsYUFBaEIsQ0FFQSw4Q0FDQSxHQUFJQyxTQUFRLENBQUcsa0JBQWYsQ0FFQSw4RUFDQSxHQUFJQyxRQUFPLENBQUcsNkNBQWQsQ0FFQSw2REFDQSxHQUFJQyxVQUFTLENBQUcsTUFBaEIsQ0FFQSxzRUFDQSxHQUFJQyxrQkFBaUIsQ0FBRyx3QkFBeEIsQ0FFQSxpREFDQSxHQUFJQyxjQUFhLENBQUcsaUJBQXBCLENBQ0lDLGlCQUFpQixDQUFHLGlCQUR4QixDQUVJQyxxQkFBcUIsQ0FBRyxpQkFGNUIsQ0FHSUMsbUJBQW1CLENBQUcsaUJBSDFCLENBSUlDLFlBQVksQ0FBR0gsaUJBQWlCLENBQUdDLHFCQUFwQixDQUE0Q0MsbUJBSi9ELENBS0lFLGNBQWMsQ0FBRyxpQkFMckIsQ0FNSUMsWUFBWSxDQUFHLDJCQU5uQixDQU9JQyxhQUFhLENBQUcsc0JBUHBCLENBUUlDLGNBQWMsQ0FBRyw4Q0FSckIsQ0FTSUMsa0JBQWtCLENBQUcsaUJBVHpCLENBVUlDLFlBQVksQ0FBRyw4SkFWbkIsQ0FXSUMsWUFBWSxDQUFHLDJCQVhuQixDQVlJQyxVQUFVLENBQUcsZ0JBWmpCLENBYUlDLFlBQVksQ0FBR04sYUFBYSxDQUFHQyxjQUFoQixDQUFpQ0Msa0JBQWpDLENBQXNEQyxZQWJ6RSxDQWVBLDhDQUNBLEdBQUlJLE9BQU0sQ0FBRyxXQUFiLENBQ0lDLFFBQVEsQ0FBRyxJQUFNZixhQUFOLENBQXNCLEdBRHJDLENBRUlnQixPQUFPLENBQUcsSUFBTUgsWUFBTixDQUFxQixHQUZuQyxDQUdJSSxPQUFPLENBQUcsSUFBTWIsWUFBTixDQUFxQixHQUhuQyxDQUlJYyxRQUFRLENBQUcsTUFKZixDQUtJQyxTQUFTLENBQUcsSUFBTWQsY0FBTixDQUF1QixHQUx2QyxDQU1JZSxPQUFPLENBQUcsSUFBTWQsWUFBTixDQUFxQixHQU5uQyxDQU9JZSxNQUFNLENBQUcsS0FBT3JCLGFBQVAsQ0FBdUJhLFlBQXZCLENBQXNDSyxRQUF0QyxDQUFpRGIsY0FBakQsQ0FBa0VDLFlBQWxFLENBQWlGSyxZQUFqRixDQUFnRyxHQVA3RyxDQVFJVyxNQUFNLENBQUcsMEJBUmIsQ0FTSUMsVUFBVSxDQUFHLE1BQVFOLE9BQVIsQ0FBa0IsR0FBbEIsQ0FBd0JLLE1BQXhCLENBQWlDLEdBVGxELENBVUlFLFdBQVcsQ0FBRyxLQUFPeEIsYUFBUCxDQUF1QixHQVZ6QyxDQVdJeUIsVUFBVSxDQUFHLGlDQVhqQixDQVlJQyxVQUFVLENBQUcsb0NBWmpCLENBYUlDLE9BQU8sQ0FBRyxJQUFNaEIsWUFBTixDQUFxQixHQWJuQyxDQWNJaUIsS0FBSyxDQUFHLFNBZFosQ0FnQkEsdUNBQ0EsR0FBSUMsWUFBVyxDQUFHLE1BQVFULE9BQVIsQ0FBa0IsR0FBbEIsQ0FBd0JDLE1BQXhCLENBQWlDLEdBQW5ELENBQ0lTLFdBQVcsQ0FBRyxNQUFRSCxPQUFSLENBQWtCLEdBQWxCLENBQXdCTixNQUF4QixDQUFpQyxHQURuRCxDQUVJVSxlQUFlLENBQUcsTUFBUWpCLE1BQVIsQ0FBaUIsd0JBRnZDLENBR0lrQixlQUFlLENBQUcsTUFBUWxCLE1BQVIsQ0FBaUIsd0JBSHZDLENBSUltQixRQUFRLENBQUdWLFVBQVUsQ0FBRyxHQUo1QixDQUtJVyxRQUFRLENBQUcsSUFBTXRCLFVBQU4sQ0FBbUIsSUFMbEMsQ0FNSXVCLFNBQVMsQ0FBRyxNQUFRUCxLQUFSLENBQWdCLEtBQWhCLENBQXdCLENBQUNKLFdBQUQsQ0FBY0MsVUFBZCxDQUEwQkMsVUFBMUIsRUFBc0M5TSxJQUF0QyxDQUEyQyxHQUEzQyxDQUF4QixDQUEwRSxHQUExRSxDQUFnRnNOLFFBQWhGLENBQTJGRCxRQUEzRixDQUFzRyxJQU50SCxDQU9JRyxVQUFVLENBQUcsa0RBUGpCLENBUUlDLFVBQVUsQ0FBRyxrREFSakIsQ0FTSUMsS0FBSyxDQUFHSixRQUFRLENBQUdELFFBQVgsQ0FBc0JFLFNBVGxDLENBVUlJLE9BQU8sQ0FBRyxNQUFRLENBQUNwQixTQUFELENBQVlNLFVBQVosQ0FBd0JDLFVBQXhCLEVBQW9DOU0sSUFBcEMsQ0FBeUMsR0FBekMsQ0FBUixDQUF3RCxHQUF4RCxDQUE4RDBOLEtBVjVFLENBV0lFLFFBQVEsQ0FBRyxNQUFRLENBQUNoQixXQUFXLENBQUdQLE9BQWQsQ0FBd0IsR0FBekIsQ0FBOEJBLE9BQTlCLENBQXVDUSxVQUF2QyxDQUFtREMsVUFBbkQsQ0FBK0RYLFFBQS9ELEVBQXlFbk0sSUFBekUsQ0FBOEUsR0FBOUUsQ0FBUixDQUE2RixHQVg1RyxDQWFBLGlDQUNBLEdBQUk2TixPQUFNLENBQUdyRSxNQUFNLENBQUMwQyxNQUFELENBQVMsR0FBVCxDQUFuQixDQUVBO0FBQ0Y7QUFDQTtBQUNBLEtBQ0UsR0FBSTRCLFlBQVcsQ0FBR3RFLE1BQU0sQ0FBQzZDLE9BQUQsQ0FBVSxHQUFWLENBQXhCLENBRUEseUZBQ0EsR0FBSTBCLFVBQVMsQ0FBR3ZFLE1BQU0sQ0FBQ2tELE1BQU0sQ0FBRyxLQUFULENBQWlCQSxNQUFqQixDQUEwQixJQUExQixDQUFpQ2tCLFFBQWpDLENBQTRDRixLQUE3QyxDQUFvRCxHQUFwRCxDQUF0QixDQUVBLCtDQUNBLEdBQUlNLGNBQWEsQ0FBR3hFLE1BQU0sQ0FBQyxDQUN6QnVELE9BQU8sQ0FBRyxHQUFWLENBQWdCUCxPQUFoQixDQUEwQixHQUExQixDQUFnQ1csZUFBaEMsQ0FBa0QsS0FBbEQsQ0FBMEQsQ0FBQ2YsT0FBRCxDQUFVVyxPQUFWLENBQW1CLEdBQW5CLEVBQXdCL00sSUFBeEIsQ0FBNkIsR0FBN0IsQ0FBMUQsQ0FBOEYsR0FEckUsQ0FFekJrTixXQUFXLENBQUcsR0FBZCxDQUFvQkUsZUFBcEIsQ0FBc0MsS0FBdEMsQ0FBOEMsQ0FBQ2hCLE9BQUQsQ0FBVVcsT0FBTyxDQUFHRSxXQUFwQixDQUFpQyxHQUFqQyxFQUFzQ2pOLElBQXRDLENBQTJDLEdBQTNDLENBQTlDLENBQWdHLEdBRnZFLENBR3pCK00sT0FBTyxDQUFHLEdBQVYsQ0FBZ0JFLFdBQWhCLENBQThCLEdBQTlCLENBQW9DRSxlQUhYLENBSXpCSixPQUFPLENBQUcsR0FBVixDQUFnQkssZUFKUyxDQUt6QkssVUFMeUIsQ0FNekJELFVBTnlCLENBT3pCbEIsUUFQeUIsQ0FRekJxQixPQVJ5QixFQVN6QjNOLElBVHlCLENBU3BCLEdBVG9CLENBQUQsQ0FTYixHQVRhLENBQTFCLENBV0Esc0pBQ0EsR0FBSWlPLGFBQVksQ0FBR3pFLE1BQU0sQ0FBQyxJQUFNd0QsS0FBTixDQUFjNUIsYUFBZCxDQUErQkksWUFBL0IsQ0FBOENRLFVBQTlDLENBQTJELEdBQTVELENBQXpCLENBRUEsNEVBQ0EsR0FBSWtDLGlCQUFnQixDQUFHLG9FQUF2QixDQUVBLDBEQUNBLEdBQUlDLGFBQVksQ0FBRyxDQUNqQixPQURpQixDQUNSLFFBRFEsQ0FDRSxVQURGLENBQ2MsTUFEZCxDQUNzQixPQUR0QixDQUMrQixjQUQvQixDQUMrQyxjQUQvQyxDQUVqQixVQUZpQixDQUVMLFdBRkssQ0FFUSxZQUZSLENBRXNCLFlBRnRCLENBRW9DLEtBRnBDLENBRTJDLE1BRjNDLENBRW1ELFFBRm5ELENBR2pCLFNBSGlCLENBR04sUUFITSxDQUdJLEtBSEosQ0FHVyxRQUhYLENBR3FCLFFBSHJCLENBRytCLFdBSC9CLENBRzRDLFlBSDVDLENBSWpCLG1CQUppQixDQUlJLGFBSkosQ0FJbUIsYUFKbkIsQ0FJa0MsU0FKbEMsQ0FLakIsR0FMaUIsQ0FLWixjQUxZLENBS0ksVUFMSixDQUtnQixVQUxoQixDQUs0QixZQUw1QixDQUFuQixDQVFBLDJEQUNBLEdBQUlDLGdCQUFlLENBQUcsQ0FBQyxDQUF2QixDQUVBLDZEQUNBLEdBQUlDLGVBQWMsQ0FBRyxFQUFyQixDQUNBQSxjQUFjLENBQUM1RixVQUFELENBQWQsQ0FBNkI0RixjQUFjLENBQUMzRixVQUFELENBQWQsQ0FDN0IyRixjQUFjLENBQUMxRixPQUFELENBQWQsQ0FBMEIwRixjQUFjLENBQUN6RixRQUFELENBQWQsQ0FDMUJ5RixjQUFjLENBQUN4RixRQUFELENBQWQsQ0FBMkJ3RixjQUFjLENBQUN2RixRQUFELENBQWQsQ0FDM0J1RixjQUFjLENBQUN0RixlQUFELENBQWQsQ0FBa0NzRixjQUFjLENBQUNyRixTQUFELENBQWQsQ0FDbENxRixjQUFjLENBQUNwRixTQUFELENBQWQsQ0FBNEIsSUFKNUIsQ0FLQW9GLGNBQWMsQ0FBQ3BILE9BQUQsQ0FBZCxDQUEwQm9ILGNBQWMsQ0FBQ25ILFFBQUQsQ0FBZCxDQUMxQm1ILGNBQWMsQ0FBQzlGLGNBQUQsQ0FBZCxDQUFpQzhGLGNBQWMsQ0FBQ2pILE9BQUQsQ0FBZCxDQUNqQ2lILGNBQWMsQ0FBQzdGLFdBQUQsQ0FBZCxDQUE4QjZGLGNBQWMsQ0FBQ2hILE9BQUQsQ0FBZCxDQUM5QmdILGNBQWMsQ0FBQzlHLFFBQUQsQ0FBZCxDQUEyQjhHLGNBQWMsQ0FBQzdHLE9BQUQsQ0FBZCxDQUMzQjZHLGNBQWMsQ0FBQzNHLE1BQUQsQ0FBZCxDQUF5QjJHLGNBQWMsQ0FBQzFHLFNBQUQsQ0FBZCxDQUN6QjBHLGNBQWMsQ0FBQ3hHLFNBQUQsQ0FBZCxDQUE0QndHLGNBQWMsQ0FBQ3JHLFNBQUQsQ0FBZCxDQUM1QnFHLGNBQWMsQ0FBQ3BHLE1BQUQsQ0FBZCxDQUF5Qm9HLGNBQWMsQ0FBQ25HLFNBQUQsQ0FBZCxDQUN6Qm1HLGNBQWMsQ0FBQ2hHLFVBQUQsQ0FBZCxDQUE2QixLQVA3QixDQVNBLG9FQUNBLEdBQUlpRyxjQUFhLENBQUcsRUFBcEIsQ0FDQUEsYUFBYSxDQUFDckgsT0FBRCxDQUFiLENBQXlCcUgsYUFBYSxDQUFDcEgsUUFBRCxDQUFiLENBQ3pCb0gsYUFBYSxDQUFDL0YsY0FBRCxDQUFiLENBQWdDK0YsYUFBYSxDQUFDOUYsV0FBRCxDQUFiLENBQ2hDOEYsYUFBYSxDQUFDbEgsT0FBRCxDQUFiLENBQXlCa0gsYUFBYSxDQUFDakgsT0FBRCxDQUFiLENBQ3pCaUgsYUFBYSxDQUFDN0YsVUFBRCxDQUFiLENBQTRCNkYsYUFBYSxDQUFDNUYsVUFBRCxDQUFiLENBQzVCNEYsYUFBYSxDQUFDM0YsT0FBRCxDQUFiLENBQXlCMkYsYUFBYSxDQUFDMUYsUUFBRCxDQUFiLENBQ3pCMEYsYUFBYSxDQUFDekYsUUFBRCxDQUFiLENBQTBCeUYsYUFBYSxDQUFDNUcsTUFBRCxDQUFiLENBQzFCNEcsYUFBYSxDQUFDM0csU0FBRCxDQUFiLENBQTJCMkcsYUFBYSxDQUFDekcsU0FBRCxDQUFiLENBQzNCeUcsYUFBYSxDQUFDdEcsU0FBRCxDQUFiLENBQTJCc0csYUFBYSxDQUFDckcsTUFBRCxDQUFiLENBQzNCcUcsYUFBYSxDQUFDcEcsU0FBRCxDQUFiLENBQTJCb0csYUFBYSxDQUFDbkcsU0FBRCxDQUFiLENBQzNCbUcsYUFBYSxDQUFDeEYsUUFBRCxDQUFiLENBQTBCd0YsYUFBYSxDQUFDdkYsZUFBRCxDQUFiLENBQzFCdUYsYUFBYSxDQUFDdEYsU0FBRCxDQUFiLENBQTJCc0YsYUFBYSxDQUFDckYsU0FBRCxDQUFiLENBQTJCLElBVnRELENBV0FxRixhQUFhLENBQUMvRyxRQUFELENBQWIsQ0FBMEIrRyxhQUFhLENBQUM5RyxPQUFELENBQWIsQ0FDMUI4RyxhQUFhLENBQUNqRyxVQUFELENBQWIsQ0FBNEIsS0FENUIsQ0FHQSxnRUFDQSxHQUFJa0csZ0JBQWUsQ0FBRyxDQUNwQjtBQUNBLE9BQVEsR0FGWSxDQUVOLE9BQVEsR0FGRixDQUVPLE9BQVEsR0FGZixDQUVvQixPQUFRLEdBRjVCLENBRWlDLE9BQVEsR0FGekMsQ0FFOEMsT0FBUSxHQUZ0RCxDQUdwQixPQUFRLEdBSFksQ0FHTixPQUFRLEdBSEYsQ0FHTyxPQUFRLEdBSGYsQ0FHb0IsT0FBUSxHQUg1QixDQUdpQyxPQUFRLEdBSHpDLENBRzhDLE9BQVEsR0FIdEQsQ0FJcEIsT0FBUSxHQUpZLENBSU4sT0FBUSxHQUpGLENBS3BCLE9BQVEsR0FMWSxDQUtOLE9BQVEsR0FMRixDQU1wQixPQUFRLEdBTlksQ0FNTixPQUFRLEdBTkYsQ0FNTyxPQUFRLEdBTmYsQ0FNb0IsT0FBUSxHQU41QixDQU9wQixPQUFRLEdBUFksQ0FPTixPQUFRLEdBUEYsQ0FPTyxPQUFRLEdBUGYsQ0FPb0IsT0FBUSxHQVA1QixDQVFwQixPQUFRLEdBUlksQ0FRTixPQUFRLEdBUkYsQ0FRTyxPQUFRLEdBUmYsQ0FRb0IsT0FBUSxHQVI1QixDQVNwQixPQUFRLEdBVFksQ0FTTixPQUFRLEdBVEYsQ0FTTyxPQUFRLEdBVGYsQ0FTb0IsT0FBUSxHQVQ1QixDQVVwQixPQUFRLEdBVlksQ0FVTixPQUFRLEdBVkYsQ0FXcEIsT0FBUSxHQVhZLENBV04sT0FBUSxHQVhGLENBV08sT0FBUSxHQVhmLENBV29CLE9BQVEsR0FYNUIsQ0FXaUMsT0FBUSxHQVh6QyxDQVc4QyxPQUFRLEdBWHRELENBWXBCLE9BQVEsR0FaWSxDQVlOLE9BQVEsR0FaRixDQVlPLE9BQVEsR0FaZixDQVlvQixPQUFRLEdBWjVCLENBWWlDLE9BQVEsR0FaekMsQ0FZOEMsT0FBUSxHQVp0RCxDQWFwQixPQUFRLEdBYlksQ0FhTixPQUFRLEdBYkYsQ0FhTyxPQUFRLEdBYmYsQ0Fhb0IsT0FBUSxHQWI1QixDQWNwQixPQUFRLEdBZFksQ0FjTixPQUFRLEdBZEYsQ0FjTyxPQUFRLEdBZGYsQ0Fjb0IsT0FBUSxHQWQ1QixDQWVwQixPQUFRLEdBZlksQ0FlTixPQUFRLEdBZkYsQ0FlTyxPQUFRLEdBZmYsQ0FnQnBCLE9BQVEsSUFoQlksQ0FnQk4sT0FBUSxJQWhCRixDQWlCcEIsT0FBUSxJQWpCWSxDQWlCTixPQUFRLElBakJGLENBa0JwQixPQUFRLElBbEJZLENBbUJwQjtBQUNBLFNBQVUsR0FwQlUsQ0FvQkosU0FBVSxHQXBCTixDQW9CVyxTQUFVLEdBcEJyQixDQXFCcEIsU0FBVSxHQXJCVSxDQXFCSixTQUFVLEdBckJOLENBcUJXLFNBQVUsR0FyQnJCLENBc0JwQixTQUFVLEdBdEJVLENBc0JKLFNBQVUsR0F0Qk4sQ0FzQlcsU0FBVSxHQXRCckIsQ0FzQjBCLFNBQVUsR0F0QnBDLENBdUJwQixTQUFVLEdBdkJVLENBdUJKLFNBQVUsR0F2Qk4sQ0F1QlcsU0FBVSxHQXZCckIsQ0F1QjBCLFNBQVUsR0F2QnBDLENBd0JwQixTQUFVLEdBeEJVLENBd0JKLFNBQVUsR0F4Qk4sQ0F3QlcsU0FBVSxHQXhCckIsQ0F3QjBCLFNBQVUsR0F4QnBDLENBeUJwQixTQUFVLEdBekJVLENBeUJKLFNBQVUsR0F6Qk4sQ0F5QlcsU0FBVSxHQXpCckIsQ0F5QjBCLFNBQVUsR0F6QnBDLENBeUJ5QyxTQUFVLEdBekJuRCxDQTBCcEIsU0FBVSxHQTFCVSxDQTBCSixTQUFVLEdBMUJOLENBMEJXLFNBQVUsR0ExQnJCLENBMEIwQixTQUFVLEdBMUJwQyxDQTBCeUMsU0FBVSxHQTFCbkQsQ0EyQnBCLFNBQVUsR0EzQlUsQ0EyQkosU0FBVSxHQTNCTixDQTJCVyxTQUFVLEdBM0JyQixDQTJCMEIsU0FBVSxHQTNCcEMsQ0E0QnBCLFNBQVUsR0E1QlUsQ0E0QkosU0FBVSxHQTVCTixDQTRCVyxTQUFVLEdBNUJyQixDQTRCMEIsU0FBVSxHQTVCcEMsQ0E2QnBCLFNBQVUsR0E3QlUsQ0E2QkosU0FBVSxHQTdCTixDQTZCVyxTQUFVLEdBN0JyQixDQTZCMEIsU0FBVSxHQTdCcEMsQ0E4QnBCLFNBQVUsR0E5QlUsQ0E4QkosU0FBVSxHQTlCTixDQThCVyxTQUFVLEdBOUJyQixDQThCMEIsU0FBVSxHQTlCcEMsQ0E4QnlDLFNBQVUsR0E5Qm5ELENBK0JwQixTQUFVLEdBL0JVLENBK0JKLFNBQVUsR0EvQk4sQ0ErQlcsU0FBVSxHQS9CckIsQ0ErQjBCLFNBQVUsR0EvQnBDLENBK0J5QyxTQUFVLEdBL0JuRCxDQWdDcEIsU0FBVSxHQWhDVSxDQWdDSixTQUFVLEdBaENOLENBaUNwQixTQUFVLEdBakNVLENBaUNKLFNBQVUsR0FqQ04sQ0FpQ1csU0FBVSxHQWpDckIsQ0FrQ3BCLFNBQVUsR0FsQ1UsQ0FrQ0osU0FBVSxHQWxDTixDQWtDVyxTQUFVLEdBbENyQixDQWtDMEIsU0FBVSxHQWxDcEMsQ0FrQ3lDLFNBQVUsR0FsQ25ELENBbUNwQixTQUFVLEdBbkNVLENBbUNKLFNBQVUsR0FuQ04sQ0FtQ1csU0FBVSxHQW5DckIsQ0FtQzBCLFNBQVUsR0FuQ3BDLENBbUN5QyxTQUFVLEdBbkNuRCxDQW9DcEIsU0FBVSxHQXBDVSxDQW9DSixTQUFVLEdBcENOLENBb0NXLFNBQVUsR0FwQ3JCLENBb0MwQixTQUFVLEdBcENwQyxDQXFDcEIsU0FBVSxHQXJDVSxDQXFDSixTQUFVLEdBckNOLENBcUNXLFNBQVUsR0FyQ3JCLENBcUMwQixTQUFVLEdBckNwQyxDQXNDcEIsU0FBVSxHQXRDVSxDQXNDSixTQUFVLEdBdENOLENBc0NXLFNBQVUsR0F0Q3JCLENBdUNwQixTQUFVLEdBdkNVLENBdUNKLFNBQVUsR0F2Q04sQ0F1Q1csU0FBVSxHQXZDckIsQ0F3Q3BCLFNBQVUsR0F4Q1UsQ0F3Q0osU0FBVSxHQXhDTixDQXdDVyxTQUFVLEdBeENyQixDQXlDcEIsU0FBVSxHQXpDVSxDQXlDSixTQUFVLEdBekNOLENBeUNXLFNBQVUsR0F6Q3JCLENBMENwQixTQUFVLEdBMUNVLENBMENKLFNBQVUsR0ExQ04sQ0EwQ1csU0FBVSxHQTFDckIsQ0EwQzBCLFNBQVUsR0ExQ3BDLENBMkNwQixTQUFVLEdBM0NVLENBMkNKLFNBQVUsR0EzQ04sQ0EyQ1csU0FBVSxHQTNDckIsQ0EyQzBCLFNBQVUsR0EzQ3BDLENBNENwQixTQUFVLEdBNUNVLENBNENKLFNBQVUsR0E1Q04sQ0E0Q1csU0FBVSxHQTVDckIsQ0E2Q3BCLFNBQVUsR0E3Q1UsQ0E2Q0osU0FBVSxHQTdDTixDQTZDVyxTQUFVLEdBN0NyQixDQThDcEIsU0FBVSxHQTlDVSxDQThDSixTQUFVLEdBOUNOLENBOENXLFNBQVUsR0E5Q3JCLENBOEMwQixTQUFVLEdBOUNwQyxDQThDeUMsU0FBVSxHQTlDbkQsQ0E4Q3dELFNBQVUsR0E5Q2xFLENBK0NwQixTQUFVLEdBL0NVLENBK0NKLFNBQVUsR0EvQ04sQ0ErQ1csU0FBVSxHQS9DckIsQ0ErQzBCLFNBQVUsR0EvQ3BDLENBK0N5QyxTQUFVLEdBL0NuRCxDQStDd0QsU0FBVSxHQS9DbEUsQ0FnRHBCLFNBQVUsR0FoRFUsQ0FnREosU0FBVSxHQWhETixDQWlEcEIsU0FBVSxHQWpEVSxDQWlESixTQUFVLEdBakROLENBaURXLFNBQVUsR0FqRHJCLENBa0RwQixTQUFVLEdBbERVLENBa0RKLFNBQVUsR0FsRE4sQ0FrRFcsU0FBVSxHQWxEckIsQ0FtRHBCLFNBQVUsR0FuRFUsQ0FtREosU0FBVSxHQW5ETixDQW1EVyxTQUFVLEdBbkRyQixDQW9EcEIsU0FBVSxJQXBEVSxDQW9ESixTQUFVLElBcEROLENBcURwQixTQUFVLElBckRVLENBcURKLFNBQVUsSUFyRE4sQ0FzRHBCLFNBQVUsSUF0RFUsQ0FzREosU0FBVSxHQXRETixDQUF0QixDQXlEQSwrQ0FDQSxHQUFJQyxZQUFXLENBQUcsQ0FDaEIsSUFBSyxPQURXLENBRWhCLElBQUssTUFGVyxDQUdoQixJQUFLLE1BSFcsQ0FJaEIsSUFBSyxRQUpXLENBS2hCLElBQUssT0FMVyxDQUFsQixDQVFBLCtDQUNBLEdBQUlDLGNBQWEsQ0FBRyxDQUNsQixRQUFTLEdBRFMsQ0FFbEIsT0FBUSxHQUZVLENBR2xCLE9BQVEsR0FIVSxDQUlsQixTQUFVLEdBSlEsQ0FLbEIsUUFBUyxHQUxTLENBQXBCLENBUUEsMkVBQ0EsR0FBSUMsY0FBYSxDQUFHLENBQ2xCLEtBQU0sSUFEWSxDQUVsQixJQUFLLEdBRmEsQ0FHbEIsS0FBTSxHQUhZLENBSWxCLEtBQU0sR0FKWSxDQUtsQixTQUFVLE9BTFEsQ0FNbEIsU0FBVSxPQU5RLENBQXBCLENBU0EsaUVBQ0EsR0FBSUMsZUFBYyxDQUFHQyxVQUFyQixDQUNJQyxZQUFZLENBQUdDLFFBRG5CLENBR0Esa0RBQ0EsR0FBSUMsV0FBVSxDQUFHLE1BQU90eEIsT0FBUCxFQUFpQixRQUFqQixFQUE2QkEsTUFBN0IsRUFBdUNBLE1BQU0sQ0FBQzdHLE1BQVAsR0FBa0JBLE1BQXpELEVBQW1FNkcsTUFBcEYsQ0FFQSxtQ0FDQSxHQUFJdXhCLFNBQVEsQ0FBRyxNQUFPQyxLQUFQLEVBQWUsUUFBZixFQUEyQkEsSUFBM0IsRUFBbUNBLElBQUksQ0FBQ3I0QixNQUFMLEdBQWdCQSxNQUFuRCxFQUE2RHE0QixJQUE1RSxDQUVBLGdEQUNBLEdBQUlwZSxLQUFJLENBQUdrZSxVQUFVLEVBQUlDLFFBQWQsRUFBMEJFLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFBckMsQ0FFQSxzQ0FDQSxHQUFJQyxZQUFXLENBQUcsT0FBOEIzeEIsT0FBOUIsRUFBeUMsQ0FBQ0EsT0FBTyxDQUFDbU4sUUFBbEQsRUFBOERuTixPQUFoRixDQUVBLHFDQUNBLEdBQUk0eEIsV0FBVSxDQUFHRCxXQUFXLEVBQUksTUFBTzV4QixPQUFQLEVBQWlCLFFBQWhDLEVBQTRDQSxNQUE1QyxFQUFzRCxDQUFDQSxNQUFNLENBQUNvTixRQUE5RCxFQUEwRXBOLE1BQTNGLENBRUEsOERBQ0EsR0FBSTh4QixjQUFhLENBQUdELFVBQVUsRUFBSUEsVUFBVSxDQUFDNXhCLE9BQVgsR0FBdUIyeEIsV0FBekQsQ0FFQSxtREFDQSxHQUFJRyxZQUFXLENBQUdELGFBQWEsRUFBSU4sVUFBVSxDQUFDUSxPQUE5QyxDQUVBLDZDQUNBLEdBQUlDLFNBQVEsQ0FBSSxVQUFXLENBQ3pCLEdBQUksQ0FDRjtBQUNBLEdBQUlDLE1BQUssQ0FBR0wsVUFBVSxFQUFJQSxVQUFVLENBQUNNLE9BQXpCLEVBQW9DTixVQUFVLENBQUNNLE9BQVgsQ0FBbUIsTUFBbkIsRUFBMkJELEtBQTNFLENBRUEsR0FBSUEsS0FBSixDQUFXLENBQ1QsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDQSxNQUFPSCxZQUFXLEVBQUlBLFdBQVcsQ0FBQ0ssT0FBM0IsRUFBc0NMLFdBQVcsQ0FBQ0ssT0FBWixDQUFvQixNQUFwQixDQUE3QyxDQUNELENBQUMsTUFBTzkyQixDQUFQLENBQVUsQ0FBRSxDQUNmLENBWmUsRUFBaEIsQ0FjQSxnQ0FDQSxHQUFJKzJCLGtCQUFpQixDQUFHSixRQUFRLEVBQUlBLFFBQVEsQ0FBQ0ssYUFBN0MsQ0FDSUMsVUFBVSxDQUFHTixRQUFRLEVBQUlBLFFBQVEsQ0FBQ08sTUFEdEMsQ0FFSUMsU0FBUyxDQUFHUixRQUFRLEVBQUlBLFFBQVEsQ0FBQ3RrQixLQUZyQyxDQUdJK2tCLFlBQVksQ0FBR1QsUUFBUSxFQUFJQSxRQUFRLENBQUNVLFFBSHhDLENBSUlDLFNBQVMsQ0FBR1gsUUFBUSxFQUFJQSxRQUFRLENBQUN0UyxLQUpyQyxDQUtJa1QsZ0JBQWdCLENBQUdaLFFBQVEsRUFBSUEsUUFBUSxDQUFDYSxZQUw1QyxDQU9BLDhFQWhkVyxDQWtkWDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVM5NkIsTUFBVCxDQUFlKzZCLElBQWYsQ0FBcUJDLE9BQXJCLENBQThCNTNCLElBQTlCLENBQW9DLENBQ2xDLE9BQVFBLElBQUksQ0FBQ2hKLE1BQWIsRUFDRSxJQUFLLEVBQUwsQ0FBUSxNQUFPMmdDLEtBQUksQ0FBQ3Y1QixJQUFMLENBQVV3NUIsT0FBVixDQUFQLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBT0QsS0FBSSxDQUFDdjVCLElBQUwsQ0FBVXc1QixPQUFWLENBQW1CNTNCLElBQUksQ0FBQyxDQUFELENBQXZCLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPMjNCLEtBQUksQ0FBQ3Y1QixJQUFMLENBQVV3NUIsT0FBVixDQUFtQjUzQixJQUFJLENBQUMsQ0FBRCxDQUF2QixDQUE0QkEsSUFBSSxDQUFDLENBQUQsQ0FBaEMsQ0FBUCxDQUNSLElBQUssRUFBTCxDQUFRLE1BQU8yM0IsS0FBSSxDQUFDdjVCLElBQUwsQ0FBVXc1QixPQUFWLENBQW1CNTNCLElBQUksQ0FBQyxDQUFELENBQXZCLENBQTRCQSxJQUFJLENBQUMsQ0FBRCxDQUFoQyxDQUFxQ0EsSUFBSSxDQUFDLENBQUQsQ0FBekMsQ0FBUCxDQUpWLENBTUEsTUFBTzIzQixLQUFJLENBQUMvNkIsS0FBTCxDQUFXZzdCLE9BQVgsQ0FBb0I1M0IsSUFBcEIsQ0FBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTNjNCLGdCQUFULENBQXlCMzhCLEtBQXpCLENBQWdDNDhCLE1BQWhDLENBQXdDQyxRQUF4QyxDQUFrREMsV0FBbEQsQ0FBK0QsQ0FDN0QsR0FBSTk0QixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFEdkMsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNBNDRCLE1BQU0sQ0FBQ0UsV0FBRCxDQUFjOS9CLEtBQWQsQ0FBcUI2L0IsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBN0IsQ0FBc0NnRCxLQUF0QyxDQUFOLENBQ0QsQ0FDRCxNQUFPODhCLFlBQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNDLFVBQVQsQ0FBbUIvOEIsS0FBbkIsQ0FBMEI2OEIsUUFBMUIsQ0FBb0MsQ0FDbEMsR0FBSTc0QixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFEdkMsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJK2dDLFFBQVEsQ0FBQzc4QixLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBZUEsS0FBZixDQUFzQmhFLEtBQXRCLENBQVIsR0FBeUMsS0FBN0MsQ0FBb0QsQ0FDbEQsTUFDRCxDQUNGLENBQ0QsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU2c5QixlQUFULENBQXdCaDlCLEtBQXhCLENBQStCNjhCLFFBQS9CLENBQXlDLENBQ3ZDLEdBQUkvZ0MsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBRUEsTUFBT0EsTUFBTSxFQUFiLENBQWlCLENBQ2YsR0FBSStnQyxRQUFRLENBQUM3OEIsS0FBSyxDQUFDbEUsTUFBRCxDQUFOLENBQWdCQSxNQUFoQixDQUF3QmtFLEtBQXhCLENBQVIsR0FBMkMsS0FBL0MsQ0FBc0QsQ0FDcEQsTUFDRCxDQUNGLENBQ0QsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTaTlCLFdBQVQsQ0FBb0JqOUIsS0FBcEIsQ0FBMkJtRSxTQUEzQixDQUFzQyxDQUNwQyxHQUFJSCxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFEdkMsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJLENBQUNxSSxTQUFTLENBQUNuRSxLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBZUEsS0FBZixDQUFzQmhFLEtBQXRCLENBQWQsQ0FBNEMsQ0FDMUMsTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU2s5QixZQUFULENBQXFCbDlCLEtBQXJCLENBQTRCbUUsU0FBNUIsQ0FBdUMsQ0FDckMsR0FBSUgsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BRHZDLENBRUlxaEMsUUFBUSxDQUFHLENBRmYsQ0FHSTNqQyxNQUFNLENBQUcsRUFIYixDQUtBLE1BQU8sRUFBRXdLLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlrQixNQUFLLENBQUdnRCxLQUFLLENBQUNnRSxLQUFELENBQWpCLENBQ0EsR0FBSUcsU0FBUyxDQUFDbkgsS0FBRCxDQUFRZ0gsS0FBUixDQUFlaEUsS0FBZixDQUFiLENBQW9DLENBQ2xDeEcsTUFBTSxDQUFDMmpDLFFBQVEsRUFBVCxDQUFOLENBQXFCbmdDLEtBQXJCLENBQ0QsQ0FDRixDQUNELE1BQU94RCxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTNGpDLGNBQVQsQ0FBdUJwOUIsS0FBdkIsQ0FBOEJoRCxLQUE5QixDQUFxQyxDQUNuQyxHQUFJbEIsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsTUFBTyxDQUFDLENBQUNBLE1BQUYsRUFBWXVoQyxXQUFXLENBQUNyOUIsS0FBRCxDQUFRaEQsS0FBUixDQUFlLENBQWYsQ0FBWCxDQUErQixDQUFDLENBQW5ELENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTc2dDLGtCQUFULENBQTJCdDlCLEtBQTNCLENBQWtDaEQsS0FBbEMsQ0FBeUNtYyxVQUF6QyxDQUFxRCxDQUNuRCxHQUFJblYsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BRHZDLENBR0EsTUFBTyxFQUFFa0ksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXFkLFVBQVUsQ0FBQ25jLEtBQUQsQ0FBUWdELEtBQUssQ0FBQ2dFLEtBQUQsQ0FBYixDQUFkLENBQXFDLENBQ25DLE1BQU8sS0FBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLE1BQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVN1NUIsU0FBVCxDQUFrQnY5QixLQUFsQixDQUF5QjY4QixRQUF6QixDQUFtQyxDQUNqQyxHQUFJNzRCLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUR2QyxDQUVJdEMsTUFBTSxDQUFHRSxLQUFLLENBQUNvQyxNQUFELENBRmxCLENBSUEsTUFBTyxFQUFFa0ksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkJ0QyxNQUFNLENBQUN3SyxLQUFELENBQU4sQ0FBZ0I2NEIsUUFBUSxDQUFDNzhCLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBTixDQUFlQSxLQUFmLENBQXNCaEUsS0FBdEIsQ0FBeEIsQ0FDRCxDQUNELE1BQU94RyxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU2drQyxVQUFULENBQW1CeDlCLEtBQW5CLENBQTBCMGYsTUFBMUIsQ0FBa0MsQ0FDaEMsR0FBSTFiLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBRzRqQixNQUFNLENBQUM1akIsTUFEcEIsQ0FFSWtNLE1BQU0sQ0FBR2hJLEtBQUssQ0FBQ2xFLE1BRm5CLENBSUEsTUFBTyxFQUFFa0ksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkJrRSxLQUFLLENBQUNnSSxNQUFNLENBQUdoRSxLQUFWLENBQUwsQ0FBd0IwYixNQUFNLENBQUMxYixLQUFELENBQTlCLENBQ0QsQ0FDRCxNQUFPaEUsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3k5QixZQUFULENBQXFCejlCLEtBQXJCLENBQTRCNjhCLFFBQTVCLENBQXNDQyxXQUF0QyxDQUFtRFksU0FBbkQsQ0FBOEQsQ0FDNUQsR0FBSTE1QixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFEdkMsQ0FHQSxHQUFJNGhDLFNBQVMsRUFBSTVoQyxNQUFqQixDQUF5QixDQUN2QmdoQyxXQUFXLENBQUc5OEIsS0FBSyxDQUFDLEVBQUVnRSxLQUFILENBQW5CLENBQ0QsQ0FDRCxNQUFPLEVBQUVBLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCZ2hDLFdBQVcsQ0FBR0QsUUFBUSxDQUFDQyxXQUFELENBQWM5OEIsS0FBSyxDQUFDZ0UsS0FBRCxDQUFuQixDQUE0QkEsS0FBNUIsQ0FBbUNoRSxLQUFuQyxDQUF0QixDQUNELENBQ0QsTUFBTzg4QixZQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTYSxpQkFBVCxDQUEwQjM5QixLQUExQixDQUFpQzY4QixRQUFqQyxDQUEyQ0MsV0FBM0MsQ0FBd0RZLFNBQXhELENBQW1FLENBQ2pFLEdBQUk1aEMsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsR0FBSTRoQyxTQUFTLEVBQUk1aEMsTUFBakIsQ0FBeUIsQ0FDdkJnaEMsV0FBVyxDQUFHOThCLEtBQUssQ0FBQyxFQUFFbEUsTUFBSCxDQUFuQixDQUNELENBQ0QsTUFBT0EsTUFBTSxFQUFiLENBQWlCLENBQ2ZnaEMsV0FBVyxDQUFHRCxRQUFRLENBQUNDLFdBQUQsQ0FBYzk4QixLQUFLLENBQUNsRSxNQUFELENBQW5CLENBQTZCQSxNQUE3QixDQUFxQ2tFLEtBQXJDLENBQXRCLENBQ0QsQ0FDRCxNQUFPODhCLFlBQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU2MsVUFBVCxDQUFtQjU5QixLQUFuQixDQUEwQm1FLFNBQTFCLENBQXFDLENBQ25DLEdBQUlILE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUR2QyxDQUdBLE1BQU8sRUFBRWtJLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlxSSxTQUFTLENBQUNuRSxLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBZUEsS0FBZixDQUFzQmhFLEtBQXRCLENBQWIsQ0FBMkMsQ0FDekMsTUFBTyxLQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxHQUFJNjlCLFVBQVMsQ0FBR0MsWUFBWSxDQUFDLFFBQUQsQ0FBNUIsQ0FFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNDLGFBQVQsQ0FBc0J2OUIsTUFBdEIsQ0FBOEIsQ0FDNUIsTUFBT0EsT0FBTSxDQUFDdzlCLEtBQVAsQ0FBYSxFQUFiLENBQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU0MsV0FBVCxDQUFvQno5QixNQUFwQixDQUE0QixDQUMxQixNQUFPQSxPQUFNLENBQUNGLEtBQVAsQ0FBYW8yQixXQUFiLEdBQTZCLEVBQXBDLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3dILFlBQVQsQ0FBcUJ6NEIsVUFBckIsQ0FBaUN0QixTQUFqQyxDQUE0Q2c2QixRQUE1QyxDQUFzRCxDQUNwRCxHQUFJM2tDLE9BQUosQ0FDQTJrQyxRQUFRLENBQUMxNEIsVUFBRCxDQUFhLFNBQVN6SSxLQUFULENBQWdCb0gsR0FBaEIsQ0FBcUJxQixVQUFyQixDQUFpQyxDQUNwRCxHQUFJdEIsU0FBUyxDQUFDbkgsS0FBRCxDQUFRb0gsR0FBUixDQUFhcUIsVUFBYixDQUFiLENBQXVDLENBQ3JDak0sTUFBTSxDQUFHNEssR0FBVCxDQUNBLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FMTyxDQUFSLENBTUEsTUFBTzVLLE9BQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTNGtDLGNBQVQsQ0FBdUJwK0IsS0FBdkIsQ0FBOEJtRSxTQUE5QixDQUF5Q2s2QixTQUF6QyxDQUFvREMsU0FBcEQsQ0FBK0QsQ0FDN0QsR0FBSXhpQyxPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNJa0ksS0FBSyxDQUFHcTZCLFNBQVMsRUFBSUMsU0FBUyxDQUFHLENBQUgsQ0FBTyxDQUFDLENBQXJCLENBRHJCLENBR0EsTUFBUUEsU0FBUyxDQUFHdDZCLEtBQUssRUFBUixDQUFhLEVBQUVBLEtBQUYsQ0FBVWxJLE1BQXhDLENBQWlELENBQy9DLEdBQUlxSSxTQUFTLENBQUNuRSxLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBZUEsS0FBZixDQUFzQmhFLEtBQXRCLENBQWIsQ0FBMkMsQ0FDekMsTUFBT2dFLE1BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxDQUFDLENBQVIsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNxNUIsWUFBVCxDQUFxQnI5QixLQUFyQixDQUE0QmhELEtBQTVCLENBQW1DcWhDLFNBQW5DLENBQThDLENBQzVDLE1BQU9yaEMsTUFBSyxHQUFLQSxLQUFWLENBQ0h1aEMsYUFBYSxDQUFDditCLEtBQUQsQ0FBUWhELEtBQVIsQ0FBZXFoQyxTQUFmLENBRFYsQ0FFSEQsYUFBYSxDQUFDcCtCLEtBQUQsQ0FBUXcrQixTQUFSLENBQW1CSCxTQUFuQixDQUZqQixDQUdELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTSSxnQkFBVCxDQUF5QnorQixLQUF6QixDQUFnQ2hELEtBQWhDLENBQXVDcWhDLFNBQXZDLENBQWtEbGxCLFVBQWxELENBQThELENBQzVELEdBQUluVixNQUFLLENBQUdxNkIsU0FBUyxDQUFHLENBQXhCLENBQ0l2aUMsTUFBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFEbkIsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJcWQsVUFBVSxDQUFDblosS0FBSyxDQUFDZ0UsS0FBRCxDQUFOLENBQWVoSCxLQUFmLENBQWQsQ0FBcUMsQ0FDbkMsTUFBT2dILE1BQVAsQ0FDRCxDQUNGLENBQ0QsTUFBTyxDQUFDLENBQVIsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3c2QixVQUFULENBQW1CeGhDLEtBQW5CLENBQTBCLENBQ3hCLE1BQU9BLE1BQUssR0FBS0EsS0FBakIsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVMwaEMsU0FBVCxDQUFrQjErQixLQUFsQixDQUF5QjY4QixRQUF6QixDQUFtQyxDQUNqQyxHQUFJL2dDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLE1BQU9BLE9BQU0sQ0FBSTZpQyxPQUFPLENBQUMzK0IsS0FBRCxDQUFRNjhCLFFBQVIsQ0FBUCxDQUEyQi9nQyxNQUEvQixDQUF5Q2kzQixHQUF0RCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTK0ssYUFBVCxDQUFzQjE1QixHQUF0QixDQUEyQixDQUN6QixNQUFPLFVBQVN4RSxNQUFULENBQWlCLENBQ3RCLE1BQU9BLE9BQU0sRUFBSSxJQUFWLENBQWlCL0QsU0FBakIsQ0FBNkIrRCxNQUFNLENBQUN3RSxHQUFELENBQTFDLENBQ0QsQ0FGRCxDQUdELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTdzZCLGVBQVQsQ0FBd0JoL0IsTUFBeEIsQ0FBZ0MsQ0FDOUIsTUFBTyxVQUFTd0UsR0FBVCxDQUFjLENBQ25CLE1BQU94RSxPQUFNLEVBQUksSUFBVixDQUFpQi9ELFNBQWpCLENBQTZCK0QsTUFBTSxDQUFDd0UsR0FBRCxDQUExQyxDQUNELENBRkQsQ0FHRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3k2QixXQUFULENBQW9CcDVCLFVBQXBCLENBQWdDbzNCLFFBQWhDLENBQTBDQyxXQUExQyxDQUF1RFksU0FBdkQsQ0FBa0VTLFFBQWxFLENBQTRFLENBQzFFQSxRQUFRLENBQUMxNEIsVUFBRCxDQUFhLFNBQVN6SSxLQUFULENBQWdCZ0gsS0FBaEIsQ0FBdUJ5QixVQUF2QixDQUFtQyxDQUN0RHEzQixXQUFXLENBQUdZLFNBQVMsRUFDbEJBLFNBQVMsQ0FBRyxLQUFaLENBQW1CMWdDLEtBREQsRUFFbkI2L0IsUUFBUSxDQUFDQyxXQUFELENBQWM5L0IsS0FBZCxDQUFxQmdILEtBQXJCLENBQTRCeUIsVUFBNUIsQ0FGWixDQUdELENBSk8sQ0FBUixDQUtBLE1BQU9xM0IsWUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTZ0MsV0FBVCxDQUFvQjkrQixLQUFwQixDQUEyQisrQixRQUEzQixDQUFxQyxDQUNuQyxHQUFJampDLE9BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BQW5CLENBRUFrRSxLQUFLLENBQUNrWixJQUFOLENBQVc2bEIsUUFBWCxFQUNBLE1BQU9qakMsTUFBTSxFQUFiLENBQWlCLENBQ2ZrRSxLQUFLLENBQUNsRSxNQUFELENBQUwsQ0FBZ0JrRSxLQUFLLENBQUNsRSxNQUFELENBQUwsQ0FBY2tCLEtBQTlCLENBQ0QsQ0FDRCxNQUFPZ0QsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBUzIrQixRQUFULENBQWlCMytCLEtBQWpCLENBQXdCNjhCLFFBQXhCLENBQWtDLENBQ2hDLEdBQUlyakMsT0FBSixDQUNJd0ssS0FBSyxDQUFHLENBQUMsQ0FEYixDQUVJbEksTUFBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFGbkIsQ0FJQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa2pDLFFBQU8sQ0FBR25DLFFBQVEsQ0FBQzc4QixLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBdEIsQ0FDQSxHQUFJZzdCLE9BQU8sR0FBS25qQyxTQUFoQixDQUEyQixDQUN6QnJDLE1BQU0sQ0FBR0EsTUFBTSxHQUFLcUMsU0FBWCxDQUF1Qm1qQyxPQUF2QixDQUFrQ3hsQyxNQUFNLENBQUd3bEMsT0FBcEQsQ0FDRCxDQUNGLENBQ0QsTUFBT3hsQyxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTeWxDLFVBQVQsQ0FBbUI1bEMsQ0FBbkIsQ0FBc0J3akMsUUFBdEIsQ0FBZ0MsQ0FDOUIsR0FBSTc0QixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0l4SyxNQUFNLENBQUdFLEtBQUssQ0FBQ0wsQ0FBRCxDQURsQixDQUdBLE1BQU8sRUFBRTJLLEtBQUYsQ0FBVTNLLENBQWpCLENBQW9CLENBQ2xCRyxNQUFNLENBQUN3SyxLQUFELENBQU4sQ0FBZ0I2NEIsUUFBUSxDQUFDNzRCLEtBQUQsQ0FBeEIsQ0FDRCxDQUNELE1BQU94SyxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTMGxDLFlBQVQsQ0FBcUJ0L0IsTUFBckIsQ0FBNkJ1L0IsS0FBN0IsQ0FBb0MsQ0FDbEMsTUFBTzVCLFNBQVEsQ0FBQzRCLEtBQUQsQ0FBUSxTQUFTLzZCLEdBQVQsQ0FBYyxDQUNuQyxNQUFPLENBQUNBLEdBQUQsQ0FBTXhFLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBWixDQUFQLENBQ0QsQ0FGYyxDQUFmLENBR0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNnN0IsU0FBVCxDQUFrQjUrQixNQUFsQixDQUEwQixDQUN4QixNQUFPQSxPQUFNLENBQ1RBLE1BQU0sQ0FBQ2hCLEtBQVAsQ0FBYSxDQUFiLENBQWdCNi9CLGVBQWUsQ0FBQzcrQixNQUFELENBQWYsQ0FBMEIsQ0FBMUMsRUFBNkM4K0IsT0FBN0MsQ0FBcURqSixXQUFyRCxDQUFrRSxFQUFsRSxDQURTLENBRVQ3MUIsTUFGSixDQUdELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTKytCLFVBQVQsQ0FBbUI5QyxJQUFuQixDQUF5QixDQUN2QixNQUFPLFVBQVN6L0IsS0FBVCxDQUFnQixDQUNyQixNQUFPeS9CLEtBQUksQ0FBQ3ovQixLQUFELENBQVgsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVN3aUMsV0FBVCxDQUFvQjUvQixNQUFwQixDQUE0QnUvQixLQUE1QixDQUFtQyxDQUNqQyxNQUFPNUIsU0FBUSxDQUFDNEIsS0FBRCxDQUFRLFNBQVMvNkIsR0FBVCxDQUFjLENBQ25DLE1BQU94RSxPQUFNLENBQUN3RSxHQUFELENBQWIsQ0FDRCxDQUZjLENBQWYsQ0FHRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTcTdCLFNBQVQsQ0FBa0I5dEIsS0FBbEIsQ0FBeUJ2TixHQUF6QixDQUE4QixDQUM1QixNQUFPdU4sTUFBSyxDQUFDWixHQUFOLENBQVUzTSxHQUFWLENBQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNzN0IsZ0JBQVQsQ0FBeUJDLFVBQXpCLENBQXFDQyxVQUFyQyxDQUFpRCxDQUMvQyxHQUFJNTdCLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBRzZqQyxVQUFVLENBQUM3akMsTUFEeEIsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFWLEVBQW9CdWhDLFdBQVcsQ0FBQ3VDLFVBQUQsQ0FBYUQsVUFBVSxDQUFDMzdCLEtBQUQsQ0FBdkIsQ0FBZ0MsQ0FBaEMsQ0FBWCxDQUFnRCxDQUFDLENBQTVFLENBQStFLENBQUUsQ0FDakYsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBUzY3QixjQUFULENBQXVCRixVQUF2QixDQUFtQ0MsVUFBbkMsQ0FBK0MsQ0FDN0MsR0FBSTU3QixNQUFLLENBQUcyN0IsVUFBVSxDQUFDN2pDLE1BQXZCLENBRUEsTUFBT2tJLEtBQUssSUFBTXE1QixXQUFXLENBQUN1QyxVQUFELENBQWFELFVBQVUsQ0FBQzM3QixLQUFELENBQXZCLENBQWdDLENBQWhDLENBQVgsQ0FBZ0QsQ0FBQyxDQUFuRSxDQUFzRSxDQUFFLENBQ3hFLE1BQU9BLE1BQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTODdCLGFBQVQsQ0FBc0I5L0IsS0FBdEIsQ0FBNkIrL0IsV0FBN0IsQ0FBMEMsQ0FDeEMsR0FBSWprQyxPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNJdEMsTUFBTSxDQUFHLENBRGIsQ0FHQSxNQUFPc0MsTUFBTSxFQUFiLENBQWlCLENBQ2YsR0FBSWtFLEtBQUssQ0FBQ2xFLE1BQUQsQ0FBTCxHQUFrQmlrQyxXQUF0QixDQUFtQyxDQUNqQyxFQUFFdm1DLE1BQUYsQ0FDRCxDQUNGLENBQ0QsTUFBT0EsT0FBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEdBQUl3bUMsYUFBWSxDQUFHcEIsY0FBYyxDQUFDbEUsZUFBRCxDQUFqQyxDQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsR0FBSXVGLGVBQWMsQ0FBR3JCLGNBQWMsQ0FBQ2pFLFdBQUQsQ0FBbkMsQ0FFQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVN1RixpQkFBVCxDQUEwQkMsR0FBMUIsQ0FBK0IsQ0FDN0IsTUFBTyxLQUFPdEYsYUFBYSxDQUFDc0YsR0FBRCxDQUEzQixDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNDLFNBQVQsQ0FBa0J4Z0MsTUFBbEIsQ0FBMEJ3RSxHQUExQixDQUErQixDQUM3QixNQUFPeEUsT0FBTSxFQUFJLElBQVYsQ0FBaUIvRCxTQUFqQixDQUE2QitELE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBMUMsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU2k4QixXQUFULENBQW9CNy9CLE1BQXBCLENBQTRCLENBQzFCLE1BQU80NUIsYUFBWSxDQUFDa0csSUFBYixDQUFrQjkvQixNQUFsQixDQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVMrL0IsZUFBVCxDQUF3Qi8vQixNQUF4QixDQUFnQyxDQUM5QixNQUFPNjVCLGlCQUFnQixDQUFDaUcsSUFBakIsQ0FBc0I5L0IsTUFBdEIsQ0FBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTZ2dDLGdCQUFULENBQXlCbjlCLFFBQXpCLENBQW1DLENBQ2pDLEdBQUk3RSxLQUFKLENBQ0loRixNQUFNLENBQUcsRUFEYixDQUdBLE1BQU8sQ0FBQyxDQUFDZ0YsSUFBSSxDQUFHNkUsUUFBUSxDQUFDOEssSUFBVCxFQUFSLEVBQXlCVSxJQUFqQyxDQUF1QyxDQUNyQ3JWLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWXpJLElBQUksQ0FBQ3hCLEtBQWpCLEVBQ0QsQ0FDRCxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTaW5DLFdBQVQsQ0FBb0Jua0MsR0FBcEIsQ0FBeUIsQ0FDdkIsR0FBSTBILE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSXhLLE1BQU0sQ0FBR0UsS0FBSyxDQUFDNEMsR0FBRyxDQUFDcEUsSUFBTCxDQURsQixDQUdBb0UsR0FBRyxDQUFDYixPQUFKLENBQVksU0FBU3VCLEtBQVQsQ0FBZ0JvSCxHQUFoQixDQUFxQixDQUMvQjVLLE1BQU0sQ0FBQyxFQUFFd0ssS0FBSCxDQUFOLENBQWtCLENBQUNJLEdBQUQsQ0FBTXBILEtBQU4sQ0FBbEIsQ0FDRCxDQUZELEVBR0EsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTa25DLFFBQVQsQ0FBaUJqRSxJQUFqQixDQUF1QmtFLFNBQXZCLENBQWtDLENBQ2hDLE1BQU8sVUFBU0MsR0FBVCxDQUFjLENBQ25CLE1BQU9uRSxLQUFJLENBQUNrRSxTQUFTLENBQUNDLEdBQUQsQ0FBVixDQUFYLENBQ0QsQ0FGRCxDQUdELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU0MsZUFBVCxDQUF3QjdnQyxLQUF4QixDQUErQisvQixXQUEvQixDQUE0QyxDQUMxQyxHQUFJLzdCLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BRG5CLENBRUlxaEMsUUFBUSxDQUFHLENBRmYsQ0FHSTNqQyxNQUFNLENBQUcsRUFIYixDQUtBLE1BQU8sRUFBRXdLLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlrQixNQUFLLENBQUdnRCxLQUFLLENBQUNnRSxLQUFELENBQWpCLENBQ0EsR0FBSWhILEtBQUssR0FBSytpQyxXQUFWLEVBQXlCL2lDLEtBQUssR0FBS3EwQixXQUF2QyxDQUFvRCxDQUNsRHJ4QixLQUFLLENBQUNnRSxLQUFELENBQUwsQ0FBZXF0QixXQUFmLENBQ0E3M0IsTUFBTSxDQUFDMmpDLFFBQVEsRUFBVCxDQUFOLENBQXFCbjVCLEtBQXJCLENBQ0QsQ0FDRixDQUNELE1BQU94SyxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNzbkMsV0FBVCxDQUFvQmxxQixHQUFwQixDQUF5QixDQUN2QixHQUFJNVMsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJeEssTUFBTSxDQUFHRSxLQUFLLENBQUNrZCxHQUFHLENBQUMxZSxJQUFMLENBRGxCLENBR0EwZSxHQUFHLENBQUNuYixPQUFKLENBQVksU0FBU3VCLEtBQVQsQ0FBZ0IsQ0FDMUJ4RCxNQUFNLENBQUMsRUFBRXdLLEtBQUgsQ0FBTixDQUFrQmhILEtBQWxCLENBQ0QsQ0FGRCxFQUdBLE1BQU94RCxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVN1bkMsV0FBVCxDQUFvQm5xQixHQUFwQixDQUF5QixDQUN2QixHQUFJNVMsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJeEssTUFBTSxDQUFHRSxLQUFLLENBQUNrZCxHQUFHLENBQUMxZSxJQUFMLENBRGxCLENBR0EwZSxHQUFHLENBQUNuYixPQUFKLENBQVksU0FBU3VCLEtBQVQsQ0FBZ0IsQ0FDMUJ4RCxNQUFNLENBQUMsRUFBRXdLLEtBQUgsQ0FBTixDQUFrQixDQUFDaEgsS0FBRCxDQUFRQSxLQUFSLENBQWxCLENBQ0QsQ0FGRCxFQUdBLE1BQU94RCxPQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVMra0MsY0FBVCxDQUF1QnYrQixLQUF2QixDQUE4QmhELEtBQTlCLENBQXFDcWhDLFNBQXJDLENBQWdELENBQzlDLEdBQUlyNkIsTUFBSyxDQUFHcTZCLFNBQVMsQ0FBRyxDQUF4QixDQUNJdmlDLE1BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BRG5CLENBR0EsTUFBTyxFQUFFa0ksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWtFLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBTCxHQUFpQmhILEtBQXJCLENBQTRCLENBQzFCLE1BQU9nSCxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sQ0FBQyxDQUFSLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNnOUIsa0JBQVQsQ0FBMkJoaEMsS0FBM0IsQ0FBa0NoRCxLQUFsQyxDQUF5Q3FoQyxTQUF6QyxDQUFvRCxDQUNsRCxHQUFJcjZCLE1BQUssQ0FBR3E2QixTQUFTLENBQUcsQ0FBeEIsQ0FDQSxNQUFPcjZCLEtBQUssRUFBWixDQUFnQixDQUNkLEdBQUloRSxLQUFLLENBQUNnRSxLQUFELENBQUwsR0FBaUJoSCxLQUFyQixDQUE0QixDQUMxQixNQUFPZ0gsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPQSxNQUFQLENBQ0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLFFBQVNpOUIsV0FBVCxDQUFvQnpnQyxNQUFwQixDQUE0QixDQUMxQixNQUFPNi9CLFdBQVUsQ0FBQzcvQixNQUFELENBQVYsQ0FDSDBnQyxXQUFXLENBQUMxZ0MsTUFBRCxDQURSLENBRUhxOUIsU0FBUyxDQUFDcjlCLE1BQUQsQ0FGYixDQUdELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxRQUFTMmdDLGNBQVQsQ0FBdUIzZ0MsTUFBdkIsQ0FBK0IsQ0FDN0IsTUFBTzYvQixXQUFVLENBQUM3L0IsTUFBRCxDQUFWLENBQ0g0Z0MsY0FBYyxDQUFDNWdDLE1BQUQsQ0FEWCxDQUVIdTlCLFlBQVksQ0FBQ3Y5QixNQUFELENBRmhCLENBR0QsQ0FFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBUzYrQixnQkFBVCxDQUF5QjcrQixNQUF6QixDQUFpQyxDQUMvQixHQUFJd0QsTUFBSyxDQUFHeEQsTUFBTSxDQUFDMUUsTUFBbkIsQ0FFQSxNQUFPa0ksS0FBSyxJQUFNc3lCLFlBQVksQ0FBQ2dLLElBQWIsQ0FBa0I5L0IsTUFBTSxDQUFDNmdDLE1BQVAsQ0FBY3I5QixLQUFkLENBQWxCLENBQWxCLENBQTJELENBQUUsQ0FDN0QsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FDRSxHQUFJczlCLGlCQUFnQixDQUFHMUMsY0FBYyxDQUFDaEUsYUFBRCxDQUFyQyxDQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3NHLFlBQVQsQ0FBcUIxZ0MsTUFBckIsQ0FBNkIsQ0FDM0IsR0FBSWhILE9BQU0sQ0FBRzBnQyxTQUFTLENBQUNxSCxTQUFWLENBQXNCLENBQW5DLENBQ0EsTUFBT3JILFNBQVMsQ0FBQ29HLElBQVYsQ0FBZTkvQixNQUFmLENBQVAsQ0FBK0IsQ0FDN0IsRUFBRWhILE1BQUYsQ0FDRCxDQUNELE1BQU9BLE9BQVAsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBUzRuQyxlQUFULENBQXdCNWdDLE1BQXhCLENBQWdDLENBQzlCLE1BQU9BLE9BQU0sQ0FBQ0YsS0FBUCxDQUFhNDVCLFNBQWIsR0FBMkIsRUFBbEMsQ0FDRCxDQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQ0UsUUFBU3NILGFBQVQsQ0FBc0JoaEMsTUFBdEIsQ0FBOEIsQ0FDNUIsTUFBT0EsT0FBTSxDQUFDRixLQUFQLENBQWE2NUIsYUFBYixHQUErQixFQUF0QyxDQUNELENBRUQsOEVBaDRDVyxDQWs0Q1g7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUNFLEdBQUlzSCxhQUFZLENBQUksUUFBU0EsYUFBVCxDQUFzQjFkLE9BQXRCLENBQStCLENBQ2pEQSxPQUFPLENBQUdBLE9BQU8sRUFBSSxJQUFYLENBQWtCL0csSUFBbEIsQ0FBeUJ2akIsQ0FBQyxDQUFDaW9DLFFBQUYsQ0FBVzFrQixJQUFJLENBQUNqYSxNQUFMLEVBQVgsQ0FBMEJnaEIsT0FBMUIsQ0FBbUN0cUIsQ0FBQyxDQUFDa29DLElBQUYsQ0FBTzNrQixJQUFQLENBQWFzZCxZQUFiLENBQW5DLENBQW5DLENBRUEsdUNBQ0EsR0FBSTVnQyxNQUFLLENBQUdxcUIsT0FBTyxDQUFDcnFCLEtBQXBCLENBQ0lpQixJQUFJLENBQUdvcEIsT0FBTyxDQUFDcHBCLElBRG5CLENBRUlvSyxLQUFLLENBQUdnZixPQUFPLENBQUNoZixLQUZwQixDQUdJczJCLFFBQVEsQ0FBR3RYLE9BQU8sQ0FBQ3NYLFFBSHZCLENBSUl4aEMsSUFBSSxDQUFHa3FCLE9BQU8sQ0FBQ2xxQixJQUpuQixDQUtJa0osTUFBTSxDQUFHZ2hCLE9BQU8sQ0FBQ2hoQixNQUxyQixDQU1JNHlCLE1BQU0sQ0FBRzVSLE9BQU8sQ0FBQzRSLE1BTnJCLENBT0luRixNQUFNLENBQUd6TSxPQUFPLENBQUN5TSxNQVByQixDQVFJeGUsU0FBUyxDQUFHK1IsT0FBTyxDQUFDL1IsU0FSeEIsQ0FVQSwyQ0FDQSxHQUFJNHZCLFdBQVUsQ0FBR2xvQyxLQUFLLENBQUNtSSxTQUF2QixDQUNJZ2dDLFNBQVMsQ0FBR3hHLFFBQVEsQ0FBQ3g1QixTQUR6QixDQUVJaWdDLFdBQVcsQ0FBRy8rQixNQUFNLENBQUNsQixTQUZ6QixDQUlBLGlEQUNBLEdBQUlrZ0MsV0FBVSxDQUFHaGUsT0FBTyxDQUFDLG9CQUFELENBQXhCLENBRUEsMERBQ0EsR0FBSWllLGFBQVksQ0FBR0gsU0FBUyxDQUFDNStCLFFBQTdCLENBRUEsZ0RBQ0EsR0FBSUgsZUFBYyxDQUFHZy9CLFdBQVcsQ0FBQ2gvQixjQUFqQyxDQUVBLG1DQUNBLEdBQUltL0IsVUFBUyxDQUFHLENBQWhCLENBRUEscURBQ0EsR0FBSUMsV0FBVSxDQUFJLFVBQVcsQ0FDM0IsR0FBSUMsSUFBRyxDQUFHLFNBQVNDLElBQVQsQ0FBY0wsVUFBVSxFQUFJQSxVQUFVLENBQUMvK0IsSUFBekIsRUFBaUMrK0IsVUFBVSxDQUFDLytCLElBQVgsQ0FBZ0JxL0IsUUFBakQsRUFBNkQsRUFBM0UsQ0FBVixDQUNBLE1BQU9GLElBQUcsQ0FBSSxpQkFBbUJBLEdBQXZCLENBQThCLEVBQXhDLENBQ0QsQ0FIaUIsRUFBbEIsQ0FLQTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSUcscUJBQW9CLENBQUdSLFdBQVcsQ0FBQzcrQixRQUF2QyxDQUVBLDhDQUNBLEdBQUlzL0IsaUJBQWdCLENBQUdQLFlBQVksQ0FBQzkrQixJQUFiLENBQWtCSCxNQUFsQixDQUF2QixDQUVBLG9FQUNBLEdBQUl5L0IsUUFBTyxDQUFHeGxCLElBQUksQ0FBQ3ZqQixDQUFuQixDQUVBLDRDQUNBLEdBQUlncEMsV0FBVSxDQUFHOU0sTUFBTSxDQUFDLElBQ3RCcU0sWUFBWSxDQUFDOStCLElBQWIsQ0FBa0JKLGNBQWxCLEVBQWtDdzhCLE9BQWxDLENBQTBDbkosWUFBMUMsQ0FBd0QsTUFBeEQsRUFDQ21KLE9BREQsQ0FDUyx3REFEVCxDQUNtRSxPQURuRSxDQURzQixDQUV3RCxHQUZ6RCxDQUF2QixDQUtBLGlDQUNBLEdBQUlvRCxPQUFNLENBQUdsSCxhQUFhLENBQUd6WCxPQUFPLENBQUMyZSxNQUFYLENBQW9CN21DLFNBQTlDLENBQ0l1SCxNQUFNLENBQUcyZ0IsT0FBTyxDQUFDM2dCLE1BRHJCLENBRUl1L0IsVUFBVSxDQUFHNWUsT0FBTyxDQUFDNGUsVUFGekIsQ0FHSUMsV0FBVyxDQUFHRixNQUFNLENBQUdBLE1BQU0sQ0FBQ0UsV0FBVixDQUF3Qi9tQyxTQUhoRCxDQUlJZ25DLFlBQVksQ0FBR25DLE9BQU8sQ0FBQzM5QixNQUFNLENBQUNrbUIsY0FBUixDQUF3QmxtQixNQUF4QixDQUoxQixDQUtJKy9CLFlBQVksQ0FBRy8vQixNQUFNLENBQUNtSCxNQUwxQixDQU1JdU0sb0JBQW9CLENBQUdxckIsV0FBVyxDQUFDcnJCLG9CQU52QyxDQU9JNEksTUFBTSxDQUFHdWlCLFVBQVUsQ0FBQ3ZpQixNQVB4QixDQVFJMGpCLGdCQUFnQixDQUFHMy9CLE1BQU0sQ0FBR0EsTUFBTSxDQUFDNC9CLGtCQUFWLENBQStCbm5DLFNBUjVELENBU0lvbkMsV0FBVyxDQUFHNy9CLE1BQU0sQ0FBR0EsTUFBTSxDQUFDQyxRQUFWLENBQXFCeEgsU0FUN0MsQ0FVSXFuQyxjQUFjLENBQUc5L0IsTUFBTSxDQUFHQSxNQUFNLENBQUMrL0IsV0FBVixDQUF3QnRuQyxTQVZuRCxDQVlBLEdBQUlxSyxlQUFjLENBQUksVUFBVyxDQUMvQixHQUFJLENBQ0YsR0FBSXUyQixLQUFJLENBQUcyRyxTQUFTLENBQUNyZ0MsTUFBRCxDQUFTLGdCQUFULENBQXBCLENBQ0EwNUIsSUFBSSxDQUFDLEVBQUQsQ0FBSyxFQUFMLENBQVMsRUFBVCxDQUFKLENBQ0EsTUFBT0EsS0FBUCxDQUNELENBQUMsTUFBT3ozQixDQUFQLENBQVUsQ0FBRSxDQUNmLENBTnFCLEVBQXRCLENBUUEsd0JBQ0EsR0FBSXErQixnQkFBZSxDQUFHdGYsT0FBTyxDQUFDdWYsWUFBUixHQUF5QnRtQixJQUFJLENBQUNzbUIsWUFBOUIsRUFBOEN2ZixPQUFPLENBQUN1ZixZQUE1RSxDQUNJQyxNQUFNLENBQUc1b0MsSUFBSSxFQUFJQSxJQUFJLENBQUNDLEdBQUwsR0FBYW9pQixJQUFJLENBQUNyaUIsSUFBTCxDQUFVQyxHQUEvQixFQUFzQ0QsSUFBSSxDQUFDQyxHQUR4RCxDQUVJNG9DLGFBQWEsQ0FBR3pmLE9BQU8sQ0FBQzBmLFVBQVIsR0FBdUJ6bUIsSUFBSSxDQUFDeW1CLFVBQTVCLEVBQTBDMWYsT0FBTyxDQUFDMGYsVUFGdEUsQ0FJQSx3RkFDQSxHQUFJQyxXQUFVLENBQUc3cEMsSUFBSSxDQUFDOGEsSUFBdEIsQ0FDSWd2QixXQUFXLENBQUc5cEMsSUFBSSxDQUFDME4sS0FEdkIsQ0FFSXE4QixnQkFBZ0IsQ0FBRzdnQyxNQUFNLENBQUMyb0IscUJBRjlCLENBR0ltWSxjQUFjLENBQUduQixNQUFNLENBQUdBLE1BQU0sQ0FBQ29CLFFBQVYsQ0FBcUJqb0MsU0FIaEQsQ0FJSWtvQyxjQUFjLENBQUdoZ0IsT0FBTyxDQUFDaWdCLFFBSjdCLENBS0lDLFVBQVUsQ0FBR3JDLFVBQVUsQ0FBQ3pWLElBTDVCLENBTUkrWCxVQUFVLENBQUd4RCxPQUFPLENBQUMzOUIsTUFBTSxDQUFDQyxJQUFSLENBQWNELE1BQWQsQ0FOeEIsQ0FPSW9oQyxTQUFTLENBQUd0cUMsSUFBSSxDQUFDNlMsR0FQckIsQ0FRSTAzQixTQUFTLENBQUd2cUMsSUFBSSxDQUFDOFQsR0FSckIsQ0FTSTAyQixTQUFTLENBQUcxcEMsSUFBSSxDQUFDQyxHQVRyQixDQVVJMHBDLGNBQWMsQ0FBR3ZnQixPQUFPLENBQUNrWCxRQVY3QixDQVdJc0osWUFBWSxDQUFHMXFDLElBQUksQ0FBQzJxQyxNQVh4QixDQVlJQyxhQUFhLENBQUc3QyxVQUFVLENBQUM3eEIsT0FaL0IsQ0FjQSxnRUFDQSxHQUFJMjBCLFNBQVEsQ0FBR3RCLFNBQVMsQ0FBQ3JmLE9BQUQsQ0FBVSxVQUFWLENBQXhCLENBQ0k1TSxHQUFHLENBQUdpc0IsU0FBUyxDQUFDcmYsT0FBRCxDQUFVLEtBQVYsQ0FEbkIsQ0FFSTRnQixPQUFPLENBQUd2QixTQUFTLENBQUNyZixPQUFELENBQVUsU0FBVixDQUZ2QixDQUdJanJCLEdBQUcsQ0FBR3NxQyxTQUFTLENBQUNyZixPQUFELENBQVUsS0FBVixDQUhuQixDQUlJOU0sT0FBTyxDQUFHbXNCLFNBQVMsQ0FBQ3JmLE9BQUQsQ0FBVSxTQUFWLENBSnZCLENBS0k2Z0IsWUFBWSxDQUFHeEIsU0FBUyxDQUFDcmdDLE1BQUQsQ0FBUyxRQUFULENBTDVCLENBT0EsdUNBQ0EsR0FBSThoQyxRQUFPLENBQUc1dEIsT0FBTyxFQUFJLEdBQUlBLFFBQUosRUFBekIsQ0FFQSxnREFDQSxHQUFJNnRCLFVBQVMsQ0FBRyxFQUFoQixDQUVBLCtDQUNBLEdBQUlDLG1CQUFrQixDQUFHdjJCLFFBQVEsQ0FBQ2syQixRQUFELENBQWpDLENBQ0lNLGFBQWEsQ0FBR3gyQixRQUFRLENBQUMySSxHQUFELENBRDVCLENBRUk4dEIsaUJBQWlCLENBQUd6MkIsUUFBUSxDQUFDbTJCLE9BQUQsQ0FGaEMsQ0FHSU8sYUFBYSxDQUFHMTJCLFFBQVEsQ0FBQzFWLEdBQUQsQ0FINUIsQ0FJSXFzQyxpQkFBaUIsQ0FBRzMyQixRQUFRLENBQUN5SSxPQUFELENBSmhDLENBTUEseURBQ0EsR0FBSW11QixZQUFXLENBQUdoaUMsTUFBTSxDQUFHQSxNQUFNLENBQUN2QixTQUFWLENBQXNCaEcsU0FBOUMsQ0FDSXdwQyxhQUFhLENBQUdELFdBQVcsQ0FBR0EsV0FBVyxDQUFDcnlCLE9BQWYsQ0FBeUJsWCxTQUR4RCxDQUVJeXBDLGNBQWMsQ0FBR0YsV0FBVyxDQUFHQSxXQUFXLENBQUNuaUMsUUFBZixDQUEwQnBILFNBRjFELENBSUEsNEVBM0hpRCxDQTZIakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBwQyxPQUFULENBQWdCdm9DLEtBQWhCLENBQXVCLENBQ3JCLEdBQUl3b0MsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QixDQUFDbUcsT0FBTyxDQUFDbkcsS0FBRCxDQUEvQixFQUEwQyxFQUFFQSxLQUFLLFdBQVl5b0MsWUFBbkIsQ0FBOUMsQ0FBK0UsQ0FDN0UsR0FBSXpvQyxLQUFLLFdBQVkwb0MsY0FBckIsQ0FBb0MsQ0FDbEMsTUFBTzFvQyxNQUFQLENBQ0QsQ0FDRCxHQUFJOEYsY0FBYyxDQUFDSSxJQUFmLENBQW9CbEcsS0FBcEIsQ0FBMkIsYUFBM0IsQ0FBSixDQUErQyxDQUM3QyxNQUFPMm9DLGFBQVksQ0FBQzNvQyxLQUFELENBQW5CLENBQ0QsQ0FDRixDQUNELE1BQU8sSUFBSTBvQyxjQUFKLENBQWtCMW9DLEtBQWxCLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJNG9DLFdBQVUsQ0FBSSxVQUFXLENBQzNCLFFBQVNobUMsT0FBVCxFQUFrQixDQUFFLENBQ3BCLE1BQU8sVUFBU2ltQyxLQUFULENBQWdCLENBQ3JCLEdBQUksQ0FBQ0MsUUFBUSxDQUFDRCxLQUFELENBQWIsQ0FBc0IsQ0FDcEIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJL0MsWUFBSixDQUFrQixDQUNoQixNQUFPQSxhQUFZLENBQUMrQyxLQUFELENBQW5CLENBQ0QsQ0FDRGptQyxNQUFNLENBQUNpQyxTQUFQLENBQW1CZ2tDLEtBQW5CLENBQ0EsR0FBSXJzQyxPQUFNLENBQUcsR0FBSW9HLE9BQUosRUFBYixDQUNBQSxNQUFNLENBQUNpQyxTQUFQLENBQW1CaEcsU0FBbkIsQ0FDQSxNQUFPckMsT0FBUCxDQUNELENBWEQsQ0FZRCxDQWRpQixFQUFsQixDQWdCQTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3VzQyxXQUFULEVBQXNCLENBQ3BCO0FBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNMLGNBQVQsQ0FBdUIxb0MsS0FBdkIsQ0FBOEJncEMsUUFBOUIsQ0FBd0MsQ0FDdEMsS0FBS0MsV0FBTCxDQUFtQmpwQyxLQUFuQixDQUNBLEtBQUtrcEMsV0FBTCxDQUFtQixFQUFuQixDQUNBLEtBQUtDLFNBQUwsQ0FBaUIsQ0FBQyxDQUFDSCxRQUFuQixDQUNBLEtBQUtJLFNBQUwsQ0FBaUIsQ0FBakIsQ0FDQSxLQUFLQyxVQUFMLENBQWtCeHFDLFNBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSTBwQyxNQUFNLENBQUNlLGdCQUFQLENBQTBCLENBRXhCO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUNNLFNBQVV6USxRQVJjLENBVXhCO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUNNLFdBQVlDLFVBaEJZLENBa0J4QjtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FDTSxjQUFlQyxhQXhCUyxDQTBCeEI7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQ00sV0FBWSxFQWhDWSxDQWtDeEI7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQ00sVUFBVyxDQUVUO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUNRLElBQUt3UCxNQVJJLENBeENhLENBQTFCLENBb0RBO0FBQ0FBLE1BQU0sQ0FBQzFqQyxTQUFQLENBQW1Ca2tDLFVBQVUsQ0FBQ2xrQyxTQUE5QixDQUNBMGpDLE1BQU0sQ0FBQzFqQyxTQUFQLENBQWlCc0ksV0FBakIsQ0FBK0JvN0IsTUFBL0IsQ0FFQUcsYUFBYSxDQUFDN2pDLFNBQWQsQ0FBMEIrakMsVUFBVSxDQUFDRyxVQUFVLENBQUNsa0MsU0FBWixDQUFwQyxDQUNBNmpDLGFBQWEsQ0FBQzdqQyxTQUFkLENBQXdCc0ksV0FBeEIsQ0FBc0N1N0IsYUFBdEMsQ0FFQSw0RUFsWGlELENBb1hqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNELFlBQVQsQ0FBcUJ6b0MsS0FBckIsQ0FBNEIsQ0FDMUIsS0FBS2lwQyxXQUFMLENBQW1CanBDLEtBQW5CLENBQ0EsS0FBS2twQyxXQUFMLENBQW1CLEVBQW5CLENBQ0EsS0FBS0ssT0FBTCxDQUFlLENBQWYsQ0FDQSxLQUFLQyxZQUFMLENBQW9CLEtBQXBCLENBQ0EsS0FBS0MsYUFBTCxDQUFxQixFQUFyQixDQUNBLEtBQUtDLGFBQUwsQ0FBcUIxVCxnQkFBckIsQ0FDQSxLQUFLMlQsU0FBTCxDQUFpQixFQUFqQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLFVBQVQsRUFBcUIsQ0FDbkIsR0FBSXB0QyxPQUFNLENBQUcsR0FBSWlzQyxZQUFKLENBQWdCLEtBQUtRLFdBQXJCLENBQWIsQ0FDQXpzQyxNQUFNLENBQUMwc0MsV0FBUCxDQUFxQlcsU0FBUyxDQUFDLEtBQUtYLFdBQU4sQ0FBOUIsQ0FDQTFzQyxNQUFNLENBQUMrc0MsT0FBUCxDQUFpQixLQUFLQSxPQUF0QixDQUNBL3NDLE1BQU0sQ0FBQ2d0QyxZQUFQLENBQXNCLEtBQUtBLFlBQTNCLENBQ0FodEMsTUFBTSxDQUFDaXRDLGFBQVAsQ0FBdUJJLFNBQVMsQ0FBQyxLQUFLSixhQUFOLENBQWhDLENBQ0FqdEMsTUFBTSxDQUFDa3RDLGFBQVAsQ0FBdUIsS0FBS0EsYUFBNUIsQ0FDQWx0QyxNQUFNLENBQUNtdEMsU0FBUCxDQUFtQkUsU0FBUyxDQUFDLEtBQUtGLFNBQU4sQ0FBNUIsQ0FDQSxNQUFPbnRDLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTc3RDLFlBQVQsRUFBdUIsQ0FDckIsR0FBSSxLQUFLTixZQUFULENBQXVCLENBQ3JCLEdBQUlodEMsT0FBTSxDQUFHLEdBQUlpc0MsWUFBSixDQUFnQixJQUFoQixDQUFiLENBQ0Fqc0MsTUFBTSxDQUFDK3NDLE9BQVAsQ0FBaUIsQ0FBQyxDQUFsQixDQUNBL3NDLE1BQU0sQ0FBQ2d0QyxZQUFQLENBQXNCLElBQXRCLENBQ0QsQ0FKRCxJQUlPLENBQ0xodEMsTUFBTSxDQUFHLEtBQUt1dEMsS0FBTCxFQUFULENBQ0F2dEMsTUFBTSxDQUFDK3NDLE9BQVAsRUFBa0IsQ0FBQyxDQUFuQixDQUNELENBQ0QsTUFBTy9zQyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3d0QyxVQUFULEVBQXFCLENBQ25CLEdBQUlobkMsTUFBSyxDQUFHLEtBQUtpbUMsV0FBTCxDQUFpQmpwQyxLQUFqQixFQUFaLENBQ0l5SyxHQUFHLENBQUcsS0FBSzgrQixPQURmLENBRUlVLEtBQUssQ0FBRzlqQyxPQUFPLENBQUNuRCxLQUFELENBRm5CLENBR0lrbkMsT0FBTyxDQUFHei9CLEdBQUcsQ0FBRyxDQUhwQixDQUlJMC9CLFNBQVMsQ0FBR0YsS0FBSyxDQUFHam5DLEtBQUssQ0FBQ2xFLE1BQVQsQ0FBa0IsQ0FKdkMsQ0FLSXNyQyxJQUFJLENBQUdDLE9BQU8sQ0FBQyxDQUFELENBQUlGLFNBQUosQ0FBZSxLQUFLUixTQUFwQixDQUxsQixDQU1JcnlCLEtBQUssQ0FBRzh5QixJQUFJLENBQUM5eUIsS0FOakIsQ0FPSWhILEdBQUcsQ0FBRzg1QixJQUFJLENBQUM5NUIsR0FQZixDQVFJeFIsTUFBTSxDQUFHd1IsR0FBRyxDQUFHZ0gsS0FSbkIsQ0FTSXRRLEtBQUssQ0FBR2tqQyxPQUFPLENBQUc1NUIsR0FBSCxDQUFVZ0gsS0FBSyxDQUFHLENBVHJDLENBVUlnekIsU0FBUyxDQUFHLEtBQUtiLGFBVnJCLENBV0ljLFVBQVUsQ0FBR0QsU0FBUyxDQUFDeHJDLE1BWDNCLENBWUlxaEMsUUFBUSxDQUFHLENBWmYsQ0FhSXFLLFNBQVMsQ0FBR3BELFNBQVMsQ0FBQ3RvQyxNQUFELENBQVMsS0FBSzRxQyxhQUFkLENBYnpCLENBZUEsR0FBSSxDQUFDTyxLQUFELEVBQVcsQ0FBQ0MsT0FBRCxFQUFZQyxTQUFTLEVBQUlyckMsTUFBekIsRUFBbUMwckMsU0FBUyxFQUFJMXJDLE1BQS9ELENBQXdFLENBQ3RFLE1BQU8yckMsaUJBQWdCLENBQUN6bkMsS0FBRCxDQUFRLEtBQUtrbUMsV0FBYixDQUF2QixDQUNELENBQ0QsR0FBSTFzQyxPQUFNLENBQUcsRUFBYixDQUVBa3VDLEtBQUssQ0FDTCxNQUFPNXJDLE1BQU0sSUFBTXFoQyxRQUFRLENBQUdxSyxTQUE5QixDQUF5QyxDQUN2Q3hqQyxLQUFLLEVBQUl5RCxHQUFULENBRUEsR0FBSWtnQyxVQUFTLENBQUcsQ0FBQyxDQUFqQixDQUNJM3FDLEtBQUssQ0FBR2dELEtBQUssQ0FBQ2dFLEtBQUQsQ0FEakIsQ0FHQSxNQUFPLEVBQUUyakMsU0FBRixDQUFjSixVQUFyQixDQUFpQyxDQUMvQixHQUFJL29DLEtBQUksQ0FBRzhvQyxTQUFTLENBQUNLLFNBQUQsQ0FBcEIsQ0FDSTlLLFFBQVEsQ0FBR3IrQixJQUFJLENBQUNxK0IsUUFEcEIsQ0FFSTVsQyxJQUFJLENBQUd1SCxJQUFJLENBQUN2SCxJQUZoQixDQUdJMndDLFFBQVEsQ0FBRy9LLFFBQVEsQ0FBQzcvQixLQUFELENBSHZCLENBS0EsR0FBSS9GLElBQUksRUFBSXk3QixhQUFaLENBQTJCLENBQ3pCMTFCLEtBQUssQ0FBRzRxQyxRQUFSLENBQ0QsQ0FGRCxJQUVPLElBQUksQ0FBQ0EsUUFBTCxDQUFlLENBQ3BCLEdBQUkzd0MsSUFBSSxFQUFJdzdCLGdCQUFaLENBQThCLENBQzVCLFFBQVNpVixNQUFULENBQ0QsQ0FGRCxJQUVPLENBQ0wsS0FBTUEsTUFBTixDQUNELENBQ0YsQ0FDRixDQUNEbHVDLE1BQU0sQ0FBQzJqQyxRQUFRLEVBQVQsQ0FBTixDQUFxQm5nQyxLQUFyQixDQUNELENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0Fpc0MsV0FBVyxDQUFDNWpDLFNBQVosQ0FBd0IrakMsVUFBVSxDQUFDRyxVQUFVLENBQUNsa0MsU0FBWixDQUFsQyxDQUNBNGpDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCc0ksV0FBdEIsQ0FBb0NzN0IsV0FBcEMsQ0FFQSw0RUF6ZWlELENBMmVqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvQyxLQUFULENBQWN6MEIsT0FBZCxDQUF1QixDQUNyQixHQUFJcFAsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHc1gsT0FBTyxFQUFJLElBQVgsQ0FBa0IsQ0FBbEIsQ0FBc0JBLE9BQU8sQ0FBQ3RYLE1BRDNDLENBR0EsS0FBS3FjLEtBQUwsR0FDQSxNQUFPLEVBQUVuVSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJcVcsTUFBSyxDQUFHaUIsT0FBTyxDQUFDcFAsS0FBRCxDQUFuQixDQUNBLEtBQUs0UyxHQUFMLENBQVN6RSxLQUFLLENBQUMsQ0FBRCxDQUFkLENBQW1CQSxLQUFLLENBQUMsQ0FBRCxDQUF4QixFQUNELENBQ0YsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMyMUIsVUFBVCxFQUFxQixDQUNuQixLQUFLQyxRQUFMLENBQWdCbkQsWUFBWSxDQUFHQSxZQUFZLENBQUMsSUFBRCxDQUFmLENBQXdCLEVBQXBELENBQ0EsS0FBSzFzQyxJQUFMLENBQVksQ0FBWixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTOHZDLFdBQVQsQ0FBb0I1akMsR0FBcEIsQ0FBeUIsQ0FDdkIsR0FBSTVLLE9BQU0sQ0FBRyxLQUFLdVgsR0FBTCxDQUFTM00sR0FBVCxHQUFpQixNQUFPLE1BQUsyakMsUUFBTCxDQUFjM2pDLEdBQWQsQ0FBckMsQ0FDQSxLQUFLbE0sSUFBTCxFQUFhc0IsTUFBTSxDQUFHLENBQUgsQ0FBTyxDQUExQixDQUNBLE1BQU9BLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5dUMsUUFBVCxDQUFpQjdqQyxHQUFqQixDQUFzQixDQUNwQixHQUFJNUYsS0FBSSxDQUFHLEtBQUt1cEMsUUFBaEIsQ0FDQSxHQUFJbkQsWUFBSixDQUFrQixDQUNoQixHQUFJcHJDLE9BQU0sQ0FBR2dGLElBQUksQ0FBQzRGLEdBQUQsQ0FBakIsQ0FDQSxNQUFPNUssT0FBTSxHQUFLMjNCLGNBQVgsQ0FBNEJ0MUIsU0FBNUIsQ0FBd0NyQyxNQUEvQyxDQUNELENBQ0QsTUFBT3NKLGVBQWMsQ0FBQ0ksSUFBZixDQUFvQjFFLElBQXBCLENBQTBCNEYsR0FBMUIsRUFBaUM1RixJQUFJLENBQUM0RixHQUFELENBQXJDLENBQTZDdkksU0FBcEQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxc0MsUUFBVCxDQUFpQjlqQyxHQUFqQixDQUFzQixDQUNwQixHQUFJNUYsS0FBSSxDQUFHLEtBQUt1cEMsUUFBaEIsQ0FDQSxNQUFPbkQsYUFBWSxDQUFJcG1DLElBQUksQ0FBQzRGLEdBQUQsQ0FBSixHQUFjdkksU0FBbEIsQ0FBK0JpSCxjQUFjLENBQUNJLElBQWYsQ0FBb0IxRSxJQUFwQixDQUEwQjRGLEdBQTFCLENBQWxELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMrakMsUUFBVCxDQUFpQi9qQyxHQUFqQixDQUFzQnBILEtBQXRCLENBQTZCLENBQzNCLEdBQUl3QixLQUFJLENBQUcsS0FBS3VwQyxRQUFoQixDQUNBLEtBQUs3dkMsSUFBTCxFQUFhLEtBQUs2WSxHQUFMLENBQVMzTSxHQUFULEVBQWdCLENBQWhCLENBQW9CLENBQWpDLENBQ0E1RixJQUFJLENBQUM0RixHQUFELENBQUosQ0FBYXdnQyxZQUFZLEVBQUk1bkMsS0FBSyxHQUFLbkIsU0FBM0IsQ0FBd0NzMUIsY0FBeEMsQ0FBeURuMEIsS0FBckUsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0E2cUMsSUFBSSxDQUFDaG1DLFNBQUwsQ0FBZXNXLEtBQWYsQ0FBdUIydkIsU0FBdkIsQ0FDQUQsSUFBSSxDQUFDaG1DLFNBQUwsQ0FBZSxRQUFmLEVBQTJCbW1DLFVBQTNCLENBQ0FILElBQUksQ0FBQ2htQyxTQUFMLENBQWVnUCxHQUFmLENBQXFCbzNCLE9BQXJCLENBQ0FKLElBQUksQ0FBQ2htQyxTQUFMLENBQWVrUCxHQUFmLENBQXFCbTNCLE9BQXJCLENBQ0FMLElBQUksQ0FBQ2htQyxTQUFMLENBQWUrVSxHQUFmLENBQXFCdXhCLE9BQXJCLENBRUEsNEVBamxCaUQsQ0FtbEJqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLFVBQVQsQ0FBbUJoMUIsT0FBbkIsQ0FBNEIsQ0FDMUIsR0FBSXBQLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR3NYLE9BQU8sRUFBSSxJQUFYLENBQWtCLENBQWxCLENBQXNCQSxPQUFPLENBQUN0WCxNQUQzQyxDQUdBLEtBQUtxYyxLQUFMLEdBQ0EsTUFBTyxFQUFFblUsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXFXLE1BQUssQ0FBR2lCLE9BQU8sQ0FBQ3BQLEtBQUQsQ0FBbkIsQ0FDQSxLQUFLNFMsR0FBTCxDQUFTekUsS0FBSyxDQUFDLENBQUQsQ0FBZCxDQUFtQkEsS0FBSyxDQUFDLENBQUQsQ0FBeEIsRUFDRCxDQUNGLENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTazJCLGVBQVQsRUFBMEIsQ0FDeEIsS0FBS04sUUFBTCxDQUFnQixFQUFoQixDQUNBLEtBQUs3dkMsSUFBTCxDQUFZLENBQVosQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvd0MsZ0JBQVQsQ0FBeUJsa0MsR0FBekIsQ0FBOEIsQ0FDNUIsR0FBSTVGLEtBQUksQ0FBRyxLQUFLdXBDLFFBQWhCLENBQ0kvakMsS0FBSyxDQUFHdWtDLFlBQVksQ0FBQy9wQyxJQUFELENBQU80RixHQUFQLENBRHhCLENBR0EsR0FBSUosS0FBSyxDQUFHLENBQVosQ0FBZSxDQUNiLE1BQU8sTUFBUCxDQUNELENBQ0QsR0FBSXU5QixVQUFTLENBQUcvaUMsSUFBSSxDQUFDMUMsTUFBTCxDQUFjLENBQTlCLENBQ0EsR0FBSWtJLEtBQUssRUFBSXU5QixTQUFiLENBQXdCLENBQ3RCL2lDLElBQUksQ0FBQ3lILEdBQUwsR0FDRCxDQUZELElBRU8sQ0FDTG9aLE1BQU0sQ0FBQ25jLElBQVAsQ0FBWTFFLElBQVosQ0FBa0J3RixLQUFsQixDQUF5QixDQUF6QixFQUNELENBQ0QsRUFBRSxLQUFLOUwsSUFBUCxDQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3N3QyxhQUFULENBQXNCcGtDLEdBQXRCLENBQTJCLENBQ3pCLEdBQUk1RixLQUFJLENBQUcsS0FBS3VwQyxRQUFoQixDQUNJL2pDLEtBQUssQ0FBR3VrQyxZQUFZLENBQUMvcEMsSUFBRCxDQUFPNEYsR0FBUCxDQUR4QixDQUdBLE1BQU9KLE1BQUssQ0FBRyxDQUFSLENBQVluSSxTQUFaLENBQXdCMkMsSUFBSSxDQUFDd0YsS0FBRCxDQUFKLENBQVksQ0FBWixDQUEvQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lrQyxhQUFULENBQXNCcmtDLEdBQXRCLENBQTJCLENBQ3pCLE1BQU9ta0MsYUFBWSxDQUFDLEtBQUtSLFFBQU4sQ0FBZ0IzakMsR0FBaEIsQ0FBWixDQUFtQyxDQUFDLENBQTNDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNza0MsYUFBVCxDQUFzQnRrQyxHQUF0QixDQUEyQnBILEtBQTNCLENBQWtDLENBQ2hDLEdBQUl3QixLQUFJLENBQUcsS0FBS3VwQyxRQUFoQixDQUNJL2pDLEtBQUssQ0FBR3VrQyxZQUFZLENBQUMvcEMsSUFBRCxDQUFPNEYsR0FBUCxDQUR4QixDQUdBLEdBQUlKLEtBQUssQ0FBRyxDQUFaLENBQWUsQ0FDYixFQUFFLEtBQUs5TCxJQUFQLENBQ0FzRyxJQUFJLENBQUN5SSxJQUFMLENBQVUsQ0FBQzdDLEdBQUQsQ0FBTXBILEtBQU4sQ0FBVixFQUNELENBSEQsSUFHTyxDQUNMd0IsSUFBSSxDQUFDd0YsS0FBRCxDQUFKLENBQVksQ0FBWixFQUFpQmhILEtBQWpCLENBQ0QsQ0FDRCxNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0FvckMsU0FBUyxDQUFDdm1DLFNBQVYsQ0FBb0JzVyxLQUFwQixDQUE0Qmt3QixjQUE1QixDQUNBRCxTQUFTLENBQUN2bUMsU0FBVixDQUFvQixRQUFwQixFQUFnQ3ltQyxlQUFoQyxDQUNBRixTQUFTLENBQUN2bUMsU0FBVixDQUFvQmdQLEdBQXBCLENBQTBCMjNCLFlBQTFCLENBQ0FKLFNBQVMsQ0FBQ3ZtQyxTQUFWLENBQW9Ca1AsR0FBcEIsQ0FBMEIwM0IsWUFBMUIsQ0FDQUwsU0FBUyxDQUFDdm1DLFNBQVYsQ0FBb0IrVSxHQUFwQixDQUEwQjh4QixZQUExQixDQUVBLDRFQXRzQmlELENBd3NCakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTQyxTQUFULENBQWtCdjFCLE9BQWxCLENBQTJCLENBQ3pCLEdBQUlwUCxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdzWCxPQUFPLEVBQUksSUFBWCxDQUFrQixDQUFsQixDQUFzQkEsT0FBTyxDQUFDdFgsTUFEM0MsQ0FHQSxLQUFLcWMsS0FBTCxHQUNBLE1BQU8sRUFBRW5VLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlxVyxNQUFLLENBQUdpQixPQUFPLENBQUNwUCxLQUFELENBQW5CLENBQ0EsS0FBSzRTLEdBQUwsQ0FBU3pFLEtBQUssQ0FBQyxDQUFELENBQWQsQ0FBbUJBLEtBQUssQ0FBQyxDQUFELENBQXhCLEVBQ0QsQ0FDRixDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3kyQixjQUFULEVBQXlCLENBQ3ZCLEtBQUsxd0MsSUFBTCxDQUFZLENBQVosQ0FDQSxLQUFLNnZDLFFBQUwsQ0FBZ0IsQ0FDZCxPQUFRLEdBQUlGLEtBQUosRUFETSxDQUVkLE1BQU8sSUFBSzF3QixHQUFHLEVBQUlpeEIsU0FBWixHQUZPLENBR2QsU0FBVSxHQUFJUCxLQUFKLEVBSEksQ0FBaEIsQ0FLRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnQixlQUFULENBQXdCemtDLEdBQXhCLENBQTZCLENBQzNCLEdBQUk1SyxPQUFNLENBQUdzdkMsVUFBVSxDQUFDLElBQUQsQ0FBTzFrQyxHQUFQLENBQVYsQ0FBc0IsUUFBdEIsRUFBZ0NBLEdBQWhDLENBQWIsQ0FDQSxLQUFLbE0sSUFBTCxFQUFhc0IsTUFBTSxDQUFHLENBQUgsQ0FBTyxDQUExQixDQUNBLE1BQU9BLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1dkMsWUFBVCxDQUFxQjNrQyxHQUFyQixDQUEwQixDQUN4QixNQUFPMGtDLFdBQVUsQ0FBQyxJQUFELENBQU8xa0MsR0FBUCxDQUFWLENBQXNCeU0sR0FBdEIsQ0FBMEJ6TSxHQUExQixDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNGtDLFlBQVQsQ0FBcUI1a0MsR0FBckIsQ0FBMEIsQ0FDeEIsTUFBTzBrQyxXQUFVLENBQUMsSUFBRCxDQUFPMWtDLEdBQVAsQ0FBVixDQUFzQjJNLEdBQXRCLENBQTBCM00sR0FBMUIsQ0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNmtDLFlBQVQsQ0FBcUI3a0MsR0FBckIsQ0FBMEJwSCxLQUExQixDQUFpQyxDQUMvQixHQUFJd0IsS0FBSSxDQUFHc3FDLFVBQVUsQ0FBQyxJQUFELENBQU8xa0MsR0FBUCxDQUFyQixDQUNJbE0sSUFBSSxDQUFHc0csSUFBSSxDQUFDdEcsSUFEaEIsQ0FHQXNHLElBQUksQ0FBQ29ZLEdBQUwsQ0FBU3hTLEdBQVQsQ0FBY3BILEtBQWQsRUFDQSxLQUFLOUUsSUFBTCxFQUFhc0csSUFBSSxDQUFDdEcsSUFBTCxFQUFhQSxJQUFiLENBQW9CLENBQXBCLENBQXdCLENBQXJDLENBQ0EsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNBeXdDLFFBQVEsQ0FBQzltQyxTQUFULENBQW1Cc1csS0FBbkIsQ0FBMkJ5d0IsYUFBM0IsQ0FDQUQsUUFBUSxDQUFDOW1DLFNBQVQsQ0FBbUIsUUFBbkIsRUFBK0JnbkMsY0FBL0IsQ0FDQUYsUUFBUSxDQUFDOW1DLFNBQVQsQ0FBbUJnUCxHQUFuQixDQUF5Qms0QixXQUF6QixDQUNBSixRQUFRLENBQUM5bUMsU0FBVCxDQUFtQmtQLEdBQW5CLENBQXlCaTRCLFdBQXpCLENBQ0FMLFFBQVEsQ0FBQzltQyxTQUFULENBQW1CK1UsR0FBbkIsQ0FBeUJxeUIsV0FBekIsQ0FFQSw0RUE3eUJpRCxDQSt5QmpEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTQyxTQUFULENBQWtCeHBCLE1BQWxCLENBQTBCLENBQ3hCLEdBQUkxYixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUc0akIsTUFBTSxFQUFJLElBQVYsQ0FBaUIsQ0FBakIsQ0FBcUJBLE1BQU0sQ0FBQzVqQixNQUR6QyxDQUdBLEtBQUtpc0MsUUFBTCxDQUFnQixHQUFJWSxTQUFKLEVBQWhCLENBQ0EsTUFBTyxFQUFFM2tDLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEtBQUt2QyxHQUFMLENBQVNtbUIsTUFBTSxDQUFDMWIsS0FBRCxDQUFmLEVBQ0QsQ0FDRixDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU21sQyxZQUFULENBQXFCbnNDLEtBQXJCLENBQTRCLENBQzFCLEtBQUsrcUMsUUFBTCxDQUFjbnhCLEdBQWQsQ0FBa0I1WixLQUFsQixDQUF5Qm0wQixjQUF6QixFQUNBLE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2lZLFlBQVQsQ0FBcUJwc0MsS0FBckIsQ0FBNEIsQ0FDMUIsTUFBTyxNQUFLK3FDLFFBQUwsQ0FBY2gzQixHQUFkLENBQWtCL1QsS0FBbEIsQ0FBUCxDQUNELENBRUQ7QUFDQWtzQyxRQUFRLENBQUNybkMsU0FBVCxDQUFtQnRJLEdBQW5CLENBQXlCMnZDLFFBQVEsQ0FBQ3JuQyxTQUFULENBQW1Cb0YsSUFBbkIsQ0FBMEJraUMsV0FBbkQsQ0FDQUQsUUFBUSxDQUFDcm5DLFNBQVQsQ0FBbUJrUCxHQUFuQixDQUF5QnE0QixXQUF6QixDQUVBLDRFQWoyQmlELENBbTJCakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTemUsTUFBVCxDQUFldlgsT0FBZixDQUF3QixDQUN0QixHQUFJNVUsS0FBSSxDQUFHLEtBQUt1cEMsUUFBTCxDQUFnQixHQUFJSyxVQUFKLENBQWNoMUIsT0FBZCxDQUEzQixDQUNBLEtBQUtsYixJQUFMLENBQVlzRyxJQUFJLENBQUN0RyxJQUFqQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbXhDLFdBQVQsRUFBc0IsQ0FDcEIsS0FBS3RCLFFBQUwsQ0FBZ0IsR0FBSUssVUFBSixFQUFoQixDQUNBLEtBQUtsd0MsSUFBTCxDQUFZLENBQVosQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNveEMsWUFBVCxDQUFxQmxsQyxHQUFyQixDQUEwQixDQUN4QixHQUFJNUYsS0FBSSxDQUFHLEtBQUt1cEMsUUFBaEIsQ0FDSXZ1QyxNQUFNLENBQUdnRixJQUFJLENBQUMsUUFBRCxDQUFKLENBQWU0RixHQUFmLENBRGIsQ0FHQSxLQUFLbE0sSUFBTCxDQUFZc0csSUFBSSxDQUFDdEcsSUFBakIsQ0FDQSxNQUFPc0IsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUyt2QyxTQUFULENBQWtCbmxDLEdBQWxCLENBQXVCLENBQ3JCLE1BQU8sTUFBSzJqQyxRQUFMLENBQWNsM0IsR0FBZCxDQUFrQnpNLEdBQWxCLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvbEMsU0FBVCxDQUFrQnBsQyxHQUFsQixDQUF1QixDQUNyQixNQUFPLE1BQUsyakMsUUFBTCxDQUFjaDNCLEdBQWQsQ0FBa0IzTSxHQUFsQixDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxbEMsU0FBVCxDQUFrQnJsQyxHQUFsQixDQUF1QnBILEtBQXZCLENBQThCLENBQzVCLEdBQUl3QixLQUFJLENBQUcsS0FBS3VwQyxRQUFoQixDQUNBLEdBQUl2cEMsSUFBSSxXQUFZNHBDLFVBQXBCLENBQStCLENBQzdCLEdBQUlzQixNQUFLLENBQUdsckMsSUFBSSxDQUFDdXBDLFFBQWpCLENBQ0EsR0FBSSxDQUFDNXdCLEdBQUQsRUFBU3V5QixLQUFLLENBQUM1dEMsTUFBTixDQUFlaTFCLGdCQUFnQixDQUFHLENBQS9DLENBQW1ELENBQ2pEMlksS0FBSyxDQUFDemlDLElBQU4sQ0FBVyxDQUFDN0MsR0FBRCxDQUFNcEgsS0FBTixDQUFYLEVBQ0EsS0FBSzlFLElBQUwsQ0FBWSxFQUFFc0csSUFBSSxDQUFDdEcsSUFBbkIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUNEc0csSUFBSSxDQUFHLEtBQUt1cEMsUUFBTCxDQUFnQixHQUFJWSxTQUFKLENBQWFlLEtBQWIsQ0FBdkIsQ0FDRCxDQUNEbHJDLElBQUksQ0FBQ29ZLEdBQUwsQ0FBU3hTLEdBQVQsQ0FBY3BILEtBQWQsRUFDQSxLQUFLOUUsSUFBTCxDQUFZc0csSUFBSSxDQUFDdEcsSUFBakIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0F5eUIsS0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0JzVyxLQUFoQixDQUF3Qmt4QixVQUF4QixDQUNBMWUsS0FBSyxDQUFDOW9CLFNBQU4sQ0FBZ0IsUUFBaEIsRUFBNEJ5bkMsV0FBNUIsQ0FDQTNlLEtBQUssQ0FBQzlvQixTQUFOLENBQWdCZ1AsR0FBaEIsQ0FBc0IwNEIsUUFBdEIsQ0FDQTVlLEtBQUssQ0FBQzlvQixTQUFOLENBQWdCa1AsR0FBaEIsQ0FBc0J5NEIsUUFBdEIsQ0FDQTdlLEtBQUssQ0FBQzlvQixTQUFOLENBQWdCK1UsR0FBaEIsQ0FBc0I2eUIsUUFBdEIsQ0FFQSw0RUF2OEJpRCxDQXk4QmpEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTRSxjQUFULENBQXVCM3NDLEtBQXZCLENBQThCNHNDLFNBQTlCLENBQXlDLENBQ3ZDLEdBQUkzQyxNQUFLLENBQUc5akMsT0FBTyxDQUFDbkcsS0FBRCxDQUFuQixDQUNJNnNDLEtBQUssQ0FBRyxDQUFDNUMsS0FBRCxFQUFVNkMsV0FBVyxDQUFDOXNDLEtBQUQsQ0FEakMsQ0FFSStzQyxNQUFNLENBQUcsQ0FBQzlDLEtBQUQsRUFBVSxDQUFDNEMsS0FBWCxFQUFvQi9GLFFBQVEsQ0FBQzltQyxLQUFELENBRnpDLENBR0lndEMsTUFBTSxDQUFHLENBQUMvQyxLQUFELEVBQVUsQ0FBQzRDLEtBQVgsRUFBb0IsQ0FBQ0UsTUFBckIsRUFBK0J2TixZQUFZLENBQUN4L0IsS0FBRCxDQUh4RCxDQUlJaXRDLFdBQVcsQ0FBR2hELEtBQUssRUFBSTRDLEtBQVQsRUFBa0JFLE1BQWxCLEVBQTRCQyxNQUo5QyxDQUtJeHdDLE1BQU0sQ0FBR3l3QyxXQUFXLENBQUdoTCxTQUFTLENBQUNqaUMsS0FBSyxDQUFDbEIsTUFBUCxDQUFlMDBCLE1BQWYsQ0FBWixDQUFxQyxFQUw3RCxDQU1JMTBCLE1BQU0sQ0FBR3RDLE1BQU0sQ0FBQ3NDLE1BTnBCLENBUUEsSUFBSyxHQUFJc0ksSUFBVCxHQUFnQnBILE1BQWhCLENBQXVCLENBQ3JCLEdBQUksQ0FBQzRzQyxTQUFTLEVBQUk5bUMsY0FBYyxDQUFDSSxJQUFmLENBQW9CbEcsS0FBcEIsQ0FBMkJvSCxHQUEzQixDQUFkLEdBQ0EsRUFBRTZsQyxXQUFXLEdBQ1Y7QUFDQTdsQyxHQUFHLEVBQUksUUFBUCxFQUVDMmxDLE1BQU0sR0FBSzNsQyxHQUFHLEVBQUksUUFBUCxFQUFtQkEsR0FBRyxFQUFJLFFBQS9CLENBRlAsRUFJQzRsQyxNQUFNLEdBQUs1bEMsR0FBRyxFQUFJLFFBQVAsRUFBbUJBLEdBQUcsRUFBSSxZQUExQixFQUEwQ0EsR0FBRyxFQUFJLFlBQXRELENBSlAsRUFLQTtBQUNBOGxDLE9BQU8sQ0FBQzlsQyxHQUFELENBQU10SSxNQUFOLENBUkcsQ0FBYixDQURKLENBVVEsQ0FDTnRDLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWTdDLEdBQVosRUFDRCxDQUNGLENBQ0QsTUFBTzVLLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJ3QyxZQUFULENBQXFCbnFDLEtBQXJCLENBQTRCLENBQzFCLEdBQUlsRSxPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNBLE1BQU9BLE9BQU0sQ0FBR2tFLEtBQUssQ0FBQ29xQyxVQUFVLENBQUMsQ0FBRCxDQUFJdHVDLE1BQU0sQ0FBRyxDQUFiLENBQVgsQ0FBUixDQUFzQ0QsU0FBbkQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTd3VDLGdCQUFULENBQXlCcnFDLEtBQXpCLENBQWdDM0csQ0FBaEMsQ0FBbUMsQ0FDakMsTUFBT2l4QyxZQUFXLENBQUN6RCxTQUFTLENBQUM3bUMsS0FBRCxDQUFWLENBQW1CdXFDLFNBQVMsQ0FBQ2x4QyxDQUFELENBQUksQ0FBSixDQUFPMkcsS0FBSyxDQUFDbEUsTUFBYixDQUE1QixDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMHVDLGFBQVQsQ0FBc0J4cUMsS0FBdEIsQ0FBNkIsQ0FDM0IsTUFBT3NxQyxZQUFXLENBQUN6RCxTQUFTLENBQUM3bUMsS0FBRCxDQUFWLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeXFDLGlCQUFULENBQTBCN3FDLE1BQTFCLENBQWtDd0UsR0FBbEMsQ0FBdUNwSCxLQUF2QyxDQUE4QyxDQUM1QyxHQUFLQSxLQUFLLEdBQUtuQixTQUFWLEVBQXVCLENBQUM2dUMsRUFBRSxDQUFDOXFDLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBUCxDQUFjcEgsS0FBZCxDQUEzQixFQUNDQSxLQUFLLEdBQUtuQixTQUFWLEVBQXVCLEVBQUV1SSxHQUFHLEdBQUl4RSxPQUFULENBRDVCLENBQytDLENBQzdDK3FDLGVBQWUsQ0FBQy9xQyxNQUFELENBQVN3RSxHQUFULENBQWNwSCxLQUFkLENBQWYsQ0FDRCxDQUNGLENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNHRDLFlBQVQsQ0FBcUJockMsTUFBckIsQ0FBNkJ3RSxHQUE3QixDQUFrQ3BILEtBQWxDLENBQXlDLENBQ3ZDLEdBQUk2dEMsU0FBUSxDQUFHanJDLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBckIsQ0FDQSxHQUFJLEVBQUV0QixjQUFjLENBQUNJLElBQWYsQ0FBb0J0RCxNQUFwQixDQUE0QndFLEdBQTVCLEdBQW9Dc21DLEVBQUUsQ0FBQ0csUUFBRCxDQUFXN3RDLEtBQVgsQ0FBeEMsR0FDQ0EsS0FBSyxHQUFLbkIsU0FBVixFQUF1QixFQUFFdUksR0FBRyxHQUFJeEUsT0FBVCxDQUQ1QixDQUMrQyxDQUM3QytxQyxlQUFlLENBQUMvcUMsTUFBRCxDQUFTd0UsR0FBVCxDQUFjcEgsS0FBZCxDQUFmLENBQ0QsQ0FDRixDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdXJDLGFBQVQsQ0FBc0J2b0MsS0FBdEIsQ0FBNkJvRSxHQUE3QixDQUFrQyxDQUNoQyxHQUFJdEksT0FBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFBbkIsQ0FDQSxNQUFPQSxNQUFNLEVBQWIsQ0FBaUIsQ0FDZixHQUFJNHVDLEVBQUUsQ0FBQzFxQyxLQUFLLENBQUNsRSxNQUFELENBQUwsQ0FBYyxDQUFkLENBQUQsQ0FBbUJzSSxHQUFuQixDQUFOLENBQStCLENBQzdCLE1BQU90SSxPQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sQ0FBQyxDQUFSLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2d2QyxlQUFULENBQXdCcmxDLFVBQXhCLENBQW9DbTNCLE1BQXBDLENBQTRDQyxRQUE1QyxDQUFzREMsV0FBdEQsQ0FBbUUsQ0FDakVpTyxRQUFRLENBQUN0bEMsVUFBRCxDQUFhLFNBQVN6SSxLQUFULENBQWdCb0gsR0FBaEIsQ0FBcUJxQixVQUFyQixDQUFpQyxDQUNwRG0zQixNQUFNLENBQUNFLFdBQUQsQ0FBYzkvQixLQUFkLENBQXFCNi9CLFFBQVEsQ0FBQzcvQixLQUFELENBQTdCLENBQXNDeUksVUFBdEMsQ0FBTixDQUNELENBRk8sQ0FBUixDQUdBLE1BQU9xM0IsWUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2tPLFdBQVQsQ0FBb0JwckMsTUFBcEIsQ0FBNEI4RSxNQUE1QixDQUFvQyxDQUNsQyxNQUFPOUUsT0FBTSxFQUFJcXJDLFVBQVUsQ0FBQ3ZtQyxNQUFELENBQVMxQixJQUFJLENBQUMwQixNQUFELENBQWIsQ0FBdUI5RSxNQUF2QixDQUEzQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3NyQyxhQUFULENBQXNCdHJDLE1BQXRCLENBQThCOEUsTUFBOUIsQ0FBc0MsQ0FDcEMsTUFBTzlFLE9BQU0sRUFBSXFyQyxVQUFVLENBQUN2bUMsTUFBRCxDQUFTeW1DLE1BQU0sQ0FBQ3ptQyxNQUFELENBQWYsQ0FBeUI5RSxNQUF6QixDQUEzQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUytxQyxnQkFBVCxDQUF5Qi9xQyxNQUF6QixDQUFpQ3dFLEdBQWpDLENBQXNDcEgsS0FBdEMsQ0FBNkMsQ0FDM0MsR0FBSW9ILEdBQUcsRUFBSSxXQUFQLEVBQXNCOEIsY0FBMUIsQ0FBMEMsQ0FDeENBLGNBQWMsQ0FBQ3RHLE1BQUQsQ0FBU3dFLEdBQVQsQ0FBYyxDQUMxQixlQUFnQixJQURVLENBRTFCLGFBQWMsSUFGWSxDQUcxQixRQUFTcEgsS0FIaUIsQ0FJMUIsV0FBWSxJQUpjLENBQWQsQ0FBZCxDQU1ELENBUEQsSUFPTyxDQUNMNEMsTUFBTSxDQUFDd0UsR0FBRCxDQUFOLENBQWNwSCxLQUFkLENBQ0QsQ0FDRixDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTb3VDLE9BQVQsQ0FBZ0J4ckMsTUFBaEIsQ0FBd0J5ckMsS0FBeEIsQ0FBK0IsQ0FDN0IsR0FBSXJuQyxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUd1dkMsS0FBSyxDQUFDdnZDLE1BRG5CLENBRUl0QyxNQUFNLENBQUdFLEtBQUssQ0FBQ29DLE1BQUQsQ0FGbEIsQ0FHSTh5QixJQUFJLENBQUdodkIsTUFBTSxFQUFJLElBSHJCLENBS0EsTUFBTyxFQUFFb0UsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkJ0QyxNQUFNLENBQUN3SyxLQUFELENBQU4sQ0FBZ0I0cUIsSUFBSSxDQUFHL3lCLFNBQUgsQ0FBZWdWLEdBQUcsQ0FBQ2pSLE1BQUQsQ0FBU3lyQyxLQUFLLENBQUNybkMsS0FBRCxDQUFkLENBQXRDLENBQ0QsQ0FDRCxNQUFPeEssT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUyt3QyxVQUFULENBQW1CbHBDLE1BQW5CLENBQTJCaXFDLEtBQTNCLENBQWtDQyxLQUFsQyxDQUF5QyxDQUN2QyxHQUFJbHFDLE1BQU0sR0FBS0EsTUFBZixDQUF1QixDQUNyQixHQUFJa3FDLEtBQUssR0FBSzF2QyxTQUFkLENBQXlCLENBQ3ZCd0YsTUFBTSxDQUFHQSxNQUFNLEVBQUlrcUMsS0FBVixDQUFrQmxxQyxNQUFsQixDQUEyQmtxQyxLQUFwQyxDQUNELENBQ0QsR0FBSUQsS0FBSyxHQUFLenZDLFNBQWQsQ0FBeUIsQ0FDdkJ3RixNQUFNLENBQUdBLE1BQU0sRUFBSWlxQyxLQUFWLENBQWtCanFDLE1BQWxCLENBQTJCaXFDLEtBQXBDLENBQ0QsQ0FDRixDQUNELE1BQU9qcUMsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbXFDLFVBQVQsQ0FBbUJ4dUMsS0FBbkIsQ0FBMEJ5dUMsT0FBMUIsQ0FBbUNDLFVBQW5DLENBQStDdG5DLEdBQS9DLENBQW9EeEUsTUFBcEQsQ0FBNEQrYyxLQUE1RCxDQUFtRSxDQUNqRSxHQUFJbmpCLE9BQUosQ0FDSW15QyxNQUFNLENBQUdGLE9BQU8sQ0FBR25hLGVBRHZCLENBRUlzYSxNQUFNLENBQUdILE9BQU8sQ0FBR2xhLGVBRnZCLENBR0lzYSxNQUFNLENBQUdKLE9BQU8sQ0FBR2phLGtCQUh2QixDQUtBLEdBQUlrYSxVQUFKLENBQWdCLENBQ2RseUMsTUFBTSxDQUFHb0csTUFBTSxDQUFHOHJDLFVBQVUsQ0FBQzF1QyxLQUFELENBQVFvSCxHQUFSLENBQWF4RSxNQUFiLENBQXFCK2MsS0FBckIsQ0FBYixDQUEyQyt1QixVQUFVLENBQUMxdUMsS0FBRCxDQUFwRSxDQUNELENBQ0QsR0FBSXhELE1BQU0sR0FBS3FDLFNBQWYsQ0FBMEIsQ0FDeEIsTUFBT3JDLE9BQVAsQ0FDRCxDQUNELEdBQUksQ0FBQ3NzQyxRQUFRLENBQUM5b0MsS0FBRCxDQUFiLENBQXNCLENBQ3BCLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUlpcUMsTUFBSyxDQUFHOWpDLE9BQU8sQ0FBQ25HLEtBQUQsQ0FBbkIsQ0FDQSxHQUFJaXFDLEtBQUosQ0FBVyxDQUNUenRDLE1BQU0sQ0FBR3N5QyxjQUFjLENBQUM5dUMsS0FBRCxDQUF2QixDQUNBLEdBQUksQ0FBQzJ1QyxNQUFMLENBQWEsQ0FDWCxNQUFPOUUsVUFBUyxDQUFDN3BDLEtBQUQsQ0FBUXhELE1BQVIsQ0FBaEIsQ0FDRCxDQUNGLENBTEQsSUFLTyxDQUNMLEdBQUl1eUMsSUFBRyxDQUFHQyxNQUFNLENBQUNodkMsS0FBRCxDQUFoQixDQUNJaXZDLE1BQU0sQ0FBR0YsR0FBRyxFQUFJcFksT0FBUCxFQUFrQm9ZLEdBQUcsRUFBSW5ZLE1BRHRDLENBR0EsR0FBSWtRLFFBQVEsQ0FBQzltQyxLQUFELENBQVosQ0FBcUIsQ0FDbkIsTUFBT2t2QyxZQUFXLENBQUNsdkMsS0FBRCxDQUFRMnVDLE1BQVIsQ0FBbEIsQ0FDRCxDQUNELEdBQUlJLEdBQUcsRUFBSS9YLFNBQVAsRUFBb0IrWCxHQUFHLEVBQUkzWSxPQUEzQixFQUF1QzZZLE1BQU0sRUFBSSxDQUFDcnNDLE1BQXRELENBQStELENBQzdEcEcsTUFBTSxDQUFJb3lDLE1BQU0sRUFBSUssTUFBWCxDQUFxQixFQUFyQixDQUEwQkUsZUFBZSxDQUFDbnZDLEtBQUQsQ0FBbEQsQ0FDQSxHQUFJLENBQUMydUMsTUFBTCxDQUFhLENBQ1gsTUFBT0MsT0FBTSxDQUNUUSxhQUFhLENBQUNwdkMsS0FBRCxDQUFRa3VDLFlBQVksQ0FBQzF4QyxNQUFELENBQVN3RCxLQUFULENBQXBCLENBREosQ0FFVHF2QyxXQUFXLENBQUNydkMsS0FBRCxDQUFRZ3VDLFVBQVUsQ0FBQ3h4QyxNQUFELENBQVN3RCxLQUFULENBQWxCLENBRmYsQ0FHRCxDQUNGLENBUEQsSUFPTyxDQUNMLEdBQUksQ0FBQ3k5QixhQUFhLENBQUNzUixHQUFELENBQWxCLENBQXlCLENBQ3ZCLE1BQU9uc0MsT0FBTSxDQUFHNUMsS0FBSCxDQUFXLEVBQXhCLENBQ0QsQ0FDRHhELE1BQU0sQ0FBRzh5QyxjQUFjLENBQUN0dkMsS0FBRCxDQUFRK3VDLEdBQVIsQ0FBYUosTUFBYixDQUF2QixDQUNELENBQ0YsQ0FDRDtBQUNBaHZCLEtBQUssR0FBS0EsS0FBSyxDQUFHLEdBQUlnTyxNQUFKLEVBQWIsQ0FBTCxDQUNBLEdBQUk0aEIsUUFBTyxDQUFHNXZCLEtBQUssQ0FBQzlMLEdBQU4sQ0FBVTdULEtBQVYsQ0FBZCxDQUNBLEdBQUl1dkMsT0FBSixDQUFhLENBQ1gsTUFBT0EsUUFBUCxDQUNELENBQ0Q1dkIsS0FBSyxDQUFDL0YsR0FBTixDQUFVNVosS0FBVixDQUFpQnhELE1BQWpCLEVBRUEsR0FBSTZ2QixLQUFLLENBQUNyc0IsS0FBRCxDQUFULENBQWtCLENBQ2hCQSxLQUFLLENBQUN2QixPQUFOLENBQWMsU0FBUyt3QyxRQUFULENBQW1CLENBQy9CaHpDLE1BQU0sQ0FBQ0QsR0FBUCxDQUFXaXlDLFNBQVMsQ0FBQ2dCLFFBQUQsQ0FBV2YsT0FBWCxDQUFvQkMsVUFBcEIsQ0FBZ0NjLFFBQWhDLENBQTBDeHZDLEtBQTFDLENBQWlEMmYsS0FBakQsQ0FBcEIsRUFDRCxDQUZELEVBR0QsQ0FKRCxJQUlPLElBQUl0RixLQUFLLENBQUNyYSxLQUFELENBQVQsQ0FBa0IsQ0FDdkJBLEtBQUssQ0FBQ3ZCLE9BQU4sQ0FBYyxTQUFTK3dDLFFBQVQsQ0FBbUJwb0MsR0FBbkIsQ0FBd0IsQ0FDcEM1SyxNQUFNLENBQUNvZCxHQUFQLENBQVd4UyxHQUFYLENBQWdCb25DLFNBQVMsQ0FBQ2dCLFFBQUQsQ0FBV2YsT0FBWCxDQUFvQkMsVUFBcEIsQ0FBZ0N0bkMsR0FBaEMsQ0FBcUNwSCxLQUFyQyxDQUE0QzJmLEtBQTVDLENBQXpCLEVBQ0QsQ0FGRCxFQUdELENBRUQsR0FBSTh2QixTQUFRLENBQUdaLE1BQU0sQ0FDaEJELE1BQU0sQ0FBR2MsWUFBSCxDQUFrQkMsVUFEUixDQUVoQmYsTUFBTSxDQUFHVCxNQUFILENBQVlub0MsSUFGdkIsQ0FJQSxHQUFJbThCLE1BQUssQ0FBRzhILEtBQUssQ0FBR3ByQyxTQUFILENBQWU0d0MsUUFBUSxDQUFDenZDLEtBQUQsQ0FBeEMsQ0FDQSsvQixTQUFTLENBQUNvQyxLQUFLLEVBQUluaUMsS0FBVixDQUFpQixTQUFTd3ZDLFFBQVQsQ0FBbUJwb0MsR0FBbkIsQ0FBd0IsQ0FDaEQsR0FBSSs2QixLQUFKLENBQVcsQ0FDVC82QixHQUFHLENBQUdvb0MsUUFBTixDQUNBQSxRQUFRLENBQUd4dkMsS0FBSyxDQUFDb0gsR0FBRCxDQUFoQixDQUNELENBQ0Q7QUFDQXdtQyxXQUFXLENBQUNweEMsTUFBRCxDQUFTNEssR0FBVCxDQUFjb25DLFNBQVMsQ0FBQ2dCLFFBQUQsQ0FBV2YsT0FBWCxDQUFvQkMsVUFBcEIsQ0FBZ0N0bkMsR0FBaEMsQ0FBcUNwSCxLQUFyQyxDQUE0QzJmLEtBQTVDLENBQXZCLENBQVgsQ0FDRCxDQVBRLENBQVQsQ0FRQSxNQUFPbmpCLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU296QyxhQUFULENBQXNCbG9DLE1BQXRCLENBQThCLENBQzVCLEdBQUl5NkIsTUFBSyxDQUFHbjhCLElBQUksQ0FBQzBCLE1BQUQsQ0FBaEIsQ0FDQSxNQUFPLFVBQVM5RSxNQUFULENBQWlCLENBQ3RCLE1BQU9pdEMsZUFBYyxDQUFDanRDLE1BQUQsQ0FBUzhFLE1BQVQsQ0FBaUJ5NkIsS0FBakIsQ0FBckIsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBOLGVBQVQsQ0FBd0JqdEMsTUFBeEIsQ0FBZ0M4RSxNQUFoQyxDQUF3Q3k2QixLQUF4QyxDQUErQyxDQUM3QyxHQUFJcmpDLE9BQU0sQ0FBR3FqQyxLQUFLLENBQUNyakMsTUFBbkIsQ0FDQSxHQUFJOEQsTUFBTSxFQUFJLElBQWQsQ0FBb0IsQ0FDbEIsTUFBTyxDQUFDOUQsTUFBUixDQUNELENBQ0Q4RCxNQUFNLENBQUdtRCxNQUFNLENBQUNuRCxNQUFELENBQWYsQ0FDQSxNQUFPOUQsTUFBTSxFQUFiLENBQWlCLENBQ2YsR0FBSXNJLElBQUcsQ0FBRys2QixLQUFLLENBQUNyakMsTUFBRCxDQUFmLENBQ0lxSSxTQUFTLENBQUdPLE1BQU0sQ0FBQ04sR0FBRCxDQUR0QixDQUVJcEgsS0FBSyxDQUFHNEMsTUFBTSxDQUFDd0UsR0FBRCxDQUZsQixDQUlBLEdBQUtwSCxLQUFLLEdBQUtuQixTQUFWLEVBQXVCLEVBQUV1SSxHQUFHLEdBQUl4RSxPQUFULENBQXhCLEVBQTZDLENBQUN1RSxTQUFTLENBQUNuSCxLQUFELENBQTNELENBQW9FLENBQ2xFLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzh2QyxVQUFULENBQW1CclEsSUFBbkIsQ0FBeUJzUSxJQUF6QixDQUErQmpvQyxJQUEvQixDQUFxQyxDQUNuQyxHQUFJLE1BQU8yM0IsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLEtBQU0sSUFBSXpxQixVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNELE1BQU93UyxXQUFVLENBQUMsVUFBVyxDQUFFaEgsSUFBSSxDQUFDLzZCLEtBQUwsQ0FBVzdGLFNBQVgsQ0FBc0JpSixJQUF0QixFQUE4QixDQUE1QyxDQUE4Q2lvQyxJQUE5QyxDQUFqQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLGVBQVQsQ0FBd0JodEMsS0FBeEIsQ0FBK0IwZixNQUEvQixDQUF1Q21kLFFBQXZDLENBQWlEMWpCLFVBQWpELENBQTZELENBQzNELEdBQUluVixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0k4UCxRQUFRLENBQUdzcEIsYUFEZixDQUVJNlAsUUFBUSxDQUFHLElBRmYsQ0FHSW54QyxNQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUhuQixDQUlJdEMsTUFBTSxDQUFHLEVBSmIsQ0FLSTB6QyxZQUFZLENBQUd4dEIsTUFBTSxDQUFDNWpCLE1BTDFCLENBT0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPdEMsT0FBUCxDQUNELENBQ0QsR0FBSXFqQyxRQUFKLENBQWMsQ0FDWm5kLE1BQU0sQ0FBRzZkLFFBQVEsQ0FBQzdkLE1BQUQsQ0FBUzZmLFNBQVMsQ0FBQzFDLFFBQUQsQ0FBbEIsQ0FBakIsQ0FDRCxDQUNELEdBQUkxakIsVUFBSixDQUFnQixDQUNkckYsUUFBUSxDQUFHd3BCLGlCQUFYLENBQ0EyUCxRQUFRLENBQUcsS0FBWCxDQUNELENBSEQsSUFJSyxJQUFJdnRCLE1BQU0sQ0FBQzVqQixNQUFQLEVBQWlCaTFCLGdCQUFyQixDQUF1QyxDQUMxQ2pkLFFBQVEsQ0FBRzJyQixRQUFYLENBQ0F3TixRQUFRLENBQUcsS0FBWCxDQUNBdnRCLE1BQU0sQ0FBRyxHQUFJd3BCLFNBQUosQ0FBYXhwQixNQUFiLENBQVQsQ0FDRCxDQUNEZ29CLEtBQUssQ0FDTCxNQUFPLEVBQUUxakMsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWtCLE1BQUssQ0FBR2dELEtBQUssQ0FBQ2dFLEtBQUQsQ0FBakIsQ0FDSTRqQyxRQUFRLENBQUcvSyxRQUFRLEVBQUksSUFBWixDQUFtQjcvQixLQUFuQixDQUEyQjYvQixRQUFRLENBQUM3L0IsS0FBRCxDQURsRCxDQUdBQSxLQUFLLENBQUltYyxVQUFVLEVBQUluYyxLQUFLLEdBQUssQ0FBekIsQ0FBOEJBLEtBQTlCLENBQXNDLENBQTlDLENBQ0EsR0FBSWl3QyxRQUFRLEVBQUlyRixRQUFRLEdBQUtBLFFBQTdCLENBQXVDLENBQ3JDLEdBQUl1RixZQUFXLENBQUdELFlBQWxCLENBQ0EsTUFBT0MsV0FBVyxFQUFsQixDQUFzQixDQUNwQixHQUFJenRCLE1BQU0sQ0FBQ3l0QixXQUFELENBQU4sR0FBd0J2RixRQUE1QixDQUFzQyxDQUNwQyxRQUFTRixNQUFULENBQ0QsQ0FDRixDQUNEbHVDLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWWpLLEtBQVosRUFDRCxDQVJELElBU0ssSUFBSSxDQUFDOFcsUUFBUSxDQUFDNEwsTUFBRCxDQUFTa29CLFFBQVQsQ0FBbUJ6dUIsVUFBbkIsQ0FBYixDQUE2QyxDQUNoRDNmLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWWpLLEtBQVosRUFDRCxDQUNGLENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJdXhDLFNBQVEsQ0FBR3FDLGNBQWMsQ0FBQ0MsVUFBRCxDQUE3QixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJQyxjQUFhLENBQUdGLGNBQWMsQ0FBQ0csZUFBRCxDQUFrQixJQUFsQixDQUFsQyxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLFVBQVQsQ0FBbUIvbkMsVUFBbkIsQ0FBK0J0QixTQUEvQixDQUEwQyxDQUN4QyxHQUFJM0ssT0FBTSxDQUFHLElBQWIsQ0FDQXV4QyxRQUFRLENBQUN0bEMsVUFBRCxDQUFhLFNBQVN6SSxLQUFULENBQWdCZ0gsS0FBaEIsQ0FBdUJ5QixVQUF2QixDQUFtQyxDQUN0RGpNLE1BQU0sQ0FBRyxDQUFDLENBQUMySyxTQUFTLENBQUNuSCxLQUFELENBQVFnSCxLQUFSLENBQWV5QixVQUFmLENBQXBCLENBQ0EsTUFBT2pNLE9BQVAsQ0FDRCxDQUhPLENBQVIsQ0FJQSxNQUFPQSxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpMEMsYUFBVCxDQUFzQnp0QyxLQUF0QixDQUE2QjY4QixRQUE3QixDQUF1QzFqQixVQUF2QyxDQUFtRCxDQUNqRCxHQUFJblYsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFEbkIsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNJZzdCLE9BQU8sQ0FBR25DLFFBQVEsQ0FBQzcvQixLQUFELENBRHRCLENBR0EsR0FBSWdpQyxPQUFPLEVBQUksSUFBWCxHQUFvQjRJLFFBQVEsR0FBSy9yQyxTQUFiLENBQ2ZtakMsT0FBTyxHQUFLQSxPQUFaLEVBQXVCLENBQUMwTyxRQUFRLENBQUMxTyxPQUFELENBRGpCLENBRWhCN2xCLFVBQVUsQ0FBQzZsQixPQUFELENBQVU0SSxRQUFWLENBRmQsQ0FBSixDQUdPLENBQ0wsR0FBSUEsU0FBUSxDQUFHNUksT0FBZixDQUNJeGxDLE1BQU0sQ0FBR3dELEtBRGIsQ0FFRCxDQUNGLENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU20wQyxTQUFULENBQWtCM3RDLEtBQWxCLENBQXlCaEQsS0FBekIsQ0FBZ0NzWCxLQUFoQyxDQUF1Q2hILEdBQXZDLENBQTRDLENBQzFDLEdBQUl4UixPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUVBd1ksS0FBSyxDQUFHczVCLFNBQVMsQ0FBQ3Q1QixLQUFELENBQWpCLENBQ0EsR0FBSUEsS0FBSyxDQUFHLENBQVosQ0FBZSxDQUNiQSxLQUFLLENBQUcsQ0FBQ0EsS0FBRCxDQUFTeFksTUFBVCxDQUFrQixDQUFsQixDQUF1QkEsTUFBTSxDQUFHd1ksS0FBeEMsQ0FDRCxDQUNEaEgsR0FBRyxDQUFJQSxHQUFHLEdBQUt6UixTQUFSLEVBQXFCeVIsR0FBRyxDQUFHeFIsTUFBNUIsQ0FBc0NBLE1BQXRDLENBQStDOHhDLFNBQVMsQ0FBQ3RnQyxHQUFELENBQTlELENBQ0EsR0FBSUEsR0FBRyxDQUFHLENBQVYsQ0FBYSxDQUNYQSxHQUFHLEVBQUl4UixNQUFQLENBQ0QsQ0FDRHdSLEdBQUcsQ0FBR2dILEtBQUssQ0FBR2hILEdBQVIsQ0FBYyxDQUFkLENBQWtCdWdDLFFBQVEsQ0FBQ3ZnQyxHQUFELENBQWhDLENBQ0EsTUFBT2dILEtBQUssQ0FBR2hILEdBQWYsQ0FBb0IsQ0FDbEJ0TixLQUFLLENBQUNzVSxLQUFLLEVBQU4sQ0FBTCxDQUFpQnRYLEtBQWpCLENBQ0QsQ0FDRCxNQUFPZ0QsTUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM4dEMsV0FBVCxDQUFvQnJvQyxVQUFwQixDQUFnQ3RCLFNBQWhDLENBQTJDLENBQ3pDLEdBQUkzSyxPQUFNLENBQUcsRUFBYixDQUNBdXhDLFFBQVEsQ0FBQ3RsQyxVQUFELENBQWEsU0FBU3pJLEtBQVQsQ0FBZ0JnSCxLQUFoQixDQUF1QnlCLFVBQXZCLENBQW1DLENBQ3RELEdBQUl0QixTQUFTLENBQUNuSCxLQUFELENBQVFnSCxLQUFSLENBQWV5QixVQUFmLENBQWIsQ0FBeUMsQ0FDdkNqTSxNQUFNLENBQUN5TixJQUFQLENBQVlqSyxLQUFaLEVBQ0QsQ0FDRixDQUpPLENBQVIsQ0FLQSxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1MEMsWUFBVCxDQUFxQi90QyxLQUFyQixDQUE0QjRtQixLQUE1QixDQUFtQ3ppQixTQUFuQyxDQUE4QzZwQyxRQUE5QyxDQUF3RHgwQyxNQUF4RCxDQUFnRSxDQUM5RCxHQUFJd0ssTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFEbkIsQ0FHQXFJLFNBQVMsR0FBS0EsU0FBUyxDQUFHOHBDLGFBQWpCLENBQVQsQ0FDQXowQyxNQUFNLEdBQUtBLE1BQU0sQ0FBRyxFQUFkLENBQU4sQ0FFQSxNQUFPLEVBQUV3SyxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNBLEdBQUk0aUIsS0FBSyxDQUFHLENBQVIsRUFBYXppQixTQUFTLENBQUNuSCxLQUFELENBQTFCLENBQW1DLENBQ2pDLEdBQUk0cEIsS0FBSyxDQUFHLENBQVosQ0FBZSxDQUNiO0FBQ0FtbkIsV0FBVyxDQUFDL3dDLEtBQUQsQ0FBUTRwQixLQUFLLENBQUcsQ0FBaEIsQ0FBbUJ6aUIsU0FBbkIsQ0FBOEI2cEMsUUFBOUIsQ0FBd0N4MEMsTUFBeEMsQ0FBWCxDQUNELENBSEQsSUFHTyxDQUNMZ2tDLFNBQVMsQ0FBQ2hrQyxNQUFELENBQVN3RCxLQUFULENBQVQsQ0FDRCxDQUNGLENBUEQsSUFPTyxJQUFJLENBQUNneEMsUUFBTCxDQUFlLENBQ3BCeDBDLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDc0MsTUFBUixDQUFOLENBQXdCa0IsS0FBeEIsQ0FDRCxDQUNGLENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJMDBDLFFBQU8sQ0FBR0MsYUFBYSxFQUEzQixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSUMsYUFBWSxDQUFHRCxhQUFhLENBQUMsSUFBRCxDQUFoQyxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTZCxXQUFULENBQW9CenRDLE1BQXBCLENBQTRCaTlCLFFBQTVCLENBQXNDLENBQ3BDLE1BQU9qOUIsT0FBTSxFQUFJc3VDLE9BQU8sQ0FBQ3R1QyxNQUFELENBQVNpOUIsUUFBVCxDQUFtQjc1QixJQUFuQixDQUF4QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1cUMsZ0JBQVQsQ0FBeUIzdEMsTUFBekIsQ0FBaUNpOUIsUUFBakMsQ0FBMkMsQ0FDekMsTUFBT2o5QixPQUFNLEVBQUl3dUMsWUFBWSxDQUFDeHVDLE1BQUQsQ0FBU2k5QixRQUFULENBQW1CNzVCLElBQW5CLENBQTdCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTcXJDLGNBQVQsQ0FBdUJ6dUMsTUFBdkIsQ0FBK0J1L0IsS0FBL0IsQ0FBc0MsQ0FDcEMsTUFBT2pDLFlBQVcsQ0FBQ2lDLEtBQUQsQ0FBUSxTQUFTLzZCLEdBQVQsQ0FBYyxDQUN0QyxNQUFPM0MsV0FBVSxDQUFDN0IsTUFBTSxDQUFDd0UsR0FBRCxDQUFQLENBQWpCLENBQ0QsQ0FGaUIsQ0FBbEIsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa3FDLFFBQVQsQ0FBaUIxdUMsTUFBakIsQ0FBeUJrSixJQUF6QixDQUErQixDQUM3QkEsSUFBSSxDQUFHeWxDLFFBQVEsQ0FBQ3psQyxJQUFELENBQU9sSixNQUFQLENBQWYsQ0FFQSxHQUFJb0UsTUFBSyxDQUFHLENBQVosQ0FDSWxJLE1BQU0sQ0FBR2dOLElBQUksQ0FBQ2hOLE1BRGxCLENBR0EsTUFBTzhELE1BQU0sRUFBSSxJQUFWLEVBQWtCb0UsS0FBSyxDQUFHbEksTUFBakMsQ0FBeUMsQ0FDdkM4RCxNQUFNLENBQUdBLE1BQU0sQ0FBQzR1QyxLQUFLLENBQUMxbEMsSUFBSSxDQUFDOUUsS0FBSyxFQUFOLENBQUwsQ0FBTixDQUFmLENBQ0QsQ0FDRCxNQUFRQSxNQUFLLEVBQUlBLEtBQUssRUFBSWxJLE1BQW5CLENBQTZCOEQsTUFBN0IsQ0FBc0MvRCxTQUE3QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0eUMsZUFBVCxDQUF3Qjd1QyxNQUF4QixDQUFnQzZzQyxRQUFoQyxDQUEwQ2lDLFdBQTFDLENBQXVELENBQ3JELEdBQUlsMUMsT0FBTSxDQUFHaXpDLFFBQVEsQ0FBQzdzQyxNQUFELENBQXJCLENBQ0EsTUFBT3VELFFBQU8sQ0FBQ3ZELE1BQUQsQ0FBUCxDQUFrQnBHLE1BQWxCLENBQTJCZ2tDLFNBQVMsQ0FBQ2hrQyxNQUFELENBQVNrMUMsV0FBVyxDQUFDOXVDLE1BQUQsQ0FBcEIsQ0FBM0MsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUyt1QyxXQUFULENBQW9CM3hDLEtBQXBCLENBQTJCLENBQ3pCLEdBQUlBLEtBQUssRUFBSSxJQUFiLENBQW1CLENBQ2pCLE1BQU9BLE1BQUssR0FBS25CLFNBQVYsQ0FBc0IwNEIsWUFBdEIsQ0FBcUNSLE9BQTVDLENBQ0QsQ0FDRCxNQUFRbVAsZUFBYyxFQUFJQSxjQUFjLEdBQUluZ0MsT0FBTSxDQUFDL0YsS0FBRCxDQUEzQyxDQUNINHhDLFNBQVMsQ0FBQzV4QyxLQUFELENBRE4sQ0FFSDZ4QyxjQUFjLENBQUM3eEMsS0FBRCxDQUZsQixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzh4QyxPQUFULENBQWdCOXhDLEtBQWhCLENBQXVCa1gsS0FBdkIsQ0FBOEIsQ0FDNUIsTUFBT2xYLE1BQUssQ0FBR2tYLEtBQWYsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNjZCLFFBQVQsQ0FBaUJudkMsTUFBakIsQ0FBeUJ3RSxHQUF6QixDQUE4QixDQUM1QixNQUFPeEUsT0FBTSxFQUFJLElBQVYsRUFBa0JrRCxjQUFjLENBQUNJLElBQWYsQ0FBb0J0RCxNQUFwQixDQUE0QndFLEdBQTVCLENBQXpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzRxQyxVQUFULENBQW1CcHZDLE1BQW5CLENBQTJCd0UsR0FBM0IsQ0FBZ0MsQ0FDOUIsTUFBT3hFLE9BQU0sRUFBSSxJQUFWLEVBQWtCd0UsR0FBRyxHQUFJckIsT0FBTSxDQUFDbkQsTUFBRCxDQUF0QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3F2QyxZQUFULENBQXFCNXRDLE1BQXJCLENBQTZCaVQsS0FBN0IsQ0FBb0NoSCxHQUFwQyxDQUF5QyxDQUN2QyxNQUFPak0sT0FBTSxFQUFJK2lDLFNBQVMsQ0FBQzl2QixLQUFELENBQVFoSCxHQUFSLENBQW5CLEVBQW1Dak0sTUFBTSxDQUFHOGlDLFNBQVMsQ0FBQzd2QixLQUFELENBQVFoSCxHQUFSLENBQTVELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0aEMsaUJBQVQsQ0FBMEJDLE1BQTFCLENBQWtDdFMsUUFBbEMsQ0FBNEMxakIsVUFBNUMsQ0FBd0QsQ0FDdEQsR0FBSXJGLFNBQVEsQ0FBR3FGLFVBQVUsQ0FBR21rQixpQkFBSCxDQUF1QkYsYUFBaEQsQ0FDSXRoQyxNQUFNLENBQUdxekMsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVcnpDLE1BRHZCLENBRUlzekMsU0FBUyxDQUFHRCxNQUFNLENBQUNyekMsTUFGdkIsQ0FHSXV6QyxRQUFRLENBQUdELFNBSGYsQ0FJSUUsTUFBTSxDQUFHNTFDLEtBQUssQ0FBQzAxQyxTQUFELENBSmxCLENBS0lHLFNBQVMsQ0FBRzM3QixRQUxoQixDQU1JcGEsTUFBTSxDQUFHLEVBTmIsQ0FRQSxNQUFPNjFDLFFBQVEsRUFBZixDQUFtQixDQUNqQixHQUFJcnZDLE1BQUssQ0FBR212QyxNQUFNLENBQUNFLFFBQUQsQ0FBbEIsQ0FDQSxHQUFJQSxRQUFRLEVBQUl4UyxRQUFoQixDQUEwQixDQUN4Qjc4QixLQUFLLENBQUd1OUIsUUFBUSxDQUFDdjlCLEtBQUQsQ0FBUXUvQixTQUFTLENBQUMxQyxRQUFELENBQWpCLENBQWhCLENBQ0QsQ0FDRDBTLFNBQVMsQ0FBR25MLFNBQVMsQ0FBQ3BrQyxLQUFLLENBQUNsRSxNQUFQLENBQWV5ekMsU0FBZixDQUFyQixDQUNBRCxNQUFNLENBQUNELFFBQUQsQ0FBTixDQUFtQixDQUFDbDJCLFVBQUQsR0FBZ0IwakIsUUFBUSxFQUFLL2dDLE1BQU0sRUFBSSxHQUFWLEVBQWlCa0UsS0FBSyxDQUFDbEUsTUFBTixFQUFnQixHQUE5RCxFQUNmLEdBQUlvdEMsU0FBSixDQUFhbUcsUUFBUSxFQUFJcnZDLEtBQXpCLENBRGUsQ0FFZm5FLFNBRkosQ0FHRCxDQUNEbUUsS0FBSyxDQUFHbXZDLE1BQU0sQ0FBQyxDQUFELENBQWQsQ0FFQSxHQUFJbnJDLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSXdyQyxJQUFJLENBQUdGLE1BQU0sQ0FBQyxDQUFELENBRGpCLENBR0E1SCxLQUFLLENBQ0wsTUFBTyxFQUFFMWpDLEtBQUYsQ0FBVWxJLE1BQVYsRUFBb0J0QyxNQUFNLENBQUNzQyxNQUFQLENBQWdCeXpDLFNBQTNDLENBQXNELENBQ3BELEdBQUl2eUMsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNJNGpDLFFBQVEsQ0FBRy9LLFFBQVEsQ0FBR0EsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBWCxDQUFxQkEsS0FENUMsQ0FHQUEsS0FBSyxDQUFJbWMsVUFBVSxFQUFJbmMsS0FBSyxHQUFLLENBQXpCLENBQThCQSxLQUE5QixDQUFzQyxDQUE5QyxDQUNBLEdBQUksRUFBRXd5QyxJQUFJLENBQ0YvUCxRQUFRLENBQUMrUCxJQUFELENBQU81SCxRQUFQLENBRE4sQ0FFRjl6QixRQUFRLENBQUN0YSxNQUFELENBQVNvdUMsUUFBVCxDQUFtQnp1QixVQUFuQixDQUZaLENBQUosQ0FHTyxDQUNMazJCLFFBQVEsQ0FBR0QsU0FBWCxDQUNBLE1BQU8sRUFBRUMsUUFBVCxDQUFtQixDQUNqQixHQUFJMTlCLE1BQUssQ0FBRzI5QixNQUFNLENBQUNELFFBQUQsQ0FBbEIsQ0FDQSxHQUFJLEVBQUUxOUIsS0FBSyxDQUNIOHRCLFFBQVEsQ0FBQzl0QixLQUFELENBQVFpMkIsUUFBUixDQURMLENBRUg5ekIsUUFBUSxDQUFDcTdCLE1BQU0sQ0FBQ0UsUUFBRCxDQUFQLENBQW1CekgsUUFBbkIsQ0FBNkJ6dUIsVUFBN0IsQ0FGWixDQUFKLENBR00sQ0FDSixRQUFTdXVCLE1BQVQsQ0FDRCxDQUNGLENBQ0QsR0FBSThILElBQUosQ0FBVSxDQUNSQSxJQUFJLENBQUN2b0MsSUFBTCxDQUFVMmdDLFFBQVYsRUFDRCxDQUNEcHVDLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWWpLLEtBQVosRUFDRCxDQUNGLENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaTJDLGFBQVQsQ0FBc0I3dkMsTUFBdEIsQ0FBOEJnOUIsTUFBOUIsQ0FBc0NDLFFBQXRDLENBQWdEQyxXQUFoRCxDQUE2RCxDQUMzRHVRLFVBQVUsQ0FBQ3p0QyxNQUFELENBQVMsU0FBUzVDLEtBQVQsQ0FBZ0JvSCxHQUFoQixDQUFxQnhFLE1BQXJCLENBQTZCLENBQzlDZzlCLE1BQU0sQ0FBQ0UsV0FBRCxDQUFjRCxRQUFRLENBQUM3L0IsS0FBRCxDQUF0QixDQUErQm9ILEdBQS9CLENBQW9DeEUsTUFBcEMsQ0FBTixDQUNELENBRlMsQ0FBVixDQUdBLE1BQU9rOUIsWUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNFMsV0FBVCxDQUFvQjl2QyxNQUFwQixDQUE0QmtKLElBQTVCLENBQWtDaEUsSUFBbEMsQ0FBd0MsQ0FDdENnRSxJQUFJLENBQUd5bEMsUUFBUSxDQUFDemxDLElBQUQsQ0FBT2xKLE1BQVAsQ0FBZixDQUNBQSxNQUFNLENBQUdsSCxNQUFNLENBQUNrSCxNQUFELENBQVNrSixJQUFULENBQWYsQ0FDQSxHQUFJMnpCLEtBQUksQ0FBRzc4QixNQUFNLEVBQUksSUFBVixDQUFpQkEsTUFBakIsQ0FBMEJBLE1BQU0sQ0FBQzR1QyxLQUFLLENBQUN4MEMsSUFBSSxDQUFDOE8sSUFBRCxDQUFMLENBQU4sQ0FBM0MsQ0FDQSxNQUFPMnpCLEtBQUksRUFBSSxJQUFSLENBQWU1Z0MsU0FBZixDQUEyQjZGLEtBQUssQ0FBQys2QixJQUFELENBQU83OEIsTUFBUCxDQUFla0YsSUFBZixDQUF2QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNnFDLGdCQUFULENBQXlCM3lDLEtBQXpCLENBQWdDLENBQzlCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCbzJCLE9BQW5ELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3YyxrQkFBVCxDQUEyQjV5QyxLQUEzQixDQUFrQyxDQUNoQyxNQUFPd29DLGFBQVksQ0FBQ3hvQyxLQUFELENBQVosRUFBdUIyeEMsVUFBVSxDQUFDM3hDLEtBQUQsQ0FBVixFQUFxQjAzQixjQUFuRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbWIsV0FBVCxDQUFvQjd5QyxLQUFwQixDQUEyQixDQUN6QixNQUFPd29DLGFBQVksQ0FBQ3hvQyxLQUFELENBQVosRUFBdUIyeEMsVUFBVSxDQUFDM3hDLEtBQUQsQ0FBVixFQUFxQncyQixPQUFuRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzYyxZQUFULENBQXFCOXlDLEtBQXJCLENBQTRCa1gsS0FBNUIsQ0FBbUN1M0IsT0FBbkMsQ0FBNENDLFVBQTVDLENBQXdEL3VCLEtBQXhELENBQStELENBQzdELEdBQUkzZixLQUFLLEdBQUtrWCxLQUFkLENBQXFCLENBQ25CLE1BQU8sS0FBUCxDQUNELENBQ0QsR0FBSWxYLEtBQUssRUFBSSxJQUFULEVBQWlCa1gsS0FBSyxFQUFJLElBQTFCLEVBQW1DLENBQUNzeEIsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBYixFQUF3QixDQUFDd29DLFlBQVksQ0FBQ3R4QixLQUFELENBQTVFLENBQXNGLENBQ3BGLE1BQU9sWCxNQUFLLEdBQUtBLEtBQVYsRUFBbUJrWCxLQUFLLEdBQUtBLEtBQXBDLENBQ0QsQ0FDRCxNQUFPNjdCLGdCQUFlLENBQUMveUMsS0FBRCxDQUFRa1gsS0FBUixDQUFldTNCLE9BQWYsQ0FBd0JDLFVBQXhCLENBQW9Db0UsV0FBcEMsQ0FBaURuekIsS0FBakQsQ0FBdEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTb3pCLGdCQUFULENBQXlCbndDLE1BQXpCLENBQWlDc1UsS0FBakMsQ0FBd0N1M0IsT0FBeEMsQ0FBaURDLFVBQWpELENBQTZEc0UsU0FBN0QsQ0FBd0VyekIsS0FBeEUsQ0FBK0UsQ0FDN0UsR0FBSXN6QixTQUFRLENBQUc5c0MsT0FBTyxDQUFDdkQsTUFBRCxDQUF0QixDQUNJc3dDLFFBQVEsQ0FBRy9zQyxPQUFPLENBQUMrUSxLQUFELENBRHRCLENBRUlpOEIsTUFBTSxDQUFHRixRQUFRLENBQUc1YyxRQUFILENBQWMyWSxNQUFNLENBQUNwc0MsTUFBRCxDQUZ6QyxDQUdJd3dDLE1BQU0sQ0FBR0YsUUFBUSxDQUFHN2MsUUFBSCxDQUFjMlksTUFBTSxDQUFDOTNCLEtBQUQsQ0FIekMsQ0FLQWk4QixNQUFNLENBQUdBLE1BQU0sRUFBSS9jLE9BQVYsQ0FBb0JZLFNBQXBCLENBQWdDbWMsTUFBekMsQ0FDQUMsTUFBTSxDQUFHQSxNQUFNLEVBQUloZCxPQUFWLENBQW9CWSxTQUFwQixDQUFnQ29jLE1BQXpDLENBRUEsR0FBSUMsU0FBUSxDQUFHRixNQUFNLEVBQUluYyxTQUF6QixDQUNJc2MsUUFBUSxDQUFHRixNQUFNLEVBQUlwYyxTQUR6QixDQUVJdWMsU0FBUyxDQUFHSixNQUFNLEVBQUlDLE1BRjFCLENBSUEsR0FBSUcsU0FBUyxFQUFJek0sUUFBUSxDQUFDbGtDLE1BQUQsQ0FBekIsQ0FBbUMsQ0FDakMsR0FBSSxDQUFDa2tDLFFBQVEsQ0FBQzV2QixLQUFELENBQWIsQ0FBc0IsQ0FDcEIsTUFBTyxNQUFQLENBQ0QsQ0FDRCs3QixRQUFRLENBQUcsSUFBWCxDQUNBSSxRQUFRLENBQUcsS0FBWCxDQUNELENBQ0QsR0FBSUUsU0FBUyxFQUFJLENBQUNGLFFBQWxCLENBQTRCLENBQzFCMXpCLEtBQUssR0FBS0EsS0FBSyxDQUFHLEdBQUlnTyxNQUFKLEVBQWIsQ0FBTCxDQUNBLE1BQVFzbEIsU0FBUSxFQUFJelQsWUFBWSxDQUFDNThCLE1BQUQsQ0FBekIsQ0FDSDR3QyxXQUFXLENBQUM1d0MsTUFBRCxDQUFTc1UsS0FBVCxDQUFnQnUzQixPQUFoQixDQUF5QkMsVUFBekIsQ0FBcUNzRSxTQUFyQyxDQUFnRHJ6QixLQUFoRCxDQURSLENBRUg4ekIsVUFBVSxDQUFDN3dDLE1BQUQsQ0FBU3NVLEtBQVQsQ0FBZ0JpOEIsTUFBaEIsQ0FBd0IxRSxPQUF4QixDQUFpQ0MsVUFBakMsQ0FBNkNzRSxTQUE3QyxDQUF3RHJ6QixLQUF4RCxDQUZkLENBR0QsQ0FDRCxHQUFJLEVBQUU4dUIsT0FBTyxDQUFHaGEsb0JBQVosQ0FBSixDQUF1QyxDQUNyQyxHQUFJaWYsYUFBWSxDQUFHTCxRQUFRLEVBQUl2dEMsY0FBYyxDQUFDSSxJQUFmLENBQW9CdEQsTUFBcEIsQ0FBNEIsYUFBNUIsQ0FBL0IsQ0FDSSt3QyxZQUFZLENBQUdMLFFBQVEsRUFBSXh0QyxjQUFjLENBQUNJLElBQWYsQ0FBb0JnUixLQUFwQixDQUEyQixhQUEzQixDQUQvQixDQUdBLEdBQUl3OEIsWUFBWSxFQUFJQyxZQUFwQixDQUFrQyxDQUNoQyxHQUFJQyxhQUFZLENBQUdGLFlBQVksQ0FBRzl3QyxNQUFNLENBQUM1QyxLQUFQLEVBQUgsQ0FBb0I0QyxNQUFuRCxDQUNJaXhDLFlBQVksQ0FBR0YsWUFBWSxDQUFHejhCLEtBQUssQ0FBQ2xYLEtBQU4sRUFBSCxDQUFtQmtYLEtBRGxELENBR0F5SSxLQUFLLEdBQUtBLEtBQUssQ0FBRyxHQUFJZ08sTUFBSixFQUFiLENBQUwsQ0FDQSxNQUFPcWxCLFVBQVMsQ0FBQ1ksWUFBRCxDQUFlQyxZQUFmLENBQTZCcEYsT0FBN0IsQ0FBc0NDLFVBQXRDLENBQWtEL3VCLEtBQWxELENBQWhCLENBQ0QsQ0FDRixDQUNELEdBQUksQ0FBQzR6QixTQUFMLENBQWdCLENBQ2QsTUFBTyxNQUFQLENBQ0QsQ0FDRDV6QixLQUFLLEdBQUtBLEtBQUssQ0FBRyxHQUFJZ08sTUFBSixFQUFiLENBQUwsQ0FDQSxNQUFPbW1CLGFBQVksQ0FBQ2x4QyxNQUFELENBQVNzVSxLQUFULENBQWdCdTNCLE9BQWhCLENBQXlCQyxVQUF6QixDQUFxQ3NFLFNBQXJDLENBQWdEcnpCLEtBQWhELENBQW5CLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvMEIsVUFBVCxDQUFtQi96QyxLQUFuQixDQUEwQixDQUN4QixNQUFPd29DLGFBQVksQ0FBQ3hvQyxLQUFELENBQVosRUFBdUJndkMsTUFBTSxDQUFDaHZDLEtBQUQsQ0FBTixFQUFpQjYyQixNQUEvQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbWQsWUFBVCxDQUFxQnB4QyxNQUFyQixDQUE2QjhFLE1BQTdCLENBQXFDdXNDLFNBQXJDLENBQWdEdkYsVUFBaEQsQ0FBNEQsQ0FDMUQsR0FBSTFuQyxNQUFLLENBQUdpdEMsU0FBUyxDQUFDbjFDLE1BQXRCLENBQ0lBLE1BQU0sQ0FBR2tJLEtBRGIsQ0FFSWt0QyxZQUFZLENBQUcsQ0FBQ3hGLFVBRnBCLENBSUEsR0FBSTlyQyxNQUFNLEVBQUksSUFBZCxDQUFvQixDQUNsQixNQUFPLENBQUM5RCxNQUFSLENBQ0QsQ0FDRDhELE1BQU0sQ0FBR21ELE1BQU0sQ0FBQ25ELE1BQUQsQ0FBZixDQUNBLE1BQU9vRSxLQUFLLEVBQVosQ0FBZ0IsQ0FDZCxHQUFJeEYsS0FBSSxDQUFHeXlDLFNBQVMsQ0FBQ2p0QyxLQUFELENBQXBCLENBQ0EsR0FBS2t0QyxZQUFZLEVBQUkxeUMsSUFBSSxDQUFDLENBQUQsQ0FBckIsQ0FDSUEsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFZb0IsTUFBTSxDQUFDcEIsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUR0QixDQUVJLEVBQUVBLElBQUksQ0FBQyxDQUFELENBQUosRUFBV29CLE9BQWIsQ0FGUixDQUdNLENBQ0osTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sRUFBRW9FLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCMEMsSUFBSSxDQUFHeXlDLFNBQVMsQ0FBQ2p0QyxLQUFELENBQWhCLENBQ0EsR0FBSUksSUFBRyxDQUFHNUYsSUFBSSxDQUFDLENBQUQsQ0FBZCxDQUNJcXNDLFFBQVEsQ0FBR2pyQyxNQUFNLENBQUN3RSxHQUFELENBRHJCLENBRUkrc0MsUUFBUSxDQUFHM3lDLElBQUksQ0FBQyxDQUFELENBRm5CLENBSUEsR0FBSTB5QyxZQUFZLEVBQUkxeUMsSUFBSSxDQUFDLENBQUQsQ0FBeEIsQ0FBNkIsQ0FDM0IsR0FBSXFzQyxRQUFRLEdBQUtodkMsU0FBYixFQUEwQixFQUFFdUksR0FBRyxHQUFJeEUsT0FBVCxDQUE5QixDQUFnRCxDQUM5QyxNQUFPLE1BQVAsQ0FDRCxDQUNGLENBSkQsSUFJTyxDQUNMLEdBQUkrYyxNQUFLLENBQUcsR0FBSWdPLE1BQUosRUFBWixDQUNBLEdBQUkrZ0IsVUFBSixDQUFnQixDQUNkLEdBQUlseUMsT0FBTSxDQUFHa3lDLFVBQVUsQ0FBQ2IsUUFBRCxDQUFXc0csUUFBWCxDQUFxQi9zQyxHQUFyQixDQUEwQnhFLE1BQTFCLENBQWtDOEUsTUFBbEMsQ0FBMENpWSxLQUExQyxDQUF2QixDQUNELENBQ0QsR0FBSSxFQUFFbmpCLE1BQU0sR0FBS3FDLFNBQVgsQ0FDRWkwQyxXQUFXLENBQUNxQixRQUFELENBQVd0RyxRQUFYLENBQXFCcFosb0JBQW9CLENBQUdDLHNCQUE1QyxDQUFvRWdhLFVBQXBFLENBQWdGL3VCLEtBQWhGLENBRGIsQ0FFRW5qQixNQUZKLENBQUosQ0FHTyxDQUNMLE1BQU8sTUFBUCxDQUNELENBQ0YsQ0FDRixDQUNELE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0M0MsYUFBVCxDQUFzQnAwQyxLQUF0QixDQUE2QixDQUMzQixHQUFJLENBQUM4b0MsUUFBUSxDQUFDOW9DLEtBQUQsQ0FBVCxFQUFvQnEwQyxRQUFRLENBQUNyMEMsS0FBRCxDQUFoQyxDQUF5QyxDQUN2QyxNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUlzMEMsUUFBTyxDQUFHN3ZDLFVBQVUsQ0FBQ3pFLEtBQUQsQ0FBVixDQUFvQnlsQyxVQUFwQixDQUFpQ3hMLFlBQS9DLENBQ0EsTUFBT3FhLFFBQU8sQ0FBQ2hSLElBQVIsQ0FBYTl4QixRQUFRLENBQUN4UixLQUFELENBQXJCLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3UwQyxhQUFULENBQXNCdjBDLEtBQXRCLENBQTZCLENBQzNCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCbTNCLFNBQW5ELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxZCxVQUFULENBQW1CeDBDLEtBQW5CLENBQTBCLENBQ3hCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1Qmd2QyxNQUFNLENBQUNodkMsS0FBRCxDQUFOLEVBQWlCbzNCLE1BQS9DLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxZCxpQkFBVCxDQUEwQnowQyxLQUExQixDQUFpQyxDQUMvQixNQUFPd29DLGFBQVksQ0FBQ3hvQyxLQUFELENBQVosRUFDTDAwQyxRQUFRLENBQUMxMEMsS0FBSyxDQUFDbEIsTUFBUCxDQURILEVBQ3FCLENBQUMsQ0FBQzArQixjQUFjLENBQUNtVSxVQUFVLENBQUMzeEMsS0FBRCxDQUFYLENBRDVDLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMyMEMsYUFBVCxDQUFzQjMwQyxLQUF0QixDQUE2QixDQUMzQjtBQUNBO0FBQ0EsR0FBSSxNQUFPQSxNQUFQLEVBQWdCLFVBQXBCLENBQWdDLENBQzlCLE1BQU9BLE1BQVAsQ0FDRCxDQUNELEdBQUlBLEtBQUssRUFBSSxJQUFiLENBQW1CLENBQ2pCLE1BQU80MEMsU0FBUCxDQUNELENBQ0QsR0FBSSxNQUFPNTBDLE1BQVAsRUFBZ0IsUUFBcEIsQ0FBOEIsQ0FDNUIsTUFBT21HLFFBQU8sQ0FBQ25HLEtBQUQsQ0FBUCxDQUNINjBDLG1CQUFtQixDQUFDNzBDLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBV0EsS0FBSyxDQUFDLENBQUQsQ0FBaEIsQ0FEaEIsQ0FFSDgwQyxXQUFXLENBQUM5MEMsS0FBRCxDQUZmLENBR0QsQ0FDRCxNQUFPKzBDLFNBQVEsQ0FBQy8wQyxLQUFELENBQWYsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2cxQyxTQUFULENBQWtCcHlDLE1BQWxCLENBQTBCLENBQ3hCLEdBQUksQ0FBQ3F5QyxXQUFXLENBQUNyeUMsTUFBRCxDQUFoQixDQUEwQixDQUN4QixNQUFPc2tDLFdBQVUsQ0FBQ3RrQyxNQUFELENBQWpCLENBQ0QsQ0FDRCxHQUFJcEcsT0FBTSxDQUFHLEVBQWIsQ0FDQSxJQUFLLEdBQUk0SyxJQUFULEdBQWdCckIsT0FBTSxDQUFDbkQsTUFBRCxDQUF0QixDQUFnQyxDQUM5QixHQUFJa0QsY0FBYyxDQUFDSSxJQUFmLENBQW9CdEQsTUFBcEIsQ0FBNEJ3RSxHQUE1QixHQUFvQ0EsR0FBRyxFQUFJLGFBQS9DLENBQThELENBQzVENUssTUFBTSxDQUFDeU4sSUFBUCxDQUFZN0MsR0FBWixFQUNELENBQ0YsQ0FDRCxNQUFPNUssT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMDRDLFdBQVQsQ0FBb0J0eUMsTUFBcEIsQ0FBNEIsQ0FDMUIsR0FBSSxDQUFDa21DLFFBQVEsQ0FBQ2xtQyxNQUFELENBQWIsQ0FBdUIsQ0FDckIsTUFBT3V5QyxhQUFZLENBQUN2eUMsTUFBRCxDQUFuQixDQUNELENBQ0QsR0FBSXd5QyxRQUFPLENBQUdILFdBQVcsQ0FBQ3J5QyxNQUFELENBQXpCLENBQ0lwRyxNQUFNLENBQUcsRUFEYixDQUdBLElBQUssR0FBSTRLLElBQVQsR0FBZ0J4RSxPQUFoQixDQUF3QixDQUN0QixHQUFJLEVBQUV3RSxHQUFHLEVBQUksYUFBUCxHQUF5Qmd1QyxPQUFPLEVBQUksQ0FBQ3R2QyxjQUFjLENBQUNJLElBQWYsQ0FBb0J0RCxNQUFwQixDQUE0QndFLEdBQTVCLENBQXJDLENBQUYsQ0FBSixDQUErRSxDQUM3RTVLLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWTdDLEdBQVosRUFDRCxDQUNGLENBQ0QsTUFBTzVLLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2NEMsT0FBVCxDQUFnQnIxQyxLQUFoQixDQUF1QmtYLEtBQXZCLENBQThCLENBQzVCLE1BQU9sWCxNQUFLLENBQUdrWCxLQUFmLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU28rQixRQUFULENBQWlCN3NDLFVBQWpCLENBQTZCbzNCLFFBQTdCLENBQXVDLENBQ3JDLEdBQUk3NEIsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJeEssTUFBTSxDQUFHNlYsV0FBVyxDQUFDNUosVUFBRCxDQUFYLENBQTBCL0wsS0FBSyxDQUFDK0wsVUFBVSxDQUFDM0osTUFBWixDQUEvQixDQUFxRCxFQURsRSxDQUdBaXZDLFFBQVEsQ0FBQ3RsQyxVQUFELENBQWEsU0FBU3pJLEtBQVQsQ0FBZ0JvSCxHQUFoQixDQUFxQnFCLFVBQXJCLENBQWlDLENBQ3BEak0sTUFBTSxDQUFDLEVBQUV3SyxLQUFILENBQU4sQ0FBa0I2NEIsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBUW9ILEdBQVIsQ0FBYXFCLFVBQWIsQ0FBMUIsQ0FDRCxDQUZPLENBQVIsQ0FHQSxNQUFPak0sT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTczRDLFlBQVQsQ0FBcUJwdEMsTUFBckIsQ0FBNkIsQ0FDM0IsR0FBSXVzQyxVQUFTLENBQUdzQixZQUFZLENBQUM3dEMsTUFBRCxDQUE1QixDQUNBLEdBQUl1c0MsU0FBUyxDQUFDbjFDLE1BQVYsRUFBb0IsQ0FBcEIsRUFBeUJtMUMsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhLENBQWIsQ0FBN0IsQ0FBOEMsQ0FDNUMsTUFBT3VCLHdCQUF1QixDQUFDdkIsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhLENBQWIsQ0FBRCxDQUFrQkEsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhLENBQWIsQ0FBbEIsQ0FBOUIsQ0FDRCxDQUNELE1BQU8sVUFBU3J4QyxNQUFULENBQWlCLENBQ3RCLE1BQU9BLE9BQU0sR0FBSzhFLE1BQVgsRUFBcUJzc0MsV0FBVyxDQUFDcHhDLE1BQUQsQ0FBUzhFLE1BQVQsQ0FBaUJ1c0MsU0FBakIsQ0FBdkMsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU1ksb0JBQVQsQ0FBNkIvb0MsSUFBN0IsQ0FBbUNxb0MsUUFBbkMsQ0FBNkMsQ0FDM0MsR0FBSXNCLEtBQUssQ0FBQzNwQyxJQUFELENBQUwsRUFBZTRwQyxrQkFBa0IsQ0FBQ3ZCLFFBQUQsQ0FBckMsQ0FBaUQsQ0FDL0MsTUFBT3FCLHdCQUF1QixDQUFDaEUsS0FBSyxDQUFDMWxDLElBQUQsQ0FBTixDQUFjcW9DLFFBQWQsQ0FBOUIsQ0FDRCxDQUNELE1BQU8sVUFBU3Z4QyxNQUFULENBQWlCLENBQ3RCLEdBQUlpckMsU0FBUSxDQUFHaDZCLEdBQUcsQ0FBQ2pSLE1BQUQsQ0FBU2tKLElBQVQsQ0FBbEIsQ0FDQSxNQUFRK2hDLFNBQVEsR0FBS2h2QyxTQUFiLEVBQTBCZ3ZDLFFBQVEsR0FBS3NHLFFBQXhDLENBQ0hsakIsS0FBSyxDQUFDcnVCLE1BQUQsQ0FBU2tKLElBQVQsQ0FERixDQUVIZ25DLFdBQVcsQ0FBQ3FCLFFBQUQsQ0FBV3RHLFFBQVgsQ0FBcUJwWixvQkFBb0IsQ0FBR0Msc0JBQTVDLENBRmYsQ0FHRCxDQUxELENBTUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2loQixVQUFULENBQW1CL3lDLE1BQW5CLENBQTJCOEUsTUFBM0IsQ0FBbUNrdUMsUUFBbkMsQ0FBNkNsSCxVQUE3QyxDQUF5RC91QixLQUF6RCxDQUFnRSxDQUM5RCxHQUFJL2MsTUFBTSxHQUFLOEUsTUFBZixDQUF1QixDQUNyQixPQUNELENBQ0R3cEMsT0FBTyxDQUFDeHBDLE1BQUQsQ0FBUyxTQUFTeXNDLFFBQVQsQ0FBbUIvc0MsR0FBbkIsQ0FBd0IsQ0FDdEN1WSxLQUFLLEdBQUtBLEtBQUssQ0FBRyxHQUFJZ08sTUFBSixFQUFiLENBQUwsQ0FDQSxHQUFJbWIsUUFBUSxDQUFDcUwsUUFBRCxDQUFaLENBQXdCLENBQ3RCMEIsYUFBYSxDQUFDanpDLE1BQUQsQ0FBUzhFLE1BQVQsQ0FBaUJOLEdBQWpCLENBQXNCd3VDLFFBQXRCLENBQWdDRCxTQUFoQyxDQUEyQ2pILFVBQTNDLENBQXVEL3VCLEtBQXZELENBQWIsQ0FDRCxDQUZELElBR0ssQ0FDSCxHQUFJd0IsU0FBUSxDQUFHdXRCLFVBQVUsQ0FDckJBLFVBQVUsQ0FBQ29ILE9BQU8sQ0FBQ2x6QyxNQUFELENBQVN3RSxHQUFULENBQVIsQ0FBdUIrc0MsUUFBdkIsQ0FBa0Mvc0MsR0FBRyxDQUFHLEVBQXhDLENBQTZDeEUsTUFBN0MsQ0FBcUQ4RSxNQUFyRCxDQUE2RGlZLEtBQTdELENBRFcsQ0FFckI5Z0IsU0FGSixDQUlBLEdBQUlzaUIsUUFBUSxHQUFLdGlCLFNBQWpCLENBQTRCLENBQzFCc2lCLFFBQVEsQ0FBR2d6QixRQUFYLENBQ0QsQ0FDRDFHLGdCQUFnQixDQUFDN3FDLE1BQUQsQ0FBU3dFLEdBQVQsQ0FBYytaLFFBQWQsQ0FBaEIsQ0FDRCxDQUNGLENBZk0sQ0FlSmd0QixNQWZJLENBQVAsQ0FnQkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMEgsY0FBVCxDQUF1Qmp6QyxNQUF2QixDQUErQjhFLE1BQS9CLENBQXVDTixHQUF2QyxDQUE0Q3d1QyxRQUE1QyxDQUFzREcsU0FBdEQsQ0FBaUVySCxVQUFqRSxDQUE2RS91QixLQUE3RSxDQUFvRixDQUNsRixHQUFJa3VCLFNBQVEsQ0FBR2lJLE9BQU8sQ0FBQ2x6QyxNQUFELENBQVN3RSxHQUFULENBQXRCLENBQ0krc0MsUUFBUSxDQUFHMkIsT0FBTyxDQUFDcHVDLE1BQUQsQ0FBU04sR0FBVCxDQUR0QixDQUVJbW9DLE9BQU8sQ0FBRzV2QixLQUFLLENBQUM5TCxHQUFOLENBQVVzZ0MsUUFBVixDQUZkLENBSUEsR0FBSTVFLE9BQUosQ0FBYSxDQUNYOUIsZ0JBQWdCLENBQUM3cUMsTUFBRCxDQUFTd0UsR0FBVCxDQUFjbW9DLE9BQWQsQ0FBaEIsQ0FDQSxPQUNELENBQ0QsR0FBSXB1QixTQUFRLENBQUd1dEIsVUFBVSxDQUNyQkEsVUFBVSxDQUFDYixRQUFELENBQVdzRyxRQUFYLENBQXNCL3NDLEdBQUcsQ0FBRyxFQUE1QixDQUFpQ3hFLE1BQWpDLENBQXlDOEUsTUFBekMsQ0FBaURpWSxLQUFqRCxDQURXLENBRXJCOWdCLFNBRkosQ0FJQSxHQUFJb3hDLFNBQVEsQ0FBRzl1QixRQUFRLEdBQUt0aUIsU0FBNUIsQ0FFQSxHQUFJb3hDLFFBQUosQ0FBYyxDQUNaLEdBQUloRyxNQUFLLENBQUc5akMsT0FBTyxDQUFDZ3VDLFFBQUQsQ0FBbkIsQ0FDSXBILE1BQU0sQ0FBRyxDQUFDOUMsS0FBRCxFQUFVbkQsUUFBUSxDQUFDcU4sUUFBRCxDQUQvQixDQUVJNkIsT0FBTyxDQUFHLENBQUMvTCxLQUFELEVBQVUsQ0FBQzhDLE1BQVgsRUFBcUJ2TixZQUFZLENBQUMyVSxRQUFELENBRi9DLENBSUFoekIsUUFBUSxDQUFHZ3pCLFFBQVgsQ0FDQSxHQUFJbEssS0FBSyxFQUFJOEMsTUFBVCxFQUFtQmlKLE9BQXZCLENBQWdDLENBQzlCLEdBQUk3dkMsT0FBTyxDQUFDMG5DLFFBQUQsQ0FBWCxDQUF1QixDQUNyQjFzQixRQUFRLENBQUcwc0IsUUFBWCxDQUNELENBRkQsSUFHSyxJQUFJb0ksaUJBQWlCLENBQUNwSSxRQUFELENBQXJCLENBQWlDLENBQ3BDMXNCLFFBQVEsQ0FBRzBvQixTQUFTLENBQUNnRSxRQUFELENBQXBCLENBQ0QsQ0FGSSxJQUdBLElBQUlkLE1BQUosQ0FBWSxDQUNma0QsUUFBUSxDQUFHLEtBQVgsQ0FDQTl1QixRQUFRLENBQUcrdEIsV0FBVyxDQUFDaUYsUUFBRCxDQUFXLElBQVgsQ0FBdEIsQ0FDRCxDQUhJLElBSUEsSUFBSTZCLE9BQUosQ0FBYSxDQUNoQi9GLFFBQVEsQ0FBRyxLQUFYLENBQ0E5dUIsUUFBUSxDQUFHKzBCLGVBQWUsQ0FBQy9CLFFBQUQsQ0FBVyxJQUFYLENBQTFCLENBQ0QsQ0FISSxJQUlBLENBQ0hoekIsUUFBUSxDQUFHLEVBQVgsQ0FDRCxDQUNGLENBbEJELElBbUJLLElBQUlnMUIsYUFBYSxDQUFDaEMsUUFBRCxDQUFiLEVBQTJCckgsV0FBVyxDQUFDcUgsUUFBRCxDQUExQyxDQUFzRCxDQUN6RGh6QixRQUFRLENBQUcwc0IsUUFBWCxDQUNBLEdBQUlmLFdBQVcsQ0FBQ2UsUUFBRCxDQUFmLENBQTJCLENBQ3pCMXNCLFFBQVEsQ0FBR2kxQixhQUFhLENBQUN2SSxRQUFELENBQXhCLENBQ0QsQ0FGRCxJQUdLLElBQUksQ0FBQy9FLFFBQVEsQ0FBQytFLFFBQUQsQ0FBVCxFQUF1QnBwQyxVQUFVLENBQUNvcEMsUUFBRCxDQUFyQyxDQUFpRCxDQUNwRDFzQixRQUFRLENBQUdndUIsZUFBZSxDQUFDZ0YsUUFBRCxDQUExQixDQUNELENBQ0YsQ0FSSSxJQVNBLENBQ0hsRSxRQUFRLENBQUcsS0FBWCxDQUNELENBQ0YsQ0FDRCxHQUFJQSxRQUFKLENBQWMsQ0FDWjtBQUNBdHdCLEtBQUssQ0FBQy9GLEdBQU4sQ0FBVXU2QixRQUFWLENBQW9CaHpCLFFBQXBCLEVBQ0E0MEIsU0FBUyxDQUFDNTBCLFFBQUQsQ0FBV2d6QixRQUFYLENBQXFCeUIsUUFBckIsQ0FBK0JsSCxVQUEvQixDQUEyQy91QixLQUEzQyxDQUFULENBQ0FBLEtBQUssQ0FBQyxRQUFELENBQUwsQ0FBZ0J3MEIsUUFBaEIsRUFDRCxDQUNEMUcsZ0JBQWdCLENBQUM3cUMsTUFBRCxDQUFTd0UsR0FBVCxDQUFjK1osUUFBZCxDQUFoQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrMUIsUUFBVCxDQUFpQnJ6QyxLQUFqQixDQUF3QjNHLENBQXhCLENBQTJCLENBQ3pCLEdBQUl5QyxPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsT0FDRCxDQUNEekMsQ0FBQyxFQUFJQSxDQUFDLENBQUcsQ0FBSixDQUFReUMsTUFBUixDQUFpQixDQUF0QixDQUNBLE1BQU9vdUMsUUFBTyxDQUFDN3dDLENBQUQsQ0FBSXlDLE1BQUosQ0FBUCxDQUFxQmtFLEtBQUssQ0FBQzNHLENBQUQsQ0FBMUIsQ0FBZ0N3QyxTQUF2QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3kzQyxZQUFULENBQXFCN3RDLFVBQXJCLENBQWlDNmhDLFNBQWpDLENBQTRDaU0sTUFBNUMsQ0FBb0QsQ0FDbEQsR0FBSWpNLFNBQVMsQ0FBQ3hyQyxNQUFkLENBQXNCLENBQ3BCd3JDLFNBQVMsQ0FBRy9KLFFBQVEsQ0FBQytKLFNBQUQsQ0FBWSxTQUFTekssUUFBVCxDQUFtQixDQUNqRCxHQUFJMTVCLE9BQU8sQ0FBQzA1QixRQUFELENBQVgsQ0FBdUIsQ0FDckIsTUFBTyxVQUFTNy9CLEtBQVQsQ0FBZ0IsQ0FDckIsTUFBT3N4QyxRQUFPLENBQUN0eEMsS0FBRCxDQUFRNi9CLFFBQVEsQ0FBQy9nQyxNQUFULEdBQW9CLENBQXBCLENBQXdCK2dDLFFBQVEsQ0FBQyxDQUFELENBQWhDLENBQXNDQSxRQUE5QyxDQUFkLENBQ0QsQ0FGRCxDQUdELENBQ0QsTUFBT0EsU0FBUCxDQUNELENBUG1CLENBQXBCLENBUUQsQ0FURCxJQVNPLENBQ0x5SyxTQUFTLENBQUcsQ0FBQ3NLLFFBQUQsQ0FBWixDQUNELENBRUQsR0FBSTV0QyxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0FzakMsU0FBUyxDQUFHL0osUUFBUSxDQUFDK0osU0FBRCxDQUFZL0gsU0FBUyxDQUFDaVUsV0FBVyxFQUFaLENBQXJCLENBQXBCLENBRUEsR0FBSWg2QyxPQUFNLENBQUc4NEMsT0FBTyxDQUFDN3NDLFVBQUQsQ0FBYSxTQUFTekksS0FBVCxDQUFnQm9ILEdBQWhCLENBQXFCcUIsVUFBckIsQ0FBaUMsQ0FDaEUsR0FBSWd1QyxTQUFRLENBQUdsVyxRQUFRLENBQUMrSixTQUFELENBQVksU0FBU3pLLFFBQVQsQ0FBbUIsQ0FDcEQsTUFBT0EsU0FBUSxDQUFDNy9CLEtBQUQsQ0FBZixDQUNELENBRnNCLENBQXZCLENBR0EsTUFBTyxDQUFFLFdBQVl5MkMsUUFBZCxDQUF3QixRQUFTLEVBQUV6dkMsS0FBbkMsQ0FBMEMsUUFBU2hILEtBQW5ELENBQVAsQ0FDRCxDQUxtQixDQUFwQixDQU9BLE1BQU84aEMsV0FBVSxDQUFDdGxDLE1BQUQsQ0FBUyxTQUFTb0csTUFBVCxDQUFpQnNVLEtBQWpCLENBQXdCLENBQ2hELE1BQU93L0IsZ0JBQWUsQ0FBQzl6QyxNQUFELENBQVNzVSxLQUFULENBQWdCcS9CLE1BQWhCLENBQXRCLENBQ0QsQ0FGZ0IsQ0FBakIsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNJLFNBQVQsQ0FBa0IvekMsTUFBbEIsQ0FBMEJ5ckMsS0FBMUIsQ0FBaUMsQ0FDL0IsTUFBT3VJLFdBQVUsQ0FBQ2gwQyxNQUFELENBQVN5ckMsS0FBVCxDQUFnQixTQUFTcnVDLEtBQVQsQ0FBZ0I4TCxJQUFoQixDQUFzQixDQUNyRCxNQUFPbWxCLE1BQUssQ0FBQ3J1QixNQUFELENBQVNrSixJQUFULENBQVosQ0FDRCxDQUZnQixDQUFqQixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzhxQyxXQUFULENBQW9CaDBDLE1BQXBCLENBQTRCeXJDLEtBQTVCLENBQW1DbG5DLFNBQW5DLENBQThDLENBQzVDLEdBQUlILE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR3V2QyxLQUFLLENBQUN2dkMsTUFEbkIsQ0FFSXRDLE1BQU0sQ0FBRyxFQUZiLENBSUEsTUFBTyxFQUFFd0ssS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWdOLEtBQUksQ0FBR3VpQyxLQUFLLENBQUNybkMsS0FBRCxDQUFoQixDQUNJaEgsS0FBSyxDQUFHc3hDLE9BQU8sQ0FBQzF1QyxNQUFELENBQVNrSixJQUFULENBRG5CLENBR0EsR0FBSTNFLFNBQVMsQ0FBQ25ILEtBQUQsQ0FBUThMLElBQVIsQ0FBYixDQUE0QixDQUMxQitxQyxPQUFPLENBQUNyNkMsTUFBRCxDQUFTKzBDLFFBQVEsQ0FBQ3psQyxJQUFELENBQU9sSixNQUFQLENBQWpCLENBQWlDNUMsS0FBakMsQ0FBUCxDQUNELENBQ0YsQ0FDRCxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTczZDLGlCQUFULENBQTBCaHJDLElBQTFCLENBQWdDLENBQzlCLE1BQU8sVUFBU2xKLE1BQVQsQ0FBaUIsQ0FDdEIsTUFBTzB1QyxRQUFPLENBQUMxdUMsTUFBRCxDQUFTa0osSUFBVCxDQUFkLENBQ0QsQ0FGRCxDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpckMsWUFBVCxDQUFxQi96QyxLQUFyQixDQUE0QjBmLE1BQTVCLENBQW9DbWQsUUFBcEMsQ0FBOEMxakIsVUFBOUMsQ0FBMEQsQ0FDeEQsR0FBSXpWLFFBQU8sQ0FBR3lWLFVBQVUsQ0FBR3NsQixlQUFILENBQXFCcEIsV0FBN0MsQ0FDSXI1QixLQUFLLENBQUcsQ0FBQyxDQURiLENBRUlsSSxNQUFNLENBQUc0akIsTUFBTSxDQUFDNWpCLE1BRnBCLENBR0kwekMsSUFBSSxDQUFHeHZDLEtBSFgsQ0FLQSxHQUFJQSxLQUFLLEdBQUswZixNQUFkLENBQXNCLENBQ3BCQSxNQUFNLENBQUdtbkIsU0FBUyxDQUFDbm5CLE1BQUQsQ0FBbEIsQ0FDRCxDQUNELEdBQUltZCxRQUFKLENBQWMsQ0FDWjJTLElBQUksQ0FBR2pTLFFBQVEsQ0FBQ3Y5QixLQUFELENBQVF1L0IsU0FBUyxDQUFDMUMsUUFBRCxDQUFqQixDQUFmLENBQ0QsQ0FDRCxNQUFPLEVBQUU3NEIsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSXVpQyxVQUFTLENBQUcsQ0FBaEIsQ0FDSXJoQyxLQUFLLENBQUcwaUIsTUFBTSxDQUFDMWIsS0FBRCxDQURsQixDQUVJNGpDLFFBQVEsQ0FBRy9LLFFBQVEsQ0FBR0EsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBWCxDQUFxQkEsS0FGNUMsQ0FJQSxNQUFPLENBQUNxaEMsU0FBUyxDQUFHMzZCLE9BQU8sQ0FBQzhyQyxJQUFELENBQU81SCxRQUFQLENBQWlCdkosU0FBakIsQ0FBNEJsbEIsVUFBNUIsQ0FBcEIsRUFBK0QsQ0FBQyxDQUF2RSxDQUEwRSxDQUN4RSxHQUFJcTJCLElBQUksR0FBS3h2QyxLQUFiLENBQW9CLENBQ2xCcWYsTUFBTSxDQUFDbmMsSUFBUCxDQUFZc3NDLElBQVosQ0FBa0JuUixTQUFsQixDQUE2QixDQUE3QixFQUNELENBQ0RoZixNQUFNLENBQUNuYyxJQUFQLENBQVlsRCxLQUFaLENBQW1CcStCLFNBQW5CLENBQThCLENBQTlCLEVBQ0QsQ0FDRixDQUNELE1BQU9yK0IsTUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2cwQyxXQUFULENBQW9CaDBDLEtBQXBCLENBQTJCaTBDLE9BQTNCLENBQW9DLENBQ2xDLEdBQUluNEMsT0FBTSxDQUFHa0UsS0FBSyxDQUFHaTBDLE9BQU8sQ0FBQ240QyxNQUFYLENBQW9CLENBQXRDLENBQ0l5bEMsU0FBUyxDQUFHemxDLE1BQU0sQ0FBRyxDQUR6QixDQUdBLE1BQU9BLE1BQU0sRUFBYixDQUFpQixDQUNmLEdBQUlrSSxNQUFLLENBQUdpd0MsT0FBTyxDQUFDbjRDLE1BQUQsQ0FBbkIsQ0FDQSxHQUFJQSxNQUFNLEVBQUl5bEMsU0FBVixFQUF1QnY5QixLQUFLLEdBQUtrd0MsUUFBckMsQ0FBK0MsQ0FDN0MsR0FBSUEsU0FBUSxDQUFHbHdDLEtBQWYsQ0FDQSxHQUFJa21DLE9BQU8sQ0FBQ2xtQyxLQUFELENBQVgsQ0FBb0IsQ0FDbEJxYixNQUFNLENBQUNuYyxJQUFQLENBQVlsRCxLQUFaLENBQW1CZ0UsS0FBbkIsQ0FBMEIsQ0FBMUIsRUFDRCxDQUZELElBRU8sQ0FDTG13QyxTQUFTLENBQUNuMEMsS0FBRCxDQUFRZ0UsS0FBUixDQUFULENBQ0QsQ0FDRixDQUNGLENBQ0QsTUFBT2hFLE1BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvcUMsV0FBVCxDQUFvQmtCLEtBQXBCLENBQTJCQyxLQUEzQixDQUFrQyxDQUNoQyxNQUFPRCxNQUFLLENBQUczSCxXQUFXLENBQUNZLFlBQVksSUFBTWdILEtBQUssQ0FBR0QsS0FBUixDQUFnQixDQUF0QixDQUFiLENBQTFCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzhJLFVBQVQsQ0FBbUI5L0IsS0FBbkIsQ0FBMEJoSCxHQUExQixDQUErQmdFLElBQS9CLENBQXFDZ3RCLFNBQXJDLENBQWdELENBQzlDLEdBQUl0NkIsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHcW9DLFNBQVMsQ0FBQ1QsVUFBVSxDQUFDLENBQUNwMkIsR0FBRyxDQUFHZ0gsS0FBUCxHQUFpQmhELElBQUksRUFBSSxDQUF6QixDQUFELENBQVgsQ0FBMEMsQ0FBMUMsQ0FEdEIsQ0FFSTlYLE1BQU0sQ0FBR0UsS0FBSyxDQUFDb0MsTUFBRCxDQUZsQixDQUlBLE1BQU9BLE1BQU0sRUFBYixDQUFpQixDQUNmdEMsTUFBTSxDQUFDOGtDLFNBQVMsQ0FBR3hpQyxNQUFILENBQVksRUFBRWtJLEtBQXhCLENBQU4sQ0FBdUNzUSxLQUF2QyxDQUNBQSxLQUFLLEVBQUloRCxJQUFULENBQ0QsQ0FDRCxNQUFPOVgsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2NkMsV0FBVCxDQUFvQjd6QyxNQUFwQixDQUE0Qm5ILENBQTVCLENBQStCLENBQzdCLEdBQUlHLE9BQU0sQ0FBRyxFQUFiLENBQ0EsR0FBSSxDQUFDZ0gsTUFBRCxFQUFXbkgsQ0FBQyxDQUFHLENBQWYsRUFBb0JBLENBQUMsQ0FBR3c1QixnQkFBNUIsQ0FBOEMsQ0FDNUMsTUFBT3I1QixPQUFQLENBQ0QsQ0FDRDtBQUNBO0FBQ0EsRUFBRyxDQUNELEdBQUlILENBQUMsQ0FBRyxDQUFSLENBQVcsQ0FDVEcsTUFBTSxFQUFJZ0gsTUFBVixDQUNELENBQ0RuSCxDQUFDLENBQUdzcUMsV0FBVyxDQUFDdHFDLENBQUMsQ0FBRyxDQUFMLENBQWYsQ0FDQSxHQUFJQSxDQUFKLENBQU8sQ0FDTG1ILE1BQU0sRUFBSUEsTUFBVixDQUNELENBQ0YsQ0FSRCxNQVFTbkgsQ0FSVCxFQVVBLE1BQU9HLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTODZDLFNBQVQsQ0FBa0I3WCxJQUFsQixDQUF3Qm5vQixLQUF4QixDQUErQixDQUM3QixNQUFPaWdDLFlBQVcsQ0FBQ0MsUUFBUSxDQUFDL1gsSUFBRCxDQUFPbm9CLEtBQVAsQ0FBY3M5QixRQUFkLENBQVQsQ0FBa0NuVixJQUFJLENBQUcsRUFBekMsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dZLFdBQVQsQ0FBb0JodkMsVUFBcEIsQ0FBZ0MsQ0FDOUIsTUFBTzBrQyxZQUFXLENBQUN6cUIsTUFBTSxDQUFDamEsVUFBRCxDQUFQLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2l2QyxlQUFULENBQXdCanZDLFVBQXhCLENBQW9DcE0sQ0FBcEMsQ0FBdUMsQ0FDckMsR0FBSTJHLE1BQUssQ0FBRzBmLE1BQU0sQ0FBQ2phLFVBQUQsQ0FBbEIsQ0FDQSxNQUFPNmtDLFlBQVcsQ0FBQ3RxQyxLQUFELENBQVF1cUMsU0FBUyxDQUFDbHhDLENBQUQsQ0FBSSxDQUFKLENBQU8yRyxLQUFLLENBQUNsRSxNQUFiLENBQWpCLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMrM0MsUUFBVCxDQUFpQmowQyxNQUFqQixDQUF5QmtKLElBQXpCLENBQStCOUwsS0FBL0IsQ0FBc0MwdUMsVUFBdEMsQ0FBa0QsQ0FDaEQsR0FBSSxDQUFDNUYsUUFBUSxDQUFDbG1DLE1BQUQsQ0FBYixDQUF1QixDQUNyQixNQUFPQSxPQUFQLENBQ0QsQ0FDRGtKLElBQUksQ0FBR3lsQyxRQUFRLENBQUN6bEMsSUFBRCxDQUFPbEosTUFBUCxDQUFmLENBRUEsR0FBSW9FLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2dOLElBQUksQ0FBQ2hOLE1BRGxCLENBRUl5bEMsU0FBUyxDQUFHemxDLE1BQU0sQ0FBRyxDQUZ6QixDQUdJaXlCLE1BQU0sQ0FBR251QixNQUhiLENBS0EsTUFBT211QixNQUFNLEVBQUksSUFBVixFQUFrQixFQUFFL3BCLEtBQUYsQ0FBVWxJLE1BQW5DLENBQTJDLENBQ3pDLEdBQUlzSSxJQUFHLENBQUdvcUMsS0FBSyxDQUFDMWxDLElBQUksQ0FBQzlFLEtBQUQsQ0FBTCxDQUFmLENBQ0ltYSxRQUFRLENBQUduaEIsS0FEZixDQUdBLEdBQUlvSCxHQUFHLEdBQUssV0FBUixFQUF1QkEsR0FBRyxHQUFLLGFBQS9CLEVBQWdEQSxHQUFHLEdBQUssV0FBNUQsQ0FBeUUsQ0FDdkUsTUFBT3hFLE9BQVAsQ0FDRCxDQUVELEdBQUlvRSxLQUFLLEVBQUl1OUIsU0FBYixDQUF3QixDQUN0QixHQUFJc0osU0FBUSxDQUFHOWMsTUFBTSxDQUFDM3BCLEdBQUQsQ0FBckIsQ0FDQStaLFFBQVEsQ0FBR3V0QixVQUFVLENBQUdBLFVBQVUsQ0FBQ2IsUUFBRCxDQUFXem1DLEdBQVgsQ0FBZ0IycEIsTUFBaEIsQ0FBYixDQUF1Q2x5QixTQUE1RCxDQUNBLEdBQUlzaUIsUUFBUSxHQUFLdGlCLFNBQWpCLENBQTRCLENBQzFCc2lCLFFBQVEsQ0FBRzJuQixRQUFRLENBQUMrRSxRQUFELENBQVIsQ0FDUEEsUUFETyxDQUVOWCxPQUFPLENBQUNwaEMsSUFBSSxDQUFDOUUsS0FBSyxDQUFHLENBQVQsQ0FBTCxDQUFQLENBQTJCLEVBQTNCLENBQWdDLEVBRnJDLENBR0QsQ0FDRixDQUNENG1DLFdBQVcsQ0FBQzdjLE1BQUQsQ0FBUzNwQixHQUFULENBQWMrWixRQUFkLENBQVgsQ0FDQTRQLE1BQU0sQ0FBR0EsTUFBTSxDQUFDM3BCLEdBQUQsQ0FBZixDQUNELENBQ0QsTUFBT3hFLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJKzBDLFlBQVcsQ0FBRyxDQUFDOVAsT0FBRCxDQUFXK00sUUFBWCxDQUFzQixTQUFTblYsSUFBVCxDQUFlaitCLElBQWYsQ0FBcUIsQ0FDM0RxbUMsT0FBTyxDQUFDanVCLEdBQVIsQ0FBWTZsQixJQUFaLENBQWtCaitCLElBQWxCLEVBQ0EsTUFBT2krQixLQUFQLENBQ0QsQ0FIRCxDQUtBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJbVksZ0JBQWUsQ0FBRyxDQUFDMXVDLGNBQUQsQ0FBa0IwckMsUUFBbEIsQ0FBNkIsU0FBU25WLElBQVQsQ0FBZWo4QixNQUFmLENBQXVCLENBQ3hFLE1BQU8wRixlQUFjLENBQUN1MkIsSUFBRCxDQUFPLFVBQVAsQ0FBbUIsQ0FDdEMsZUFBZ0IsSUFEc0IsQ0FFdEMsYUFBYyxLQUZ3QixDQUd0QyxRQUFTb1ksUUFBUSxDQUFDcjBDLE1BQUQsQ0FIcUIsQ0FJdEMsV0FBWSxJQUowQixDQUFuQixDQUFyQixDQU1ELENBUEQsQ0FTQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzMEMsWUFBVCxDQUFxQnJ2QyxVQUFyQixDQUFpQyxDQUMvQixNQUFPNmtDLFlBQVcsQ0FBQzVxQixNQUFNLENBQUNqYSxVQUFELENBQVAsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzdkMsVUFBVCxDQUFtQi8wQyxLQUFuQixDQUEwQnNVLEtBQTFCLENBQWlDaEgsR0FBakMsQ0FBc0MsQ0FDcEMsR0FBSXRKLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BRG5CLENBR0EsR0FBSXdZLEtBQUssQ0FBRyxDQUFaLENBQWUsQ0FDYkEsS0FBSyxDQUFHLENBQUNBLEtBQUQsQ0FBU3hZLE1BQVQsQ0FBa0IsQ0FBbEIsQ0FBdUJBLE1BQU0sQ0FBR3dZLEtBQXhDLENBQ0QsQ0FDRGhILEdBQUcsQ0FBR0EsR0FBRyxDQUFHeFIsTUFBTixDQUFlQSxNQUFmLENBQXdCd1IsR0FBOUIsQ0FDQSxHQUFJQSxHQUFHLENBQUcsQ0FBVixDQUFhLENBQ1hBLEdBQUcsRUFBSXhSLE1BQVAsQ0FDRCxDQUNEQSxNQUFNLENBQUd3WSxLQUFLLENBQUdoSCxHQUFSLENBQWMsQ0FBZCxDQUFvQkEsR0FBRyxDQUFHZ0gsS0FBUCxHQUFrQixDQUE5QyxDQUNBQSxLQUFLLElBQU0sQ0FBWCxDQUVBLEdBQUk5YSxPQUFNLENBQUdFLEtBQUssQ0FBQ29DLE1BQUQsQ0FBbEIsQ0FDQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QnRDLE1BQU0sQ0FBQ3dLLEtBQUQsQ0FBTixDQUFnQmhFLEtBQUssQ0FBQ2dFLEtBQUssQ0FBR3NRLEtBQVQsQ0FBckIsQ0FDRCxDQUNELE1BQU85YSxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdzdDLFNBQVQsQ0FBa0J2dkMsVUFBbEIsQ0FBOEJ0QixTQUE5QixDQUF5QyxDQUN2QyxHQUFJM0ssT0FBSixDQUVBdXhDLFFBQVEsQ0FBQ3RsQyxVQUFELENBQWEsU0FBU3pJLEtBQVQsQ0FBZ0JnSCxLQUFoQixDQUF1QnlCLFVBQXZCLENBQW1DLENBQ3REak0sTUFBTSxDQUFHMkssU0FBUyxDQUFDbkgsS0FBRCxDQUFRZ0gsS0FBUixDQUFleUIsVUFBZixDQUFsQixDQUNBLE1BQU8sQ0FBQ2pNLE1BQVIsQ0FDRCxDQUhPLENBQVIsQ0FJQSxNQUFPLENBQUMsQ0FBQ0EsTUFBVCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3k3QyxnQkFBVCxDQUF5QmoxQyxLQUF6QixDQUFnQ2hELEtBQWhDLENBQXVDazRDLFVBQXZDLENBQW1ELENBQ2pELEdBQUlDLElBQUcsQ0FBRyxDQUFWLENBQ0lDLElBQUksQ0FBR3AxQyxLQUFLLEVBQUksSUFBVCxDQUFnQm0xQyxHQUFoQixDQUFzQm4xQyxLQUFLLENBQUNsRSxNQUR2QyxDQUdBLEdBQUksTUFBT2tCLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEJBLEtBQUssR0FBS0EsS0FBdEMsRUFBK0NvNEMsSUFBSSxFQUFJbGlCLHFCQUEzRCxDQUFrRixDQUNoRixNQUFPaWlCLEdBQUcsQ0FBR0MsSUFBYixDQUFtQixDQUNqQixHQUFJQyxJQUFHLENBQUlGLEdBQUcsQ0FBR0MsSUFBUCxHQUFpQixDQUEzQixDQUNJeE4sUUFBUSxDQUFHNW5DLEtBQUssQ0FBQ3ExQyxHQUFELENBRHBCLENBR0EsR0FBSXpOLFFBQVEsR0FBSyxJQUFiLEVBQXFCLENBQUM4RixRQUFRLENBQUM5RixRQUFELENBQTlCLEdBQ0NzTixVQUFVLENBQUl0TixRQUFRLEVBQUk1cUMsS0FBaEIsQ0FBMEI0cUMsUUFBUSxDQUFHNXFDLEtBRGhELENBQUosQ0FDNkQsQ0FDM0RtNEMsR0FBRyxDQUFHRSxHQUFHLENBQUcsQ0FBWixDQUNELENBSEQsSUFHTyxDQUNMRCxJQUFJLENBQUdDLEdBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBT0QsS0FBUCxDQUNELENBQ0QsTUFBT0Usa0JBQWlCLENBQUN0MUMsS0FBRCxDQUFRaEQsS0FBUixDQUFlNDBDLFFBQWYsQ0FBeUJzRCxVQUF6QixDQUF4QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTSSxrQkFBVCxDQUEyQnQxQyxLQUEzQixDQUFrQ2hELEtBQWxDLENBQXlDNi9CLFFBQXpDLENBQW1EcVksVUFBbkQsQ0FBK0QsQ0FDN0QsR0FBSUMsSUFBRyxDQUFHLENBQVYsQ0FDSUMsSUFBSSxDQUFHcDFDLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQURyQyxDQUVBLEdBQUlzNUMsSUFBSSxHQUFLLENBQWIsQ0FBZ0IsQ0FDZCxNQUFPLEVBQVAsQ0FDRCxDQUVEcDRDLEtBQUssQ0FBRzYvQixRQUFRLENBQUM3L0IsS0FBRCxDQUFoQixDQUNBLEdBQUl1NEMsU0FBUSxDQUFHdjRDLEtBQUssR0FBS0EsS0FBekIsQ0FDSXc0QyxTQUFTLENBQUd4NEMsS0FBSyxHQUFLLElBRDFCLENBRUl5NEMsV0FBVyxDQUFHL0gsUUFBUSxDQUFDMXdDLEtBQUQsQ0FGMUIsQ0FHSTA0QyxjQUFjLENBQUcxNEMsS0FBSyxHQUFLbkIsU0FIL0IsQ0FLQSxNQUFPczVDLEdBQUcsQ0FBR0MsSUFBYixDQUFtQixDQUNqQixHQUFJQyxJQUFHLENBQUcxUixXQUFXLENBQUMsQ0FBQ3dSLEdBQUcsQ0FBR0MsSUFBUCxFQUFlLENBQWhCLENBQXJCLENBQ0l4TixRQUFRLENBQUcvSyxRQUFRLENBQUM3OEIsS0FBSyxDQUFDcTFDLEdBQUQsQ0FBTixDQUR2QixDQUVJTSxZQUFZLENBQUcvTixRQUFRLEdBQUsvckMsU0FGaEMsQ0FHSSs1QyxTQUFTLENBQUdoTyxRQUFRLEdBQUssSUFIN0IsQ0FJSWlPLGNBQWMsQ0FBR2pPLFFBQVEsR0FBS0EsUUFKbEMsQ0FLSWtPLFdBQVcsQ0FBR3BJLFFBQVEsQ0FBQzlGLFFBQUQsQ0FMMUIsQ0FPQSxHQUFJMk4sUUFBSixDQUFjLENBQ1osR0FBSVEsT0FBTSxDQUFHYixVQUFVLEVBQUlXLGNBQTNCLENBQ0QsQ0FGRCxJQUVPLElBQUlILGNBQUosQ0FBb0IsQ0FDekJLLE1BQU0sQ0FBR0YsY0FBYyxHQUFLWCxVQUFVLEVBQUlTLFlBQW5CLENBQXZCLENBQ0QsQ0FGTSxJQUVBLElBQUlILFNBQUosQ0FBZSxDQUNwQk8sTUFBTSxDQUFHRixjQUFjLEVBQUlGLFlBQWxCLEdBQW1DVCxVQUFVLEVBQUksQ0FBQ1UsU0FBbEQsQ0FBVCxDQUNELENBRk0sSUFFQSxJQUFJSCxXQUFKLENBQWlCLENBQ3RCTSxNQUFNLENBQUdGLGNBQWMsRUFBSUYsWUFBbEIsRUFBa0MsQ0FBQ0MsU0FBbkMsR0FBaURWLFVBQVUsRUFBSSxDQUFDWSxXQUFoRSxDQUFULENBQ0QsQ0FGTSxJQUVBLElBQUlGLFNBQVMsRUFBSUUsV0FBakIsQ0FBOEIsQ0FDbkNDLE1BQU0sQ0FBRyxLQUFULENBQ0QsQ0FGTSxJQUVBLENBQ0xBLE1BQU0sQ0FBR2IsVUFBVSxDQUFJdE4sUUFBUSxFQUFJNXFDLEtBQWhCLENBQTBCNHFDLFFBQVEsQ0FBRzVxQyxLQUF4RCxDQUNELENBQ0QsR0FBSSs0QyxNQUFKLENBQVksQ0FDVlosR0FBRyxDQUFHRSxHQUFHLENBQUcsQ0FBWixDQUNELENBRkQsSUFFTyxDQUNMRCxJQUFJLENBQUdDLEdBQVAsQ0FDRCxDQUNGLENBQ0QsTUFBT2pSLFVBQVMsQ0FBQ2dSLElBQUQsQ0FBT25pQixlQUFQLENBQWhCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK2lCLGVBQVQsQ0FBd0JoMkMsS0FBeEIsQ0FBK0I2OEIsUUFBL0IsQ0FBeUMsQ0FDdkMsR0FBSTc0QixNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQURuQixDQUVJcWhDLFFBQVEsQ0FBRyxDQUZmLENBR0kzakMsTUFBTSxDQUFHLEVBSGIsQ0FLQSxNQUFPLEVBQUV3SyxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNJNGpDLFFBQVEsQ0FBRy9LLFFBQVEsQ0FBR0EsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBWCxDQUFxQkEsS0FENUMsQ0FHQSxHQUFJLENBQUNnSCxLQUFELEVBQVUsQ0FBQzBtQyxFQUFFLENBQUM5QyxRQUFELENBQVc0SCxJQUFYLENBQWpCLENBQW1DLENBQ2pDLEdBQUlBLEtBQUksQ0FBRzVILFFBQVgsQ0FDQXB1QyxNQUFNLENBQUMyakMsUUFBUSxFQUFULENBQU4sQ0FBcUJuZ0MsS0FBSyxHQUFLLENBQVYsQ0FBYyxDQUFkLENBQWtCQSxLQUF2QyxDQUNELENBQ0YsQ0FDRCxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5OEMsYUFBVCxDQUFzQmo1QyxLQUF0QixDQUE2QixDQUMzQixHQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBcEIsQ0FBOEIsQ0FDNUIsTUFBT0EsTUFBUCxDQUNELENBQ0QsR0FBSTB3QyxRQUFRLENBQUMxd0MsS0FBRCxDQUFaLENBQXFCLENBQ25CLE1BQU8rMUIsSUFBUCxDQUNELENBQ0QsTUFBTyxDQUFDLzFCLEtBQVIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTazVDLGFBQVQsQ0FBc0JsNUMsS0FBdEIsQ0FBNkIsQ0FDM0I7QUFDQSxHQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBcEIsQ0FBOEIsQ0FDNUIsTUFBT0EsTUFBUCxDQUNELENBQ0QsR0FBSW1HLE9BQU8sQ0FBQ25HLEtBQUQsQ0FBWCxDQUFvQixDQUNsQjtBQUNBLE1BQU91Z0MsU0FBUSxDQUFDdmdDLEtBQUQsQ0FBUWs1QyxZQUFSLENBQVIsQ0FBZ0MsRUFBdkMsQ0FDRCxDQUNELEdBQUl4SSxRQUFRLENBQUMxd0MsS0FBRCxDQUFaLENBQXFCLENBQ25CLE1BQU9zb0MsZUFBYyxDQUFHQSxjQUFjLENBQUNwaUMsSUFBZixDQUFvQmxHLEtBQXBCLENBQUgsQ0FBZ0MsRUFBckQsQ0FDRCxDQUNELEdBQUl4RCxPQUFNLENBQUl3RCxLQUFLLENBQUcsRUFBdEIsQ0FDQSxNQUFReEQsT0FBTSxFQUFJLEdBQVYsRUFBa0IsRUFBSXdELEtBQUwsRUFBZSxDQUFDNDFCLFFBQWxDLENBQThDLElBQTlDLENBQXFEcDVCLE1BQTVELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMjhDLFNBQVQsQ0FBa0JuMkMsS0FBbEIsQ0FBeUI2OEIsUUFBekIsQ0FBbUMxakIsVUFBbkMsQ0FBK0MsQ0FDN0MsR0FBSW5WLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSThQLFFBQVEsQ0FBR3NwQixhQURmLENBRUl0aEMsTUFBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFGbkIsQ0FHSW14QyxRQUFRLENBQUcsSUFIZixDQUlJenpDLE1BQU0sQ0FBRyxFQUpiLENBS0lnMkMsSUFBSSxDQUFHaDJDLE1BTFgsQ0FPQSxHQUFJMmYsVUFBSixDQUFnQixDQUNkOHpCLFFBQVEsQ0FBRyxLQUFYLENBQ0FuNUIsUUFBUSxDQUFHd3BCLGlCQUFYLENBQ0QsQ0FIRCxJQUlLLElBQUl4aEMsTUFBTSxFQUFJaTFCLGdCQUFkLENBQWdDLENBQ25DLEdBQUluYSxJQUFHLENBQUdpbUIsUUFBUSxDQUFHLElBQUgsQ0FBVXVaLFNBQVMsQ0FBQ3AyQyxLQUFELENBQXJDLENBQ0EsR0FBSTRXLEdBQUosQ0FBUyxDQUNQLE1BQU9rcUIsV0FBVSxDQUFDbHFCLEdBQUQsQ0FBakIsQ0FDRCxDQUNEcTJCLFFBQVEsQ0FBRyxLQUFYLENBQ0FuNUIsUUFBUSxDQUFHMnJCLFFBQVgsQ0FDQStQLElBQUksQ0FBRyxHQUFJdEcsU0FBSixFQUFQLENBQ0QsQ0FSSSxJQVNBLENBQ0hzRyxJQUFJLENBQUczUyxRQUFRLENBQUcsRUFBSCxDQUFRcmpDLE1BQXZCLENBQ0QsQ0FDRGt1QyxLQUFLLENBQ0wsTUFBTyxFQUFFMWpDLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlrQixNQUFLLENBQUdnRCxLQUFLLENBQUNnRSxLQUFELENBQWpCLENBQ0k0akMsUUFBUSxDQUFHL0ssUUFBUSxDQUFHQSxRQUFRLENBQUM3L0IsS0FBRCxDQUFYLENBQXFCQSxLQUQ1QyxDQUdBQSxLQUFLLENBQUltYyxVQUFVLEVBQUluYyxLQUFLLEdBQUssQ0FBekIsQ0FBOEJBLEtBQTlCLENBQXNDLENBQTlDLENBQ0EsR0FBSWl3QyxRQUFRLEVBQUlyRixRQUFRLEdBQUtBLFFBQTdCLENBQXVDLENBQ3JDLEdBQUl5TyxVQUFTLENBQUc3RyxJQUFJLENBQUMxekMsTUFBckIsQ0FDQSxNQUFPdTZDLFNBQVMsRUFBaEIsQ0FBb0IsQ0FDbEIsR0FBSTdHLElBQUksQ0FBQzZHLFNBQUQsQ0FBSixHQUFvQnpPLFFBQXhCLENBQWtDLENBQ2hDLFFBQVNGLE1BQVQsQ0FDRCxDQUNGLENBQ0QsR0FBSTdLLFFBQUosQ0FBYyxDQUNaMlMsSUFBSSxDQUFDdm9DLElBQUwsQ0FBVTJnQyxRQUFWLEVBQ0QsQ0FDRHB1QyxNQUFNLENBQUN5TixJQUFQLENBQVlqSyxLQUFaLEVBQ0QsQ0FYRCxJQVlLLElBQUksQ0FBQzhXLFFBQVEsQ0FBQzA3QixJQUFELENBQU81SCxRQUFQLENBQWlCenVCLFVBQWpCLENBQWIsQ0FBMkMsQ0FDOUMsR0FBSXEyQixJQUFJLEdBQUtoMkMsTUFBYixDQUFxQixDQUNuQmcyQyxJQUFJLENBQUN2b0MsSUFBTCxDQUFVMmdDLFFBQVYsRUFDRCxDQUNEcHVDLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWWpLLEtBQVosRUFDRCxDQUNGLENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMjZDLFVBQVQsQ0FBbUJ2MEMsTUFBbkIsQ0FBMkJrSixJQUEzQixDQUFpQyxDQUMvQkEsSUFBSSxDQUFHeWxDLFFBQVEsQ0FBQ3psQyxJQUFELENBQU9sSixNQUFQLENBQWYsQ0FDQUEsTUFBTSxDQUFHbEgsTUFBTSxDQUFDa0gsTUFBRCxDQUFTa0osSUFBVCxDQUFmLENBQ0EsTUFBT2xKLE9BQU0sRUFBSSxJQUFWLEVBQWtCLE1BQU9BLE9BQU0sQ0FBQzR1QyxLQUFLLENBQUN4MEMsSUFBSSxDQUFDOE8sSUFBRCxDQUFMLENBQU4sQ0FBdEMsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3d0QyxXQUFULENBQW9CMTJDLE1BQXBCLENBQTRCa0osSUFBNUIsQ0FBa0NpUCxPQUFsQyxDQUEyQzJ6QixVQUEzQyxDQUF1RCxDQUNyRCxNQUFPbUksUUFBTyxDQUFDajBDLE1BQUQsQ0FBU2tKLElBQVQsQ0FBZWlQLE9BQU8sQ0FBQ3UyQixPQUFPLENBQUMxdUMsTUFBRCxDQUFTa0osSUFBVCxDQUFSLENBQXRCLENBQStDNGlDLFVBQS9DLENBQWQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNkssVUFBVCxDQUFtQnYyQyxLQUFuQixDQUEwQm1FLFNBQTFCLENBQXFDcXlDLE1BQXJDLENBQTZDbFksU0FBN0MsQ0FBd0QsQ0FDdEQsR0FBSXhpQyxPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNJa0ksS0FBSyxDQUFHczZCLFNBQVMsQ0FBR3hpQyxNQUFILENBQVksQ0FBQyxDQURsQyxDQUdBLE1BQU8sQ0FBQ3dpQyxTQUFTLENBQUd0NkIsS0FBSyxFQUFSLENBQWEsRUFBRUEsS0FBRixDQUFVbEksTUFBakMsR0FDTHFJLFNBQVMsQ0FBQ25FLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBTixDQUFlQSxLQUFmLENBQXNCaEUsS0FBdEIsQ0FEWCxDQUN5QyxDQUFFLENBRTNDLE1BQU93MkMsT0FBTSxDQUNUekIsU0FBUyxDQUFDLzBDLEtBQUQsQ0FBU3MrQixTQUFTLENBQUcsQ0FBSCxDQUFPdDZCLEtBQXpCLENBQWtDczZCLFNBQVMsQ0FBR3Q2QixLQUFLLENBQUcsQ0FBWCxDQUFlbEksTUFBMUQsQ0FEQSxDQUVUaTVDLFNBQVMsQ0FBQy8wQyxLQUFELENBQVNzK0IsU0FBUyxDQUFHdDZCLEtBQUssQ0FBRyxDQUFYLENBQWUsQ0FBakMsQ0FBc0NzNkIsU0FBUyxDQUFHeGlDLE1BQUgsQ0FBWWtJLEtBQTNELENBRmIsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lqQyxpQkFBVCxDQUEwQnpxQyxLQUExQixDQUFpQ3k1QyxPQUFqQyxDQUEwQyxDQUN4QyxHQUFJajlDLE9BQU0sQ0FBR3dELEtBQWIsQ0FDQSxHQUFJeEQsTUFBTSxXQUFZaXNDLFlBQXRCLENBQW1DLENBQ2pDanNDLE1BQU0sQ0FBR0EsTUFBTSxDQUFDd0QsS0FBUCxFQUFULENBQ0QsQ0FDRCxNQUFPeWdDLFlBQVcsQ0FBQ2daLE9BQUQsQ0FBVSxTQUFTajlDLE1BQVQsQ0FBaUI3QyxNQUFqQixDQUF5QixDQUNuRCxNQUFPQSxPQUFNLENBQUM4bEMsSUFBUCxDQUFZLzZCLEtBQVosQ0FBa0IvSyxNQUFNLENBQUMrbEMsT0FBekIsQ0FBa0NjLFNBQVMsQ0FBQyxDQUFDaGtDLE1BQUQsQ0FBRCxDQUFXN0MsTUFBTSxDQUFDbU8sSUFBbEIsQ0FBM0MsQ0FBUCxDQUNELENBRmlCLENBRWZ0TCxNQUZlLENBQWxCLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrOUMsUUFBVCxDQUFpQnZILE1BQWpCLENBQXlCdFMsUUFBekIsQ0FBbUMxakIsVUFBbkMsQ0FBK0MsQ0FDN0MsR0FBSXJkLE9BQU0sQ0FBR3F6QyxNQUFNLENBQUNyekMsTUFBcEIsQ0FDQSxHQUFJQSxNQUFNLENBQUcsQ0FBYixDQUFnQixDQUNkLE1BQU9BLE9BQU0sQ0FBR3E2QyxRQUFRLENBQUNoSCxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQVgsQ0FBeUIsRUFBdEMsQ0FDRCxDQUNELEdBQUluckMsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJeEssTUFBTSxDQUFHRSxLQUFLLENBQUNvQyxNQUFELENBRGxCLENBR0EsTUFBTyxFQUFFa0ksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWtFLE1BQUssQ0FBR212QyxNQUFNLENBQUNuckMsS0FBRCxDQUFsQixDQUNJcXJDLFFBQVEsQ0FBRyxDQUFDLENBRGhCLENBR0EsTUFBTyxFQUFFQSxRQUFGLENBQWF2ekMsTUFBcEIsQ0FBNEIsQ0FDMUIsR0FBSXV6QyxRQUFRLEVBQUlyckMsS0FBaEIsQ0FBdUIsQ0FDckJ4SyxNQUFNLENBQUN3SyxLQUFELENBQU4sQ0FBZ0JncEMsY0FBYyxDQUFDeHpDLE1BQU0sQ0FBQ3dLLEtBQUQsQ0FBTixFQUFpQmhFLEtBQWxCLENBQXlCbXZDLE1BQU0sQ0FBQ0UsUUFBRCxDQUEvQixDQUEyQ3hTLFFBQTNDLENBQXFEMWpCLFVBQXJELENBQTlCLENBQ0QsQ0FDRixDQUNGLENBQ0QsTUFBT2c5QixTQUFRLENBQUNwSSxXQUFXLENBQUN2MEMsTUFBRCxDQUFTLENBQVQsQ0FBWixDQUF5QnFqQyxRQUF6QixDQUFtQzFqQixVQUFuQyxDQUFmLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdzlCLGNBQVQsQ0FBdUJ4WCxLQUF2QixDQUE4QnpmLE1BQTlCLENBQXNDazNCLFVBQXRDLENBQWtELENBQ2hELEdBQUk1eUMsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHcWpDLEtBQUssQ0FBQ3JqQyxNQURuQixDQUVJKzZDLFVBQVUsQ0FBR24zQixNQUFNLENBQUM1akIsTUFGeEIsQ0FHSXRDLE1BQU0sQ0FBRyxFQUhiLENBS0EsTUFBTyxFQUFFd0ssS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWtCLE1BQUssQ0FBR2dILEtBQUssQ0FBRzZ5QyxVQUFSLENBQXFCbjNCLE1BQU0sQ0FBQzFiLEtBQUQsQ0FBM0IsQ0FBcUNuSSxTQUFqRCxDQUNBKzZDLFVBQVUsQ0FBQ3A5QyxNQUFELENBQVMybEMsS0FBSyxDQUFDbjdCLEtBQUQsQ0FBZCxDQUF1QmhILEtBQXZCLENBQVYsQ0FDRCxDQUNELE1BQU94RCxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzOUMsb0JBQVQsQ0FBNkI5NUMsS0FBN0IsQ0FBb0MsQ0FDbEMsTUFBT2kyQyxrQkFBaUIsQ0FBQ2oyQyxLQUFELENBQWpCLENBQTJCQSxLQUEzQixDQUFtQyxFQUExQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTKzVDLGFBQVQsQ0FBc0IvNUMsS0FBdEIsQ0FBNkIsQ0FDM0IsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFVBQWhCLENBQTZCQSxLQUE3QixDQUFxQzQwQyxRQUE1QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNyRCxTQUFULENBQWtCdnhDLEtBQWxCLENBQXlCNEMsTUFBekIsQ0FBaUMsQ0FDL0IsR0FBSXVELE9BQU8sQ0FBQ25HLEtBQUQsQ0FBWCxDQUFvQixDQUNsQixNQUFPQSxNQUFQLENBQ0QsQ0FDRCxNQUFPeTFDLE1BQUssQ0FBQ3oxQyxLQUFELENBQVE0QyxNQUFSLENBQUwsQ0FBdUIsQ0FBQzVDLEtBQUQsQ0FBdkIsQ0FBaUNnNkMsWUFBWSxDQUFDL3pDLFFBQVEsQ0FBQ2pHLEtBQUQsQ0FBVCxDQUFwRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWk2QyxTQUFRLENBQUczQyxRQUFmLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzRDLFVBQVQsQ0FBbUJsM0MsS0FBbkIsQ0FBMEJzVSxLQUExQixDQUFpQ2hILEdBQWpDLENBQXNDLENBQ3BDLEdBQUl4UixPQUFNLENBQUdrRSxLQUFLLENBQUNsRSxNQUFuQixDQUNBd1IsR0FBRyxDQUFHQSxHQUFHLEdBQUt6UixTQUFSLENBQW9CQyxNQUFwQixDQUE2QndSLEdBQW5DLENBQ0EsTUFBUSxDQUFDZ0gsS0FBRCxFQUFVaEgsR0FBRyxFQUFJeFIsTUFBbEIsQ0FBNEJrRSxLQUE1QixDQUFvQyswQyxTQUFTLENBQUMvMEMsS0FBRCxDQUFRc1UsS0FBUixDQUFlaEgsR0FBZixDQUFwRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWcyQixhQUFZLENBQUdELGVBQWUsRUFBSSxTQUFTbDhCLEVBQVQsQ0FBYSxDQUNqRCxNQUFPNlYsS0FBSSxDQUFDc21CLFlBQUwsQ0FBa0JuOEIsRUFBbEIsQ0FBUCxDQUNELENBRkQsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUytrQyxZQUFULENBQXFCaUwsTUFBckIsQ0FBNkJ4TCxNQUE3QixDQUFxQyxDQUNuQyxHQUFJQSxNQUFKLENBQVksQ0FDVixNQUFPd0wsT0FBTSxDQUFDMzNDLEtBQVAsRUFBUCxDQUNELENBQ0QsR0FBSTFELE9BQU0sQ0FBR3E3QyxNQUFNLENBQUNyN0MsTUFBcEIsQ0FDSXRDLE1BQU0sQ0FBR29wQyxXQUFXLENBQUdBLFdBQVcsQ0FBQzltQyxNQUFELENBQWQsQ0FBeUIsR0FBSXE3QyxPQUFNLENBQUNodEMsV0FBWCxDQUF1QnJPLE1BQXZCLENBRGpELENBR0FxN0MsTUFBTSxDQUFDQyxJQUFQLENBQVk1OUMsTUFBWixFQUNBLE1BQU9BLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzY5QyxpQkFBVCxDQUEwQkMsV0FBMUIsQ0FBdUMsQ0FDckMsR0FBSTk5QyxPQUFNLENBQUcsR0FBSTg5QyxZQUFXLENBQUNudEMsV0FBaEIsQ0FBNEJtdEMsV0FBVyxDQUFDQyxVQUF4QyxDQUFiLENBQ0EsR0FBSTVVLFdBQUosQ0FBZW5wQyxNQUFmLEVBQXVCb2QsR0FBdkIsQ0FBMkIsR0FBSStyQixXQUFKLENBQWUyVSxXQUFmLENBQTNCLEVBQ0EsTUFBTzk5QyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2crQyxjQUFULENBQXVCQyxRQUF2QixDQUFpQzlMLE1BQWpDLENBQXlDLENBQ3ZDLEdBQUl3TCxPQUFNLENBQUd4TCxNQUFNLENBQUcwTCxnQkFBZ0IsQ0FBQ0ksUUFBUSxDQUFDTixNQUFWLENBQW5CLENBQXVDTSxRQUFRLENBQUNOLE1BQW5FLENBQ0EsTUFBTyxJQUFJTSxTQUFRLENBQUN0dEMsV0FBYixDQUF5Qmd0QyxNQUF6QixDQUFpQ00sUUFBUSxDQUFDQyxVQUExQyxDQUFzREQsUUFBUSxDQUFDRixVQUEvRCxDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNJLFlBQVQsQ0FBcUJDLE1BQXJCLENBQTZCLENBQzNCLEdBQUlwK0MsT0FBTSxDQUFHLEdBQUlvK0MsT0FBTSxDQUFDenRDLFdBQVgsQ0FBdUJ5dEMsTUFBTSxDQUFDbHpDLE1BQTlCLENBQXNDb3lCLE9BQU8sQ0FBQ3NMLElBQVIsQ0FBYXdWLE1BQWIsQ0FBdEMsQ0FBYixDQUNBcCtDLE1BQU0sQ0FBQytuQyxTQUFQLENBQW1CcVcsTUFBTSxDQUFDclcsU0FBMUIsQ0FDQSxNQUFPL25DLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3ErQyxZQUFULENBQXFCQyxNQUFyQixDQUE2QixDQUMzQixNQUFPelMsY0FBYSxDQUFHdGlDLE1BQU0sQ0FBQ3NpQyxhQUFhLENBQUNuaUMsSUFBZCxDQUFtQjQwQyxNQUFuQixDQUFELENBQVQsQ0FBd0MsRUFBNUQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNUUsZ0JBQVQsQ0FBeUI2RSxVQUF6QixDQUFxQ3BNLE1BQXJDLENBQTZDLENBQzNDLEdBQUl3TCxPQUFNLENBQUd4TCxNQUFNLENBQUcwTCxnQkFBZ0IsQ0FBQ1UsVUFBVSxDQUFDWixNQUFaLENBQW5CLENBQXlDWSxVQUFVLENBQUNaLE1BQXZFLENBQ0EsTUFBTyxJQUFJWSxXQUFVLENBQUM1dEMsV0FBZixDQUEyQmd0QyxNQUEzQixDQUFtQ1ksVUFBVSxDQUFDTCxVQUE5QyxDQUEwREssVUFBVSxDQUFDajhDLE1BQXJFLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTazhDLGlCQUFULENBQTBCaDdDLEtBQTFCLENBQWlDa1gsS0FBakMsQ0FBd0MsQ0FDdEMsR0FBSWxYLEtBQUssR0FBS2tYLEtBQWQsQ0FBcUIsQ0FDbkIsR0FBSStqQyxhQUFZLENBQUdqN0MsS0FBSyxHQUFLbkIsU0FBN0IsQ0FDSTI1QyxTQUFTLENBQUd4NEMsS0FBSyxHQUFLLElBRDFCLENBRUlrN0MsY0FBYyxDQUFHbDdDLEtBQUssR0FBS0EsS0FGL0IsQ0FHSXk0QyxXQUFXLENBQUcvSCxRQUFRLENBQUMxd0MsS0FBRCxDQUgxQixDQUtBLEdBQUkyNEMsYUFBWSxDQUFHemhDLEtBQUssR0FBS3JZLFNBQTdCLENBQ0krNUMsU0FBUyxDQUFHMWhDLEtBQUssR0FBSyxJQUQxQixDQUVJMmhDLGNBQWMsQ0FBRzNoQyxLQUFLLEdBQUtBLEtBRi9CLENBR0k0aEMsV0FBVyxDQUFHcEksUUFBUSxDQUFDeDVCLEtBQUQsQ0FIMUIsQ0FLQSxHQUFLLENBQUMwaEMsU0FBRCxFQUFjLENBQUNFLFdBQWYsRUFBOEIsQ0FBQ0wsV0FBL0IsRUFBOEN6NEMsS0FBSyxDQUFHa1gsS0FBdkQsRUFDQ3VoQyxXQUFXLEVBQUlFLFlBQWYsRUFBK0JFLGNBQS9CLEVBQWlELENBQUNELFNBQWxELEVBQStELENBQUNFLFdBRGpFLEVBRUNOLFNBQVMsRUFBSUcsWUFBYixFQUE2QkUsY0FGOUIsRUFHQyxDQUFDb0MsWUFBRCxFQUFpQnBDLGNBSGxCLEVBSUEsQ0FBQ3FDLGNBSkwsQ0FJcUIsQ0FDbkIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFLLENBQUMxQyxTQUFELEVBQWMsQ0FBQ0MsV0FBZixFQUE4QixDQUFDSyxXQUEvQixFQUE4Qzk0QyxLQUFLLENBQUdrWCxLQUF2RCxFQUNDNGhDLFdBQVcsRUFBSW1DLFlBQWYsRUFBK0JDLGNBQS9CLEVBQWlELENBQUMxQyxTQUFsRCxFQUErRCxDQUFDQyxXQURqRSxFQUVDRyxTQUFTLEVBQUlxQyxZQUFiLEVBQTZCQyxjQUY5QixFQUdDLENBQUN2QyxZQUFELEVBQWlCdUMsY0FIbEIsRUFJQSxDQUFDckMsY0FKTCxDQUlxQixDQUNuQixNQUFPLENBQUMsQ0FBUixDQUNELENBQ0YsQ0FDRCxNQUFPLEVBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbkMsZ0JBQVQsQ0FBeUI5ekMsTUFBekIsQ0FBaUNzVSxLQUFqQyxDQUF3Q3EvQixNQUF4QyxDQUFnRCxDQUM5QyxHQUFJdnZDLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSW0wQyxXQUFXLENBQUd2NEMsTUFBTSxDQUFDNnpDLFFBRHpCLENBRUkyRSxXQUFXLENBQUdsa0MsS0FBSyxDQUFDdS9CLFFBRnhCLENBR0kzM0MsTUFBTSxDQUFHcThDLFdBQVcsQ0FBQ3I4QyxNQUh6QixDQUlJdThDLFlBQVksQ0FBRzlFLE1BQU0sQ0FBQ3ozQyxNQUoxQixDQU1BLE1BQU8sRUFBRWtJLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUl0QyxPQUFNLENBQUd3K0MsZ0JBQWdCLENBQUNHLFdBQVcsQ0FBQ24wQyxLQUFELENBQVosQ0FBcUJvMEMsV0FBVyxDQUFDcDBDLEtBQUQsQ0FBaEMsQ0FBN0IsQ0FDQSxHQUFJeEssTUFBSixDQUFZLENBQ1YsR0FBSXdLLEtBQUssRUFBSXEwQyxZQUFiLENBQTJCLENBQ3pCLE1BQU83K0MsT0FBUCxDQUNELENBQ0QsR0FBSTgrQyxNQUFLLENBQUcvRSxNQUFNLENBQUN2dkMsS0FBRCxDQUFsQixDQUNBLE1BQU94SyxPQUFNLEVBQUk4K0MsS0FBSyxFQUFJLE1BQVQsQ0FBa0IsQ0FBQyxDQUFuQixDQUF1QixDQUEzQixDQUFiLENBQ0QsQ0FDRixDQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTzE0QyxPQUFNLENBQUNvRSxLQUFQLENBQWVrUSxLQUFLLENBQUNsUSxLQUE1QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1MEMsWUFBVCxDQUFxQnp6QyxJQUFyQixDQUEyQjB6QyxRQUEzQixDQUFxQ0MsT0FBckMsQ0FBOENDLFNBQTlDLENBQXlELENBQ3ZELEdBQUlDLFVBQVMsQ0FBRyxDQUFDLENBQWpCLENBQ0lDLFVBQVUsQ0FBRzl6QyxJQUFJLENBQUNoSixNQUR0QixDQUVJKzhDLGFBQWEsQ0FBR0osT0FBTyxDQUFDMzhDLE1BRjVCLENBR0lnOUMsU0FBUyxDQUFHLENBQUMsQ0FIakIsQ0FJSUMsVUFBVSxDQUFHUCxRQUFRLENBQUMxOEMsTUFKMUIsQ0FLSWs5QyxXQUFXLENBQUc3VSxTQUFTLENBQUN5VSxVQUFVLENBQUdDLGFBQWQsQ0FBNkIsQ0FBN0IsQ0FMM0IsQ0FNSXIvQyxNQUFNLENBQUdFLEtBQUssQ0FBQ3EvQyxVQUFVLENBQUdDLFdBQWQsQ0FObEIsQ0FPSUMsV0FBVyxDQUFHLENBQUNQLFNBUG5CLENBU0EsTUFBTyxFQUFFSSxTQUFGLENBQWNDLFVBQXJCLENBQWlDLENBQy9Cdi9DLE1BQU0sQ0FBQ3MvQyxTQUFELENBQU4sQ0FBb0JOLFFBQVEsQ0FBQ00sU0FBRCxDQUE1QixDQUNELENBQ0QsTUFBTyxFQUFFSCxTQUFGLENBQWNFLGFBQXJCLENBQW9DLENBQ2xDLEdBQUlJLFdBQVcsRUFBSU4sU0FBUyxDQUFHQyxVQUEvQixDQUEyQyxDQUN6Q3AvQyxNQUFNLENBQUNpL0MsT0FBTyxDQUFDRSxTQUFELENBQVIsQ0FBTixDQUE2Qjd6QyxJQUFJLENBQUM2ekMsU0FBRCxDQUFqQyxDQUNELENBQ0YsQ0FDRCxNQUFPSyxXQUFXLEVBQWxCLENBQXNCLENBQ3BCeC9DLE1BQU0sQ0FBQ3MvQyxTQUFTLEVBQVYsQ0FBTixDQUFzQmgwQyxJQUFJLENBQUM2ekMsU0FBUyxFQUFWLENBQTFCLENBQ0QsQ0FDRCxNQUFPbi9DLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMC9DLGlCQUFULENBQTBCcDBDLElBQTFCLENBQWdDMHpDLFFBQWhDLENBQTBDQyxPQUExQyxDQUFtREMsU0FBbkQsQ0FBOEQsQ0FDNUQsR0FBSUMsVUFBUyxDQUFHLENBQUMsQ0FBakIsQ0FDSUMsVUFBVSxDQUFHOXpDLElBQUksQ0FBQ2hKLE1BRHRCLENBRUlxOUMsWUFBWSxDQUFHLENBQUMsQ0FGcEIsQ0FHSU4sYUFBYSxDQUFHSixPQUFPLENBQUMzOEMsTUFINUIsQ0FJSXM5QyxVQUFVLENBQUcsQ0FBQyxDQUpsQixDQUtJQyxXQUFXLENBQUdiLFFBQVEsQ0FBQzE4QyxNQUwzQixDQU1JazlDLFdBQVcsQ0FBRzdVLFNBQVMsQ0FBQ3lVLFVBQVUsQ0FBR0MsYUFBZCxDQUE2QixDQUE3QixDQU4zQixDQU9Jci9DLE1BQU0sQ0FBR0UsS0FBSyxDQUFDcy9DLFdBQVcsQ0FBR0ssV0FBZixDQVBsQixDQVFJSixXQUFXLENBQUcsQ0FBQ1AsU0FSbkIsQ0FVQSxNQUFPLEVBQUVDLFNBQUYsQ0FBY0ssV0FBckIsQ0FBa0MsQ0FDaEN4L0MsTUFBTSxDQUFDbS9DLFNBQUQsQ0FBTixDQUFvQjd6QyxJQUFJLENBQUM2ekMsU0FBRCxDQUF4QixDQUNELENBQ0QsR0FBSTN3QyxPQUFNLENBQUcyd0MsU0FBYixDQUNBLE1BQU8sRUFBRVMsVUFBRixDQUFlQyxXQUF0QixDQUFtQyxDQUNqQzcvQyxNQUFNLENBQUN3TyxNQUFNLENBQUdveEMsVUFBVixDQUFOLENBQThCWixRQUFRLENBQUNZLFVBQUQsQ0FBdEMsQ0FDRCxDQUNELE1BQU8sRUFBRUQsWUFBRixDQUFpQk4sYUFBeEIsQ0FBdUMsQ0FDckMsR0FBSUksV0FBVyxFQUFJTixTQUFTLENBQUdDLFVBQS9CLENBQTJDLENBQ3pDcC9DLE1BQU0sQ0FBQ3dPLE1BQU0sQ0FBR3l3QyxPQUFPLENBQUNVLFlBQUQsQ0FBakIsQ0FBTixDQUF5Q3IwQyxJQUFJLENBQUM2ekMsU0FBUyxFQUFWLENBQTdDLENBQ0QsQ0FDRixDQUNELE1BQU9uL0MsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxdEMsVUFBVCxDQUFtQm5pQyxNQUFuQixDQUEyQjFFLEtBQTNCLENBQWtDLENBQ2hDLEdBQUlnRSxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUc0SSxNQUFNLENBQUM1SSxNQURwQixDQUdBa0UsS0FBSyxHQUFLQSxLQUFLLENBQUd0RyxLQUFLLENBQUNvQyxNQUFELENBQWxCLENBQUwsQ0FDQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QmtFLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBTCxDQUFlVSxNQUFNLENBQUNWLEtBQUQsQ0FBckIsQ0FDRCxDQUNELE1BQU9oRSxNQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpckMsV0FBVCxDQUFvQnZtQyxNQUFwQixDQUE0Qnk2QixLQUE1QixDQUFtQ3YvQixNQUFuQyxDQUEyQzhyQyxVQUEzQyxDQUF1RCxDQUNyRCxHQUFJNE4sTUFBSyxDQUFHLENBQUMxNUMsTUFBYixDQUNBQSxNQUFNLEdBQUtBLE1BQU0sQ0FBRyxFQUFkLENBQU4sQ0FFQSxHQUFJb0UsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHcWpDLEtBQUssQ0FBQ3JqQyxNQURuQixDQUdBLE1BQU8sRUFBRWtJLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUlzSSxJQUFHLENBQUcrNkIsS0FBSyxDQUFDbjdCLEtBQUQsQ0FBZixDQUVBLEdBQUltYSxTQUFRLENBQUd1dEIsVUFBVSxDQUNyQkEsVUFBVSxDQUFDOXJDLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBUCxDQUFjTSxNQUFNLENBQUNOLEdBQUQsQ0FBcEIsQ0FBMkJBLEdBQTNCLENBQWdDeEUsTUFBaEMsQ0FBd0M4RSxNQUF4QyxDQURXLENBRXJCN0ksU0FGSixDQUlBLEdBQUlzaUIsUUFBUSxHQUFLdGlCLFNBQWpCLENBQTRCLENBQzFCc2lCLFFBQVEsQ0FBR3paLE1BQU0sQ0FBQ04sR0FBRCxDQUFqQixDQUNELENBQ0QsR0FBSWsxQyxLQUFKLENBQVcsQ0FDVDNPLGVBQWUsQ0FBQy9xQyxNQUFELENBQVN3RSxHQUFULENBQWMrWixRQUFkLENBQWYsQ0FDRCxDQUZELElBRU8sQ0FDTHlzQixXQUFXLENBQUNockMsTUFBRCxDQUFTd0UsR0FBVCxDQUFjK1osUUFBZCxDQUFYLENBQ0QsQ0FDRixDQUNELE1BQU92ZSxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lzQyxZQUFULENBQXFCM25DLE1BQXJCLENBQTZCOUUsTUFBN0IsQ0FBcUMsQ0FDbkMsTUFBT3FyQyxXQUFVLENBQUN2bUMsTUFBRCxDQUFTNjBDLFVBQVUsQ0FBQzcwQyxNQUFELENBQW5CLENBQTZCOUUsTUFBN0IsQ0FBakIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTd3NDLGNBQVQsQ0FBdUIxbkMsTUFBdkIsQ0FBK0I5RSxNQUEvQixDQUF1QyxDQUNyQyxNQUFPcXJDLFdBQVUsQ0FBQ3ZtQyxNQUFELENBQVM4MEMsWUFBWSxDQUFDOTBDLE1BQUQsQ0FBckIsQ0FBK0I5RSxNQUEvQixDQUFqQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2NUMsaUJBQVQsQ0FBMEI3YyxNQUExQixDQUFrQzhjLFdBQWxDLENBQStDLENBQzdDLE1BQU8sVUFBU2owQyxVQUFULENBQXFCbzNCLFFBQXJCLENBQStCLENBQ3BDLEdBQUlKLEtBQUksQ0FBR3Q1QixPQUFPLENBQUNzQyxVQUFELENBQVAsQ0FBc0JrM0IsZUFBdEIsQ0FBd0NtTyxjQUFuRCxDQUNJaE8sV0FBVyxDQUFHNGMsV0FBVyxDQUFHQSxXQUFXLEVBQWQsQ0FBbUIsRUFEaEQsQ0FHQSxNQUFPamQsS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYW0zQixNQUFiLENBQXFCNFcsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBaEMsQ0FBK0NDLFdBQS9DLENBQVgsQ0FDRCxDQUxELENBTUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2YyxlQUFULENBQXdCQyxRQUF4QixDQUFrQyxDQUNoQyxNQUFPdEYsU0FBUSxDQUFDLFNBQVMxMEMsTUFBVCxDQUFpQmk2QyxPQUFqQixDQUEwQixDQUN4QyxHQUFJNzFDLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBRys5QyxPQUFPLENBQUMvOUMsTUFEckIsQ0FFSTR2QyxVQUFVLENBQUc1dkMsTUFBTSxDQUFHLENBQVQsQ0FBYSs5QyxPQUFPLENBQUMvOUMsTUFBTSxDQUFHLENBQVYsQ0FBcEIsQ0FBbUNELFNBRnBELENBR0lpK0MsS0FBSyxDQUFHaCtDLE1BQU0sQ0FBRyxDQUFULENBQWErOUMsT0FBTyxDQUFDLENBQUQsQ0FBcEIsQ0FBMEJoK0MsU0FIdEMsQ0FLQTZ2QyxVQUFVLENBQUlrTyxRQUFRLENBQUM5OUMsTUFBVCxDQUFrQixDQUFsQixFQUF1QixNQUFPNHZDLFdBQVAsRUFBcUIsVUFBN0MsRUFDUjV2QyxNQUFNLEdBQUk0dkMsVUFERixFQUVUN3ZDLFNBRkosQ0FJQSxHQUFJaStDLEtBQUssRUFBSUMsY0FBYyxDQUFDRixPQUFPLENBQUMsQ0FBRCxDQUFSLENBQWFBLE9BQU8sQ0FBQyxDQUFELENBQXBCLENBQXlCQyxLQUF6QixDQUEzQixDQUE0RCxDQUMxRHBPLFVBQVUsQ0FBRzV2QyxNQUFNLENBQUcsQ0FBVCxDQUFhRCxTQUFiLENBQXlCNnZDLFVBQXRDLENBQ0E1dkMsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUNEOEQsTUFBTSxDQUFHbUQsTUFBTSxDQUFDbkQsTUFBRCxDQUFmLENBQ0EsTUFBTyxFQUFFb0UsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSTRJLE9BQU0sQ0FBR20xQyxPQUFPLENBQUM3MUMsS0FBRCxDQUFwQixDQUNBLEdBQUlVLE1BQUosQ0FBWSxDQUNWazFDLFFBQVEsQ0FBQ2g2QyxNQUFELENBQVM4RSxNQUFULENBQWlCVixLQUFqQixDQUF3QjBuQyxVQUF4QixDQUFSLENBQ0QsQ0FDRixDQUNELE1BQU85ckMsT0FBUCxDQUNELENBdEJjLENBQWYsQ0F1QkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3d0QyxlQUFULENBQXdCalAsUUFBeEIsQ0FBa0NHLFNBQWxDLENBQTZDLENBQzNDLE1BQU8sVUFBUzc0QixVQUFULENBQXFCbzNCLFFBQXJCLENBQStCLENBQ3BDLEdBQUlwM0IsVUFBVSxFQUFJLElBQWxCLENBQXdCLENBQ3RCLE1BQU9BLFdBQVAsQ0FDRCxDQUNELEdBQUksQ0FBQzRKLFdBQVcsQ0FBQzVKLFVBQUQsQ0FBaEIsQ0FBOEIsQ0FDNUIsTUFBTzA0QixTQUFRLENBQUMxNEIsVUFBRCxDQUFhbzNCLFFBQWIsQ0FBZixDQUNELENBQ0QsR0FBSS9nQyxPQUFNLENBQUcySixVQUFVLENBQUMzSixNQUF4QixDQUNJa0ksS0FBSyxDQUFHczZCLFNBQVMsQ0FBR3hpQyxNQUFILENBQVksQ0FBQyxDQURsQyxDQUVJb0UsUUFBUSxDQUFHNkMsTUFBTSxDQUFDMEMsVUFBRCxDQUZyQixDQUlBLE1BQVE2NEIsU0FBUyxDQUFHdDZCLEtBQUssRUFBUixDQUFhLEVBQUVBLEtBQUYsQ0FBVWxJLE1BQXhDLENBQWlELENBQy9DLEdBQUkrZ0MsUUFBUSxDQUFDMzhCLFFBQVEsQ0FBQzhELEtBQUQsQ0FBVCxDQUFrQkEsS0FBbEIsQ0FBeUI5RCxRQUF6QixDQUFSLEdBQStDLEtBQW5ELENBQTBELENBQ3hELE1BQ0QsQ0FDRixDQUNELE1BQU91RixXQUFQLENBQ0QsQ0FqQkQsQ0FrQkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMwb0MsY0FBVCxDQUF1QjdQLFNBQXZCLENBQWtDLENBQ2hDLE1BQU8sVUFBUzErQixNQUFULENBQWlCaTlCLFFBQWpCLENBQTJCNFAsUUFBM0IsQ0FBcUMsQ0FDMUMsR0FBSXpvQyxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0k5RCxRQUFRLENBQUc2QyxNQUFNLENBQUNuRCxNQUFELENBRHJCLENBRUl1L0IsS0FBSyxDQUFHc04sUUFBUSxDQUFDN3NDLE1BQUQsQ0FGcEIsQ0FHSTlELE1BQU0sQ0FBR3FqQyxLQUFLLENBQUNyakMsTUFIbkIsQ0FLQSxNQUFPQSxNQUFNLEVBQWIsQ0FBaUIsQ0FDZixHQUFJc0ksSUFBRyxDQUFHKzZCLEtBQUssQ0FBQ2IsU0FBUyxDQUFHeGlDLE1BQUgsQ0FBWSxFQUFFa0ksS0FBeEIsQ0FBZixDQUNBLEdBQUk2NEIsUUFBUSxDQUFDMzhCLFFBQVEsQ0FBQ2tFLEdBQUQsQ0FBVCxDQUFnQkEsR0FBaEIsQ0FBcUJsRSxRQUFyQixDQUFSLEdBQTJDLEtBQS9DLENBQXNELENBQ3BELE1BQ0QsQ0FDRixDQUNELE1BQU9OLE9BQVAsQ0FDRCxDQWJELENBY0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvNkMsV0FBVCxDQUFvQnZkLElBQXBCLENBQTBCZ1AsT0FBMUIsQ0FBbUMvTyxPQUFuQyxDQUE0QyxDQUMxQyxHQUFJdWQsT0FBTSxDQUFHeE8sT0FBTyxDQUFHOVosY0FBdkIsQ0FDSXVvQixJQUFJLENBQUdDLFVBQVUsQ0FBQzFkLElBQUQsQ0FEckIsQ0FHQSxRQUFTMmQsUUFBVCxFQUFtQixDQUNqQixHQUFJdHFDLEdBQUUsQ0FBSSxNQUFRLE9BQVNrTixJQUFqQixFQUF5QixlQUFnQm85QixRQUExQyxDQUFxREYsSUFBckQsQ0FBNER6ZCxJQUFyRSxDQUNBLE1BQU8zc0IsR0FBRSxDQUFDcE8sS0FBSCxDQUFTdTRDLE1BQU0sQ0FBR3ZkLE9BQUgsQ0FBYSxJQUE1QixDQUFrQzczQixTQUFsQyxDQUFQLENBQ0QsQ0FDRCxNQUFPdTFDLFFBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU0MsZ0JBQVQsQ0FBeUJDLFVBQXpCLENBQXFDLENBQ25DLE1BQU8sVUFBUzk1QyxNQUFULENBQWlCLENBQ3RCQSxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBRUEsR0FBSW0vQixXQUFVLENBQUdVLFVBQVUsQ0FBQzcvQixNQUFELENBQVYsQ0FDYjJnQyxhQUFhLENBQUMzZ0MsTUFBRCxDQURBLENBRWIzRSxTQUZKLENBSUEsR0FBSXNrQyxJQUFHLENBQUdSLFVBQVUsQ0FDaEJBLFVBQVUsQ0FBQyxDQUFELENBRE0sQ0FFaEJuL0IsTUFBTSxDQUFDNmdDLE1BQVAsQ0FBYyxDQUFkLENBRkosQ0FJQSxHQUFJa1osU0FBUSxDQUFHNWEsVUFBVSxDQUNyQnVYLFNBQVMsQ0FBQ3ZYLFVBQUQsQ0FBYSxDQUFiLENBQVQsQ0FBeUJ4VCxJQUF6QixDQUE4QixFQUE5QixDQURxQixDQUVyQjNyQixNQUFNLENBQUNoQixLQUFQLENBQWEsQ0FBYixDQUZKLENBSUEsTUFBTzJnQyxJQUFHLENBQUNtYSxVQUFELENBQUgsR0FBb0JDLFFBQTNCLENBQ0QsQ0FoQkQsQ0FpQkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLGlCQUFULENBQTBCQyxRQUExQixDQUFvQyxDQUNsQyxNQUFPLFVBQVNqNkMsTUFBVCxDQUFpQixDQUN0QixNQUFPaTlCLFlBQVcsQ0FBQ2lkLEtBQUssQ0FBQ0MsTUFBTSxDQUFDbjZDLE1BQUQsQ0FBTixDQUFlOCtCLE9BQWYsQ0FBdUJ0RixNQUF2QixDQUErQixFQUEvQixDQUFELENBQU4sQ0FBNEN5Z0IsUUFBNUMsQ0FBc0QsRUFBdEQsQ0FBbEIsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU04sV0FBVCxDQUFvQkQsSUFBcEIsQ0FBMEIsQ0FDeEIsTUFBTyxXQUFXLENBQ2hCO0FBQ0E7QUFDQTtBQUNBLEdBQUlwMUMsS0FBSSxDQUFHRCxTQUFYLENBQ0EsT0FBUUMsSUFBSSxDQUFDaEosTUFBYixFQUNFLElBQUssRUFBTCxDQUFRLE1BQU8sSUFBSW8rQyxLQUFKLEVBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlBLEtBQUosQ0FBU3AxQyxJQUFJLENBQUMsQ0FBRCxDQUFiLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlvMUMsS0FBSixDQUFTcDFDLElBQUksQ0FBQyxDQUFELENBQWIsQ0FBa0JBLElBQUksQ0FBQyxDQUFELENBQXRCLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlvMUMsS0FBSixDQUFTcDFDLElBQUksQ0FBQyxDQUFELENBQWIsQ0FBa0JBLElBQUksQ0FBQyxDQUFELENBQXRCLENBQTJCQSxJQUFJLENBQUMsQ0FBRCxDQUEvQixDQUFQLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBTyxJQUFJbzFDLEtBQUosQ0FBU3AxQyxJQUFJLENBQUMsQ0FBRCxDQUFiLENBQWtCQSxJQUFJLENBQUMsQ0FBRCxDQUF0QixDQUEyQkEsSUFBSSxDQUFDLENBQUQsQ0FBL0IsQ0FBb0NBLElBQUksQ0FBQyxDQUFELENBQXhDLENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlvMUMsS0FBSixDQUFTcDFDLElBQUksQ0FBQyxDQUFELENBQWIsQ0FBa0JBLElBQUksQ0FBQyxDQUFELENBQXRCLENBQTJCQSxJQUFJLENBQUMsQ0FBRCxDQUEvQixDQUFvQ0EsSUFBSSxDQUFDLENBQUQsQ0FBeEMsQ0FBNkNBLElBQUksQ0FBQyxDQUFELENBQWpELENBQVAsQ0FDUixJQUFLLEVBQUwsQ0FBUSxNQUFPLElBQUlvMUMsS0FBSixDQUFTcDFDLElBQUksQ0FBQyxDQUFELENBQWIsQ0FBa0JBLElBQUksQ0FBQyxDQUFELENBQXRCLENBQTJCQSxJQUFJLENBQUMsQ0FBRCxDQUEvQixDQUFvQ0EsSUFBSSxDQUFDLENBQUQsQ0FBeEMsQ0FBNkNBLElBQUksQ0FBQyxDQUFELENBQWpELENBQXNEQSxJQUFJLENBQUMsQ0FBRCxDQUExRCxDQUFQLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBTyxJQUFJbzFDLEtBQUosQ0FBU3AxQyxJQUFJLENBQUMsQ0FBRCxDQUFiLENBQWtCQSxJQUFJLENBQUMsQ0FBRCxDQUF0QixDQUEyQkEsSUFBSSxDQUFDLENBQUQsQ0FBL0IsQ0FBb0NBLElBQUksQ0FBQyxDQUFELENBQXhDLENBQTZDQSxJQUFJLENBQUMsQ0FBRCxDQUFqRCxDQUFzREEsSUFBSSxDQUFDLENBQUQsQ0FBMUQsQ0FBK0RBLElBQUksQ0FBQyxDQUFELENBQW5FLENBQVAsQ0FSVixDQVVBLEdBQUk4MUMsWUFBVyxDQUFHaFYsVUFBVSxDQUFDc1UsSUFBSSxDQUFDcjRDLFNBQU4sQ0FBNUIsQ0FDSXJJLE1BQU0sQ0FBRzBnRCxJQUFJLENBQUN4NEMsS0FBTCxDQUFXazVDLFdBQVgsQ0FBd0I5MUMsSUFBeEIsQ0FEYixDQUdBO0FBQ0E7QUFDQSxNQUFPZ2hDLFNBQVEsQ0FBQ3RzQyxNQUFELENBQVIsQ0FBbUJBLE1BQW5CLENBQTRCb2hELFdBQW5DLENBQ0QsQ0FyQkQsQ0FzQkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTQyxZQUFULENBQXFCcGUsSUFBckIsQ0FBMkJnUCxPQUEzQixDQUFvQ3FQLEtBQXBDLENBQTJDLENBQ3pDLEdBQUlaLEtBQUksQ0FBR0MsVUFBVSxDQUFDMWQsSUFBRCxDQUFyQixDQUVBLFFBQVMyZCxRQUFULEVBQW1CLENBQ2pCLEdBQUl0K0MsT0FBTSxDQUFHK0ksU0FBUyxDQUFDL0ksTUFBdkIsQ0FDSWdKLElBQUksQ0FBR3BMLEtBQUssQ0FBQ29DLE1BQUQsQ0FEaEIsQ0FFSWtJLEtBQUssQ0FBR2xJLE1BRlosQ0FHSWlrQyxXQUFXLENBQUdnYixTQUFTLENBQUNYLE9BQUQsQ0FIM0IsQ0FLQSxNQUFPcDJDLEtBQUssRUFBWixDQUFnQixDQUNkYyxJQUFJLENBQUNkLEtBQUQsQ0FBSixDQUFjYSxTQUFTLENBQUNiLEtBQUQsQ0FBdkIsQ0FDRCxDQUNELEdBQUl5MEMsUUFBTyxDQUFJMzhDLE1BQU0sQ0FBRyxDQUFULEVBQWNnSixJQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVlpN0IsV0FBMUIsRUFBeUNqN0IsSUFBSSxDQUFDaEosTUFBTSxDQUFHLENBQVYsQ0FBSixHQUFxQmlrQyxXQUEvRCxDQUNWLEVBRFUsQ0FFVmMsY0FBYyxDQUFDLzdCLElBQUQsQ0FBT2k3QixXQUFQLENBRmxCLENBSUFqa0MsTUFBTSxFQUFJMjhDLE9BQU8sQ0FBQzM4QyxNQUFsQixDQUNBLEdBQUlBLE1BQU0sQ0FBR2cvQyxLQUFiLENBQW9CLENBQ2xCLE1BQU9FLGNBQWEsQ0FDbEJ2ZSxJQURrQixDQUNaZ1AsT0FEWSxDQUNId1AsWUFERyxDQUNXYixPQUFPLENBQUNyYSxXQURuQixDQUNnQ2xrQyxTQURoQyxDQUVsQmlKLElBRmtCLENBRVoyekMsT0FGWSxDQUVINThDLFNBRkcsQ0FFUUEsU0FGUixDQUVtQmkvQyxLQUFLLENBQUdoL0MsTUFGM0IsQ0FBcEIsQ0FHRCxDQUNELEdBQUlnVSxHQUFFLENBQUksTUFBUSxPQUFTa04sSUFBakIsRUFBeUIsZUFBZ0JvOUIsUUFBMUMsQ0FBcURGLElBQXJELENBQTREemQsSUFBckUsQ0FDQSxNQUFPLzZCLE1BQUssQ0FBQ29PLEVBQUQsQ0FBSyxJQUFMLENBQVdoTCxJQUFYLENBQVosQ0FDRCxDQUNELE1BQU9zMUMsUUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTYyxXQUFULENBQW9CQyxhQUFwQixDQUFtQyxDQUNqQyxNQUFPLFVBQVMxMUMsVUFBVCxDQUFxQnRCLFNBQXJCLENBQWdDazZCLFNBQWhDLENBQTJDLENBQ2hELEdBQUluK0IsU0FBUSxDQUFHNkMsTUFBTSxDQUFDMEMsVUFBRCxDQUFyQixDQUNBLEdBQUksQ0FBQzRKLFdBQVcsQ0FBQzVKLFVBQUQsQ0FBaEIsQ0FBOEIsQ0FDNUIsR0FBSW8zQixTQUFRLENBQUcyVyxXQUFXLENBQUNydkMsU0FBRCxDQUFZLENBQVosQ0FBMUIsQ0FDQXNCLFVBQVUsQ0FBR3pDLElBQUksQ0FBQ3lDLFVBQUQsQ0FBakIsQ0FDQXRCLFNBQVMsQ0FBRyxTQUFTQyxHQUFULENBQWMsQ0FBRSxNQUFPeTRCLFNBQVEsQ0FBQzM4QixRQUFRLENBQUNrRSxHQUFELENBQVQsQ0FBZ0JBLEdBQWhCLENBQXFCbEUsUUFBckIsQ0FBZixDQUFnRCxDQUE1RSxDQUNELENBQ0QsR0FBSThELE1BQUssQ0FBR20zQyxhQUFhLENBQUMxMUMsVUFBRCxDQUFhdEIsU0FBYixDQUF3Qms2QixTQUF4QixDQUF6QixDQUNBLE1BQU9yNkIsTUFBSyxDQUFHLENBQUMsQ0FBVCxDQUFhOUQsUUFBUSxDQUFDMjhCLFFBQVEsQ0FBR3AzQixVQUFVLENBQUN6QixLQUFELENBQWIsQ0FBdUJBLEtBQWhDLENBQXJCLENBQThEbkksU0FBckUsQ0FDRCxDQVRELENBVUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1L0MsV0FBVCxDQUFvQjljLFNBQXBCLENBQStCLENBQzdCLE1BQU8rYyxTQUFRLENBQUMsU0FBU0MsS0FBVCxDQUFnQixDQUM5QixHQUFJeC9DLE9BQU0sQ0FBR3cvQyxLQUFLLENBQUN4L0MsTUFBbkIsQ0FDSWtJLEtBQUssQ0FBR2xJLE1BRFosQ0FFSXkvQyxNQUFNLENBQUc3VixhQUFhLENBQUM3akMsU0FBZCxDQUF3QjI1QyxJQUZyQyxDQUlBLEdBQUlsZCxTQUFKLENBQWUsQ0FDYmdkLEtBQUssQ0FBQ3ZyQyxPQUFOLEdBQ0QsQ0FDRCxNQUFPL0wsS0FBSyxFQUFaLENBQWdCLENBQ2QsR0FBSXk0QixLQUFJLENBQUc2ZSxLQUFLLENBQUN0M0MsS0FBRCxDQUFoQixDQUNBLEdBQUksTUFBT3k0QixLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJenFCLFVBQUosQ0FBY2lmLGVBQWQsQ0FBTixDQUNELENBQ0QsR0FBSXNxQixNQUFNLEVBQUksQ0FBQ25CLE9BQVgsRUFBc0JxQixXQUFXLENBQUNoZixJQUFELENBQVgsRUFBcUIsU0FBL0MsQ0FBMEQsQ0FDeEQsR0FBSTJkLFFBQU8sQ0FBRyxHQUFJMVUsY0FBSixDQUFrQixFQUFsQixDQUFzQixJQUF0QixDQUFkLENBQ0QsQ0FDRixDQUNEMWhDLEtBQUssQ0FBR28yQyxPQUFPLENBQUdwMkMsS0FBSCxDQUFXbEksTUFBMUIsQ0FDQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QjJnQyxJQUFJLENBQUc2ZSxLQUFLLENBQUN0M0MsS0FBRCxDQUFaLENBRUEsR0FBSTAzQyxTQUFRLENBQUdELFdBQVcsQ0FBQ2hmLElBQUQsQ0FBMUIsQ0FDSWorQixJQUFJLENBQUdrOUMsUUFBUSxFQUFJLFNBQVosQ0FBd0JDLE9BQU8sQ0FBQ2xmLElBQUQsQ0FBL0IsQ0FBd0M1Z0MsU0FEbkQsQ0FHQSxHQUFJMkMsSUFBSSxFQUFJbzlDLFVBQVUsQ0FBQ3A5QyxJQUFJLENBQUMsQ0FBRCxDQUFMLENBQWxCLEVBQ0VBLElBQUksQ0FBQyxDQUFELENBQUosR0FBWTB6QixhQUFhLENBQUdKLGVBQWhCLENBQWtDRSxpQkFBbEMsQ0FBc0RHLGVBQWxFLENBREYsRUFFRSxDQUFDM3pCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUTFDLE1BRlgsRUFFcUIwQyxJQUFJLENBQUMsQ0FBRCxDQUFKLEVBQVcsQ0FGcEMsQ0FHTSxDQUNKNDdDLE9BQU8sQ0FBR0EsT0FBTyxDQUFDcUIsV0FBVyxDQUFDajlDLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBWixDQUFQLENBQThCa0QsS0FBOUIsQ0FBb0MwNEMsT0FBcEMsQ0FBNkM1N0MsSUFBSSxDQUFDLENBQUQsQ0FBakQsQ0FBVixDQUNELENBTEQsSUFLTyxDQUNMNDdDLE9BQU8sQ0FBSTNkLElBQUksQ0FBQzNnQyxNQUFMLEVBQWUsQ0FBZixFQUFvQjgvQyxVQUFVLENBQUNuZixJQUFELENBQS9CLENBQ04yZCxPQUFPLENBQUNzQixRQUFELENBQVAsRUFETSxDQUVOdEIsT0FBTyxDQUFDb0IsSUFBUixDQUFhL2UsSUFBYixDQUZKLENBR0QsQ0FDRixDQUNELE1BQU8sV0FBVyxDQUNoQixHQUFJMzNCLEtBQUksQ0FBR0QsU0FBWCxDQUNJN0gsS0FBSyxDQUFHOEgsSUFBSSxDQUFDLENBQUQsQ0FEaEIsQ0FHQSxHQUFJczFDLE9BQU8sRUFBSXQxQyxJQUFJLENBQUNoSixNQUFMLEVBQWUsQ0FBMUIsRUFBK0JxSCxPQUFPLENBQUNuRyxLQUFELENBQTFDLENBQW1ELENBQ2pELE1BQU9vOUMsUUFBTyxDQUFDeUIsS0FBUixDQUFjNytDLEtBQWQsRUFBcUJBLEtBQXJCLEVBQVAsQ0FDRCxDQUNELEdBQUlnSCxNQUFLLENBQUcsQ0FBWixDQUNJeEssTUFBTSxDQUFHc0MsTUFBTSxDQUFHdy9DLEtBQUssQ0FBQ3QzQyxLQUFELENBQUwsQ0FBYXRDLEtBQWIsQ0FBbUIsSUFBbkIsQ0FBeUJvRCxJQUF6QixDQUFILENBQW9DOUgsS0FEdkQsQ0FHQSxNQUFPLEVBQUVnSCxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QnRDLE1BQU0sQ0FBRzhoRCxLQUFLLENBQUN0M0MsS0FBRCxDQUFMLENBQWFkLElBQWIsQ0FBa0IsSUFBbEIsQ0FBd0IxSixNQUF4QixDQUFULENBQ0QsQ0FDRCxNQUFPQSxPQUFQLENBQ0QsQ0FkRCxDQWVELENBbERjLENBQWYsQ0FtREQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5aEQsYUFBVCxDQUFzQnhlLElBQXRCLENBQTRCZ1AsT0FBNUIsQ0FBcUMvTyxPQUFyQyxDQUE4QzhiLFFBQTlDLENBQXdEQyxPQUF4RCxDQUFpRXFELGFBQWpFLENBQWdGQyxZQUFoRixDQUE4RkMsTUFBOUYsQ0FBc0dDLEdBQXRHLENBQTJHbkIsS0FBM0csQ0FBa0gsQ0FDaEgsR0FBSW9CLE1BQUssQ0FBR3pRLE9BQU8sQ0FBR3ZaLGFBQXRCLENBQ0krbkIsTUFBTSxDQUFHeE8sT0FBTyxDQUFHOVosY0FEdkIsQ0FFSXdxQixTQUFTLENBQUcxUSxPQUFPLENBQUc3WixrQkFGMUIsQ0FHSThtQixTQUFTLENBQUdqTixPQUFPLEVBQUkzWixlQUFlLENBQUdDLHFCQUF0QixDQUh2QixDQUlJcXFCLE1BQU0sQ0FBRzNRLE9BQU8sQ0FBR3JaLGNBSnZCLENBS0k4bkIsSUFBSSxDQUFHaUMsU0FBUyxDQUFHdGdELFNBQUgsQ0FBZXMrQyxVQUFVLENBQUMxZCxJQUFELENBTDdDLENBT0EsUUFBUzJkLFFBQVQsRUFBbUIsQ0FDakIsR0FBSXQrQyxPQUFNLENBQUcrSSxTQUFTLENBQUMvSSxNQUF2QixDQUNJZ0osSUFBSSxDQUFHcEwsS0FBSyxDQUFDb0MsTUFBRCxDQURoQixDQUVJa0ksS0FBSyxDQUFHbEksTUFGWixDQUlBLE1BQU9rSSxLQUFLLEVBQVosQ0FBZ0IsQ0FDZGMsSUFBSSxDQUFDZCxLQUFELENBQUosQ0FBY2EsU0FBUyxDQUFDYixLQUFELENBQXZCLENBQ0QsQ0FDRCxHQUFJMDBDLFNBQUosQ0FBZSxDQUNiLEdBQUkzWSxZQUFXLENBQUdnYixTQUFTLENBQUNYLE9BQUQsQ0FBM0IsQ0FDSWlDLFlBQVksQ0FBR3ZjLFlBQVksQ0FBQ2g3QixJQUFELENBQU9pN0IsV0FBUCxDQUQvQixDQUVELENBQ0QsR0FBSXlZLFFBQUosQ0FBYyxDQUNaMXpDLElBQUksQ0FBR3l6QyxXQUFXLENBQUN6ekMsSUFBRCxDQUFPMHpDLFFBQVAsQ0FBaUJDLE9BQWpCLENBQTBCQyxTQUExQixDQUFsQixDQUNELENBQ0QsR0FBSW9ELGFBQUosQ0FBbUIsQ0FDakJoM0MsSUFBSSxDQUFHbzBDLGdCQUFnQixDQUFDcDBDLElBQUQsQ0FBT2czQyxhQUFQLENBQXNCQyxZQUF0QixDQUFvQ3JELFNBQXBDLENBQXZCLENBQ0QsQ0FDRDU4QyxNQUFNLEVBQUl1Z0QsWUFBVixDQUNBLEdBQUkzRCxTQUFTLEVBQUk1OEMsTUFBTSxDQUFHZy9DLEtBQTFCLENBQWlDLENBQy9CLEdBQUl3QixXQUFVLENBQUd6YixjQUFjLENBQUMvN0IsSUFBRCxDQUFPaTdCLFdBQVAsQ0FBL0IsQ0FDQSxNQUFPaWIsY0FBYSxDQUNsQnZlLElBRGtCLENBQ1pnUCxPQURZLENBQ0h3UCxZQURHLENBQ1diLE9BQU8sQ0FBQ3JhLFdBRG5CLENBQ2dDckQsT0FEaEMsQ0FFbEI1M0IsSUFGa0IsQ0FFWnczQyxVQUZZLENBRUFOLE1BRkEsQ0FFUUMsR0FGUixDQUVhbkIsS0FBSyxDQUFHaC9DLE1BRnJCLENBQXBCLENBSUQsQ0FDRCxHQUFJOCtDLFlBQVcsQ0FBR1gsTUFBTSxDQUFHdmQsT0FBSCxDQUFhLElBQXJDLENBQ0k1c0IsRUFBRSxDQUFHcXNDLFNBQVMsQ0FBR3ZCLFdBQVcsQ0FBQ25lLElBQUQsQ0FBZCxDQUF1QkEsSUFEekMsQ0FHQTNnQyxNQUFNLENBQUdnSixJQUFJLENBQUNoSixNQUFkLENBQ0EsR0FBSWtnRCxNQUFKLENBQVksQ0FDVmwzQyxJQUFJLENBQUd5M0MsT0FBTyxDQUFDejNDLElBQUQsQ0FBT2szQyxNQUFQLENBQWQsQ0FDRCxDQUZELElBRU8sSUFBSUksTUFBTSxFQUFJdGdELE1BQU0sQ0FBRyxDQUF2QixDQUEwQixDQUMvQmdKLElBQUksQ0FBQ2lMLE9BQUwsR0FDRCxDQUNELEdBQUltc0MsS0FBSyxFQUFJRCxHQUFHLENBQUduZ0QsTUFBbkIsQ0FBMkIsQ0FDekJnSixJQUFJLENBQUNoSixNQUFMLENBQWNtZ0QsR0FBZCxDQUNELENBQ0QsR0FBSSxNQUFRLE9BQVNqL0IsSUFBakIsRUFBeUIsZUFBZ0JvOUIsUUFBN0MsQ0FBc0QsQ0FDcER0cUMsRUFBRSxDQUFHb3FDLElBQUksRUFBSUMsVUFBVSxDQUFDcnFDLEVBQUQsQ0FBdkIsQ0FDRCxDQUNELE1BQU9BLEdBQUUsQ0FBQ3BPLEtBQUgsQ0FBU2s1QyxXQUFULENBQXNCOTFDLElBQXRCLENBQVAsQ0FDRCxDQUNELE1BQU9zMUMsUUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvQyxlQUFULENBQXdCNWYsTUFBeEIsQ0FBZ0M2ZixVQUFoQyxDQUE0QyxDQUMxQyxNQUFPLFVBQVM3OEMsTUFBVCxDQUFpQmk5QixRQUFqQixDQUEyQixDQUNoQyxNQUFPNFMsYUFBWSxDQUFDN3ZDLE1BQUQsQ0FBU2c5QixNQUFULENBQWlCNmYsVUFBVSxDQUFDNWYsUUFBRCxDQUEzQixDQUF1QyxFQUF2QyxDQUFuQixDQUNELENBRkQsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNmYsb0JBQVQsQ0FBNkJDLFFBQTdCLENBQXVDQyxZQUF2QyxDQUFxRCxDQUNuRCxNQUFPLFVBQVM1L0MsS0FBVCxDQUFnQmtYLEtBQWhCLENBQXVCLENBQzVCLEdBQUkxYSxPQUFKLENBQ0EsR0FBSXdELEtBQUssR0FBS25CLFNBQVYsRUFBdUJxWSxLQUFLLEdBQUtyWSxTQUFyQyxDQUFnRCxDQUM5QyxNQUFPK2dELGFBQVAsQ0FDRCxDQUNELEdBQUk1L0MsS0FBSyxHQUFLbkIsU0FBZCxDQUF5QixDQUN2QnJDLE1BQU0sQ0FBR3dELEtBQVQsQ0FDRCxDQUNELEdBQUlrWCxLQUFLLEdBQUtyWSxTQUFkLENBQXlCLENBQ3ZCLEdBQUlyQyxNQUFNLEdBQUtxQyxTQUFmLENBQTBCLENBQ3hCLE1BQU9xWSxNQUFQLENBQ0QsQ0FDRCxHQUFJLE1BQU9sWCxNQUFQLEVBQWdCLFFBQWhCLEVBQTRCLE1BQU9rWCxNQUFQLEVBQWdCLFFBQWhELENBQTBELENBQ3hEbFgsS0FBSyxDQUFHazVDLFlBQVksQ0FBQ2w1QyxLQUFELENBQXBCLENBQ0FrWCxLQUFLLENBQUdnaUMsWUFBWSxDQUFDaGlDLEtBQUQsQ0FBcEIsQ0FDRCxDQUhELElBR08sQ0FDTGxYLEtBQUssQ0FBR2k1QyxZQUFZLENBQUNqNUMsS0FBRCxDQUFwQixDQUNBa1gsS0FBSyxDQUFHK2hDLFlBQVksQ0FBQy9oQyxLQUFELENBQXBCLENBQ0QsQ0FDRDFhLE1BQU0sQ0FBR21qRCxRQUFRLENBQUMzL0MsS0FBRCxDQUFRa1gsS0FBUixDQUFqQixDQUNELENBQ0QsTUFBTzFhLE9BQVAsQ0FDRCxDQXRCRCxDQXVCRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3FqRCxXQUFULENBQW9CQyxTQUFwQixDQUErQixDQUM3QixNQUFPekIsU0FBUSxDQUFDLFNBQVMvVCxTQUFULENBQW9CLENBQ2xDQSxTQUFTLENBQUcvSixRQUFRLENBQUMrSixTQUFELENBQVkvSCxTQUFTLENBQUNpVSxXQUFXLEVBQVosQ0FBckIsQ0FBcEIsQ0FDQSxNQUFPYyxTQUFRLENBQUMsU0FBU3h2QyxJQUFULENBQWUsQ0FDN0IsR0FBSTQzQixRQUFPLENBQUcsSUFBZCxDQUNBLE1BQU9vZ0IsVUFBUyxDQUFDeFYsU0FBRCxDQUFZLFNBQVN6SyxRQUFULENBQW1CLENBQzdDLE1BQU9uN0IsTUFBSyxDQUFDbTdCLFFBQUQsQ0FBV0gsT0FBWCxDQUFvQjUzQixJQUFwQixDQUFaLENBQ0QsQ0FGZSxDQUFoQixDQUdELENBTGMsQ0FBZixDQU1ELENBUmMsQ0FBZixDQVNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2k0QyxjQUFULENBQXVCamhELE1BQXZCLENBQStCa2hELEtBQS9CLENBQXNDLENBQ3BDQSxLQUFLLENBQUdBLEtBQUssR0FBS25oRCxTQUFWLENBQXNCLEdBQXRCLENBQTRCcTZDLFlBQVksQ0FBQzhHLEtBQUQsQ0FBaEQsQ0FFQSxHQUFJQyxZQUFXLENBQUdELEtBQUssQ0FBQ2xoRCxNQUF4QixDQUNBLEdBQUltaEQsV0FBVyxDQUFHLENBQWxCLENBQXFCLENBQ25CLE1BQU9BLFlBQVcsQ0FBRzVJLFVBQVUsQ0FBQzJJLEtBQUQsQ0FBUWxoRCxNQUFSLENBQWIsQ0FBK0JraEQsS0FBakQsQ0FDRCxDQUNELEdBQUl4akQsT0FBTSxDQUFHNjZDLFVBQVUsQ0FBQzJJLEtBQUQsQ0FBUXRaLFVBQVUsQ0FBQzVuQyxNQUFNLENBQUdtbEMsVUFBVSxDQUFDK2IsS0FBRCxDQUFwQixDQUFsQixDQUF2QixDQUNBLE1BQU8zYyxXQUFVLENBQUMyYyxLQUFELENBQVYsQ0FDSDlGLFNBQVMsQ0FBQy9WLGFBQWEsQ0FBQzNuQyxNQUFELENBQWQsQ0FBd0IsQ0FBeEIsQ0FBMkJzQyxNQUEzQixDQUFULENBQTRDcXdCLElBQTVDLENBQWlELEVBQWpELENBREcsQ0FFSDN5QixNQUFNLENBQUNnRyxLQUFQLENBQWEsQ0FBYixDQUFnQjFELE1BQWhCLENBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvaEQsY0FBVCxDQUF1QnpnQixJQUF2QixDQUE2QmdQLE9BQTdCLENBQXNDL08sT0FBdEMsQ0FBK0M4YixRQUEvQyxDQUF5RCxDQUN2RCxHQUFJeUIsT0FBTSxDQUFHeE8sT0FBTyxDQUFHOVosY0FBdkIsQ0FDSXVvQixJQUFJLENBQUdDLFVBQVUsQ0FBQzFkLElBQUQsQ0FEckIsQ0FHQSxRQUFTMmQsUUFBVCxFQUFtQixDQUNqQixHQUFJekIsVUFBUyxDQUFHLENBQUMsQ0FBakIsQ0FDSUMsVUFBVSxDQUFHL3pDLFNBQVMsQ0FBQy9JLE1BRDNCLENBRUlnOUMsU0FBUyxDQUFHLENBQUMsQ0FGakIsQ0FHSUMsVUFBVSxDQUFHUCxRQUFRLENBQUMxOEMsTUFIMUIsQ0FJSWdKLElBQUksQ0FBR3BMLEtBQUssQ0FBQ3EvQyxVQUFVLENBQUdILFVBQWQsQ0FKaEIsQ0FLSTlvQyxFQUFFLENBQUksTUFBUSxPQUFTa04sSUFBakIsRUFBeUIsZUFBZ0JvOUIsUUFBMUMsQ0FBcURGLElBQXJELENBQTREemQsSUFMckUsQ0FPQSxNQUFPLEVBQUVxYyxTQUFGLENBQWNDLFVBQXJCLENBQWlDLENBQy9CajBDLElBQUksQ0FBQ2cwQyxTQUFELENBQUosQ0FBa0JOLFFBQVEsQ0FBQ00sU0FBRCxDQUExQixDQUNELENBQ0QsTUFBT0YsVUFBVSxFQUFqQixDQUFxQixDQUNuQjl6QyxJQUFJLENBQUNnMEMsU0FBUyxFQUFWLENBQUosQ0FBb0JqMEMsU0FBUyxDQUFDLEVBQUU4ekMsU0FBSCxDQUE3QixDQUNELENBQ0QsTUFBT2ozQyxNQUFLLENBQUNvTyxFQUFELENBQUttcUMsTUFBTSxDQUFHdmQsT0FBSCxDQUFhLElBQXhCLENBQThCNTNCLElBQTlCLENBQVosQ0FDRCxDQUNELE1BQU9zMUMsUUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK0MsWUFBVCxDQUFxQjdlLFNBQXJCLENBQWdDLENBQzlCLE1BQU8sVUFBU2hxQixLQUFULENBQWdCaEgsR0FBaEIsQ0FBcUJnRSxJQUFyQixDQUEyQixDQUNoQyxHQUFJQSxJQUFJLEVBQUksTUFBT0EsS0FBUCxFQUFlLFFBQXZCLEVBQW1DeW9DLGNBQWMsQ0FBQ3psQyxLQUFELENBQVFoSCxHQUFSLENBQWFnRSxJQUFiLENBQXJELENBQXlFLENBQ3ZFaEUsR0FBRyxDQUFHZ0UsSUFBSSxDQUFHelYsU0FBYixDQUNELENBQ0Q7QUFDQXlZLEtBQUssQ0FBRzhvQyxRQUFRLENBQUM5b0MsS0FBRCxDQUFoQixDQUNBLEdBQUloSCxHQUFHLEdBQUt6UixTQUFaLENBQXVCLENBQ3JCeVIsR0FBRyxDQUFHZ0gsS0FBTixDQUNBQSxLQUFLLENBQUcsQ0FBUixDQUNELENBSEQsSUFHTyxDQUNMaEgsR0FBRyxDQUFHOHZDLFFBQVEsQ0FBQzl2QyxHQUFELENBQWQsQ0FDRCxDQUNEZ0UsSUFBSSxDQUFHQSxJQUFJLEdBQUt6VixTQUFULENBQXNCeVksS0FBSyxDQUFHaEgsR0FBUixDQUFjLENBQWQsQ0FBa0IsQ0FBQyxDQUF6QyxDQUE4Qzh2QyxRQUFRLENBQUM5ckMsSUFBRCxDQUE3RCxDQUNBLE1BQU84aUMsVUFBUyxDQUFDOS9CLEtBQUQsQ0FBUWhILEdBQVIsQ0FBYWdFLElBQWIsQ0FBbUJndEIsU0FBbkIsQ0FBaEIsQ0FDRCxDQWRELENBZUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMrZSwwQkFBVCxDQUFtQ1YsUUFBbkMsQ0FBNkMsQ0FDM0MsTUFBTyxVQUFTMy9DLEtBQVQsQ0FBZ0JrWCxLQUFoQixDQUF1QixDQUM1QixHQUFJLEVBQUUsTUFBT2xYLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEIsTUFBT2tYLE1BQVAsRUFBZ0IsUUFBOUMsQ0FBSixDQUE2RCxDQUMzRGxYLEtBQUssQ0FBR3NnRCxRQUFRLENBQUN0Z0QsS0FBRCxDQUFoQixDQUNBa1gsS0FBSyxDQUFHb3BDLFFBQVEsQ0FBQ3BwQyxLQUFELENBQWhCLENBQ0QsQ0FDRCxNQUFPeW9DLFNBQVEsQ0FBQzMvQyxLQUFELENBQVFrWCxLQUFSLENBQWYsQ0FDRCxDQU5ELENBT0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzhtQyxjQUFULENBQXVCdmUsSUFBdkIsQ0FBNkJnUCxPQUE3QixDQUFzQzhSLFFBQXRDLENBQWdEeGQsV0FBaEQsQ0FBNkRyRCxPQUE3RCxDQUFzRThiLFFBQXRFLENBQWdGQyxPQUFoRixDQUF5RnVELE1BQXpGLENBQWlHQyxHQUFqRyxDQUFzR25CLEtBQXRHLENBQTZHLENBQzNHLEdBQUkwQyxRQUFPLENBQUcvUixPQUFPLENBQUczWixlQUF4QixDQUNJd3FCLFVBQVUsQ0FBR2tCLE9BQU8sQ0FBRy9FLE9BQUgsQ0FBYTU4QyxTQURyQyxDQUVJNGhELGVBQWUsQ0FBR0QsT0FBTyxDQUFHM2hELFNBQUgsQ0FBZTQ4QyxPQUY1QyxDQUdJaUYsV0FBVyxDQUFHRixPQUFPLENBQUdoRixRQUFILENBQWMzOEMsU0FIdkMsQ0FJSThoRCxnQkFBZ0IsQ0FBR0gsT0FBTyxDQUFHM2hELFNBQUgsQ0FBZTI4QyxRQUo3QyxDQU1BL00sT0FBTyxFQUFLK1IsT0FBTyxDQUFHeHJCLGlCQUFILENBQXVCQyx1QkFBMUMsQ0FDQXdaLE9BQU8sRUFBSSxFQUFFK1IsT0FBTyxDQUFHdnJCLHVCQUFILENBQTZCRCxpQkFBdEMsQ0FBWCxDQUVBLEdBQUksRUFBRXlaLE9BQU8sQ0FBRzVaLHFCQUFaLENBQUosQ0FBd0MsQ0FDdEM0WixPQUFPLEVBQUksRUFBRTlaLGNBQWMsQ0FBR0Msa0JBQW5CLENBQVgsQ0FDRCxDQUNELEdBQUlnc0IsUUFBTyxDQUFHLENBQ1puaEIsSUFEWSxDQUNOZ1AsT0FETSxDQUNHL08sT0FESCxDQUNZZ2hCLFdBRFosQ0FDeUJwQixVQUR6QixDQUNxQ3FCLGdCQURyQyxDQUVaRixlQUZZLENBRUt6QixNQUZMLENBRWFDLEdBRmIsQ0FFa0JuQixLQUZsQixDQUFkLENBS0EsR0FBSXRoRCxPQUFNLENBQUcrakQsUUFBUSxDQUFDNzdDLEtBQVQsQ0FBZTdGLFNBQWYsQ0FBMEIraEQsT0FBMUIsQ0FBYixDQUNBLEdBQUloQyxVQUFVLENBQUNuZixJQUFELENBQWQsQ0FBc0IsQ0FDcEJvaEIsT0FBTyxDQUFDcmtELE1BQUQsQ0FBU29rRCxPQUFULENBQVAsQ0FDRCxDQUNEcGtELE1BQU0sQ0FBQ3VtQyxXQUFQLENBQXFCQSxXQUFyQixDQUNBLE1BQU8rZCxnQkFBZSxDQUFDdGtELE1BQUQsQ0FBU2lqQyxJQUFULENBQWVnUCxPQUFmLENBQXRCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzUyxZQUFULENBQXFCekQsVUFBckIsQ0FBaUMsQ0FDL0IsR0FBSTdkLEtBQUksQ0FBRzVpQyxJQUFJLENBQUN5Z0QsVUFBRCxDQUFmLENBQ0EsTUFBTyxVQUFTajVDLE1BQVQsQ0FBaUIyOEMsU0FBakIsQ0FBNEIsQ0FDakMzOEMsTUFBTSxDQUFHaThDLFFBQVEsQ0FBQ2o4QyxNQUFELENBQWpCLENBQ0EyOEMsU0FBUyxDQUFHQSxTQUFTLEVBQUksSUFBYixDQUFvQixDQUFwQixDQUF3QjVaLFNBQVMsQ0FBQ3dKLFNBQVMsQ0FBQ29RLFNBQUQsQ0FBVixDQUF1QixHQUF2QixDQUE3QyxDQUNBLEdBQUlBLFNBQVMsRUFBSWphLGNBQWMsQ0FBQzFpQyxNQUFELENBQS9CLENBQXlDLENBQ3ZDO0FBQ0E7QUFDQSxHQUFJNDhDLEtBQUksQ0FBRyxDQUFDaDdDLFFBQVEsQ0FBQzVCLE1BQUQsQ0FBUixDQUFtQixHQUFwQixFQUF5QjI4QixLQUF6QixDQUErQixHQUEvQixDQUFYLENBQ0loaEMsS0FBSyxDQUFHeS9CLElBQUksQ0FBQ3doQixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVUsR0FBVixFQUFpQixDQUFDQSxJQUFJLENBQUMsQ0FBRCxDQUFMLENBQVdELFNBQTVCLENBQUQsQ0FEaEIsQ0FHQUMsSUFBSSxDQUFHLENBQUNoN0MsUUFBUSxDQUFDakcsS0FBRCxDQUFSLENBQWtCLEdBQW5CLEVBQXdCZ2hDLEtBQXhCLENBQThCLEdBQTlCLENBQVAsQ0FDQSxNQUFPLEVBQUVpZ0IsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVLEdBQVYsRUFBaUIsQ0FBQ0EsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFXRCxTQUE1QixDQUFGLENBQVAsQ0FDRCxDQUNELE1BQU92aEIsS0FBSSxDQUFDcDdCLE1BQUQsQ0FBWCxDQUNELENBYkQsQ0FjRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSSswQyxVQUFTLENBQUcsRUFBRXQ5QyxHQUFHLEVBQUssRUFBSWdvQyxVQUFVLENBQUMsR0FBSWhvQyxJQUFKLENBQVEsRUFBRSxDQUFDLENBQUgsQ0FBUixDQUFELENBQVYsQ0FBMkIsQ0FBM0IsQ0FBTCxFQUF1Qzg1QixRQUFoRCxFQUE0RHNyQixJQUE1RCxDQUFtRSxTQUFTeCtCLE1BQVQsQ0FBaUIsQ0FDbEcsTUFBTyxJQUFJNW1CLElBQUosQ0FBUTRtQixNQUFSLENBQVAsQ0FDRCxDQUZELENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeStCLGNBQVQsQ0FBdUIxUixRQUF2QixDQUFpQyxDQUMvQixNQUFPLFVBQVM3c0MsTUFBVCxDQUFpQixDQUN0QixHQUFJbXNDLElBQUcsQ0FBR0MsTUFBTSxDQUFDcHNDLE1BQUQsQ0FBaEIsQ0FDQSxHQUFJbXNDLEdBQUcsRUFBSWxZLE1BQVgsQ0FBbUIsQ0FDakIsTUFBTzRNLFdBQVUsQ0FBQzdnQyxNQUFELENBQWpCLENBQ0QsQ0FDRCxHQUFJbXNDLEdBQUcsRUFBSTNYLE1BQVgsQ0FBbUIsQ0FDakIsTUFBTzJNLFdBQVUsQ0FBQ25oQyxNQUFELENBQWpCLENBQ0QsQ0FDRCxNQUFPcy9CLFlBQVcsQ0FBQ3QvQixNQUFELENBQVM2c0MsUUFBUSxDQUFDN3NDLE1BQUQsQ0FBakIsQ0FBbEIsQ0FDRCxDQVRELENBVUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3K0MsV0FBVCxDQUFvQjNoQixJQUFwQixDQUEwQmdQLE9BQTFCLENBQW1DL08sT0FBbkMsQ0FBNEM4YixRQUE1QyxDQUFzREMsT0FBdEQsQ0FBK0R1RCxNQUEvRCxDQUF1RUMsR0FBdkUsQ0FBNEVuQixLQUE1RSxDQUFtRixDQUNqRixHQUFJcUIsVUFBUyxDQUFHMVEsT0FBTyxDQUFHN1osa0JBQTFCLENBQ0EsR0FBSSxDQUFDdXFCLFNBQUQsRUFBYyxNQUFPMWYsS0FBUCxFQUFlLFVBQWpDLENBQTZDLENBQzNDLEtBQU0sSUFBSXpxQixVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNELEdBQUluMUIsT0FBTSxDQUFHMDhDLFFBQVEsQ0FBR0EsUUFBUSxDQUFDMThDLE1BQVosQ0FBcUIsQ0FBMUMsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYMnZDLE9BQU8sRUFBSSxFQUFFelosaUJBQWlCLENBQUdDLHVCQUF0QixDQUFYLENBQ0F1bUIsUUFBUSxDQUFHQyxPQUFPLENBQUc1OEMsU0FBckIsQ0FDRCxDQUNEb2dELEdBQUcsQ0FBR0EsR0FBRyxHQUFLcGdELFNBQVIsQ0FBb0JvZ0QsR0FBcEIsQ0FBMEI5WCxTQUFTLENBQUN5SixTQUFTLENBQUNxTyxHQUFELENBQVYsQ0FBaUIsQ0FBakIsQ0FBekMsQ0FDQW5CLEtBQUssQ0FBR0EsS0FBSyxHQUFLai9DLFNBQVYsQ0FBc0JpL0MsS0FBdEIsQ0FBOEJsTixTQUFTLENBQUNrTixLQUFELENBQS9DLENBQ0FoL0MsTUFBTSxFQUFJMjhDLE9BQU8sQ0FBR0EsT0FBTyxDQUFDMzhDLE1BQVgsQ0FBb0IsQ0FBckMsQ0FFQSxHQUFJMnZDLE9BQU8sQ0FBR3haLHVCQUFkLENBQXVDLENBQ3JDLEdBQUk2cEIsY0FBYSxDQUFHdEQsUUFBcEIsQ0FDSXVELFlBQVksQ0FBR3RELE9BRG5CLENBR0FELFFBQVEsQ0FBR0MsT0FBTyxDQUFHNThDLFNBQXJCLENBQ0QsQ0FDRCxHQUFJMkMsS0FBSSxDQUFHMjlDLFNBQVMsQ0FBR3RnRCxTQUFILENBQWU4L0MsT0FBTyxDQUFDbGYsSUFBRCxDQUExQyxDQUVBLEdBQUltaEIsUUFBTyxDQUFHLENBQ1puaEIsSUFEWSxDQUNOZ1AsT0FETSxDQUNHL08sT0FESCxDQUNZOGIsUUFEWixDQUNzQkMsT0FEdEIsQ0FDK0JxRCxhQUQvQixDQUM4Q0MsWUFEOUMsQ0FFWkMsTUFGWSxDQUVKQyxHQUZJLENBRUNuQixLQUZELENBQWQsQ0FLQSxHQUFJdDhDLElBQUosQ0FBVSxDQUNSNi9DLFNBQVMsQ0FBQ1QsT0FBRCxDQUFVcC9DLElBQVYsQ0FBVCxDQUNELENBQ0RpK0IsSUFBSSxDQUFHbWhCLE9BQU8sQ0FBQyxDQUFELENBQWQsQ0FDQW5TLE9BQU8sQ0FBR21TLE9BQU8sQ0FBQyxDQUFELENBQWpCLENBQ0FsaEIsT0FBTyxDQUFHa2hCLE9BQU8sQ0FBQyxDQUFELENBQWpCLENBQ0FwRixRQUFRLENBQUdvRixPQUFPLENBQUMsQ0FBRCxDQUFsQixDQUNBbkYsT0FBTyxDQUFHbUYsT0FBTyxDQUFDLENBQUQsQ0FBakIsQ0FDQTlDLEtBQUssQ0FBRzhDLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBYUEsT0FBTyxDQUFDLENBQUQsQ0FBUCxHQUFlL2hELFNBQWYsQ0FDaEJzZ0QsU0FBUyxDQUFHLENBQUgsQ0FBTzFmLElBQUksQ0FBQzNnQyxNQURMLENBRWpCcW9DLFNBQVMsQ0FBQ3laLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBYTloRCxNQUFkLENBQXNCLENBQXRCLENBRmIsQ0FJQSxHQUFJLENBQUNnL0MsS0FBRCxFQUFVclAsT0FBTyxFQUFJM1osZUFBZSxDQUFHQyxxQkFBdEIsQ0FBckIsQ0FBbUUsQ0FDakUwWixPQUFPLEVBQUksRUFBRTNaLGVBQWUsQ0FBR0MscUJBQXBCLENBQVgsQ0FDRCxDQUNELEdBQUksQ0FBQzBaLE9BQUQsRUFBWUEsT0FBTyxFQUFJOVosY0FBM0IsQ0FBMkMsQ0FDekMsR0FBSW40QixPQUFNLENBQUd3Z0QsVUFBVSxDQUFDdmQsSUFBRCxDQUFPZ1AsT0FBUCxDQUFnQi9PLE9BQWhCLENBQXZCLENBQ0QsQ0FGRCxJQUVPLElBQUkrTyxPQUFPLEVBQUkzWixlQUFYLEVBQThCMlosT0FBTyxFQUFJMVoscUJBQTdDLENBQW9FLENBQ3pFdjRCLE1BQU0sQ0FBR3FoRCxXQUFXLENBQUNwZSxJQUFELENBQU9nUCxPQUFQLENBQWdCcVAsS0FBaEIsQ0FBcEIsQ0FDRCxDQUZNLElBRUEsSUFBSSxDQUFDclAsT0FBTyxFQUFJelosaUJBQVgsRUFBZ0N5WixPQUFPLEdBQUs5WixjQUFjLENBQUdLLGlCQUF0QixDQUF4QyxHQUFxRixDQUFDeW1CLE9BQU8sQ0FBQzM4QyxNQUFsRyxDQUEwRyxDQUMvR3RDLE1BQU0sQ0FBRzBqRCxhQUFhLENBQUN6Z0IsSUFBRCxDQUFPZ1AsT0FBUCxDQUFnQi9PLE9BQWhCLENBQXlCOGIsUUFBekIsQ0FBdEIsQ0FDRCxDQUZNLElBRUEsQ0FDTGgvQyxNQUFNLENBQUd5aEQsWUFBWSxDQUFDdjVDLEtBQWIsQ0FBbUI3RixTQUFuQixDQUE4QitoRCxPQUE5QixDQUFULENBQ0QsQ0FDRCxHQUFJaGhCLE9BQU0sQ0FBR3ArQixJQUFJLENBQUdtMkMsV0FBSCxDQUFpQmtKLE9BQWxDLENBQ0EsTUFBT0MsZ0JBQWUsQ0FBQ2xoQixNQUFNLENBQUNwakMsTUFBRCxDQUFTb2tELE9BQVQsQ0FBUCxDQUEwQm5oQixJQUExQixDQUFnQ2dQLE9BQWhDLENBQXRCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNlMsdUJBQVQsQ0FBZ0N6VCxRQUFoQyxDQUEwQ3NHLFFBQTFDLENBQW9EL3NDLEdBQXBELENBQXlEeEUsTUFBekQsQ0FBaUUsQ0FDL0QsR0FBSWlyQyxRQUFRLEdBQUtodkMsU0FBYixFQUNDNnVDLEVBQUUsQ0FBQ0csUUFBRCxDQUFXL0ksV0FBVyxDQUFDMTlCLEdBQUQsQ0FBdEIsQ0FBRixFQUFrQyxDQUFDdEIsY0FBYyxDQUFDSSxJQUFmLENBQW9CdEQsTUFBcEIsQ0FBNEJ3RSxHQUE1QixDQUR4QyxDQUMyRSxDQUN6RSxNQUFPK3NDLFNBQVAsQ0FDRCxDQUNELE1BQU90RyxTQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBULG9CQUFULENBQTZCMVQsUUFBN0IsQ0FBdUNzRyxRQUF2QyxDQUFpRC9zQyxHQUFqRCxDQUFzRHhFLE1BQXRELENBQThEOEUsTUFBOUQsQ0FBc0VpWSxLQUF0RSxDQUE2RSxDQUMzRSxHQUFJbXBCLFFBQVEsQ0FBQytFLFFBQUQsQ0FBUixFQUFzQi9FLFFBQVEsQ0FBQ3FMLFFBQUQsQ0FBbEMsQ0FBOEMsQ0FDNUM7QUFDQXgwQixLQUFLLENBQUMvRixHQUFOLENBQVV1NkIsUUFBVixDQUFvQnRHLFFBQXBCLEVBQ0E4SCxTQUFTLENBQUM5SCxRQUFELENBQVdzRyxRQUFYLENBQXFCdDFDLFNBQXJCLENBQWdDMGlELG1CQUFoQyxDQUFxRDVoQyxLQUFyRCxDQUFULENBQ0FBLEtBQUssQ0FBQyxRQUFELENBQUwsQ0FBZ0J3MEIsUUFBaEIsRUFDRCxDQUNELE1BQU90RyxTQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMlQsZ0JBQVQsQ0FBeUJ4aEQsS0FBekIsQ0FBZ0MsQ0FDOUIsTUFBT20yQyxjQUFhLENBQUNuMkMsS0FBRCxDQUFiLENBQXVCbkIsU0FBdkIsQ0FBbUNtQixLQUExQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTd3pDLFlBQVQsQ0FBcUJ4d0MsS0FBckIsQ0FBNEJrVSxLQUE1QixDQUFtQ3UzQixPQUFuQyxDQUE0Q0MsVUFBNUMsQ0FBd0RzRSxTQUF4RCxDQUFtRXJ6QixLQUFuRSxDQUEwRSxDQUN4RSxHQUFJOGhDLFVBQVMsQ0FBR2hULE9BQU8sQ0FBR2hhLG9CQUExQixDQUNJMFYsU0FBUyxDQUFHbm5DLEtBQUssQ0FBQ2xFLE1BRHRCLENBRUlzekMsU0FBUyxDQUFHbDdCLEtBQUssQ0FBQ3BZLE1BRnRCLENBSUEsR0FBSXFyQyxTQUFTLEVBQUlpSSxTQUFiLEVBQTBCLEVBQUVxUCxTQUFTLEVBQUlyUCxTQUFTLENBQUdqSSxTQUEzQixDQUE5QixDQUFxRSxDQUNuRSxNQUFPLE1BQVAsQ0FDRCxDQUNEO0FBQ0EsR0FBSXVYLFdBQVUsQ0FBRy9oQyxLQUFLLENBQUM5TCxHQUFOLENBQVU3USxLQUFWLENBQWpCLENBQ0EsR0FBSTIrQyxXQUFVLENBQUdoaUMsS0FBSyxDQUFDOUwsR0FBTixDQUFVcUQsS0FBVixDQUFqQixDQUNBLEdBQUl3cUMsVUFBVSxFQUFJQyxVQUFsQixDQUE4QixDQUM1QixNQUFPRCxXQUFVLEVBQUl4cUMsS0FBZCxFQUF1QnlxQyxVQUFVLEVBQUkzK0MsS0FBNUMsQ0FDRCxDQUNELEdBQUlnRSxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0l4SyxNQUFNLENBQUcsSUFEYixDQUVJZzJDLElBQUksQ0FBSS9ELE9BQU8sQ0FBRy9aLHNCQUFYLENBQXFDLEdBQUl3WCxTQUFKLEVBQXJDLENBQW9EcnRDLFNBRi9ELENBSUE4Z0IsS0FBSyxDQUFDL0YsR0FBTixDQUFVNVcsS0FBVixDQUFpQmtVLEtBQWpCLEVBQ0F5SSxLQUFLLENBQUMvRixHQUFOLENBQVUxQyxLQUFWLENBQWlCbFUsS0FBakIsRUFFQTtBQUNBLE1BQU8sRUFBRWdFLEtBQUYsQ0FBVW1qQyxTQUFqQixDQUE0QixDQUMxQixHQUFJeVgsU0FBUSxDQUFHNStDLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBcEIsQ0FDSTY2QyxRQUFRLENBQUczcUMsS0FBSyxDQUFDbFEsS0FBRCxDQURwQixDQUdBLEdBQUkwbkMsVUFBSixDQUFnQixDQUNkLEdBQUlvVCxTQUFRLENBQUdMLFNBQVMsQ0FDcEIvUyxVQUFVLENBQUNtVCxRQUFELENBQVdELFFBQVgsQ0FBcUI1NkMsS0FBckIsQ0FBNEJrUSxLQUE1QixDQUFtQ2xVLEtBQW5DLENBQTBDMmMsS0FBMUMsQ0FEVSxDQUVwQit1QixVQUFVLENBQUNrVCxRQUFELENBQVdDLFFBQVgsQ0FBcUI3NkMsS0FBckIsQ0FBNEJoRSxLQUE1QixDQUFtQ2tVLEtBQW5DLENBQTBDeUksS0FBMUMsQ0FGZCxDQUdELENBQ0QsR0FBSW1pQyxRQUFRLEdBQUtqakQsU0FBakIsQ0FBNEIsQ0FDMUIsR0FBSWlqRCxRQUFKLENBQWMsQ0FDWixTQUNELENBQ0R0bEQsTUFBTSxDQUFHLEtBQVQsQ0FDQSxNQUNELENBQ0Q7QUFDQSxHQUFJZzJDLElBQUosQ0FBVSxDQUNSLEdBQUksQ0FBQzVSLFNBQVMsQ0FBQzFwQixLQUFELENBQVEsU0FBUzJxQyxRQUFULENBQW1CeFAsUUFBbkIsQ0FBNkIsQ0FDN0MsR0FBSSxDQUFDNVAsUUFBUSxDQUFDK1AsSUFBRCxDQUFPSCxRQUFQLENBQVQsR0FDQ3VQLFFBQVEsR0FBS0MsUUFBYixFQUF5QjdPLFNBQVMsQ0FBQzRPLFFBQUQsQ0FBV0MsUUFBWCxDQUFxQnBULE9BQXJCLENBQThCQyxVQUE5QixDQUEwQy91QixLQUExQyxDQURuQyxDQUFKLENBQzBGLENBQ3hGLE1BQU82eUIsS0FBSSxDQUFDdm9DLElBQUwsQ0FBVW9vQyxRQUFWLENBQVAsQ0FDRCxDQUNGLENBTFMsQ0FBZCxDQUtRLENBQ043MUMsTUFBTSxDQUFHLEtBQVQsQ0FDQSxNQUNELENBQ0YsQ0FWRCxJQVVPLElBQUksRUFDTG9sRCxRQUFRLEdBQUtDLFFBQWIsRUFDRTdPLFNBQVMsQ0FBQzRPLFFBQUQsQ0FBV0MsUUFBWCxDQUFxQnBULE9BQXJCLENBQThCQyxVQUE5QixDQUEwQy91QixLQUExQyxDQUZOLENBQUosQ0FHQSxDQUNMbmpCLE1BQU0sQ0FBRyxLQUFULENBQ0EsTUFDRCxDQUNGLENBQ0RtakIsS0FBSyxDQUFDLFFBQUQsQ0FBTCxDQUFnQjNjLEtBQWhCLEVBQ0EyYyxLQUFLLENBQUMsUUFBRCxDQUFMLENBQWdCekksS0FBaEIsRUFDQSxNQUFPMWEsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpM0MsV0FBVCxDQUFvQjd3QyxNQUFwQixDQUE0QnNVLEtBQTVCLENBQW1DNjNCLEdBQW5DLENBQXdDTixPQUF4QyxDQUFpREMsVUFBakQsQ0FBNkRzRSxTQUE3RCxDQUF3RXJ6QixLQUF4RSxDQUErRSxDQUM3RSxPQUFRb3ZCLEdBQVIsRUFDRSxJQUFLcFgsWUFBTCxDQUNFLEdBQUsvMEIsTUFBTSxDQUFDMjNDLFVBQVAsRUFBcUJyakMsS0FBSyxDQUFDcWpDLFVBQTVCLEVBQ0MzM0MsTUFBTSxDQUFDODNDLFVBQVAsRUFBcUJ4akMsS0FBSyxDQUFDd2pDLFVBRGhDLENBQzZDLENBQzNDLE1BQU8sTUFBUCxDQUNELENBQ0Q5M0MsTUFBTSxDQUFHQSxNQUFNLENBQUN1M0MsTUFBaEIsQ0FDQWpqQyxLQUFLLENBQUdBLEtBQUssQ0FBQ2lqQyxNQUFkLENBRUYsSUFBS3ppQixlQUFMLENBQ0UsR0FBSzkwQixNQUFNLENBQUMyM0MsVUFBUCxFQUFxQnJqQyxLQUFLLENBQUNxakMsVUFBNUIsRUFDQSxDQUFDdkgsU0FBUyxDQUFDLEdBQUlyTixXQUFKLENBQWUvaUMsTUFBZixDQUFELENBQXlCLEdBQUkraUMsV0FBSixDQUFlenVCLEtBQWYsQ0FBekIsQ0FEZCxDQUMrRCxDQUM3RCxNQUFPLE1BQVAsQ0FDRCxDQUNELE1BQU8sS0FBUCxDQUVGLElBQUtxZixRQUFMLENBQ0EsSUFBS0MsUUFBTCxDQUNBLElBQUtNLFVBQUwsQ0FDRTtBQUNBO0FBQ0EsTUFBTzRXLEdBQUUsQ0FBQyxDQUFDOXFDLE1BQUYsQ0FBVSxDQUFDc1UsS0FBWCxDQUFULENBRUYsSUFBS3dmLFNBQUwsQ0FDRSxNQUFPOXpCLE9BQU0sQ0FBQzFELElBQVAsRUFBZWdZLEtBQUssQ0FBQ2hZLElBQXJCLEVBQTZCMEQsTUFBTSxDQUFDdEIsT0FBUCxFQUFrQjRWLEtBQUssQ0FBQzVWLE9BQTVELENBRUYsSUFBSzYxQixVQUFMLENBQ0EsSUFBS0UsVUFBTCxDQUNFO0FBQ0E7QUFDQTtBQUNBLE1BQU96MEIsT0FBTSxFQUFLc1UsS0FBSyxDQUFHLEVBQTFCLENBRUYsSUFBSzJmLE9BQUwsQ0FDRSxHQUFJa3JCLFFBQU8sQ0FBR3RlLFVBQWQsQ0FFRixJQUFLck0sT0FBTCxDQUNFLEdBQUlxcUIsVUFBUyxDQUFHaFQsT0FBTyxDQUFHaGEsb0JBQTFCLENBQ0FzdEIsT0FBTyxHQUFLQSxPQUFPLENBQUdqZSxVQUFmLENBQVAsQ0FFQSxHQUFJbGhDLE1BQU0sQ0FBQzFILElBQVAsRUFBZWdjLEtBQUssQ0FBQ2hjLElBQXJCLEVBQTZCLENBQUN1bUQsU0FBbEMsQ0FBNkMsQ0FDM0MsTUFBTyxNQUFQLENBQ0QsQ0FDRDtBQUNBLEdBQUlsUyxRQUFPLENBQUc1dkIsS0FBSyxDQUFDOUwsR0FBTixDQUFValIsTUFBVixDQUFkLENBQ0EsR0FBSTJzQyxPQUFKLENBQWEsQ0FDWCxNQUFPQSxRQUFPLEVBQUlyNEIsS0FBbEIsQ0FDRCxDQUNEdTNCLE9BQU8sRUFBSS9aLHNCQUFYLENBRUE7QUFDQS9VLEtBQUssQ0FBQy9GLEdBQU4sQ0FBVWhYLE1BQVYsQ0FBa0JzVSxLQUFsQixFQUNBLEdBQUkxYSxPQUFNLENBQUdnM0MsV0FBVyxDQUFDdU8sT0FBTyxDQUFDbi9DLE1BQUQsQ0FBUixDQUFrQm0vQyxPQUFPLENBQUM3cUMsS0FBRCxDQUF6QixDQUFrQ3UzQixPQUFsQyxDQUEyQ0MsVUFBM0MsQ0FBdURzRSxTQUF2RCxDQUFrRXJ6QixLQUFsRSxDQUF4QixDQUNBQSxLQUFLLENBQUMsUUFBRCxDQUFMLENBQWdCL2MsTUFBaEIsRUFDQSxNQUFPcEcsT0FBUCxDQUVGLElBQUs4NkIsVUFBTCxDQUNFLEdBQUkrUSxhQUFKLENBQW1CLENBQ2pCLE1BQU9BLGNBQWEsQ0FBQ25pQyxJQUFkLENBQW1CdEQsTUFBbkIsR0FBOEJ5bEMsYUFBYSxDQUFDbmlDLElBQWQsQ0FBbUJnUixLQUFuQixDQUFyQyxDQUNELENBM0RMLENBNkRBLE1BQU8sTUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNDhCLGFBQVQsQ0FBc0JseEMsTUFBdEIsQ0FBOEJzVSxLQUE5QixDQUFxQ3UzQixPQUFyQyxDQUE4Q0MsVUFBOUMsQ0FBMERzRSxTQUExRCxDQUFxRXJ6QixLQUFyRSxDQUE0RSxDQUMxRSxHQUFJOGhDLFVBQVMsQ0FBR2hULE9BQU8sQ0FBR2hhLG9CQUExQixDQUNJdXRCLFFBQVEsQ0FBR3JTLFVBQVUsQ0FBQy9zQyxNQUFELENBRHpCLENBRUlxL0MsU0FBUyxDQUFHRCxRQUFRLENBQUNsakQsTUFGekIsQ0FHSW9qRCxRQUFRLENBQUd2UyxVQUFVLENBQUN6NEIsS0FBRCxDQUh6QixDQUlJazdCLFNBQVMsQ0FBRzhQLFFBQVEsQ0FBQ3BqRCxNQUp6QixDQU1BLEdBQUltakQsU0FBUyxFQUFJN1AsU0FBYixFQUEwQixDQUFDcVAsU0FBL0IsQ0FBMEMsQ0FDeEMsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFJejZDLE1BQUssQ0FBR2k3QyxTQUFaLENBQ0EsTUFBT2o3QyxLQUFLLEVBQVosQ0FBZ0IsQ0FDZCxHQUFJSSxJQUFHLENBQUc0NkMsUUFBUSxDQUFDaDdDLEtBQUQsQ0FBbEIsQ0FDQSxHQUFJLEVBQUV5NkMsU0FBUyxDQUFHcjZDLEdBQUcsR0FBSThQLE1BQVYsQ0FBa0JwUixjQUFjLENBQUNJLElBQWYsQ0FBb0JnUixLQUFwQixDQUEyQjlQLEdBQTNCLENBQTdCLENBQUosQ0FBbUUsQ0FDakUsTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNEO0FBQ0EsR0FBSSs2QyxXQUFVLENBQUd4aUMsS0FBSyxDQUFDOUwsR0FBTixDQUFValIsTUFBVixDQUFqQixDQUNBLEdBQUkrK0MsV0FBVSxDQUFHaGlDLEtBQUssQ0FBQzlMLEdBQU4sQ0FBVXFELEtBQVYsQ0FBakIsQ0FDQSxHQUFJaXJDLFVBQVUsRUFBSVIsVUFBbEIsQ0FBOEIsQ0FDNUIsTUFBT1EsV0FBVSxFQUFJanJDLEtBQWQsRUFBdUJ5cUMsVUFBVSxFQUFJLytDLE1BQTVDLENBQ0QsQ0FDRCxHQUFJcEcsT0FBTSxDQUFHLElBQWIsQ0FDQW1qQixLQUFLLENBQUMvRixHQUFOLENBQVVoWCxNQUFWLENBQWtCc1UsS0FBbEIsRUFDQXlJLEtBQUssQ0FBQy9GLEdBQU4sQ0FBVTFDLEtBQVYsQ0FBaUJ0VSxNQUFqQixFQUVBLEdBQUl3L0MsU0FBUSxDQUFHWCxTQUFmLENBQ0EsTUFBTyxFQUFFejZDLEtBQUYsQ0FBVWk3QyxTQUFqQixDQUE0QixDQUMxQjc2QyxHQUFHLENBQUc0NkMsUUFBUSxDQUFDaDdDLEtBQUQsQ0FBZCxDQUNBLEdBQUk2bUMsU0FBUSxDQUFHanJDLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBckIsQ0FDSXk2QyxRQUFRLENBQUczcUMsS0FBSyxDQUFDOVAsR0FBRCxDQURwQixDQUdBLEdBQUlzbkMsVUFBSixDQUFnQixDQUNkLEdBQUlvVCxTQUFRLENBQUdMLFNBQVMsQ0FDcEIvUyxVQUFVLENBQUNtVCxRQUFELENBQVdoVSxRQUFYLENBQXFCem1DLEdBQXJCLENBQTBCOFAsS0FBMUIsQ0FBaUN0VSxNQUFqQyxDQUF5QytjLEtBQXpDLENBRFUsQ0FFcEIrdUIsVUFBVSxDQUFDYixRQUFELENBQVdnVSxRQUFYLENBQXFCejZDLEdBQXJCLENBQTBCeEUsTUFBMUIsQ0FBa0NzVSxLQUFsQyxDQUF5Q3lJLEtBQXpDLENBRmQsQ0FHRCxDQUNEO0FBQ0EsR0FBSSxFQUFFbWlDLFFBQVEsR0FBS2pqRCxTQUFiLENBQ0dndkMsUUFBUSxHQUFLZ1UsUUFBYixFQUF5QjdPLFNBQVMsQ0FBQ25GLFFBQUQsQ0FBV2dVLFFBQVgsQ0FBcUJwVCxPQUFyQixDQUE4QkMsVUFBOUIsQ0FBMEMvdUIsS0FBMUMsQ0FEckMsQ0FFRW1pQyxRQUZKLENBQUosQ0FHTyxDQUNMdGxELE1BQU0sQ0FBRyxLQUFULENBQ0EsTUFDRCxDQUNENGxELFFBQVEsR0FBS0EsUUFBUSxDQUFHaDdDLEdBQUcsRUFBSSxhQUF2QixDQUFSLENBQ0QsQ0FDRCxHQUFJNUssTUFBTSxFQUFJLENBQUM0bEQsUUFBZixDQUF5QixDQUN2QixHQUFJQyxRQUFPLENBQUd6L0MsTUFBTSxDQUFDdUssV0FBckIsQ0FDSW0xQyxPQUFPLENBQUdwckMsS0FBSyxDQUFDL0osV0FEcEIsQ0FHQTtBQUNBLEdBQUlrMUMsT0FBTyxFQUFJQyxPQUFYLEVBQ0MsZUFBaUIxL0MsT0FBakIsRUFBMkIsZUFBaUJzVSxNQUQ3QyxFQUVBLEVBQUUsTUFBT21yQyxRQUFQLEVBQWtCLFVBQWxCLEVBQWdDQSxPQUFPLFdBQVlBLFFBQW5ELEVBQ0EsTUFBT0MsUUFBUCxFQUFrQixVQURsQixFQUNnQ0EsT0FBTyxXQUFZQSxRQURyRCxDQUZKLENBR21FLENBQ2pFOWxELE1BQU0sQ0FBRyxLQUFULENBQ0QsQ0FDRixDQUNEbWpCLEtBQUssQ0FBQyxRQUFELENBQUwsQ0FBZ0IvYyxNQUFoQixFQUNBK2MsS0FBSyxDQUFDLFFBQUQsQ0FBTCxDQUFnQnpJLEtBQWhCLEVBQ0EsTUFBTzFhLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZoRCxTQUFULENBQWtCNWUsSUFBbEIsQ0FBd0IsQ0FDdEIsTUFBTzhYLFlBQVcsQ0FBQ0MsUUFBUSxDQUFDL1gsSUFBRCxDQUFPNWdDLFNBQVAsQ0FBa0I0cUIsT0FBbEIsQ0FBVCxDQUFxQ2dXLElBQUksQ0FBRyxFQUE1QyxDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa1EsV0FBVCxDQUFvQi9zQyxNQUFwQixDQUE0QixDQUMxQixNQUFPNnVDLGVBQWMsQ0FBQzd1QyxNQUFELENBQVNvRCxJQUFULENBQWV1MkMsVUFBZixDQUFyQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM3TSxhQUFULENBQXNCOXNDLE1BQXRCLENBQThCLENBQzVCLE1BQU82dUMsZUFBYyxDQUFDN3VDLE1BQUQsQ0FBU3VyQyxNQUFULENBQWlCcU8sWUFBakIsQ0FBckIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW1DLFFBQU8sQ0FBRyxDQUFDOVcsT0FBRCxDQUFXcVosSUFBWCxDQUFrQixTQUFTemhCLElBQVQsQ0FBZSxDQUM3QyxNQUFPb0ksUUFBTyxDQUFDaDBCLEdBQVIsQ0FBWTRyQixJQUFaLENBQVAsQ0FDRCxDQUZELENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTZ2YsWUFBVCxDQUFxQmhmLElBQXJCLENBQTJCLENBQ3pCLEdBQUlqakMsT0FBTSxDQUFJaWpDLElBQUksQ0FBQ3ZnQyxJQUFMLENBQVksRUFBMUIsQ0FDSThELEtBQUssQ0FBRzhrQyxTQUFTLENBQUN0ckMsTUFBRCxDQURyQixDQUVJc0MsTUFBTSxDQUFHZ0gsY0FBYyxDQUFDSSxJQUFmLENBQW9CNGhDLFNBQXBCLENBQStCdHJDLE1BQS9CLEVBQXlDd0csS0FBSyxDQUFDbEUsTUFBL0MsQ0FBd0QsQ0FGckUsQ0FJQSxNQUFPQSxNQUFNLEVBQWIsQ0FBaUIsQ0FDZixHQUFJMEMsS0FBSSxDQUFHd0IsS0FBSyxDQUFDbEUsTUFBRCxDQUFoQixDQUNJeWpELFNBQVMsQ0FBRy9nRCxJQUFJLENBQUNpK0IsSUFEckIsQ0FFQSxHQUFJOGlCLFNBQVMsRUFBSSxJQUFiLEVBQXFCQSxTQUFTLEVBQUk5aUIsSUFBdEMsQ0FBNEMsQ0FDMUMsTUFBT2orQixLQUFJLENBQUN0QyxJQUFaLENBQ0QsQ0FDRixDQUNELE1BQU8xQyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1aEQsVUFBVCxDQUFtQnRlLElBQW5CLENBQXlCLENBQ3ZCLEdBQUk3OEIsT0FBTSxDQUFHa0QsY0FBYyxDQUFDSSxJQUFmLENBQW9CcWlDLE1BQXBCLENBQTRCLGFBQTVCLEVBQTZDQSxNQUE3QyxDQUFzRDlJLElBQW5FLENBQ0EsTUFBTzc4QixPQUFNLENBQUNtZ0MsV0FBZCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5VCxZQUFULEVBQXVCLENBQ3JCLEdBQUloNkMsT0FBTSxDQUFHK3JDLE1BQU0sQ0FBQzFJLFFBQVAsRUFBbUJBLFFBQWhDLENBQ0FyakMsTUFBTSxDQUFHQSxNQUFNLEdBQUtxakMsUUFBWCxDQUFzQjhVLFlBQXRCLENBQXFDbjRDLE1BQTlDLENBQ0EsTUFBT3FMLFVBQVMsQ0FBQy9JLE1BQVYsQ0FBbUJ0QyxNQUFNLENBQUNxTCxTQUFTLENBQUMsQ0FBRCxDQUFWLENBQWVBLFNBQVMsQ0FBQyxDQUFELENBQXhCLENBQXpCLENBQXdEckwsTUFBL0QsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTc3ZDLFdBQVQsQ0FBb0J4c0MsR0FBcEIsQ0FBeUI4SCxHQUF6QixDQUE4QixDQUM1QixHQUFJNUYsS0FBSSxDQUFHbEMsR0FBRyxDQUFDeXJDLFFBQWYsQ0FDQSxNQUFPeVgsVUFBUyxDQUFDcDdDLEdBQUQsQ0FBVCxDQUNINUYsSUFBSSxDQUFDLE1BQU80RixJQUFQLEVBQWMsUUFBZCxDQUF5QixRQUF6QixDQUFvQyxNQUFyQyxDQURELENBRUg1RixJQUFJLENBQUNsQyxHQUZULENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpMkMsYUFBVCxDQUFzQjN5QyxNQUF0QixDQUE4QixDQUM1QixHQUFJcEcsT0FBTSxDQUFHd0osSUFBSSxDQUFDcEQsTUFBRCxDQUFqQixDQUNJOUQsTUFBTSxDQUFHdEMsTUFBTSxDQUFDc0MsTUFEcEIsQ0FHQSxNQUFPQSxNQUFNLEVBQWIsQ0FBaUIsQ0FDZixHQUFJc0ksSUFBRyxDQUFHNUssTUFBTSxDQUFDc0MsTUFBRCxDQUFoQixDQUNJa0IsS0FBSyxDQUFHNEMsTUFBTSxDQUFDd0UsR0FBRCxDQURsQixDQUdBNUssTUFBTSxDQUFDc0MsTUFBRCxDQUFOLENBQWlCLENBQUNzSSxHQUFELENBQU1wSCxLQUFOLENBQWEwMUMsa0JBQWtCLENBQUMxMUMsS0FBRCxDQUEvQixDQUFqQixDQUNELENBQ0QsTUFBT3hELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNHBDLFVBQVQsQ0FBbUJ4akMsTUFBbkIsQ0FBMkJ3RSxHQUEzQixDQUFnQyxDQUM5QixHQUFJcEgsTUFBSyxDQUFHb2pDLFFBQVEsQ0FBQ3hnQyxNQUFELENBQVN3RSxHQUFULENBQXBCLENBQ0EsTUFBT2d0QyxhQUFZLENBQUNwMEMsS0FBRCxDQUFaLENBQXNCQSxLQUF0QixDQUE4Qm5CLFNBQXJDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMreUMsVUFBVCxDQUFtQjV4QyxLQUFuQixDQUEwQixDQUN4QixHQUFJeWlELE1BQUssQ0FBRzM4QyxjQUFjLENBQUNJLElBQWYsQ0FBb0JsRyxLQUFwQixDQUEyQmttQyxjQUEzQixDQUFaLENBQ0k2SSxHQUFHLENBQUcvdUMsS0FBSyxDQUFDa21DLGNBQUQsQ0FEZixDQUdBLEdBQUksQ0FDRmxtQyxLQUFLLENBQUNrbUMsY0FBRCxDQUFMLENBQXdCcm5DLFNBQXhCLENBQ0EsR0FBSTZqRCxTQUFRLENBQUcsSUFBZixDQUNELENBQUMsTUFBTzE2QyxDQUFQLENBQVUsQ0FBRSxDQUVkLEdBQUl4TCxPQUFNLENBQUc4b0Msb0JBQW9CLENBQUNwL0IsSUFBckIsQ0FBMEJsRyxLQUExQixDQUFiLENBQ0EsR0FBSTBpRCxRQUFKLENBQWMsQ0FDWixHQUFJRCxLQUFKLENBQVcsQ0FDVHppRCxLQUFLLENBQUNrbUMsY0FBRCxDQUFMLENBQXdCNkksR0FBeEIsQ0FDRCxDQUZELElBRU8sQ0FDTCxNQUFPL3VDLE1BQUssQ0FBQ2ttQyxjQUFELENBQVosQ0FDRCxDQUNGLENBQ0QsTUFBTzFwQyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkrL0MsV0FBVSxDQUFHLENBQUMzVixnQkFBRCxDQUFvQitiLFNBQXBCLENBQWdDLFNBQVMvL0MsTUFBVCxDQUFpQixDQUNoRSxHQUFJQSxNQUFNLEVBQUksSUFBZCxDQUFvQixDQUNsQixNQUFPLEVBQVAsQ0FDRCxDQUNEQSxNQUFNLENBQUdtRCxNQUFNLENBQUNuRCxNQUFELENBQWYsQ0FDQSxNQUFPczlCLFlBQVcsQ0FBQzBHLGdCQUFnQixDQUFDaGtDLE1BQUQsQ0FBakIsQ0FBMkIsU0FBU2s0QyxNQUFULENBQWlCLENBQzVELE1BQU9yaEMscUJBQW9CLENBQUN2VCxJQUFyQixDQUEwQnRELE1BQTFCLENBQWtDazRDLE1BQWxDLENBQVAsQ0FDRCxDQUZpQixDQUFsQixDQUdELENBUkQsQ0FVQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkwQixhQUFZLENBQUcsQ0FBQzVWLGdCQUFELENBQW9CK2IsU0FBcEIsQ0FBZ0MsU0FBUy8vQyxNQUFULENBQWlCLENBQ2xFLEdBQUlwRyxPQUFNLENBQUcsRUFBYixDQUNBLE1BQU9vRyxNQUFQLENBQWUsQ0FDYjQ5QixTQUFTLENBQUNoa0MsTUFBRCxDQUFTKy9DLFVBQVUsQ0FBQzM1QyxNQUFELENBQW5CLENBQVQsQ0FDQUEsTUFBTSxDQUFHaWpDLFlBQVksQ0FBQ2pqQyxNQUFELENBQXJCLENBQ0QsQ0FDRCxNQUFPcEcsT0FBUCxDQUNELENBUEQsQ0FTQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl3eUMsT0FBTSxDQUFHMkMsVUFBYixDQUVBO0FBQ0EsR0FBS2pLLFFBQVEsRUFBSXNILE1BQU0sQ0FBQyxHQUFJdEgsU0FBSixDQUFhLEdBQUlrYixZQUFKLENBQWdCLENBQWhCLENBQWIsQ0FBRCxDQUFOLEVBQTRDanJCLFdBQXpELEVBQ0N4ZCxHQUFHLEVBQUk2MEIsTUFBTSxDQUFDLEdBQUk3MEIsSUFBSixFQUFELENBQU4sRUFBbUIwYyxNQUQzQixFQUVDOFEsT0FBTyxFQUFJcUgsTUFBTSxDQUFDckgsT0FBTyxDQUFDa2IsT0FBUixFQUFELENBQU4sRUFBNkI1ckIsVUFGekMsRUFHQ243QixHQUFHLEVBQUlrekMsTUFBTSxDQUFDLEdBQUlsekMsSUFBSixFQUFELENBQU4sRUFBbUJzN0IsTUFIM0IsRUFJQ25kLE9BQU8sRUFBSSswQixNQUFNLENBQUMsR0FBSS8wQixRQUFKLEVBQUQsQ0FBTixFQUF1QnVkLFVBSnZDLENBSW9ELENBQ2xEd1gsTUFBTSxDQUFHLFNBQVNodkMsS0FBVCxDQUFnQixDQUN2QixHQUFJeEQsT0FBTSxDQUFHbTFDLFVBQVUsQ0FBQzN4QyxLQUFELENBQXZCLENBQ0lrOUMsSUFBSSxDQUFHMWdELE1BQU0sRUFBSXc2QixTQUFWLENBQXNCaDNCLEtBQUssQ0FBQ21OLFdBQTVCLENBQTBDdE8sU0FEckQsQ0FFSWlrRCxVQUFVLENBQUc1RixJQUFJLENBQUcxckMsUUFBUSxDQUFDMHJDLElBQUQsQ0FBWCxDQUFvQixFQUZ6QyxDQUlBLEdBQUk0RixVQUFKLENBQWdCLENBQ2QsT0FBUUEsVUFBUixFQUNFLElBQUsvYSxtQkFBTCxDQUF5QixNQUFPcFEsWUFBUCxDQUN6QixJQUFLcVEsY0FBTCxDQUFvQixNQUFPblIsT0FBUCxDQUNwQixJQUFLb1Isa0JBQUwsQ0FBd0IsTUFBT2hSLFdBQVAsQ0FDeEIsSUFBS2lSLGNBQUwsQ0FBb0IsTUFBTzlRLE9BQVAsQ0FDcEIsSUFBSytRLGtCQUFMLENBQXdCLE1BQU8zUSxXQUFQLENBTDFCLENBT0QsQ0FDRCxNQUFPaDdCLE9BQVAsQ0FDRCxDQWZELENBZ0JELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNnRDLFFBQVQsQ0FBaUIveUIsS0FBakIsQ0FBd0JoSCxHQUF4QixDQUE2Qnl5QyxVQUE3QixDQUF5QyxDQUN2QyxHQUFJLzdDLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2lrRCxVQUFVLENBQUNqa0QsTUFEeEIsQ0FHQSxNQUFPLEVBQUVrSSxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJMEMsS0FBSSxDQUFHdWhELFVBQVUsQ0FBQy83QyxLQUFELENBQXJCLENBQ0k5TCxJQUFJLENBQUdzRyxJQUFJLENBQUN0RyxJQURoQixDQUdBLE9BQVFzRyxJQUFJLENBQUN2SCxJQUFiLEVBQ0UsSUFBSyxNQUFMLENBQWtCcWQsS0FBSyxFQUFJcGMsSUFBVCxDQUFlLE1BQ2pDLElBQUssV0FBTCxDQUFrQm9WLEdBQUcsRUFBSXBWLElBQVAsQ0FBYSxNQUMvQixJQUFLLE1BQUwsQ0FBa0JvVixHQUFHLENBQUc4MkIsU0FBUyxDQUFDOTJCLEdBQUQsQ0FBTWdILEtBQUssQ0FBR3BjLElBQWQsQ0FBZixDQUFvQyxNQUN0RCxJQUFLLFdBQUwsQ0FBa0JvYyxLQUFLLENBQUc2dkIsU0FBUyxDQUFDN3ZCLEtBQUQsQ0FBUWhILEdBQUcsQ0FBR3BWLElBQWQsQ0FBakIsQ0FBc0MsTUFKMUQsQ0FNRCxDQUNELE1BQU8sQ0FBRSxRQUFTb2MsS0FBWCxDQUFrQixNQUFPaEgsR0FBekIsQ0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMHlDLGVBQVQsQ0FBd0J0N0MsTUFBeEIsQ0FBZ0MsQ0FDOUIsR0FBSXBFLE1BQUssQ0FBR29FLE1BQU0sQ0FBQ3BFLEtBQVAsQ0FBYWsyQixhQUFiLENBQVosQ0FDQSxNQUFPbDJCLE1BQUssQ0FBR0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMDlCLEtBQVQsQ0FBZXZILGNBQWYsQ0FBSCxDQUFvQyxFQUFoRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzU0QixRQUFULENBQWlCK0IsTUFBakIsQ0FBeUJrSixJQUF6QixDQUErQm0zQyxPQUEvQixDQUF3QyxDQUN0Q24zQyxJQUFJLENBQUd5bEMsUUFBUSxDQUFDemxDLElBQUQsQ0FBT2xKLE1BQVAsQ0FBZixDQUVBLEdBQUlvRSxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lsSSxNQUFNLENBQUdnTixJQUFJLENBQUNoTixNQURsQixDQUVJdEMsTUFBTSxDQUFHLEtBRmIsQ0FJQSxNQUFPLEVBQUV3SyxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJc0ksSUFBRyxDQUFHb3FDLEtBQUssQ0FBQzFsQyxJQUFJLENBQUM5RSxLQUFELENBQUwsQ0FBZixDQUNBLEdBQUksRUFBRXhLLE1BQU0sQ0FBR29HLE1BQU0sRUFBSSxJQUFWLEVBQWtCcWdELE9BQU8sQ0FBQ3JnRCxNQUFELENBQVN3RSxHQUFULENBQXBDLENBQUosQ0FBd0QsQ0FDdEQsTUFDRCxDQUNEeEUsTUFBTSxDQUFHQSxNQUFNLENBQUN3RSxHQUFELENBQWYsQ0FDRCxDQUNELEdBQUk1SyxNQUFNLEVBQUksRUFBRXdLLEtBQUYsRUFBV2xJLE1BQXpCLENBQWlDLENBQy9CLE1BQU90QyxPQUFQLENBQ0QsQ0FDRHNDLE1BQU0sQ0FBRzhELE1BQU0sRUFBSSxJQUFWLENBQWlCLENBQWpCLENBQXFCQSxNQUFNLENBQUM5RCxNQUFyQyxDQUNBLE1BQU8sQ0FBQyxDQUFDQSxNQUFGLEVBQVk0MUMsUUFBUSxDQUFDNTFDLE1BQUQsQ0FBcEIsRUFBZ0NvdUMsT0FBTyxDQUFDOWxDLEdBQUQsQ0FBTXRJLE1BQU4sQ0FBdkMsR0FDSnFILE9BQU8sQ0FBQ3ZELE1BQUQsQ0FBUCxFQUFtQmtxQyxXQUFXLENBQUNscUMsTUFBRCxDQUQxQixDQUFQLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrc0MsZUFBVCxDQUF3QjlyQyxLQUF4QixDQUErQixDQUM3QixHQUFJbEUsT0FBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFBbkIsQ0FDSXRDLE1BQU0sQ0FBRyxHQUFJd0csTUFBSyxDQUFDbUssV0FBVixDQUFzQnJPLE1BQXRCLENBRGIsQ0FHQTtBQUNBLEdBQUlBLE1BQU0sRUFBSSxNQUFPa0UsTUFBSyxDQUFDLENBQUQsQ0FBWixFQUFtQixRQUE3QixFQUF5QzhDLGNBQWMsQ0FBQ0ksSUFBZixDQUFvQmxELEtBQXBCLENBQTJCLE9BQTNCLENBQTdDLENBQWtGLENBQ2hGeEcsTUFBTSxDQUFDd0ssS0FBUCxDQUFlaEUsS0FBSyxDQUFDZ0UsS0FBckIsQ0FDQXhLLE1BQU0sQ0FBQzBtRCxLQUFQLENBQWVsZ0QsS0FBSyxDQUFDa2dELEtBQXJCLENBQ0QsQ0FDRCxNQUFPMW1ELE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJ5QyxnQkFBVCxDQUF5QnZzQyxNQUF6QixDQUFpQyxDQUMvQixNQUFRLE9BQU9BLE9BQU0sQ0FBQ3VLLFdBQWQsRUFBNkIsVUFBN0IsRUFBMkMsQ0FBQzhuQyxXQUFXLENBQUNyeUMsTUFBRCxDQUF4RCxDQUNIZ21DLFVBQVUsQ0FBQy9DLFlBQVksQ0FBQ2pqQyxNQUFELENBQWIsQ0FEUCxDQUVILEVBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMwc0MsZUFBVCxDQUF3QjFzQyxNQUF4QixDQUFnQ21zQyxHQUFoQyxDQUFxQ0osTUFBckMsQ0FBNkMsQ0FDM0MsR0FBSXVPLEtBQUksQ0FBR3Q2QyxNQUFNLENBQUN1SyxXQUFsQixDQUNBLE9BQVE0aEMsR0FBUixFQUNFLElBQUtyWCxlQUFMLENBQ0UsTUFBTzJpQixpQkFBZ0IsQ0FBQ3ozQyxNQUFELENBQXZCLENBRUYsSUFBSzJ6QixRQUFMLENBQ0EsSUFBS0MsUUFBTCxDQUNFLE1BQU8sSUFBSTBtQixLQUFKLENBQVMsQ0FBQ3Q2QyxNQUFWLENBQVAsQ0FFRixJQUFLKzBCLFlBQUwsQ0FDRSxNQUFPNmlCLGNBQWEsQ0FBQzUzQyxNQUFELENBQVMrckMsTUFBVCxDQUFwQixDQUVGLElBQUsvVyxXQUFMLENBQWlCLElBQUtDLFdBQUwsQ0FDakIsSUFBS0MsUUFBTCxDQUFjLElBQUtDLFNBQUwsQ0FBZSxJQUFLQyxTQUFMLENBQzdCLElBQUtDLFNBQUwsQ0FBZSxJQUFLQyxnQkFBTCxDQUFzQixJQUFLQyxVQUFMLENBQWdCLElBQUtDLFVBQUwsQ0FDbkQsTUFBTzhkLGdCQUFlLENBQUN0ekMsTUFBRCxDQUFTK3JDLE1BQVQsQ0FBdEIsQ0FFRixJQUFLOVgsT0FBTCxDQUNFLE1BQU8sSUFBSXFtQixLQUFKLEVBQVAsQ0FFRixJQUFLcG1CLFVBQUwsQ0FDQSxJQUFLTyxVQUFMLENBQ0UsTUFBTyxJQUFJNmxCLEtBQUosQ0FBU3Q2QyxNQUFULENBQVAsQ0FFRixJQUFLdTBCLFVBQUwsQ0FDRSxNQUFPd2pCLFlBQVcsQ0FBQy8zQyxNQUFELENBQWxCLENBRUYsSUFBS3cwQixPQUFMLENBQ0UsTUFBTyxJQUFJOGxCLEtBQUosRUFBUCxDQUVGLElBQUs1bEIsVUFBTCxDQUNFLE1BQU91akIsWUFBVyxDQUFDajRDLE1BQUQsQ0FBbEIsQ0E5QkosQ0FnQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3VnRCxrQkFBVCxDQUEyQno3QyxNQUEzQixDQUFtQzA3QyxPQUFuQyxDQUE0QyxDQUMxQyxHQUFJdGtELE9BQU0sQ0FBR3NrRCxPQUFPLENBQUN0a0QsTUFBckIsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE1BQU80SSxPQUFQLENBQ0QsQ0FDRCxHQUFJNjhCLFVBQVMsQ0FBR3psQyxNQUFNLENBQUcsQ0FBekIsQ0FDQXNrRCxPQUFPLENBQUM3ZSxTQUFELENBQVAsQ0FBcUIsQ0FBQ3psQyxNQUFNLENBQUcsQ0FBVCxDQUFhLElBQWIsQ0FBb0IsRUFBckIsRUFBMkJza0QsT0FBTyxDQUFDN2UsU0FBRCxDQUF2RCxDQUNBNmUsT0FBTyxDQUFHQSxPQUFPLENBQUNqMEIsSUFBUixDQUFhcndCLE1BQU0sQ0FBRyxDQUFULENBQWEsSUFBYixDQUFvQixHQUFqQyxDQUFWLENBQ0EsTUFBTzRJLE9BQU0sQ0FBQzQ2QixPQUFQLENBQWUvSSxhQUFmLENBQThCLHVCQUF5QjZwQixPQUF6QixDQUFtQyxRQUFqRSxDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNuUyxjQUFULENBQXVCanhDLEtBQXZCLENBQThCLENBQzVCLE1BQU9tRyxRQUFPLENBQUNuRyxLQUFELENBQVAsRUFBa0I4c0MsV0FBVyxDQUFDOXNDLEtBQUQsQ0FBN0IsRUFDTCxDQUFDLEVBQUUrbEMsZ0JBQWdCLEVBQUkvbEMsS0FBcEIsRUFBNkJBLEtBQUssQ0FBQytsQyxnQkFBRCxDQUFwQyxDQURILENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU21ILFFBQVQsQ0FBaUJsdEMsS0FBakIsQ0FBd0JsQixNQUF4QixDQUFnQyxDQUM5QixHQUFJN0UsS0FBSSxDQUFHLE1BQU8rRixNQUFsQixDQUNBbEIsTUFBTSxDQUFHQSxNQUFNLEVBQUksSUFBVixDQUFpQisyQixnQkFBakIsQ0FBb0MvMkIsTUFBN0MsQ0FFQSxNQUFPLENBQUMsQ0FBQ0EsTUFBRixHQUNKN0UsSUFBSSxFQUFJLFFBQVIsRUFDRUEsSUFBSSxFQUFJLFFBQVIsRUFBb0JrZ0MsUUFBUSxDQUFDbUosSUFBVCxDQUFjdGpDLEtBQWQsQ0FGbEIsR0FHQUEsS0FBSyxDQUFHLENBQUMsQ0FBVCxFQUFjQSxLQUFLLENBQUcsQ0FBUixFQUFhLENBQTNCLEVBQWdDQSxLQUFLLENBQUdsQixNQUgvQyxDQUlELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaStDLGVBQVQsQ0FBd0IvOEMsS0FBeEIsQ0FBK0JnSCxLQUEvQixDQUFzQ3BFLE1BQXRDLENBQThDLENBQzVDLEdBQUksQ0FBQ2ttQyxRQUFRLENBQUNsbUMsTUFBRCxDQUFiLENBQXVCLENBQ3JCLE1BQU8sTUFBUCxDQUNELENBQ0QsR0FBSTNJLEtBQUksQ0FBRyxNQUFPK00sTUFBbEIsQ0FDQSxHQUFJL00sSUFBSSxFQUFJLFFBQVIsQ0FDS29ZLFdBQVcsQ0FBQ3pQLE1BQUQsQ0FBWCxFQUF1QnNxQyxPQUFPLENBQUNsbUMsS0FBRCxDQUFRcEUsTUFBTSxDQUFDOUQsTUFBZixDQURuQyxDQUVLN0UsSUFBSSxFQUFJLFFBQVIsRUFBb0IrTSxLQUFLLEdBQUlwRSxPQUZ0QyxDQUdNLENBQ0osTUFBTzhxQyxHQUFFLENBQUM5cUMsTUFBTSxDQUFDb0UsS0FBRCxDQUFQLENBQWdCaEgsS0FBaEIsQ0FBVCxDQUNELENBQ0QsTUFBTyxNQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3kxQyxNQUFULENBQWV6MUMsS0FBZixDQUFzQjRDLE1BQXRCLENBQThCLENBQzVCLEdBQUl1RCxPQUFPLENBQUNuRyxLQUFELENBQVgsQ0FBb0IsQ0FDbEIsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFJL0YsS0FBSSxDQUFHLE1BQU8rRixNQUFsQixDQUNBLEdBQUkvRixJQUFJLEVBQUksUUFBUixFQUFvQkEsSUFBSSxFQUFJLFFBQTVCLEVBQXdDQSxJQUFJLEVBQUksU0FBaEQsRUFDQStGLEtBQUssRUFBSSxJQURULEVBQ2lCMHdDLFFBQVEsQ0FBQzF3QyxLQUFELENBRDdCLENBQ3NDLENBQ3BDLE1BQU8sS0FBUCxDQUNELENBQ0QsTUFBT2k1QixjQUFhLENBQUNxSyxJQUFkLENBQW1CdGpDLEtBQW5CLEdBQTZCLENBQUNnNUIsWUFBWSxDQUFDc0ssSUFBYixDQUFrQnRqQyxLQUFsQixDQUE5QixFQUNKNEMsTUFBTSxFQUFJLElBQVYsRUFBa0I1QyxLQUFLLEdBQUkrRixPQUFNLENBQUNuRCxNQUFELENBRHBDLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0L0MsVUFBVCxDQUFtQnhpRCxLQUFuQixDQUEwQixDQUN4QixHQUFJL0YsS0FBSSxDQUFHLE1BQU8rRixNQUFsQixDQUNBLE1BQVEvRixLQUFJLEVBQUksUUFBUixFQUFvQkEsSUFBSSxFQUFJLFFBQTVCLEVBQXdDQSxJQUFJLEVBQUksUUFBaEQsRUFBNERBLElBQUksRUFBSSxTQUFyRSxDQUNGK0YsS0FBSyxHQUFLLFdBRFIsQ0FFRkEsS0FBSyxHQUFLLElBRmYsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNCtDLFdBQVQsQ0FBb0JuZixJQUFwQixDQUEwQixDQUN4QixHQUFJaWYsU0FBUSxDQUFHRCxXQUFXLENBQUNoZixJQUFELENBQTFCLENBQ0l2b0IsS0FBSyxDQUFHcXhCLE1BQU0sQ0FBQ21XLFFBQUQsQ0FEbEIsQ0FHQSxHQUFJLE1BQU94bkMsTUFBUCxFQUFnQixVQUFoQixFQUE4QixFQUFFd25DLFFBQVEsR0FBSWpXLFlBQVcsQ0FBQzVqQyxTQUExQixDQUFsQyxDQUF3RSxDQUN0RSxNQUFPLE1BQVAsQ0FDRCxDQUNELEdBQUk0NkIsSUFBSSxHQUFLdm9CLEtBQWIsQ0FBb0IsQ0FDbEIsTUFBTyxLQUFQLENBQ0QsQ0FDRCxHQUFJMVYsS0FBSSxDQUFHbTlDLE9BQU8sQ0FBQ3puQyxLQUFELENBQWxCLENBQ0EsTUFBTyxDQUFDLENBQUMxVixJQUFGLEVBQVVpK0IsSUFBSSxHQUFLaitCLElBQUksQ0FBQyxDQUFELENBQTlCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2eUMsU0FBVCxDQUFrQjVVLElBQWxCLENBQXdCLENBQ3RCLE1BQU8sQ0FBQyxDQUFDeUYsVUFBRixFQUFpQkEsVUFBVSxHQUFJekYsS0FBdEMsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTRqQixXQUFVLENBQUd0ZSxVQUFVLENBQUd0Z0MsVUFBSCxDQUFnQjYrQyxTQUEzQyxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3JPLFlBQVQsQ0FBcUJqMUMsS0FBckIsQ0FBNEIsQ0FDMUIsR0FBSWs5QyxLQUFJLENBQUdsOUMsS0FBSyxFQUFJQSxLQUFLLENBQUNtTixXQUExQixDQUNJMDdCLEtBQUssQ0FBSSxNQUFPcVUsS0FBUCxFQUFlLFVBQWYsRUFBNkJBLElBQUksQ0FBQ3I0QyxTQUFuQyxFQUFpRGlnQyxXQUQ3RCxDQUdBLE1BQU85a0MsTUFBSyxHQUFLNm9DLEtBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZNLG1CQUFULENBQTRCMTFDLEtBQTVCLENBQW1DLENBQ2pDLE1BQU9BLE1BQUssR0FBS0EsS0FBVixFQUFtQixDQUFDOG9DLFFBQVEsQ0FBQzlvQyxLQUFELENBQW5DLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdzFDLHdCQUFULENBQWlDcHVDLEdBQWpDLENBQXNDK3NDLFFBQXRDLENBQWdELENBQzlDLE1BQU8sVUFBU3Z4QyxNQUFULENBQWlCLENBQ3RCLEdBQUlBLE1BQU0sRUFBSSxJQUFkLENBQW9CLENBQ2xCLE1BQU8sTUFBUCxDQUNELENBQ0QsTUFBT0EsT0FBTSxDQUFDd0UsR0FBRCxDQUFOLEdBQWdCK3NDLFFBQWhCLEdBQ0pBLFFBQVEsR0FBS3QxQyxTQUFiLEVBQTJCdUksR0FBRyxHQUFJckIsT0FBTSxDQUFDbkQsTUFBRCxDQURwQyxDQUFQLENBRUQsQ0FORCxDQU9ELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMyZ0QsY0FBVCxDQUF1QjlqQixJQUF2QixDQUE2QixDQUMzQixHQUFJampDLE9BQU0sQ0FBR2duRCxPQUFPLENBQUMvakIsSUFBRCxDQUFPLFNBQVNyNEIsR0FBVCxDQUFjLENBQ3ZDLEdBQUl1TixLQUFLLENBQUN6WixJQUFOLEdBQWVrNUIsZ0JBQW5CLENBQXFDLENBQ25DemYsS0FBSyxDQUFDd0csS0FBTixHQUNELENBQ0QsTUFBTy9ULElBQVAsQ0FDRCxDQUxtQixDQUFwQixDQU9BLEdBQUl1TixNQUFLLENBQUduWSxNQUFNLENBQUNtWSxLQUFuQixDQUNBLE1BQU9uWSxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2a0QsVUFBVCxDQUFtQjcvQyxJQUFuQixDQUF5QmtHLE1BQXpCLENBQWlDLENBQy9CLEdBQUkrbUMsUUFBTyxDQUFHanRDLElBQUksQ0FBQyxDQUFELENBQWxCLENBQ0lpaUQsVUFBVSxDQUFHLzdDLE1BQU0sQ0FBQyxDQUFELENBRHZCLENBRUlnOEMsVUFBVSxDQUFHalYsT0FBTyxDQUFHZ1YsVUFGM0IsQ0FHSXhULFFBQVEsQ0FBR3lULFVBQVUsRUFBSS91QixjQUFjLENBQUdDLGtCQUFqQixDQUFzQ00sYUFBMUMsQ0FIekIsQ0FLQSxHQUFJeXVCLFFBQU8sQ0FDUEYsVUFBVSxFQUFJdnVCLGFBQWYsRUFBa0N1WixPQUFPLEVBQUkzWixlQUE5QyxFQUNFMnVCLFVBQVUsRUFBSXZ1QixhQUFmLEVBQWtDdVosT0FBTyxFQUFJdFosZUFBN0MsRUFBa0UzekIsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRMUMsTUFBUixFQUFrQjRJLE1BQU0sQ0FBQyxDQUFELENBRDNGLEVBRUUrN0MsVUFBVSxHQUFLdnVCLGFBQWEsQ0FBR0MsZUFBckIsQ0FBWCxFQUFzRHp0QixNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVU1SSxNQUFWLEVBQW9CNEksTUFBTSxDQUFDLENBQUQsQ0FBaEYsRUFBeUYrbUMsT0FBTyxFQUFJM1osZUFIdkcsQ0FLQTtBQUNBLEdBQUksRUFBRW1iLFFBQVEsRUFBSTBULE9BQWQsQ0FBSixDQUE0QixDQUMxQixNQUFPbmlELEtBQVAsQ0FDRCxDQUNEO0FBQ0EsR0FBSWlpRCxVQUFVLENBQUc5dUIsY0FBakIsQ0FBaUMsQ0FDL0JuekIsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVa0csTUFBTSxDQUFDLENBQUQsQ0FBaEIsQ0FDQTtBQUNBZzhDLFVBQVUsRUFBSWpWLE9BQU8sQ0FBRzlaLGNBQVYsQ0FBMkIsQ0FBM0IsQ0FBK0JFLHFCQUE3QyxDQUNELENBQ0Q7QUFDQSxHQUFJNzBCLE1BQUssQ0FBRzBILE1BQU0sQ0FBQyxDQUFELENBQWxCLENBQ0EsR0FBSTFILEtBQUosQ0FBVyxDQUNULEdBQUl3N0MsU0FBUSxDQUFHaDZDLElBQUksQ0FBQyxDQUFELENBQW5CLENBQ0FBLElBQUksQ0FBQyxDQUFELENBQUosQ0FBVWc2QyxRQUFRLENBQUdELFdBQVcsQ0FBQ0MsUUFBRCxDQUFXeDdDLEtBQVgsQ0FBa0IwSCxNQUFNLENBQUMsQ0FBRCxDQUF4QixDQUFkLENBQTZDMUgsS0FBL0QsQ0FDQXdCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBVWc2QyxRQUFRLENBQUczWCxjQUFjLENBQUNyaUMsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFVNnlCLFdBQVYsQ0FBakIsQ0FBMEMzc0IsTUFBTSxDQUFDLENBQUQsQ0FBbEUsQ0FDRCxDQUNEO0FBQ0ExSCxLQUFLLENBQUcwSCxNQUFNLENBQUMsQ0FBRCxDQUFkLENBQ0EsR0FBSTFILEtBQUosQ0FBVyxDQUNUdzdDLFFBQVEsQ0FBR2g2QyxJQUFJLENBQUMsQ0FBRCxDQUFmLENBQ0FBLElBQUksQ0FBQyxDQUFELENBQUosQ0FBVWc2QyxRQUFRLENBQUdVLGdCQUFnQixDQUFDVixRQUFELENBQVd4N0MsS0FBWCxDQUFrQjBILE1BQU0sQ0FBQyxDQUFELENBQXhCLENBQW5CLENBQWtEMUgsS0FBcEUsQ0FDQXdCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBVWc2QyxRQUFRLENBQUczWCxjQUFjLENBQUNyaUMsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFVNnlCLFdBQVYsQ0FBakIsQ0FBMEMzc0IsTUFBTSxDQUFDLENBQUQsQ0FBbEUsQ0FDRCxDQUNEO0FBQ0ExSCxLQUFLLENBQUcwSCxNQUFNLENBQUMsQ0FBRCxDQUFkLENBQ0EsR0FBSTFILEtBQUosQ0FBVyxDQUNUd0IsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVeEIsS0FBVixDQUNELENBQ0Q7QUFDQSxHQUFJeWpELFVBQVUsQ0FBR3Z1QixhQUFqQixDQUFnQyxDQUM5QjF6QixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVVBLElBQUksQ0FBQyxDQUFELENBQUosRUFBVyxJQUFYLENBQWtCa0csTUFBTSxDQUFDLENBQUQsQ0FBeEIsQ0FBOEIwL0IsU0FBUyxDQUFDNWxDLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBVWtHLE1BQU0sQ0FBQyxDQUFELENBQWhCLENBQWpELENBQ0QsQ0FDRDtBQUNBLEdBQUlsRyxJQUFJLENBQUMsQ0FBRCxDQUFKLEVBQVcsSUFBZixDQUFxQixDQUNuQkEsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVa0csTUFBTSxDQUFDLENBQUQsQ0FBaEIsQ0FDRCxDQUNEO0FBQ0FsRyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVVrRyxNQUFNLENBQUMsQ0FBRCxDQUFoQixDQUNBbEcsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFVa2lELFVBQVYsQ0FFQSxNQUFPbGlELEtBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMyekMsYUFBVCxDQUFzQnZ5QyxNQUF0QixDQUE4QixDQUM1QixHQUFJcEcsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFJb0csTUFBTSxFQUFJLElBQWQsQ0FBb0IsQ0FDbEIsSUFBSyxHQUFJd0UsSUFBVCxHQUFnQnJCLE9BQU0sQ0FBQ25ELE1BQUQsQ0FBdEIsQ0FBZ0MsQ0FDOUJwRyxNQUFNLENBQUN5TixJQUFQLENBQVk3QyxHQUFaLEVBQ0QsQ0FDRixDQUNELE1BQU81SyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxMUMsZUFBVCxDQUF3Qjd4QyxLQUF4QixDQUErQixDQUM3QixNQUFPc2xDLHFCQUFvQixDQUFDcC9CLElBQXJCLENBQTBCbEcsS0FBMUIsQ0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3czQyxTQUFULENBQWtCL1gsSUFBbEIsQ0FBd0Jub0IsS0FBeEIsQ0FBK0Jxc0IsU0FBL0IsQ0FBMEMsQ0FDeENyc0IsS0FBSyxDQUFHNnZCLFNBQVMsQ0FBQzd2QixLQUFLLEdBQUt6WSxTQUFWLENBQXVCNGdDLElBQUksQ0FBQzNnQyxNQUFMLENBQWMsQ0FBckMsQ0FBMEN3WSxLQUEzQyxDQUFrRCxDQUFsRCxDQUFqQixDQUNBLE1BQU8sV0FBVyxDQUNoQixHQUFJeFAsS0FBSSxDQUFHRCxTQUFYLENBQ0liLEtBQUssQ0FBRyxDQUFDLENBRGIsQ0FFSWxJLE1BQU0sQ0FBR3FvQyxTQUFTLENBQUNyL0IsSUFBSSxDQUFDaEosTUFBTCxDQUFjd1ksS0FBZixDQUFzQixDQUF0QixDQUZ0QixDQUdJdFUsS0FBSyxDQUFHdEcsS0FBSyxDQUFDb0MsTUFBRCxDQUhqQixDQUtBLE1BQU8sRUFBRWtJLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCa0UsS0FBSyxDQUFDZ0UsS0FBRCxDQUFMLENBQWVjLElBQUksQ0FBQ3dQLEtBQUssQ0FBR3RRLEtBQVQsQ0FBbkIsQ0FDRCxDQUNEQSxLQUFLLENBQUcsQ0FBQyxDQUFULENBQ0EsR0FBSTQ4QyxVQUFTLENBQUdsbkQsS0FBSyxDQUFDNGEsS0FBSyxDQUFHLENBQVQsQ0FBckIsQ0FDQSxNQUFPLEVBQUV0USxLQUFGLENBQVVzUSxLQUFqQixDQUF3QixDQUN0QnNzQyxTQUFTLENBQUM1OEMsS0FBRCxDQUFULENBQW1CYyxJQUFJLENBQUNkLEtBQUQsQ0FBdkIsQ0FDRCxDQUNENDhDLFNBQVMsQ0FBQ3RzQyxLQUFELENBQVQsQ0FBbUJxc0IsU0FBUyxDQUFDM2dDLEtBQUQsQ0FBNUIsQ0FDQSxNQUFPMEIsTUFBSyxDQUFDKzZCLElBQUQsQ0FBTyxJQUFQLENBQWFta0IsU0FBYixDQUFaLENBQ0QsQ0FoQkQsQ0FpQkQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2xvRCxPQUFULENBQWdCa0gsTUFBaEIsQ0FBd0JrSixJQUF4QixDQUE4QixDQUM1QixNQUFPQSxLQUFJLENBQUNoTixNQUFMLENBQWMsQ0FBZCxDQUFrQjhELE1BQWxCLENBQTJCMHVDLE9BQU8sQ0FBQzF1QyxNQUFELENBQVNtMUMsU0FBUyxDQUFDanNDLElBQUQsQ0FBTyxDQUFQLENBQVUsQ0FBQyxDQUFYLENBQWxCLENBQXpDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5ekMsUUFBVCxDQUFpQnY4QyxLQUFqQixDQUF3QmkwQyxPQUF4QixDQUFpQyxDQUMvQixHQUFJOU0sVUFBUyxDQUFHbm5DLEtBQUssQ0FBQ2xFLE1BQXRCLENBQ0lBLE1BQU0sQ0FBR3NvQyxTQUFTLENBQUM2UCxPQUFPLENBQUNuNEMsTUFBVCxDQUFpQnFyQyxTQUFqQixDQUR0QixDQUVJMFosUUFBUSxDQUFHaGEsU0FBUyxDQUFDN21DLEtBQUQsQ0FGeEIsQ0FJQSxNQUFPbEUsTUFBTSxFQUFiLENBQWlCLENBQ2YsR0FBSWtJLE1BQUssQ0FBR2l3QyxPQUFPLENBQUNuNEMsTUFBRCxDQUFuQixDQUNBa0UsS0FBSyxDQUFDbEUsTUFBRCxDQUFMLENBQWdCb3VDLE9BQU8sQ0FBQ2xtQyxLQUFELENBQVFtakMsU0FBUixDQUFQLENBQTRCMFosUUFBUSxDQUFDNzhDLEtBQUQsQ0FBcEMsQ0FBOENuSSxTQUE5RCxDQUNELENBQ0QsTUFBT21FLE1BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTOHlDLFFBQVQsQ0FBaUJsekMsTUFBakIsQ0FBeUJ3RSxHQUF6QixDQUE4QixDQUM1QixHQUFJQSxHQUFHLEdBQUssYUFBUixFQUF5QixNQUFPeEUsT0FBTSxDQUFDd0UsR0FBRCxDQUFiLEdBQXVCLFVBQXBELENBQWdFLENBQzlELE9BQ0QsQ0FFRCxHQUFJQSxHQUFHLEVBQUksV0FBWCxDQUF3QixDQUN0QixPQUNELENBRUQsTUFBT3hFLE9BQU0sQ0FBQ3dFLEdBQUQsQ0FBYixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl5NUMsUUFBTyxDQUFHaUQsUUFBUSxDQUFDbk0sV0FBRCxDQUF0QixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJbFIsV0FBVSxDQUFHRCxhQUFhLEVBQUksU0FBUy9HLElBQVQsQ0FBZXNRLElBQWYsQ0FBcUIsQ0FDckQsTUFBTy92QixLQUFJLENBQUN5bUIsVUFBTCxDQUFnQmhILElBQWhCLENBQXNCc1EsSUFBdEIsQ0FBUCxDQUNELENBRkQsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXdILFlBQVcsQ0FBR3VNLFFBQVEsQ0FBQ2xNLGVBQUQsQ0FBMUIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrSixnQkFBVCxDQUF5QjFELE9BQXpCLENBQWtDMkcsU0FBbEMsQ0FBNkN0VixPQUE3QyxDQUFzRCxDQUNwRCxHQUFJL21DLE9BQU0sQ0FBSXE4QyxTQUFTLENBQUcsRUFBMUIsQ0FDQSxNQUFPeE0sWUFBVyxDQUFDNkYsT0FBRCxDQUFVK0YsaUJBQWlCLENBQUN6N0MsTUFBRCxDQUFTczhDLGlCQUFpQixDQUFDaEIsY0FBYyxDQUFDdDdDLE1BQUQsQ0FBZixDQUF5QittQyxPQUF6QixDQUExQixDQUEzQixDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3FWLFNBQVQsQ0FBa0Jya0IsSUFBbEIsQ0FBd0IsQ0FDdEIsR0FBSTFnQixNQUFLLENBQUcsQ0FBWixDQUNJa2xDLFVBQVUsQ0FBRyxDQURqQixDQUdBLE1BQU8sV0FBVyxDQUNoQixHQUFJQyxNQUFLLENBQUc3YyxTQUFTLEVBQXJCLENBQ0k4YyxTQUFTLENBQUczdUIsUUFBUSxFQUFJMHVCLEtBQUssQ0FBR0QsVUFBWixDQUR4QixDQUdBQSxVQUFVLENBQUdDLEtBQWIsQ0FDQSxHQUFJQyxTQUFTLENBQUcsQ0FBaEIsQ0FBbUIsQ0FDakIsR0FBSSxFQUFFcGxDLEtBQUYsRUFBV3dXLFNBQWYsQ0FBMEIsQ0FDeEIsTUFBTzF0QixVQUFTLENBQUMsQ0FBRCxDQUFoQixDQUNELENBQ0YsQ0FKRCxJQUlPLENBQ0xrWCxLQUFLLENBQUcsQ0FBUixDQUNELENBQ0QsTUFBTzBnQixLQUFJLENBQUMvNkIsS0FBTCxDQUFXN0YsU0FBWCxDQUFzQmdKLFNBQXRCLENBQVAsQ0FDRCxDQWJELENBY0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lsQyxZQUFULENBQXFCdHFDLEtBQXJCLENBQTRCOUgsSUFBNUIsQ0FBa0MsQ0FDaEMsR0FBSThMLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BRG5CLENBRUl5bEMsU0FBUyxDQUFHemxDLE1BQU0sQ0FBRyxDQUZ6QixDQUlBNUQsSUFBSSxDQUFHQSxJQUFJLEdBQUsyRCxTQUFULENBQXFCQyxNQUFyQixDQUE4QjVELElBQXJDLENBQ0EsTUFBTyxFQUFFOEwsS0FBRixDQUFVOUwsSUFBakIsQ0FBdUIsQ0FDckIsR0FBSWtwRCxLQUFJLENBQUdoWCxVQUFVLENBQUNwbUMsS0FBRCxDQUFRdTlCLFNBQVIsQ0FBckIsQ0FDSXZrQyxLQUFLLENBQUdnRCxLQUFLLENBQUNvaEQsSUFBRCxDQURqQixDQUdBcGhELEtBQUssQ0FBQ29oRCxJQUFELENBQUwsQ0FBY3BoRCxLQUFLLENBQUNnRSxLQUFELENBQW5CLENBQ0FoRSxLQUFLLENBQUNnRSxLQUFELENBQUwsQ0FBZWhILEtBQWYsQ0FDRCxDQUNEZ0QsS0FBSyxDQUFDbEUsTUFBTixDQUFlNUQsSUFBZixDQUNBLE1BQU84SCxNQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlnM0MsYUFBWSxDQUFHdUosYUFBYSxDQUFDLFNBQVMvL0MsTUFBVCxDQUFpQixDQUNoRCxHQUFJaEgsT0FBTSxDQUFHLEVBQWIsQ0FDQSxHQUFJZ0gsTUFBTSxDQUFDMlYsVUFBUCxDQUFrQixDQUFsQixJQUF5QixFQUFHLE9BQWhDLENBQXlDLENBQ3ZDM2MsTUFBTSxDQUFDeU4sSUFBUCxDQUFZLEVBQVosRUFDRCxDQUNEekcsTUFBTSxDQUFDOCtCLE9BQVAsQ0FBZXBKLFVBQWYsQ0FBMkIsU0FBUzUxQixLQUFULENBQWdCZSxNQUFoQixDQUF3QmdnRCxLQUF4QixDQUErQkMsU0FBL0IsQ0FBMEMsQ0FDbkU5bkQsTUFBTSxDQUFDeU4sSUFBUCxDQUFZbzZDLEtBQUssQ0FBR0MsU0FBUyxDQUFDaGlCLE9BQVYsQ0FBa0IxSSxZQUFsQixDQUFnQyxJQUFoQyxDQUFILENBQTRDdjFCLE1BQU0sRUFBSWYsS0FBdkUsRUFDRCxDQUZELEVBR0EsTUFBTzlHLE9BQVAsQ0FDRCxDQVQrQixDQUFoQyxDQVdBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2cxQyxNQUFULENBQWV4eEMsS0FBZixDQUFzQixDQUNwQixHQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEIwd0MsUUFBUSxDQUFDMXdDLEtBQUQsQ0FBeEMsQ0FBaUQsQ0FDL0MsTUFBT0EsTUFBUCxDQUNELENBQ0QsR0FBSXhELE9BQU0sQ0FBSXdELEtBQUssQ0FBRyxFQUF0QixDQUNBLE1BQVF4RCxPQUFNLEVBQUksR0FBVixFQUFrQixFQUFJd0QsS0FBTCxFQUFlLENBQUM0MUIsUUFBbEMsQ0FBOEMsSUFBOUMsQ0FBcURwNUIsTUFBNUQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dWLFNBQVQsQ0FBa0JpdUIsSUFBbEIsQ0FBd0IsQ0FDdEIsR0FBSUEsSUFBSSxFQUFJLElBQVosQ0FBa0IsQ0FDaEIsR0FBSSxDQUNGLE1BQU91RixhQUFZLENBQUM5K0IsSUFBYixDQUFrQnU1QixJQUFsQixDQUFQLENBQ0QsQ0FBQyxNQUFPejNCLENBQVAsQ0FBVSxDQUFFLENBQ2QsR0FBSSxDQUNGLE1BQVF5M0IsS0FBSSxDQUFHLEVBQWYsQ0FDRCxDQUFDLE1BQU96M0IsQ0FBUCxDQUFVLENBQUUsQ0FDZixDQUNELE1BQU8sRUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnOEMsa0JBQVQsQ0FBMkJaLE9BQTNCLENBQW9DM1UsT0FBcEMsQ0FBNkMsQ0FDM0MxTyxTQUFTLENBQUM1SixTQUFELENBQVksU0FBUzhxQixJQUFULENBQWUsQ0FDbEMsR0FBSWpoRCxNQUFLLENBQUcsS0FBT2loRCxJQUFJLENBQUMsQ0FBRCxDQUF2QixDQUNBLEdBQUt4UyxPQUFPLENBQUd3UyxJQUFJLENBQUMsQ0FBRCxDQUFmLEVBQXVCLENBQUM3Z0IsYUFBYSxDQUFDZ2pCLE9BQUQsQ0FBVXBqRCxLQUFWLENBQXpDLENBQTJELENBQ3pEb2pELE9BQU8sQ0FBQ241QyxJQUFSLENBQWFqSyxLQUFiLEVBQ0QsQ0FDRixDQUxRLENBQVQsQ0FNQSxNQUFPb2pELFFBQU8sQ0FBQ2xuQyxJQUFSLEVBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lzQixhQUFULENBQXNCeVUsT0FBdEIsQ0FBK0IsQ0FDN0IsR0FBSUEsT0FBTyxXQUFZM1UsWUFBdkIsQ0FBb0MsQ0FDbEMsTUFBTzJVLFFBQU8sQ0FBQ3JULEtBQVIsRUFBUCxDQUNELENBQ0QsR0FBSXZ0QyxPQUFNLENBQUcsR0FBSWtzQyxjQUFKLENBQWtCMFUsT0FBTyxDQUFDblUsV0FBMUIsQ0FBdUNtVSxPQUFPLENBQUNqVSxTQUEvQyxDQUFiLENBQ0Ezc0MsTUFBTSxDQUFDMHNDLFdBQVAsQ0FBcUJXLFNBQVMsQ0FBQ3VULE9BQU8sQ0FBQ2xVLFdBQVQsQ0FBOUIsQ0FDQTFzQyxNQUFNLENBQUM0c0MsU0FBUCxDQUFvQmdVLE9BQU8sQ0FBQ2hVLFNBQTVCLENBQ0E1c0MsTUFBTSxDQUFDNnNDLFVBQVAsQ0FBb0IrVCxPQUFPLENBQUMvVCxVQUE1QixDQUNBLE1BQU83c0MsT0FBUCxDQUNELENBRUQsNEVBeHpLaUQsQ0EwektqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK25ELE1BQVQsQ0FBZXZoRCxLQUFmLENBQXNCOUgsSUFBdEIsQ0FBNEI0aEQsS0FBNUIsQ0FBbUMsQ0FDakMsR0FBS0EsS0FBSyxDQUFHQyxjQUFjLENBQUMvNUMsS0FBRCxDQUFROUgsSUFBUixDQUFjNGhELEtBQWQsQ0FBakIsQ0FBd0M1aEQsSUFBSSxHQUFLMkQsU0FBM0QsQ0FBdUUsQ0FDckUzRCxJQUFJLENBQUcsQ0FBUCxDQUNELENBRkQsSUFFTyxDQUNMQSxJQUFJLENBQUdpc0MsU0FBUyxDQUFDeUosU0FBUyxDQUFDMTFDLElBQUQsQ0FBVixDQUFrQixDQUFsQixDQUFoQixDQUNELENBQ0QsR0FBSTRELE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBRCxFQUFXNUQsSUFBSSxDQUFHLENBQXRCLENBQXlCLENBQ3ZCLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSThMLE1BQUssQ0FBRyxDQUFaLENBQ0ltNUIsUUFBUSxDQUFHLENBRGYsQ0FFSTNqQyxNQUFNLENBQUdFLEtBQUssQ0FBQ2dxQyxVQUFVLENBQUM1bkMsTUFBTSxDQUFHNUQsSUFBVixDQUFYLENBRmxCLENBSUEsTUFBTzhMLEtBQUssQ0FBR2xJLE1BQWYsQ0FBdUIsQ0FDckJ0QyxNQUFNLENBQUMyakMsUUFBUSxFQUFULENBQU4sQ0FBcUI0WCxTQUFTLENBQUMvMEMsS0FBRCxDQUFRZ0UsS0FBUixDQUFnQkEsS0FBSyxFQUFJOUwsSUFBekIsQ0FBOUIsQ0FDRCxDQUNELE1BQU9zQixPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTZ29ELFFBQVQsQ0FBaUJ4aEQsS0FBakIsQ0FBd0IsQ0FDdEIsR0FBSWdFLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUR2QyxDQUVJcWhDLFFBQVEsQ0FBRyxDQUZmLENBR0kzakMsTUFBTSxDQUFHLEVBSGIsQ0FLQSxNQUFPLEVBQUV3SyxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNBLEdBQUloSCxLQUFKLENBQVcsQ0FDVHhELE1BQU0sQ0FBQzJqQyxRQUFRLEVBQVQsQ0FBTixDQUFxQm5nQyxLQUFyQixDQUNELENBQ0YsQ0FDRCxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTb00sT0FBVCxFQUFrQixDQUNoQixHQUFJOUosT0FBTSxDQUFHK0ksU0FBUyxDQUFDL0ksTUFBdkIsQ0FDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSWdKLEtBQUksQ0FBR3BMLEtBQUssQ0FBQ29DLE1BQU0sQ0FBRyxDQUFWLENBQWhCLENBQ0lrRSxLQUFLLENBQUc2RSxTQUFTLENBQUMsQ0FBRCxDQURyQixDQUVJYixLQUFLLENBQUdsSSxNQUZaLENBSUEsTUFBT2tJLEtBQUssRUFBWixDQUFnQixDQUNkYyxJQUFJLENBQUNkLEtBQUssQ0FBRyxDQUFULENBQUosQ0FBa0JhLFNBQVMsQ0FBQ2IsS0FBRCxDQUEzQixDQUNELENBQ0QsTUFBT3c1QixVQUFTLENBQUNyNkIsT0FBTyxDQUFDbkQsS0FBRCxDQUFQLENBQWlCNm1DLFNBQVMsQ0FBQzdtQyxLQUFELENBQTFCLENBQW9DLENBQUNBLEtBQUQsQ0FBckMsQ0FBOEMrdEMsV0FBVyxDQUFDanBDLElBQUQsQ0FBTyxDQUFQLENBQXpELENBQWhCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJMjhDLFdBQVUsQ0FBR25OLFFBQVEsQ0FBQyxTQUFTdDBDLEtBQVQsQ0FBZ0IwZixNQUFoQixDQUF3QixDQUNoRCxNQUFPdXpCLGtCQUFpQixDQUFDanpDLEtBQUQsQ0FBakIsQ0FDSGd0QyxjQUFjLENBQUNodEMsS0FBRCxDQUFRK3RDLFdBQVcsQ0FBQ3J1QixNQUFELENBQVMsQ0FBVCxDQUFZdXpCLGlCQUFaLENBQStCLElBQS9CLENBQW5CLENBRFgsQ0FFSCxFQUZKLENBR0QsQ0FKd0IsQ0FBekIsQ0FNQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXlPLGFBQVksQ0FBR3BOLFFBQVEsQ0FBQyxTQUFTdDBDLEtBQVQsQ0FBZ0IwZixNQUFoQixDQUF3QixDQUNsRCxHQUFJbWQsU0FBUSxDQUFHN2lDLElBQUksQ0FBQzBsQixNQUFELENBQW5CLENBQ0EsR0FBSXV6QixpQkFBaUIsQ0FBQ3BXLFFBQUQsQ0FBckIsQ0FBaUMsQ0FDL0JBLFFBQVEsQ0FBR2hoQyxTQUFYLENBQ0QsQ0FDRCxNQUFPbzNDLGtCQUFpQixDQUFDanpDLEtBQUQsQ0FBakIsQ0FDSGd0QyxjQUFjLENBQUNodEMsS0FBRCxDQUFRK3RDLFdBQVcsQ0FBQ3J1QixNQUFELENBQVMsQ0FBVCxDQUFZdXpCLGlCQUFaLENBQStCLElBQS9CLENBQW5CLENBQXlETyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFwRSxDQURYLENBRUgsRUFGSixDQUdELENBUjBCLENBQTNCLENBVUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk4a0IsZUFBYyxDQUFHck4sUUFBUSxDQUFDLFNBQVN0MEMsS0FBVCxDQUFnQjBmLE1BQWhCLENBQXdCLENBQ3BELEdBQUl2RyxXQUFVLENBQUduZixJQUFJLENBQUMwbEIsTUFBRCxDQUFyQixDQUNBLEdBQUl1ekIsaUJBQWlCLENBQUM5NUIsVUFBRCxDQUFyQixDQUFtQyxDQUNqQ0EsVUFBVSxDQUFHdGQsU0FBYixDQUNELENBQ0QsTUFBT28zQyxrQkFBaUIsQ0FBQ2p6QyxLQUFELENBQWpCLENBQ0hndEMsY0FBYyxDQUFDaHRDLEtBQUQsQ0FBUSt0QyxXQUFXLENBQUNydUIsTUFBRCxDQUFTLENBQVQsQ0FBWXV6QixpQkFBWixDQUErQixJQUEvQixDQUFuQixDQUF5RHAzQyxTQUF6RCxDQUFvRXNkLFVBQXBFLENBRFgsQ0FFSCxFQUZKLENBR0QsQ0FSNEIsQ0FBN0IsQ0FVQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5b0MsS0FBVCxDQUFjNWhELEtBQWQsQ0FBcUIzRyxDQUFyQixDQUF3QnlnRCxLQUF4QixDQUErQixDQUM3QixHQUFJaCtDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRHpDLENBQUMsQ0FBSXlnRCxLQUFLLEVBQUl6Z0QsQ0FBQyxHQUFLd0MsU0FBaEIsQ0FBNkIsQ0FBN0IsQ0FBaUMreEMsU0FBUyxDQUFDdjBDLENBQUQsQ0FBOUMsQ0FDQSxNQUFPMDdDLFVBQVMsQ0FBQy8wQyxLQUFELENBQVEzRyxDQUFDLENBQUcsQ0FBSixDQUFRLENBQVIsQ0FBWUEsQ0FBcEIsQ0FBdUJ5QyxNQUF2QixDQUFoQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK2xELFVBQVQsQ0FBbUI3aEQsS0FBbkIsQ0FBMEIzRyxDQUExQixDQUE2QnlnRCxLQUE3QixDQUFvQyxDQUNsQyxHQUFJaCtDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRHpDLENBQUMsQ0FBSXlnRCxLQUFLLEVBQUl6Z0QsQ0FBQyxHQUFLd0MsU0FBaEIsQ0FBNkIsQ0FBN0IsQ0FBaUMreEMsU0FBUyxDQUFDdjBDLENBQUQsQ0FBOUMsQ0FDQUEsQ0FBQyxDQUFHeUMsTUFBTSxDQUFHekMsQ0FBYixDQUNBLE1BQU8wN0MsVUFBUyxDQUFDLzBDLEtBQUQsQ0FBUSxDQUFSLENBQVczRyxDQUFDLENBQUcsQ0FBSixDQUFRLENBQVIsQ0FBWUEsQ0FBdkIsQ0FBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeW9ELGVBQVQsQ0FBd0I5aEQsS0FBeEIsQ0FBK0JtRSxTQUEvQixDQUEwQyxDQUN4QyxNQUFRbkUsTUFBSyxFQUFJQSxLQUFLLENBQUNsRSxNQUFoQixDQUNIeTZDLFNBQVMsQ0FBQ3YyQyxLQUFELENBQVF3ekMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBWSxDQUFaLENBQW5CLENBQW1DLElBQW5DLENBQXlDLElBQXpDLENBRE4sQ0FFSCxFQUZKLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzQ5QyxVQUFULENBQW1CL2hELEtBQW5CLENBQTBCbUUsU0FBMUIsQ0FBcUMsQ0FDbkMsTUFBUW5FLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSHk2QyxTQUFTLENBQUN2MkMsS0FBRCxDQUFRd3pDLFdBQVcsQ0FBQ3J2QyxTQUFELENBQVksQ0FBWixDQUFuQixDQUFtQyxJQUFuQyxDQUROLENBRUgsRUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2OUMsS0FBVCxDQUFjaGlELEtBQWQsQ0FBcUJoRCxLQUFyQixDQUE0QnNYLEtBQTVCLENBQW1DaEgsR0FBbkMsQ0FBd0MsQ0FDdEMsR0FBSXhSLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJd1ksS0FBSyxFQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBekIsRUFBcUN5bEMsY0FBYyxDQUFDLzVDLEtBQUQsQ0FBUWhELEtBQVIsQ0FBZXNYLEtBQWYsQ0FBdkQsQ0FBOEUsQ0FDNUVBLEtBQUssQ0FBRyxDQUFSLENBQ0FoSCxHQUFHLENBQUd4UixNQUFOLENBQ0QsQ0FDRCxNQUFPNnhDLFNBQVEsQ0FBQzN0QyxLQUFELENBQVFoRCxLQUFSLENBQWVzWCxLQUFmLENBQXNCaEgsR0FBdEIsQ0FBZixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzaUIsVUFBVCxDQUFtQjV2QixLQUFuQixDQUEwQm1FLFNBQTFCLENBQXFDazZCLFNBQXJDLENBQWdELENBQzlDLEdBQUl2aUMsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSWtJLE1BQUssQ0FBR3E2QixTQUFTLEVBQUksSUFBYixDQUFvQixDQUFwQixDQUF3QnVQLFNBQVMsQ0FBQ3ZQLFNBQUQsQ0FBN0MsQ0FDQSxHQUFJcjZCLEtBQUssQ0FBRyxDQUFaLENBQWUsQ0FDYkEsS0FBSyxDQUFHbWdDLFNBQVMsQ0FBQ3JvQyxNQUFNLENBQUdrSSxLQUFWLENBQWlCLENBQWpCLENBQWpCLENBQ0QsQ0FDRCxNQUFPbzZCLGNBQWEsQ0FBQ3ArQixLQUFELENBQVF3ekMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBWSxDQUFaLENBQW5CLENBQW1DSCxLQUFuQyxDQUFwQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnc0IsY0FBVCxDQUF1Qmh3QixLQUF2QixDQUE4Qm1FLFNBQTlCLENBQXlDazZCLFNBQXpDLENBQW9ELENBQ2xELEdBQUl2aUMsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLENBQUMsQ0FBUixDQUNELENBQ0QsR0FBSWtJLE1BQUssQ0FBR2xJLE1BQU0sQ0FBRyxDQUFyQixDQUNBLEdBQUl1aUMsU0FBUyxHQUFLeGlDLFNBQWxCLENBQTZCLENBQzNCbUksS0FBSyxDQUFHNHBDLFNBQVMsQ0FBQ3ZQLFNBQUQsQ0FBakIsQ0FDQXI2QixLQUFLLENBQUdxNkIsU0FBUyxDQUFHLENBQVosQ0FDSjhGLFNBQVMsQ0FBQ3JvQyxNQUFNLENBQUdrSSxLQUFWLENBQWlCLENBQWpCLENBREwsQ0FFSm9nQyxTQUFTLENBQUNwZ0MsS0FBRCxDQUFRbEksTUFBTSxDQUFHLENBQWpCLENBRmIsQ0FHRCxDQUNELE1BQU9zaUMsY0FBYSxDQUFDcCtCLEtBQUQsQ0FBUXd6QyxXQUFXLENBQUNydkMsU0FBRCxDQUFZLENBQVosQ0FBbkIsQ0FBbUNILEtBQW5DLENBQTBDLElBQTFDLENBQXBCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lpQixRQUFULENBQWlCem1CLEtBQWpCLENBQXdCLENBQ3RCLEdBQUlsRSxPQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFBdkMsQ0FDQSxNQUFPQSxPQUFNLENBQUdpeUMsV0FBVyxDQUFDL3RDLEtBQUQsQ0FBUSxDQUFSLENBQWQsQ0FBMkIsRUFBeEMsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaWlELFlBQVQsQ0FBcUJqaUQsS0FBckIsQ0FBNEIsQ0FDMUIsR0FBSWxFLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLE1BQU9BLE9BQU0sQ0FBR2l5QyxXQUFXLENBQUMvdEMsS0FBRCxDQUFRNHlCLFFBQVIsQ0FBZCxDQUFrQyxFQUEvQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzdkIsYUFBVCxDQUFzQmxpRCxLQUF0QixDQUE2QjRtQixLQUE3QixDQUFvQyxDQUNsQyxHQUFJOXFCLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRDhxQixLQUFLLENBQUdBLEtBQUssR0FBSy9xQixTQUFWLENBQXNCLENBQXRCLENBQTBCK3hDLFNBQVMsQ0FBQ2huQixLQUFELENBQTNDLENBQ0EsTUFBT21uQixZQUFXLENBQUMvdEMsS0FBRCxDQUFRNG1CLEtBQVIsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1N0IsVUFBVCxDQUFtQnpZLEtBQW5CLENBQTBCLENBQ3hCLEdBQUkxbEMsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNJbEksTUFBTSxDQUFHNHRDLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUM1dEMsTUFEdkMsQ0FFSXRDLE1BQU0sQ0FBRyxFQUZiLENBSUEsTUFBTyxFQUFFd0ssS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSW1pRCxLQUFJLENBQUd2VSxLQUFLLENBQUMxbEMsS0FBRCxDQUFoQixDQUNBeEssTUFBTSxDQUFDeWtELElBQUksQ0FBQyxDQUFELENBQUwsQ0FBTixDQUFrQkEsSUFBSSxDQUFDLENBQUQsQ0FBdEIsQ0FDRCxDQUNELE1BQU96a0QsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3V4QixLQUFULENBQWMvcUIsS0FBZCxDQUFxQixDQUNuQixNQUFRQSxNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQTBCa0UsS0FBSyxDQUFDLENBQUQsQ0FBL0IsQ0FBcUNuRSxTQUE1QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM2SCxRQUFULENBQWlCMUQsS0FBakIsQ0FBd0JoRCxLQUF4QixDQUErQnFoQyxTQUEvQixDQUEwQyxDQUN4QyxHQUFJdmlDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxDQUFDLENBQVIsQ0FDRCxDQUNELEdBQUlrSSxNQUFLLENBQUdxNkIsU0FBUyxFQUFJLElBQWIsQ0FBb0IsQ0FBcEIsQ0FBd0J1UCxTQUFTLENBQUN2UCxTQUFELENBQTdDLENBQ0EsR0FBSXI2QixLQUFLLENBQUcsQ0FBWixDQUFlLENBQ2JBLEtBQUssQ0FBR21nQyxTQUFTLENBQUNyb0MsTUFBTSxDQUFHa0ksS0FBVixDQUFpQixDQUFqQixDQUFqQixDQUNELENBQ0QsTUFBT3E1QixZQUFXLENBQUNyOUIsS0FBRCxDQUFRaEQsS0FBUixDQUFlZ0gsS0FBZixDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvK0MsUUFBVCxDQUFpQnBpRCxLQUFqQixDQUF3QixDQUN0QixHQUFJbEUsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsTUFBT0EsT0FBTSxDQUFHaTVDLFNBQVMsQ0FBQy8wQyxLQUFELENBQVEsQ0FBUixDQUFXLENBQUMsQ0FBWixDQUFaLENBQTZCLEVBQTFDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXFpRCxhQUFZLENBQUcvTixRQUFRLENBQUMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDM0MsR0FBSW1ULE9BQU0sQ0FBRy9rQixRQUFRLENBQUM0UixNQUFELENBQVMySCxtQkFBVCxDQUFyQixDQUNBLE1BQVF3TCxPQUFNLENBQUN4bUQsTUFBUCxFQUFpQndtRCxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQWNuVCxNQUFNLENBQUMsQ0FBRCxDQUF0QyxDQUNIRCxnQkFBZ0IsQ0FBQ29ULE1BQUQsQ0FEYixDQUVILEVBRkosQ0FHRCxDQUwwQixDQUEzQixDQU9BO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJQyxlQUFjLENBQUdqTyxRQUFRLENBQUMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDN0MsR0FBSXRTLFNBQVEsQ0FBRzdpQyxJQUFJLENBQUNtMUMsTUFBRCxDQUFuQixDQUNJbVQsTUFBTSxDQUFHL2tCLFFBQVEsQ0FBQzRSLE1BQUQsQ0FBUzJILG1CQUFULENBRHJCLENBR0EsR0FBSWphLFFBQVEsR0FBSzdpQyxJQUFJLENBQUNzb0QsTUFBRCxDQUFyQixDQUErQixDQUM3QnpsQixRQUFRLENBQUdoaEMsU0FBWCxDQUNELENBRkQsSUFFTyxDQUNMeW1ELE1BQU0sQ0FBQ3I4QyxHQUFQLEdBQ0QsQ0FDRCxNQUFRcThDLE9BQU0sQ0FBQ3htRCxNQUFQLEVBQWlCd21ELE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBY25ULE1BQU0sQ0FBQyxDQUFELENBQXRDLENBQ0hELGdCQUFnQixDQUFDb1QsTUFBRCxDQUFTOU8sV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBcEIsQ0FEYixDQUVILEVBRkosQ0FHRCxDQVo0QixDQUE3QixDQWNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkybEIsaUJBQWdCLENBQUdsTyxRQUFRLENBQUMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDL0MsR0FBSWgyQixXQUFVLENBQUduZixJQUFJLENBQUNtMUMsTUFBRCxDQUFyQixDQUNJbVQsTUFBTSxDQUFHL2tCLFFBQVEsQ0FBQzRSLE1BQUQsQ0FBUzJILG1CQUFULENBRHJCLENBR0EzOUIsVUFBVSxDQUFHLE1BQU9BLFdBQVAsRUFBcUIsVUFBckIsQ0FBa0NBLFVBQWxDLENBQStDdGQsU0FBNUQsQ0FDQSxHQUFJc2QsVUFBSixDQUFnQixDQUNkbXBDLE1BQU0sQ0FBQ3I4QyxHQUFQLEdBQ0QsQ0FDRCxNQUFRcThDLE9BQU0sQ0FBQ3htRCxNQUFQLEVBQWlCd21ELE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBY25ULE1BQU0sQ0FBQyxDQUFELENBQXRDLENBQ0hELGdCQUFnQixDQUFDb1QsTUFBRCxDQUFTem1ELFNBQVQsQ0FBb0JzZCxVQUFwQixDQURiLENBRUgsRUFGSixDQUdELENBWDhCLENBQS9CLENBYUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dULEtBQVQsQ0FBY25zQixLQUFkLENBQXFCbW5CLFNBQXJCLENBQWdDLENBQzlCLE1BQU9ubkIsTUFBSyxFQUFJLElBQVQsQ0FBZ0IsRUFBaEIsQ0FBcUJpa0MsVUFBVSxDQUFDL2dDLElBQVgsQ0FBZ0JsRCxLQUFoQixDQUF1Qm1uQixTQUF2QixDQUE1QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNudEIsS0FBVCxDQUFjZ0csS0FBZCxDQUFxQixDQUNuQixHQUFJbEUsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsTUFBT0EsT0FBTSxDQUFHa0UsS0FBSyxDQUFDbEUsTUFBTSxDQUFHLENBQVYsQ0FBUixDQUF1QkQsU0FBcEMsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNtWSxZQUFULENBQXFCaFUsS0FBckIsQ0FBNEJoRCxLQUE1QixDQUFtQ3FoQyxTQUFuQyxDQUE4QyxDQUM1QyxHQUFJdmlDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxDQUFDLENBQVIsQ0FDRCxDQUNELEdBQUlrSSxNQUFLLENBQUdsSSxNQUFaLENBQ0EsR0FBSXVpQyxTQUFTLEdBQUt4aUMsU0FBbEIsQ0FBNkIsQ0FDM0JtSSxLQUFLLENBQUc0cEMsU0FBUyxDQUFDdlAsU0FBRCxDQUFqQixDQUNBcjZCLEtBQUssQ0FBR0EsS0FBSyxDQUFHLENBQVIsQ0FBWW1nQyxTQUFTLENBQUNyb0MsTUFBTSxDQUFHa0ksS0FBVixDQUFpQixDQUFqQixDQUFyQixDQUEyQ29nQyxTQUFTLENBQUNwZ0MsS0FBRCxDQUFRbEksTUFBTSxDQUFHLENBQWpCLENBQTVELENBQ0QsQ0FDRCxNQUFPa0IsTUFBSyxHQUFLQSxLQUFWLENBQ0hna0MsaUJBQWlCLENBQUNoaEMsS0FBRCxDQUFRaEQsS0FBUixDQUFlZ0gsS0FBZixDQURkLENBRUhvNkIsYUFBYSxDQUFDcCtCLEtBQUQsQ0FBUXcrQixTQUFSLENBQW1CeDZCLEtBQW5CLENBQTBCLElBQTFCLENBRmpCLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeStDLElBQVQsQ0FBYXppRCxLQUFiLENBQW9CM0csQ0FBcEIsQ0FBdUIsQ0FDckIsTUFBUTJHLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FBMEJ1M0MsT0FBTyxDQUFDcnpDLEtBQUQsQ0FBUTR0QyxTQUFTLENBQUN2MEMsQ0FBRCxDQUFqQixDQUFqQyxDQUF5RHdDLFNBQWhFLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTZtRCxLQUFJLENBQUdwTyxRQUFRLENBQUNxTyxPQUFELENBQW5CLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNBLFFBQVQsQ0FBaUIzaUQsS0FBakIsQ0FBd0IwZixNQUF4QixDQUFnQyxDQUM5QixNQUFRMWYsTUFBSyxFQUFJQSxLQUFLLENBQUNsRSxNQUFmLEVBQXlCNGpCLE1BQXpCLEVBQW1DQSxNQUFNLENBQUM1akIsTUFBM0MsQ0FDSGk0QyxXQUFXLENBQUMvekMsS0FBRCxDQUFRMGYsTUFBUixDQURSLENBRUgxZixLQUZKLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzRpRCxVQUFULENBQW1CNWlELEtBQW5CLENBQTBCMGYsTUFBMUIsQ0FBa0NtZCxRQUFsQyxDQUE0QyxDQUMxQyxNQUFRNzhCLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBZixFQUF5QjRqQixNQUF6QixFQUFtQ0EsTUFBTSxDQUFDNWpCLE1BQTNDLENBQ0hpNEMsV0FBVyxDQUFDL3pDLEtBQUQsQ0FBUTBmLE1BQVIsQ0FBZ0I4ekIsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBM0IsQ0FEUixDQUVINzhCLEtBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNmlELFlBQVQsQ0FBcUI3aUQsS0FBckIsQ0FBNEIwZixNQUE1QixDQUFvQ3ZHLFVBQXBDLENBQWdELENBQzlDLE1BQVFuWixNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWYsRUFBeUI0akIsTUFBekIsRUFBbUNBLE1BQU0sQ0FBQzVqQixNQUEzQyxDQUNIaTRDLFdBQVcsQ0FBQy96QyxLQUFELENBQVEwZixNQUFSLENBQWdCN2pCLFNBQWhCLENBQTJCc2QsVUFBM0IsQ0FEUixDQUVIblosS0FGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSThpRCxPQUFNLENBQUd6SCxRQUFRLENBQUMsU0FBU3I3QyxLQUFULENBQWdCaTBDLE9BQWhCLENBQXlCLENBQzdDLEdBQUluNEMsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0l0QyxNQUFNLENBQUc0eEMsTUFBTSxDQUFDcHJDLEtBQUQsQ0FBUWkwQyxPQUFSLENBRG5CLENBR0FELFVBQVUsQ0FBQ2gwQyxLQUFELENBQVF1OUIsUUFBUSxDQUFDMFcsT0FBRCxDQUFVLFNBQVNqd0MsS0FBVCxDQUFnQixDQUNsRCxNQUFPa21DLFFBQU8sQ0FBQ2xtQyxLQUFELENBQVFsSSxNQUFSLENBQVAsQ0FBeUIsQ0FBQ2tJLEtBQTFCLENBQWtDQSxLQUF6QyxDQUNELENBRnlCLENBQVIsQ0FFZmtWLElBRmUsQ0FFVjgrQixnQkFGVSxDQUFSLENBQVYsQ0FJQSxNQUFPeCtDLE9BQVAsQ0FDRCxDQVRvQixDQUFyQixDQVdBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3FlLE9BQVQsQ0FBZ0I3WCxLQUFoQixDQUF1Qm1FLFNBQXZCLENBQWtDLENBQ2hDLEdBQUkzSyxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUksRUFBRXdHLEtBQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBakIsQ0FBSixDQUE4QixDQUM1QixNQUFPdEMsT0FBUCxDQUNELENBQ0QsR0FBSXdLLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWl3QyxPQUFPLENBQUcsRUFEZCxDQUVJbjRDLE1BQU0sQ0FBR2tFLEtBQUssQ0FBQ2xFLE1BRm5CLENBSUFxSSxTQUFTLENBQUdxdkMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBWSxDQUFaLENBQXZCLENBQ0EsTUFBTyxFQUFFSCxLQUFGLENBQVVsSSxNQUFqQixDQUF5QixDQUN2QixHQUFJa0IsTUFBSyxDQUFHZ0QsS0FBSyxDQUFDZ0UsS0FBRCxDQUFqQixDQUNBLEdBQUlHLFNBQVMsQ0FBQ25ILEtBQUQsQ0FBUWdILEtBQVIsQ0FBZWhFLEtBQWYsQ0FBYixDQUFvQyxDQUNsQ3hHLE1BQU0sQ0FBQ3lOLElBQVAsQ0FBWWpLLEtBQVosRUFDQWkzQyxPQUFPLENBQUNodEMsSUFBUixDQUFhakQsS0FBYixFQUNELENBQ0YsQ0FDRGd3QyxVQUFVLENBQUNoMEMsS0FBRCxDQUFRaTBDLE9BQVIsQ0FBVixDQUNBLE1BQU96NkMsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1VyxRQUFULENBQWlCL1AsS0FBakIsQ0FBd0IsQ0FDdEIsTUFBT0EsTUFBSyxFQUFJLElBQVQsQ0FBZ0JBLEtBQWhCLENBQXdCeWtDLGFBQWEsQ0FBQ3ZoQyxJQUFkLENBQW1CbEQsS0FBbkIsQ0FBL0IsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU1IsTUFBVCxDQUFlUSxLQUFmLENBQXNCc1UsS0FBdEIsQ0FBNkJoSCxHQUE3QixDQUFrQyxDQUNoQyxHQUFJeFIsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsR0FBSSxDQUFDQSxNQUFMLENBQWEsQ0FDWCxNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUl3UixHQUFHLEVBQUksTUFBT0EsSUFBUCxFQUFjLFFBQXJCLEVBQWlDeXNDLGNBQWMsQ0FBQy81QyxLQUFELENBQVFzVSxLQUFSLENBQWVoSCxHQUFmLENBQW5ELENBQXdFLENBQ3RFZ0gsS0FBSyxDQUFHLENBQVIsQ0FDQWhILEdBQUcsQ0FBR3hSLE1BQU4sQ0FDRCxDQUhELElBSUssQ0FDSHdZLEtBQUssQ0FBR0EsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JzNUIsU0FBUyxDQUFDdDVCLEtBQUQsQ0FBckMsQ0FDQWhILEdBQUcsQ0FBR0EsR0FBRyxHQUFLelIsU0FBUixDQUFvQkMsTUFBcEIsQ0FBNkI4eEMsU0FBUyxDQUFDdGdDLEdBQUQsQ0FBNUMsQ0FDRCxDQUNELE1BQU95bkMsVUFBUyxDQUFDLzBDLEtBQUQsQ0FBUXNVLEtBQVIsQ0FBZWhILEdBQWYsQ0FBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeTFDLFlBQVQsQ0FBcUIvaUQsS0FBckIsQ0FBNEJoRCxLQUE1QixDQUFtQyxDQUNqQyxNQUFPaTRDLGdCQUFlLENBQUNqMUMsS0FBRCxDQUFRaEQsS0FBUixDQUF0QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTZ21ELGNBQVQsQ0FBdUJoakQsS0FBdkIsQ0FBOEJoRCxLQUE5QixDQUFxQzYvQixRQUFyQyxDQUErQyxDQUM3QyxNQUFPeVksa0JBQWlCLENBQUN0MUMsS0FBRCxDQUFRaEQsS0FBUixDQUFldzJDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQTFCLENBQXhCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvbUIsY0FBVCxDQUF1QmpqRCxLQUF2QixDQUE4QmhELEtBQTlCLENBQXFDLENBQ25DLEdBQUlsQixPQUFNLENBQUdrRSxLQUFLLEVBQUksSUFBVCxDQUFnQixDQUFoQixDQUFvQkEsS0FBSyxDQUFDbEUsTUFBdkMsQ0FDQSxHQUFJQSxNQUFKLENBQVksQ0FDVixHQUFJa0ksTUFBSyxDQUFHaXhDLGVBQWUsQ0FBQ2oxQyxLQUFELENBQVFoRCxLQUFSLENBQTNCLENBQ0EsR0FBSWdILEtBQUssQ0FBR2xJLE1BQVIsRUFBa0I0dUMsRUFBRSxDQUFDMXFDLEtBQUssQ0FBQ2dFLEtBQUQsQ0FBTixDQUFlaEgsS0FBZixDQUF4QixDQUErQyxDQUM3QyxNQUFPZ0gsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLENBQUMsQ0FBUixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2svQyxnQkFBVCxDQUF5QmxqRCxLQUF6QixDQUFnQ2hELEtBQWhDLENBQXVDLENBQ3JDLE1BQU9pNEMsZ0JBQWUsQ0FBQ2oxQyxLQUFELENBQVFoRCxLQUFSLENBQWUsSUFBZixDQUF0QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbW1ELGtCQUFULENBQTJCbmpELEtBQTNCLENBQWtDaEQsS0FBbEMsQ0FBeUM2L0IsUUFBekMsQ0FBbUQsQ0FDakQsTUFBT3lZLGtCQUFpQixDQUFDdDFDLEtBQUQsQ0FBUWhELEtBQVIsQ0FBZXcyQyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUExQixDQUF5QyxJQUF6QyxDQUF4QixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdW1CLGtCQUFULENBQTJCcGpELEtBQTNCLENBQWtDaEQsS0FBbEMsQ0FBeUMsQ0FDdkMsR0FBSWxCLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUlBLE1BQUosQ0FBWSxDQUNWLEdBQUlrSSxNQUFLLENBQUdpeEMsZUFBZSxDQUFDajFDLEtBQUQsQ0FBUWhELEtBQVIsQ0FBZSxJQUFmLENBQWYsQ0FBc0MsQ0FBbEQsQ0FDQSxHQUFJMHRDLEVBQUUsQ0FBQzFxQyxLQUFLLENBQUNnRSxLQUFELENBQU4sQ0FBZWhILEtBQWYsQ0FBTixDQUE2QixDQUMzQixNQUFPZ0gsTUFBUCxDQUNELENBQ0YsQ0FDRCxNQUFPLENBQUMsQ0FBUixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3EvQyxXQUFULENBQW9CcmpELEtBQXBCLENBQTJCLENBQ3pCLE1BQVFBLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSGs2QyxjQUFjLENBQUNoMkMsS0FBRCxDQURYLENBRUgsRUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTc2pELGFBQVQsQ0FBc0J0akQsS0FBdEIsQ0FBNkI2OEIsUUFBN0IsQ0FBdUMsQ0FDckMsTUFBUTc4QixNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQ0hrNkMsY0FBYyxDQUFDaDJDLEtBQUQsQ0FBUXd6QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFuQixDQURYLENBRUgsRUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMzYixLQUFULENBQWNsaEIsS0FBZCxDQUFxQixDQUNuQixHQUFJbEUsT0FBTSxDQUFHa0UsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQ2xFLE1BQXZDLENBQ0EsTUFBT0EsT0FBTSxDQUFHaTVDLFNBQVMsQ0FBQy8wQyxLQUFELENBQVEsQ0FBUixDQUFXbEUsTUFBWCxDQUFaLENBQWlDLEVBQTlDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNtekIsS0FBVCxDQUFjanZCLEtBQWQsQ0FBcUIzRyxDQUFyQixDQUF3QnlnRCxLQUF4QixDQUErQixDQUM3QixHQUFJLEVBQUU5NUMsS0FBSyxFQUFJQSxLQUFLLENBQUNsRSxNQUFqQixDQUFKLENBQThCLENBQzVCLE1BQU8sRUFBUCxDQUNELENBQ0R6QyxDQUFDLENBQUl5Z0QsS0FBSyxFQUFJemdELENBQUMsR0FBS3dDLFNBQWhCLENBQTZCLENBQTdCLENBQWlDK3hDLFNBQVMsQ0FBQ3YwQyxDQUFELENBQTlDLENBQ0EsTUFBTzA3QyxVQUFTLENBQUMvMEMsS0FBRCxDQUFRLENBQVIsQ0FBVzNHLENBQUMsQ0FBRyxDQUFKLENBQVEsQ0FBUixDQUFZQSxDQUF2QixDQUFoQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa3FELFVBQVQsQ0FBbUJ2akQsS0FBbkIsQ0FBMEIzRyxDQUExQixDQUE2QnlnRCxLQUE3QixDQUFvQyxDQUNsQyxHQUFJaCtDLE9BQU0sQ0FBR2tFLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CQSxLQUFLLENBQUNsRSxNQUF2QyxDQUNBLEdBQUksQ0FBQ0EsTUFBTCxDQUFhLENBQ1gsTUFBTyxFQUFQLENBQ0QsQ0FDRHpDLENBQUMsQ0FBSXlnRCxLQUFLLEVBQUl6Z0QsQ0FBQyxHQUFLd0MsU0FBaEIsQ0FBNkIsQ0FBN0IsQ0FBaUMreEMsU0FBUyxDQUFDdjBDLENBQUQsQ0FBOUMsQ0FDQUEsQ0FBQyxDQUFHeUMsTUFBTSxDQUFHekMsQ0FBYixDQUNBLE1BQU8wN0MsVUFBUyxDQUFDLzBDLEtBQUQsQ0FBUTNHLENBQUMsQ0FBRyxDQUFKLENBQVEsQ0FBUixDQUFZQSxDQUFwQixDQUF1QnlDLE1BQXZCLENBQWhCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBuRCxlQUFULENBQXdCeGpELEtBQXhCLENBQStCbUUsU0FBL0IsQ0FBMEMsQ0FDeEMsTUFBUW5FLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSHk2QyxTQUFTLENBQUN2MkMsS0FBRCxDQUFRd3pDLFdBQVcsQ0FBQ3J2QyxTQUFELENBQVksQ0FBWixDQUFuQixDQUFtQyxLQUFuQyxDQUEwQyxJQUExQyxDQUROLENBRUgsRUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnckIsVUFBVCxDQUFtQm52QixLQUFuQixDQUEwQm1FLFNBQTFCLENBQXFDLENBQ25DLE1BQVFuRSxNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQ0h5NkMsU0FBUyxDQUFDdjJDLEtBQUQsQ0FBUXd6QyxXQUFXLENBQUNydkMsU0FBRCxDQUFZLENBQVosQ0FBbkIsQ0FETixDQUVILEVBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXNsQixNQUFLLENBQUc2cUIsUUFBUSxDQUFDLFNBQVNuRixNQUFULENBQWlCLENBQ3BDLE1BQU9nSCxTQUFRLENBQUNwSSxXQUFXLENBQUNvQixNQUFELENBQVMsQ0FBVCxDQUFZOEQsaUJBQVosQ0FBK0IsSUFBL0IsQ0FBWixDQUFmLENBQ0QsQ0FGbUIsQ0FBcEIsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXdRLFFBQU8sQ0FBR25QLFFBQVEsQ0FBQyxTQUFTbkYsTUFBVCxDQUFpQixDQUN0QyxHQUFJdFMsU0FBUSxDQUFHN2lDLElBQUksQ0FBQ20xQyxNQUFELENBQW5CLENBQ0EsR0FBSThELGlCQUFpQixDQUFDcFcsUUFBRCxDQUFyQixDQUFpQyxDQUMvQkEsUUFBUSxDQUFHaGhDLFNBQVgsQ0FDRCxDQUNELE1BQU9zNkMsU0FBUSxDQUFDcEksV0FBVyxDQUFDb0IsTUFBRCxDQUFTLENBQVQsQ0FBWThELGlCQUFaLENBQStCLElBQS9CLENBQVosQ0FBa0RPLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQTdELENBQWYsQ0FDRCxDQU5xQixDQUF0QixDQVFBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk2bUIsVUFBUyxDQUFHcFAsUUFBUSxDQUFDLFNBQVNuRixNQUFULENBQWlCLENBQ3hDLEdBQUloMkIsV0FBVSxDQUFHbmYsSUFBSSxDQUFDbTFDLE1BQUQsQ0FBckIsQ0FDQWgyQixVQUFVLENBQUcsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0N0ZCxTQUE1RCxDQUNBLE1BQU9zNkMsU0FBUSxDQUFDcEksV0FBVyxDQUFDb0IsTUFBRCxDQUFTLENBQVQsQ0FBWThELGlCQUFaLENBQStCLElBQS9CLENBQVosQ0FBa0RwM0MsU0FBbEQsQ0FBNkRzZCxVQUE3RCxDQUFmLENBQ0QsQ0FKdUIsQ0FBeEIsQ0FNQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTd3FDLEtBQVQsQ0FBYzNqRCxLQUFkLENBQXFCLENBQ25CLE1BQVFBLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FBMEJxNkMsUUFBUSxDQUFDbjJDLEtBQUQsQ0FBbEMsQ0FBNEMsRUFBbkQsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNGpELE9BQVQsQ0FBZ0I1akQsS0FBaEIsQ0FBdUI2OEIsUUFBdkIsQ0FBaUMsQ0FDL0IsTUFBUTc4QixNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQTBCcTZDLFFBQVEsQ0FBQ24yQyxLQUFELENBQVF3ekMsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBbkIsQ0FBbEMsQ0FBc0UsRUFBN0UsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTZ25CLFNBQVQsQ0FBa0I3akQsS0FBbEIsQ0FBeUJtWixVQUF6QixDQUFxQyxDQUNuQ0EsVUFBVSxDQUFHLE1BQU9BLFdBQVAsRUFBcUIsVUFBckIsQ0FBa0NBLFVBQWxDLENBQStDdGQsU0FBNUQsQ0FDQSxNQUFRbUUsTUFBSyxFQUFJQSxLQUFLLENBQUNsRSxNQUFoQixDQUEwQnE2QyxRQUFRLENBQUNuMkMsS0FBRCxDQUFRbkUsU0FBUixDQUFtQnNkLFVBQW5CLENBQWxDLENBQW1FLEVBQTFFLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMycUMsTUFBVCxDQUFlOWpELEtBQWYsQ0FBc0IsQ0FDcEIsR0FBSSxFQUFFQSxLQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWpCLENBQUosQ0FBOEIsQ0FDNUIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJQSxPQUFNLENBQUcsQ0FBYixDQUNBa0UsS0FBSyxDQUFHazlCLFdBQVcsQ0FBQ2w5QixLQUFELENBQVEsU0FBUytqRCxLQUFULENBQWdCLENBQ3pDLEdBQUk5USxpQkFBaUIsQ0FBQzhRLEtBQUQsQ0FBckIsQ0FBOEIsQ0FDNUJqb0QsTUFBTSxDQUFHcW9DLFNBQVMsQ0FBQzRmLEtBQUssQ0FBQ2pvRCxNQUFQLENBQWVBLE1BQWYsQ0FBbEIsQ0FDQSxNQUFPLEtBQVAsQ0FDRCxDQUNGLENBTGtCLENBQW5CLENBTUEsTUFBT21qQyxVQUFTLENBQUNuakMsTUFBRCxDQUFTLFNBQVNrSSxLQUFULENBQWdCLENBQ3ZDLE1BQU91NUIsU0FBUSxDQUFDdjlCLEtBQUQsQ0FBUTg5QixZQUFZLENBQUM5NUIsS0FBRCxDQUFwQixDQUFmLENBQ0QsQ0FGZSxDQUFoQixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dnRCxVQUFULENBQW1CaGtELEtBQW5CLENBQTBCNjhCLFFBQTFCLENBQW9DLENBQ2xDLEdBQUksRUFBRTc4QixLQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWpCLENBQUosQ0FBOEIsQ0FDNUIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJdEMsT0FBTSxDQUFHc3FELEtBQUssQ0FBQzlqRCxLQUFELENBQWxCLENBQ0EsR0FBSTY4QixRQUFRLEVBQUksSUFBaEIsQ0FBc0IsQ0FDcEIsTUFBT3JqQyxPQUFQLENBQ0QsQ0FDRCxNQUFPK2pDLFNBQVEsQ0FBQy9qQyxNQUFELENBQVMsU0FBU3VxRCxLQUFULENBQWdCLENBQ3RDLE1BQU9yaUQsTUFBSyxDQUFDbTdCLFFBQUQsQ0FBV2hoQyxTQUFYLENBQXNCa29ELEtBQXRCLENBQVosQ0FDRCxDQUZjLENBQWYsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJRSxRQUFPLENBQUczUCxRQUFRLENBQUMsU0FBU3QwQyxLQUFULENBQWdCMGYsTUFBaEIsQ0FBd0IsQ0FDN0MsTUFBT3V6QixrQkFBaUIsQ0FBQ2p6QyxLQUFELENBQWpCLENBQ0hndEMsY0FBYyxDQUFDaHRDLEtBQUQsQ0FBUTBmLE1BQVIsQ0FEWCxDQUVILEVBRkosQ0FHRCxDQUpxQixDQUF0QixDQU1BO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl3a0MsSUFBRyxDQUFHNVAsUUFBUSxDQUFDLFNBQVNuRixNQUFULENBQWlCLENBQ2xDLE1BQU91SCxRQUFPLENBQUN4WixXQUFXLENBQUNpUyxNQUFELENBQVM4RCxpQkFBVCxDQUFaLENBQWQsQ0FDRCxDQUZpQixDQUFsQixDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJa1IsTUFBSyxDQUFHN1AsUUFBUSxDQUFDLFNBQVNuRixNQUFULENBQWlCLENBQ3BDLEdBQUl0UyxTQUFRLENBQUc3aUMsSUFBSSxDQUFDbTFDLE1BQUQsQ0FBbkIsQ0FDQSxHQUFJOEQsaUJBQWlCLENBQUNwVyxRQUFELENBQXJCLENBQWlDLENBQy9CQSxRQUFRLENBQUdoaEMsU0FBWCxDQUNELENBQ0QsTUFBTzY2QyxRQUFPLENBQUN4WixXQUFXLENBQUNpUyxNQUFELENBQVM4RCxpQkFBVCxDQUFaLENBQXlDTyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFwRCxDQUFkLENBQ0QsQ0FObUIsQ0FBcEIsQ0FRQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJdW5CLFFBQU8sQ0FBRzlQLFFBQVEsQ0FBQyxTQUFTbkYsTUFBVCxDQUFpQixDQUN0QyxHQUFJaDJCLFdBQVUsQ0FBR25mLElBQUksQ0FBQ20xQyxNQUFELENBQXJCLENBQ0FoMkIsVUFBVSxDQUFHLE1BQU9BLFdBQVAsRUFBcUIsVUFBckIsQ0FBa0NBLFVBQWxDLENBQStDdGQsU0FBNUQsQ0FDQSxNQUFPNjZDLFFBQU8sQ0FBQ3haLFdBQVcsQ0FBQ2lTLE1BQUQsQ0FBUzhELGlCQUFULENBQVosQ0FBeUNwM0MsU0FBekMsQ0FBb0RzZCxVQUFwRCxDQUFkLENBQ0QsQ0FKcUIsQ0FBdEIsQ0FNQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlrWCxJQUFHLENBQUdpa0IsUUFBUSxDQUFDd1AsS0FBRCxDQUFsQixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU08sVUFBVCxDQUFtQmxsQixLQUFuQixDQUEwQnpmLE1BQTFCLENBQWtDLENBQ2hDLE1BQU9pM0IsY0FBYSxDQUFDeFgsS0FBSyxFQUFJLEVBQVYsQ0FBY3pmLE1BQU0sRUFBSSxFQUF4QixDQUE0QmtyQixXQUE1QixDQUFwQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBaLGNBQVQsQ0FBdUJubEIsS0FBdkIsQ0FBOEJ6ZixNQUE5QixDQUFzQyxDQUNwQyxNQUFPaTNCLGNBQWEsQ0FBQ3hYLEtBQUssRUFBSSxFQUFWLENBQWN6ZixNQUFNLEVBQUksRUFBeEIsQ0FBNEJtMEIsT0FBNUIsQ0FBcEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJdGpCLFFBQU8sQ0FBRytqQixRQUFRLENBQUMsU0FBU25GLE1BQVQsQ0FBaUIsQ0FDdEMsR0FBSXJ6QyxPQUFNLENBQUdxekMsTUFBTSxDQUFDcnpDLE1BQXBCLENBQ0krZ0MsUUFBUSxDQUFHL2dDLE1BQU0sQ0FBRyxDQUFULENBQWFxekMsTUFBTSxDQUFDcnpDLE1BQU0sQ0FBRyxDQUFWLENBQW5CLENBQWtDRCxTQURqRCxDQUdBZ2hDLFFBQVEsQ0FBRyxNQUFPQSxTQUFQLEVBQW1CLFVBQW5CLEVBQWlDc1MsTUFBTSxDQUFDbHBDLEdBQVAsR0FBYzQyQixRQUEvQyxFQUEyRGhoQyxTQUF0RSxDQUNBLE1BQU9tb0QsVUFBUyxDQUFDN1UsTUFBRCxDQUFTdFMsUUFBVCxDQUFoQixDQUNELENBTnFCLENBQXRCLENBUUEsNEVBMXBPaUQsQ0E0cE9qRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2xnQyxNQUFULENBQWVLLEtBQWYsQ0FBc0IsQ0FDcEIsR0FBSXhELE9BQU0sQ0FBRytyQyxNQUFNLENBQUN2b0MsS0FBRCxDQUFuQixDQUNBeEQsTUFBTSxDQUFDMnNDLFNBQVAsQ0FBbUIsSUFBbkIsQ0FDQSxNQUFPM3NDLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK3FELElBQVQsQ0FBYXZuRCxLQUFiLENBQW9Cd25ELFdBQXBCLENBQWlDLENBQy9CQSxXQUFXLENBQUN4bkQsS0FBRCxDQUFYLENBQ0EsTUFBT0EsTUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3K0MsS0FBVCxDQUFjeCtDLEtBQWQsQ0FBcUJ3bkQsV0FBckIsQ0FBa0MsQ0FDaEMsTUFBT0EsWUFBVyxDQUFDeG5ELEtBQUQsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXluRCxVQUFTLENBQUdwSixRQUFRLENBQUMsU0FBU2hRLEtBQVQsQ0FBZ0IsQ0FDdkMsR0FBSXZ2QyxPQUFNLENBQUd1dkMsS0FBSyxDQUFDdnZDLE1BQW5CLENBQ0l3WSxLQUFLLENBQUd4WSxNQUFNLENBQUd1dkMsS0FBSyxDQUFDLENBQUQsQ0FBUixDQUFjLENBRGhDLENBRUlydUMsS0FBSyxDQUFHLEtBQUtpcEMsV0FGakIsQ0FHSXVlLFdBQVcsQ0FBRyxTQUFTNWtELE1BQVQsQ0FBaUIsQ0FBRSxNQUFPd3JDLE9BQU0sQ0FBQ3hyQyxNQUFELENBQVN5ckMsS0FBVCxDQUFiLENBQStCLENBSHBFLENBS0EsR0FBSXZ2QyxNQUFNLENBQUcsQ0FBVCxFQUFjLEtBQUtvcUMsV0FBTCxDQUFpQnBxQyxNQUEvQixFQUNBLEVBQUVrQixLQUFLLFdBQVl5b0MsWUFBbkIsQ0FEQSxFQUNtQyxDQUFDeUUsT0FBTyxDQUFDNTFCLEtBQUQsQ0FEL0MsQ0FDd0QsQ0FDdEQsTUFBTyxNQUFLa25DLElBQUwsQ0FBVWdKLFdBQVYsQ0FBUCxDQUNELENBQ0R4bkQsS0FBSyxDQUFHQSxLQUFLLENBQUN3QyxLQUFOLENBQVk4VSxLQUFaLENBQW1CLENBQUNBLEtBQUQsRUFBVXhZLE1BQU0sQ0FBRyxDQUFILENBQU8sQ0FBdkIsQ0FBbkIsQ0FBUixDQUNBa0IsS0FBSyxDQUFDa3BDLFdBQU4sQ0FBa0JqL0IsSUFBbEIsQ0FBdUIsQ0FDckIsT0FBUXUwQyxJQURhLENBRXJCLE9BQVEsQ0FBQ2dKLFdBQUQsQ0FGYSxDQUdyQixVQUFXM29ELFNBSFUsQ0FBdkIsRUFLQSxNQUFPLElBQUk2cEMsY0FBSixDQUFrQjFvQyxLQUFsQixDQUF5QixLQUFLbXBDLFNBQTlCLEVBQXlDcVYsSUFBekMsQ0FBOEMsU0FBU3g3QyxLQUFULENBQWdCLENBQ25FLEdBQUlsRSxNQUFNLEVBQUksQ0FBQ2tFLEtBQUssQ0FBQ2xFLE1BQXJCLENBQTZCLENBQzNCa0UsS0FBSyxDQUFDaUgsSUFBTixDQUFXcEwsU0FBWCxFQUNELENBQ0QsTUFBT21FLE1BQVAsQ0FDRCxDQUxNLENBQVAsQ0FNRCxDQXRCdUIsQ0FBeEIsQ0F3QkE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBrRCxhQUFULEVBQXdCLENBQ3RCLE1BQU8vbkQsTUFBSyxDQUFDLElBQUQsQ0FBWixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnb0QsY0FBVCxFQUF5QixDQUN2QixNQUFPLElBQUlqZixjQUFKLENBQWtCLEtBQUsxb0MsS0FBTCxFQUFsQixDQUFnQyxLQUFLbXBDLFNBQXJDLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3llLFlBQVQsRUFBdUIsQ0FDckIsR0FBSSxLQUFLdmUsVUFBTCxHQUFvQnhxQyxTQUF4QixDQUFtQyxDQUNqQyxLQUFLd3FDLFVBQUwsQ0FBa0JocUMsT0FBTyxDQUFDLEtBQUtXLEtBQUwsRUFBRCxDQUF6QixDQUNELENBQ0QsR0FBSTZSLEtBQUksQ0FBRyxLQUFLdTNCLFNBQUwsRUFBa0IsS0FBS0MsVUFBTCxDQUFnQnZxQyxNQUE3QyxDQUNJa0IsS0FBSyxDQUFHNlIsSUFBSSxDQUFHaFQsU0FBSCxDQUFlLEtBQUt3cUMsVUFBTCxDQUFnQixLQUFLRCxTQUFMLEVBQWhCLENBRC9CLENBR0EsTUFBTyxDQUFFLE9BQVF2M0IsSUFBVixDQUFnQixRQUFTN1IsS0FBekIsQ0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZuRCxrQkFBVCxFQUE2QixDQUMzQixNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLGFBQVQsQ0FBc0I5bkQsS0FBdEIsQ0FBNkIsQ0FDM0IsR0FBSXhELE9BQUosQ0FDSWQsTUFBTSxDQUFHLElBRGIsQ0FHQSxNQUFPQSxNQUFNLFdBQVlxdEMsV0FBekIsQ0FBcUMsQ0FDbkMsR0FBSWdCLE1BQUssQ0FBR3BCLFlBQVksQ0FBQ2p0QyxNQUFELENBQXhCLENBQ0FxdUMsS0FBSyxDQUFDWCxTQUFOLENBQWtCLENBQWxCLENBQ0FXLEtBQUssQ0FBQ1YsVUFBTixDQUFtQnhxQyxTQUFuQixDQUNBLEdBQUlyQyxNQUFKLENBQVksQ0FDVjA2QyxRQUFRLENBQUNqTyxXQUFULENBQXVCYyxLQUF2QixDQUNELENBRkQsSUFFTyxDQUNMdnRDLE1BQU0sQ0FBR3V0QyxLQUFULENBQ0QsQ0FDRCxHQUFJbU4sU0FBUSxDQUFHbk4sS0FBZixDQUNBcnVDLE1BQU0sQ0FBR0EsTUFBTSxDQUFDdXRDLFdBQWhCLENBQ0QsQ0FDRGlPLFFBQVEsQ0FBQ2pPLFdBQVQsQ0FBdUJqcEMsS0FBdkIsQ0FDQSxNQUFPeEQsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1ckQsZUFBVCxFQUEwQixDQUN4QixHQUFJL25ELE1BQUssQ0FBRyxLQUFLaXBDLFdBQWpCLENBQ0EsR0FBSWpwQyxLQUFLLFdBQVl5b0MsWUFBckIsQ0FBa0MsQ0FDaEMsR0FBSXVmLFFBQU8sQ0FBR2hvRCxLQUFkLENBQ0EsR0FBSSxLQUFLa3BDLFdBQUwsQ0FBaUJwcUMsTUFBckIsQ0FBNkIsQ0FDM0JrcEQsT0FBTyxDQUFHLEdBQUl2ZixZQUFKLENBQWdCLElBQWhCLENBQVYsQ0FDRCxDQUNEdWYsT0FBTyxDQUFHQSxPQUFPLENBQUNqMUMsT0FBUixFQUFWLENBQ0FpMUMsT0FBTyxDQUFDOWUsV0FBUixDQUFvQmovQixJQUFwQixDQUF5QixDQUN2QixPQUFRdTBDLElBRGUsQ0FFdkIsT0FBUSxDQUFDenJDLE9BQUQsQ0FGZSxDQUd2QixVQUFXbFUsU0FIWSxDQUF6QixFQUtBLE1BQU8sSUFBSTZwQyxjQUFKLENBQWtCc2YsT0FBbEIsQ0FBMkIsS0FBSzdlLFNBQWhDLENBQVAsQ0FDRCxDQUNELE1BQU8sTUFBS3FWLElBQUwsQ0FBVXpyQyxPQUFWLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTazFDLGFBQVQsRUFBd0IsQ0FDdEIsTUFBT3hkLGlCQUFnQixDQUFDLEtBQUt4QixXQUFOLENBQW1CLEtBQUtDLFdBQXhCLENBQXZCLENBQ0QsQ0FFRCw0RUFyL09pRCxDQXUvT2pEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWhaLFFBQU8sQ0FBR3VzQixnQkFBZ0IsQ0FBQyxTQUFTamdELE1BQVQsQ0FBaUJ3RCxLQUFqQixDQUF3Qm9ILEdBQXhCLENBQTZCLENBQzFELEdBQUl0QixjQUFjLENBQUNJLElBQWYsQ0FBb0IxSixNQUFwQixDQUE0QjRLLEdBQTVCLENBQUosQ0FBc0MsQ0FDcEMsRUFBRTVLLE1BQU0sQ0FBQzRLLEdBQUQsQ0FBUixDQUNELENBRkQsSUFFTyxDQUNMdW1DLGVBQWUsQ0FBQ254QyxNQUFELENBQVM0SyxHQUFULENBQWMsQ0FBZCxDQUFmLENBQ0QsQ0FDRixDQU42QixDQUE5QixDQVFBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaVAsTUFBVCxDQUFlNU4sVUFBZixDQUEyQnRCLFNBQTNCLENBQXNDMjFDLEtBQXRDLENBQTZDLENBQzNDLEdBQUlyZCxLQUFJLENBQUd0NUIsT0FBTyxDQUFDc0MsVUFBRCxDQUFQLENBQXNCdzNCLFVBQXRCLENBQW1DdVEsU0FBOUMsQ0FDQSxHQUFJc00sS0FBSyxFQUFJQyxjQUFjLENBQUN0MEMsVUFBRCxDQUFhdEIsU0FBYixDQUF3QjIxQyxLQUF4QixDQUEzQixDQUEyRCxDQUN6RDMxQyxTQUFTLENBQUd0SSxTQUFaLENBQ0QsQ0FDRCxNQUFPNGdDLEtBQUksQ0FBQ2gzQixVQUFELENBQWErdEMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBWSxDQUFaLENBQXhCLENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa0UsT0FBVCxDQUFnQjVDLFVBQWhCLENBQTRCdEIsU0FBNUIsQ0FBdUMsQ0FDckMsR0FBSXM0QixLQUFJLENBQUd0NUIsT0FBTyxDQUFDc0MsVUFBRCxDQUFQLENBQXNCeTNCLFdBQXRCLENBQW9DNFEsVUFBL0MsQ0FDQSxNQUFPclIsS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYSt0QyxXQUFXLENBQUNydkMsU0FBRCxDQUFZLENBQVosQ0FBeEIsQ0FBWCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWtvQixLQUFJLENBQUc2dUIsVUFBVSxDQUFDdHJCLFNBQUQsQ0FBckIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlwQyxTQUFRLENBQUcwdEIsVUFBVSxDQUFDbHJCLGFBQUQsQ0FBekIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbnpCLFFBQVQsQ0FBaUI0SSxVQUFqQixDQUE2Qm8zQixRQUE3QixDQUF1QyxDQUNyQyxNQUFPa1IsWUFBVyxDQUFDenhDLEdBQUcsQ0FBQ21KLFVBQUQsQ0FBYW8zQixRQUFiLENBQUosQ0FBNEIsQ0FBNUIsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTcW9CLFlBQVQsQ0FBcUJ6L0MsVUFBckIsQ0FBaUNvM0IsUUFBakMsQ0FBMkMsQ0FDekMsTUFBT2tSLFlBQVcsQ0FBQ3p4QyxHQUFHLENBQUNtSixVQUFELENBQWFvM0IsUUFBYixDQUFKLENBQTRCakssUUFBNUIsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1eUIsYUFBVCxDQUFzQjEvQyxVQUF0QixDQUFrQ28zQixRQUFsQyxDQUE0Q2pXLEtBQTVDLENBQW1ELENBQ2pEQSxLQUFLLENBQUdBLEtBQUssR0FBSy9xQixTQUFWLENBQXNCLENBQXRCLENBQTBCK3hDLFNBQVMsQ0FBQ2huQixLQUFELENBQTNDLENBQ0EsTUFBT21uQixZQUFXLENBQUN6eEMsR0FBRyxDQUFDbUosVUFBRCxDQUFhbzNCLFFBQWIsQ0FBSixDQUE0QmpXLEtBQTVCLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbnJCLFFBQVQsQ0FBaUJnSyxVQUFqQixDQUE2Qm8zQixRQUE3QixDQUF1QyxDQUNyQyxHQUFJSixLQUFJLENBQUd0NUIsT0FBTyxDQUFDc0MsVUFBRCxDQUFQLENBQXNCczNCLFNBQXRCLENBQWtDZ08sUUFBN0MsQ0FDQSxNQUFPdE8sS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYSt0QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUF4QixDQUFYLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3VvQixhQUFULENBQXNCMy9DLFVBQXRCLENBQWtDbzNCLFFBQWxDLENBQTRDLENBQzFDLEdBQUlKLEtBQUksQ0FBR3Q1QixPQUFPLENBQUNzQyxVQUFELENBQVAsQ0FBc0J1M0IsY0FBdEIsQ0FBdUNzUSxhQUFsRCxDQUNBLE1BQU83USxLQUFJLENBQUNoM0IsVUFBRCxDQUFhK3RDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQXhCLENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJN08sUUFBTyxDQUFHeXJCLGdCQUFnQixDQUFDLFNBQVNqZ0QsTUFBVCxDQUFpQndELEtBQWpCLENBQXdCb0gsR0FBeEIsQ0FBNkIsQ0FDMUQsR0FBSXRCLGNBQWMsQ0FBQ0ksSUFBZixDQUFvQjFKLE1BQXBCLENBQTRCNEssR0FBNUIsQ0FBSixDQUFzQyxDQUNwQzVLLE1BQU0sQ0FBQzRLLEdBQUQsQ0FBTixDQUFZNkMsSUFBWixDQUFpQmpLLEtBQWpCLEVBQ0QsQ0FGRCxJQUVPLENBQ0wydEMsZUFBZSxDQUFDbnhDLE1BQUQsQ0FBUzRLLEdBQVQsQ0FBYyxDQUFDcEgsS0FBRCxDQUFkLENBQWYsQ0FDRCxDQUNGLENBTjZCLENBQTlCLENBUUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzhXLFNBQVQsQ0FBa0JyTyxVQUFsQixDQUE4QnpJLEtBQTlCLENBQXFDcWhDLFNBQXJDLENBQWdEeWIsS0FBaEQsQ0FBdUQsQ0FDckRyMEMsVUFBVSxDQUFHNEosV0FBVyxDQUFDNUosVUFBRCxDQUFYLENBQTBCQSxVQUExQixDQUF1Q2lhLE1BQU0sQ0FBQ2phLFVBQUQsQ0FBMUQsQ0FDQTQ0QixTQUFTLENBQUlBLFNBQVMsRUFBSSxDQUFDeWIsS0FBZixDQUF3QmxNLFNBQVMsQ0FBQ3ZQLFNBQUQsQ0FBakMsQ0FBK0MsQ0FBM0QsQ0FFQSxHQUFJdmlDLE9BQU0sQ0FBRzJKLFVBQVUsQ0FBQzNKLE1BQXhCLENBQ0EsR0FBSXVpQyxTQUFTLENBQUcsQ0FBaEIsQ0FBbUIsQ0FDakJBLFNBQVMsQ0FBRzhGLFNBQVMsQ0FBQ3JvQyxNQUFNLENBQUd1aUMsU0FBVixDQUFxQixDQUFyQixDQUFyQixDQUNELENBQ0QsTUFBT2duQixTQUFRLENBQUM1L0MsVUFBRCxDQUFSLENBQ0Y0NEIsU0FBUyxFQUFJdmlDLE1BQWIsRUFBdUIySixVQUFVLENBQUMvQixPQUFYLENBQW1CMUcsS0FBbkIsQ0FBMEJxaEMsU0FBMUIsRUFBdUMsQ0FBQyxDQUQ3RCxDQUVGLENBQUMsQ0FBQ3ZpQyxNQUFGLEVBQVl1aEMsV0FBVyxDQUFDNTNCLFVBQUQsQ0FBYXpJLEtBQWIsQ0FBb0JxaEMsU0FBcEIsQ0FBWCxDQUE0QyxDQUFDLENBRjlELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWluQixVQUFTLENBQUdoUixRQUFRLENBQUMsU0FBUzd1QyxVQUFULENBQXFCcUQsSUFBckIsQ0FBMkJoRSxJQUEzQixDQUFpQyxDQUN4RCxHQUFJZCxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0lpb0MsTUFBTSxDQUFHLE1BQU9uakMsS0FBUCxFQUFlLFVBRDVCLENBRUl0UCxNQUFNLENBQUc2VixXQUFXLENBQUM1SixVQUFELENBQVgsQ0FBMEIvTCxLQUFLLENBQUMrTCxVQUFVLENBQUMzSixNQUFaLENBQS9CLENBQXFELEVBRmxFLENBSUFpdkMsUUFBUSxDQUFDdGxDLFVBQUQsQ0FBYSxTQUFTekksS0FBVCxDQUFnQixDQUNuQ3hELE1BQU0sQ0FBQyxFQUFFd0ssS0FBSCxDQUFOLENBQWtCaW9DLE1BQU0sQ0FBR3ZxQyxLQUFLLENBQUNvSCxJQUFELENBQU85TCxLQUFQLENBQWM4SCxJQUFkLENBQVIsQ0FBOEI0cUMsVUFBVSxDQUFDMXlDLEtBQUQsQ0FBUThMLElBQVIsQ0FBY2hFLElBQWQsQ0FBaEUsQ0FDRCxDQUZPLENBQVIsQ0FHQSxNQUFPdEwsT0FBUCxDQUNELENBVHVCLENBQXhCLENBV0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJK3JELE1BQUssQ0FBRzlMLGdCQUFnQixDQUFDLFNBQVNqZ0QsTUFBVCxDQUFpQndELEtBQWpCLENBQXdCb0gsR0FBeEIsQ0FBNkIsQ0FDeER1bUMsZUFBZSxDQUFDbnhDLE1BQUQsQ0FBUzRLLEdBQVQsQ0FBY3BILEtBQWQsQ0FBZixDQUNELENBRjJCLENBQTVCLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU1YsSUFBVCxDQUFhbUosVUFBYixDQUF5Qm8zQixRQUF6QixDQUFtQyxDQUNqQyxHQUFJSixLQUFJLENBQUd0NUIsT0FBTyxDQUFDc0MsVUFBRCxDQUFQLENBQXNCODNCLFFBQXRCLENBQWlDK1UsT0FBNUMsQ0FDQSxNQUFPN1YsS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYSt0QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUF4QixDQUFYLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJvQixRQUFULENBQWlCLy9DLFVBQWpCLENBQTZCNmhDLFNBQTdCLENBQXdDaU0sTUFBeEMsQ0FBZ0R1RyxLQUFoRCxDQUF1RCxDQUNyRCxHQUFJcjBDLFVBQVUsRUFBSSxJQUFsQixDQUF3QixDQUN0QixNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUksQ0FBQ3RDLE9BQU8sQ0FBQ21rQyxTQUFELENBQVosQ0FBeUIsQ0FDdkJBLFNBQVMsQ0FBR0EsU0FBUyxFQUFJLElBQWIsQ0FBb0IsRUFBcEIsQ0FBeUIsQ0FBQ0EsU0FBRCxDQUFyQyxDQUNELENBQ0RpTSxNQUFNLENBQUd1RyxLQUFLLENBQUdqK0MsU0FBSCxDQUFlMDNDLE1BQTdCLENBQ0EsR0FBSSxDQUFDcHdDLE9BQU8sQ0FBQ293QyxNQUFELENBQVosQ0FBc0IsQ0FDcEJBLE1BQU0sQ0FBR0EsTUFBTSxFQUFJLElBQVYsQ0FBaUIsRUFBakIsQ0FBc0IsQ0FBQ0EsTUFBRCxDQUEvQixDQUNELENBQ0QsTUFBT0QsWUFBVyxDQUFDN3RDLFVBQUQsQ0FBYTZoQyxTQUFiLENBQXdCaU0sTUFBeEIsQ0FBbEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlrUyxVQUFTLENBQUdoTSxnQkFBZ0IsQ0FBQyxTQUFTamdELE1BQVQsQ0FBaUJ3RCxLQUFqQixDQUF3Qm9ILEdBQXhCLENBQTZCLENBQzVENUssTUFBTSxDQUFDNEssR0FBRyxDQUFHLENBQUgsQ0FBTyxDQUFYLENBQU4sQ0FBb0I2QyxJQUFwQixDQUF5QmpLLEtBQXpCLEVBQ0QsQ0FGK0IsQ0FFN0IsVUFBVyxDQUFFLE1BQU8sQ0FBQyxFQUFELENBQUssRUFBTCxDQUFQLENBQWtCLENBRkYsQ0FBaEMsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrSSxPQUFULENBQWdCTyxVQUFoQixDQUE0Qm8zQixRQUE1QixDQUFzQ0MsV0FBdEMsQ0FBbUQsQ0FDakQsR0FBSUwsS0FBSSxDQUFHdDVCLE9BQU8sQ0FBQ3NDLFVBQUQsQ0FBUCxDQUFzQmc0QixXQUF0QixDQUFvQ29CLFVBQS9DLENBQ0luQixTQUFTLENBQUc3NEIsU0FBUyxDQUFDL0ksTUFBVixDQUFtQixDQURuQyxDQUdBLE1BQU8yZ0MsS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYSt0QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUF4QixDQUF1Q0MsV0FBdkMsQ0FBb0RZLFNBQXBELENBQStEcU4sUUFBL0QsQ0FBWCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTamUsWUFBVCxDQUFxQnJuQixVQUFyQixDQUFpQ28zQixRQUFqQyxDQUEyQ0MsV0FBM0MsQ0FBd0QsQ0FDdEQsR0FBSUwsS0FBSSxDQUFHdDVCLE9BQU8sQ0FBQ3NDLFVBQUQsQ0FBUCxDQUFzQms0QixnQkFBdEIsQ0FBeUNrQixVQUFwRCxDQUNJbkIsU0FBUyxDQUFHNzRCLFNBQVMsQ0FBQy9JLE1BQVYsQ0FBbUIsQ0FEbkMsQ0FHQSxNQUFPMmdDLEtBQUksQ0FBQ2gzQixVQUFELENBQWErdEMsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBeEIsQ0FBdUNDLFdBQXZDLENBQW9EWSxTQUFwRCxDQUErRDRQLGFBQS9ELENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU29ZLE9BQVQsQ0FBZ0JqZ0QsVUFBaEIsQ0FBNEJ0QixTQUE1QixDQUF1QyxDQUNyQyxHQUFJczRCLEtBQUksQ0FBR3Q1QixPQUFPLENBQUNzQyxVQUFELENBQVAsQ0FBc0J5M0IsV0FBdEIsQ0FBb0M0USxVQUEvQyxDQUNBLE1BQU9yUixLQUFJLENBQUNoM0IsVUFBRCxDQUFha2dELE1BQU0sQ0FBQ25TLFdBQVcsQ0FBQ3J2QyxTQUFELENBQVksQ0FBWixDQUFaLENBQW5CLENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTakosT0FBVCxDQUFnQnVLLFVBQWhCLENBQTRCLENBQzFCLEdBQUlnM0IsS0FBSSxDQUFHdDVCLE9BQU8sQ0FBQ3NDLFVBQUQsQ0FBUCxDQUFzQjBrQyxXQUF0QixDQUFvQ3NLLFVBQS9DLENBQ0EsTUFBT2hZLEtBQUksQ0FBQ2gzQixVQUFELENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbWdELFdBQVQsQ0FBb0JuZ0QsVUFBcEIsQ0FBZ0NwTSxDQUFoQyxDQUFtQ3lnRCxLQUFuQyxDQUEwQyxDQUN4QyxHQUFLQSxLQUFLLENBQUdDLGNBQWMsQ0FBQ3QwQyxVQUFELENBQWFwTSxDQUFiLENBQWdCeWdELEtBQWhCLENBQWpCLENBQTBDemdELENBQUMsR0FBS3dDLFNBQTFELENBQXNFLENBQ3BFeEMsQ0FBQyxDQUFHLENBQUosQ0FDRCxDQUZELElBRU8sQ0FDTEEsQ0FBQyxDQUFHdTBDLFNBQVMsQ0FBQ3YwQyxDQUFELENBQWIsQ0FDRCxDQUNELEdBQUlvakMsS0FBSSxDQUFHdDVCLE9BQU8sQ0FBQ3NDLFVBQUQsQ0FBUCxDQUFzQjRrQyxlQUF0QixDQUF3Q3FLLGNBQW5ELENBQ0EsTUFBT2pZLEtBQUksQ0FBQ2gzQixVQUFELENBQWFwTSxDQUFiLENBQVgsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3c0QsUUFBVCxDQUFpQnBnRCxVQUFqQixDQUE2QixDQUMzQixHQUFJZzNCLEtBQUksQ0FBR3Q1QixPQUFPLENBQUNzQyxVQUFELENBQVAsQ0FBc0Ira0MsWUFBdEIsQ0FBcUNzSyxXQUFoRCxDQUNBLE1BQU9yWSxLQUFJLENBQUNoM0IsVUFBRCxDQUFYLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdk4sS0FBVCxDQUFjdU4sVUFBZCxDQUEwQixDQUN4QixHQUFJQSxVQUFVLEVBQUksSUFBbEIsQ0FBd0IsQ0FDdEIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJNEosV0FBVyxDQUFDNUosVUFBRCxDQUFmLENBQTZCLENBQzNCLE1BQU80L0MsU0FBUSxDQUFDNS9DLFVBQUQsQ0FBUixDQUF1Qnc3QixVQUFVLENBQUN4N0IsVUFBRCxDQUFqQyxDQUFnREEsVUFBVSxDQUFDM0osTUFBbEUsQ0FDRCxDQUNELEdBQUlpd0MsSUFBRyxDQUFHQyxNQUFNLENBQUN2bUMsVUFBRCxDQUFoQixDQUNBLEdBQUlzbUMsR0FBRyxFQUFJbFksTUFBUCxFQUFpQmtZLEdBQUcsRUFBSTNYLE1BQTVCLENBQW9DLENBQ2xDLE1BQU8zdUIsV0FBVSxDQUFDdk4sSUFBbEIsQ0FDRCxDQUNELE1BQU84NUMsU0FBUSxDQUFDdnNDLFVBQUQsQ0FBUixDQUFxQjNKLE1BQTVCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa3NCLEtBQVQsQ0FBY3ZpQixVQUFkLENBQTBCdEIsU0FBMUIsQ0FBcUMyMUMsS0FBckMsQ0FBNEMsQ0FDMUMsR0FBSXJkLEtBQUksQ0FBR3Q1QixPQUFPLENBQUNzQyxVQUFELENBQVAsQ0FBc0JtNEIsU0FBdEIsQ0FBa0NvWCxRQUE3QyxDQUNBLEdBQUk4RSxLQUFLLEVBQUlDLGNBQWMsQ0FBQ3QwQyxVQUFELENBQWF0QixTQUFiLENBQXdCMjFDLEtBQXhCLENBQTNCLENBQTJELENBQ3pEMzFDLFNBQVMsQ0FBR3RJLFNBQVosQ0FDRCxDQUNELE1BQU80Z0MsS0FBSSxDQUFDaDNCLFVBQUQsQ0FBYSt0QyxXQUFXLENBQUNydkMsU0FBRCxDQUFZLENBQVosQ0FBeEIsQ0FBWCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl2SyxPQUFNLENBQUcwNkMsUUFBUSxDQUFDLFNBQVM3dUMsVUFBVCxDQUFxQjZoQyxTQUFyQixDQUFnQyxDQUNwRCxHQUFJN2hDLFVBQVUsRUFBSSxJQUFsQixDQUF3QixDQUN0QixNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUkzSixPQUFNLENBQUd3ckMsU0FBUyxDQUFDeHJDLE1BQXZCLENBQ0EsR0FBSUEsTUFBTSxDQUFHLENBQVQsRUFBY2krQyxjQUFjLENBQUN0MEMsVUFBRCxDQUFhNmhDLFNBQVMsQ0FBQyxDQUFELENBQXRCLENBQTJCQSxTQUFTLENBQUMsQ0FBRCxDQUFwQyxDQUFoQyxDQUEwRSxDQUN4RUEsU0FBUyxDQUFHLEVBQVosQ0FDRCxDQUZELElBRU8sSUFBSXhyQyxNQUFNLENBQUcsQ0FBVCxFQUFjaStDLGNBQWMsQ0FBQ3pTLFNBQVMsQ0FBQyxDQUFELENBQVYsQ0FBZUEsU0FBUyxDQUFDLENBQUQsQ0FBeEIsQ0FBNkJBLFNBQVMsQ0FBQyxDQUFELENBQXRDLENBQWhDLENBQTRFLENBQ2pGQSxTQUFTLENBQUcsQ0FBQ0EsU0FBUyxDQUFDLENBQUQsQ0FBVixDQUFaLENBQ0QsQ0FDRCxNQUFPZ00sWUFBVyxDQUFDN3RDLFVBQUQsQ0FBYXNvQyxXQUFXLENBQUN6RyxTQUFELENBQVksQ0FBWixDQUF4QixDQUF3QyxFQUF4QyxDQUFsQixDQUNELENBWG9CLENBQXJCLENBYUEsNEVBbDNRaUQsQ0FvM1FqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkxc0MsSUFBRyxDQUFHMm9DLE1BQU0sRUFBSSxVQUFXLENBQzdCLE1BQU92bUIsS0FBSSxDQUFDcmlCLElBQUwsQ0FBVUMsR0FBVixFQUFQLENBQ0QsQ0FGRCxDQUlBLDRFQXg0UWlELENBMDRRakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZqQixNQUFULENBQWVwbEIsQ0FBZixDQUFrQm9qQyxJQUFsQixDQUF3QixDQUN0QixHQUFJLE1BQU9BLEtBQVAsRUFBZSxVQUFuQixDQUErQixDQUM3QixLQUFNLElBQUl6cUIsVUFBSixDQUFjaWYsZUFBZCxDQUFOLENBQ0QsQ0FDRDUzQixDQUFDLENBQUd1MEMsU0FBUyxDQUFDdjBDLENBQUQsQ0FBYixDQUNBLE1BQU8sV0FBVyxDQUNoQixHQUFJLEVBQUVBLENBQUYsQ0FBTSxDQUFWLENBQWEsQ0FDWCxNQUFPb2pDLEtBQUksQ0FBQy82QixLQUFMLENBQVcsSUFBWCxDQUFpQm1ELFNBQWpCLENBQVAsQ0FDRCxDQUNGLENBSkQsQ0FLRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbzNDLElBQVQsQ0FBYXhmLElBQWIsQ0FBbUJwakMsQ0FBbkIsQ0FBc0J5Z0QsS0FBdEIsQ0FBNkIsQ0FDM0J6Z0QsQ0FBQyxDQUFHeWdELEtBQUssQ0FBR2orQyxTQUFILENBQWV4QyxDQUF4QixDQUNBQSxDQUFDLENBQUlvakMsSUFBSSxFQUFJcGpDLENBQUMsRUFBSSxJQUFkLENBQXNCb2pDLElBQUksQ0FBQzNnQyxNQUEzQixDQUFvQ3pDLENBQXhDLENBQ0EsTUFBTytrRCxXQUFVLENBQUMzaEIsSUFBRCxDQUFPdkssYUFBUCxDQUFzQnIyQixTQUF0QixDQUFpQ0EsU0FBakMsQ0FBNENBLFNBQTVDLENBQXVEQSxTQUF2RCxDQUFrRXhDLENBQWxFLENBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lzRCxPQUFULENBQWdCenNELENBQWhCLENBQW1Cb2pDLElBQW5CLENBQXlCLENBQ3ZCLEdBQUlqakMsT0FBSixDQUNBLEdBQUksTUFBT2lqQyxLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJenFCLFVBQUosQ0FBY2lmLGVBQWQsQ0FBTixDQUNELENBQ0Q1M0IsQ0FBQyxDQUFHdTBDLFNBQVMsQ0FBQ3YwQyxDQUFELENBQWIsQ0FDQSxNQUFPLFdBQVcsQ0FDaEIsR0FBSSxFQUFFQSxDQUFGLENBQU0sQ0FBVixDQUFhLENBQ1hHLE1BQU0sQ0FBR2lqQyxJQUFJLENBQUMvNkIsS0FBTCxDQUFXLElBQVgsQ0FBaUJtRCxTQUFqQixDQUFULENBQ0QsQ0FDRCxHQUFJeEwsQ0FBQyxFQUFJLENBQVQsQ0FBWSxDQUNWb2pDLElBQUksQ0FBRzVnQyxTQUFQLENBQ0QsQ0FDRCxNQUFPckMsT0FBUCxDQUNELENBUkQsQ0FTRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJZ04sS0FBSSxDQUFHOHRDLFFBQVEsQ0FBQyxTQUFTN1gsSUFBVCxDQUFlQyxPQUFmLENBQXdCOGIsUUFBeEIsQ0FBa0MsQ0FDcEQsR0FBSS9NLFFBQU8sQ0FBRzlaLGNBQWQsQ0FDQSxHQUFJNm1CLFFBQVEsQ0FBQzE4QyxNQUFiLENBQXFCLENBQ25CLEdBQUkyOEMsUUFBTyxDQUFHNVgsY0FBYyxDQUFDMlgsUUFBRCxDQUFXdUMsU0FBUyxDQUFDdjBDLElBQUQsQ0FBcEIsQ0FBNUIsQ0FDQWlsQyxPQUFPLEVBQUl6WixpQkFBWCxDQUNELENBQ0QsTUFBT29zQixXQUFVLENBQUMzaEIsSUFBRCxDQUFPZ1AsT0FBUCxDQUFnQi9PLE9BQWhCLENBQXlCOGIsUUFBekIsQ0FBbUNDLE9BQW5DLENBQWpCLENBQ0QsQ0FQa0IsQ0FBbkIsQ0FTQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJc04sUUFBTyxDQUFHelIsUUFBUSxDQUFDLFNBQVMxMEMsTUFBVCxDQUFpQndFLEdBQWpCLENBQXNCbzBDLFFBQXRCLENBQWdDLENBQ3JELEdBQUkvTSxRQUFPLENBQUc5WixjQUFjLENBQUdDLGtCQUEvQixDQUNBLEdBQUk0bUIsUUFBUSxDQUFDMThDLE1BQWIsQ0FBcUIsQ0FDbkIsR0FBSTI4QyxRQUFPLENBQUc1WCxjQUFjLENBQUMyWCxRQUFELENBQVd1QyxTQUFTLENBQUNnTCxPQUFELENBQXBCLENBQTVCLENBQ0F0YSxPQUFPLEVBQUl6WixpQkFBWCxDQUNELENBQ0QsTUFBT29zQixXQUFVLENBQUNoNkMsR0FBRCxDQUFNcW5DLE9BQU4sQ0FBZTdyQyxNQUFmLENBQXVCNDRDLFFBQXZCLENBQWlDQyxPQUFqQyxDQUFqQixDQUNELENBUHFCLENBQXRCLENBU0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1TixNQUFULENBQWV2cEIsSUFBZixDQUFxQnFlLEtBQXJCLENBQTRCaEIsS0FBNUIsQ0FBbUMsQ0FDakNnQixLQUFLLENBQUdoQixLQUFLLENBQUdqK0MsU0FBSCxDQUFlaS9DLEtBQTVCLENBQ0EsR0FBSXRoRCxPQUFNLENBQUc0a0QsVUFBVSxDQUFDM2hCLElBQUQsQ0FBTzNLLGVBQVAsQ0FBd0JqMkIsU0FBeEIsQ0FBbUNBLFNBQW5DLENBQThDQSxTQUE5QyxDQUF5REEsU0FBekQsQ0FBb0VBLFNBQXBFLENBQStFaS9DLEtBQS9FLENBQXZCLENBQ0F0aEQsTUFBTSxDQUFDdW1DLFdBQVAsQ0FBcUJpbUIsS0FBSyxDQUFDam1CLFdBQTNCLENBQ0EsTUFBT3ZtQyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lzRCxXQUFULENBQW9CeHBCLElBQXBCLENBQTBCcWUsS0FBMUIsQ0FBaUNoQixLQUFqQyxDQUF3QyxDQUN0Q2dCLEtBQUssQ0FBR2hCLEtBQUssQ0FBR2orQyxTQUFILENBQWVpL0MsS0FBNUIsQ0FDQSxHQUFJdGhELE9BQU0sQ0FBRzRrRCxVQUFVLENBQUMzaEIsSUFBRCxDQUFPMUsscUJBQVAsQ0FBOEJsMkIsU0FBOUIsQ0FBeUNBLFNBQXpDLENBQW9EQSxTQUFwRCxDQUErREEsU0FBL0QsQ0FBMEVBLFNBQTFFLENBQXFGaS9DLEtBQXJGLENBQXZCLENBQ0F0aEQsTUFBTSxDQUFDdW1DLFdBQVAsQ0FBcUJrbUIsVUFBVSxDQUFDbG1CLFdBQWhDLENBQ0EsTUFBT3ZtQyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMHNELFNBQVQsQ0FBa0J6cEIsSUFBbEIsQ0FBd0JzUSxJQUF4QixDQUE4QjF5QyxPQUE5QixDQUF1QyxDQUNyQyxHQUFJOHJELFNBQUosQ0FDSUMsUUFESixDQUVJQyxPQUZKLENBR0k3c0QsTUFISixDQUlJOHNELE9BSkosQ0FLSUMsWUFMSixDQU1JQyxjQUFjLENBQUcsQ0FOckIsQ0FPSUMsT0FBTyxDQUFHLEtBUGQsQ0FRSUMsTUFBTSxDQUFHLEtBUmIsQ0FTSW5NLFFBQVEsQ0FBRyxJQVRmLENBV0EsR0FBSSxNQUFPOWQsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLEtBQU0sSUFBSXpxQixVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNEOGIsSUFBSSxDQUFHdVEsUUFBUSxDQUFDdlEsSUFBRCxDQUFSLEVBQWtCLENBQXpCLENBQ0EsR0FBSWpILFFBQVEsQ0FBQ3pyQyxPQUFELENBQVosQ0FBdUIsQ0FDckJvc0QsT0FBTyxDQUFHLENBQUMsQ0FBQ3BzRCxPQUFPLENBQUNvc0QsT0FBcEIsQ0FDQUMsTUFBTSxDQUFHLFdBQWFyc0QsUUFBdEIsQ0FDQWdzRCxPQUFPLENBQUdLLE1BQU0sQ0FBR3ZpQixTQUFTLENBQUNtWixRQUFRLENBQUNqakQsT0FBTyxDQUFDZ3NELE9BQVQsQ0FBUixFQUE2QixDQUE5QixDQUFpQ3RaLElBQWpDLENBQVosQ0FBcURzWixPQUFyRSxDQUNBOUwsUUFBUSxDQUFHLFlBQWNsZ0QsUUFBZCxDQUF3QixDQUFDLENBQUNBLE9BQU8sQ0FBQ2tnRCxRQUFsQyxDQUE2Q0EsUUFBeEQsQ0FDRCxDQUVELFFBQVNvTSxXQUFULENBQW9CQyxJQUFwQixDQUEwQixDQUN4QixHQUFJOWhELEtBQUksQ0FBR3FoRCxRQUFYLENBQ0l6cEIsT0FBTyxDQUFHMHBCLFFBRGQsQ0FHQUQsUUFBUSxDQUFHQyxRQUFRLENBQUd2cUQsU0FBdEIsQ0FDQTJxRCxjQUFjLENBQUdJLElBQWpCLENBQ0FwdEQsTUFBTSxDQUFHaWpDLElBQUksQ0FBQy82QixLQUFMLENBQVdnN0IsT0FBWCxDQUFvQjUzQixJQUFwQixDQUFULENBQ0EsTUFBT3RMLE9BQVAsQ0FDRCxDQUVELFFBQVNxdEQsWUFBVCxDQUFxQkQsSUFBckIsQ0FBMkIsQ0FDekI7QUFDQUosY0FBYyxDQUFHSSxJQUFqQixDQUNBO0FBQ0FOLE9BQU8sQ0FBRzdpQixVQUFVLENBQUNxakIsWUFBRCxDQUFlL1osSUFBZixDQUFwQixDQUNBO0FBQ0EsTUFBTzBaLFFBQU8sQ0FBR0UsVUFBVSxDQUFDQyxJQUFELENBQWIsQ0FBc0JwdEQsTUFBcEMsQ0FDRCxDQUVELFFBQVN1dEQsY0FBVCxDQUF1QkgsSUFBdkIsQ0FBNkIsQ0FDM0IsR0FBSUksa0JBQWlCLENBQUdKLElBQUksQ0FBR0wsWUFBL0IsQ0FDSVUsbUJBQW1CLENBQUdMLElBQUksQ0FBR0osY0FEakMsQ0FFSVUsV0FBVyxDQUFHbmEsSUFBSSxDQUFHaWEsaUJBRnpCLENBSUEsTUFBT04sT0FBTSxDQUNUdGlCLFNBQVMsQ0FBQzhpQixXQUFELENBQWNiLE9BQU8sQ0FBR1ksbUJBQXhCLENBREEsQ0FFVEMsV0FGSixDQUdELENBRUQsUUFBU0MsYUFBVCxDQUFzQlAsSUFBdEIsQ0FBNEIsQ0FDMUIsR0FBSUksa0JBQWlCLENBQUdKLElBQUksQ0FBR0wsWUFBL0IsQ0FDSVUsbUJBQW1CLENBQUdMLElBQUksQ0FBR0osY0FEakMsQ0FHQTtBQUNBO0FBQ0E7QUFDQSxNQUFRRCxhQUFZLEdBQUsxcUQsU0FBakIsRUFBK0JtckQsaUJBQWlCLEVBQUlqYSxJQUFwRCxFQUNMaWEsaUJBQWlCLENBQUcsQ0FEZixFQUNzQk4sTUFBTSxFQUFJTyxtQkFBbUIsRUFBSVosT0FEL0QsQ0FFRCxDQUVELFFBQVNTLGFBQVQsRUFBd0IsQ0FDdEIsR0FBSUYsS0FBSSxDQUFHaHNELEdBQUcsRUFBZCxDQUNBLEdBQUl1c0QsWUFBWSxDQUFDUCxJQUFELENBQWhCLENBQXdCLENBQ3RCLE1BQU9RLGFBQVksQ0FBQ1IsSUFBRCxDQUFuQixDQUNELENBQ0Q7QUFDQU4sT0FBTyxDQUFHN2lCLFVBQVUsQ0FBQ3FqQixZQUFELENBQWVDLGFBQWEsQ0FBQ0gsSUFBRCxDQUE1QixDQUFwQixDQUNELENBRUQsUUFBU1EsYUFBVCxDQUFzQlIsSUFBdEIsQ0FBNEIsQ0FDMUJOLE9BQU8sQ0FBR3pxRCxTQUFWLENBRUE7QUFDQTtBQUNBLEdBQUkwK0MsUUFBUSxFQUFJNEwsUUFBaEIsQ0FBMEIsQ0FDeEIsTUFBT1EsV0FBVSxDQUFDQyxJQUFELENBQWpCLENBQ0QsQ0FDRFQsUUFBUSxDQUFHQyxRQUFRLENBQUd2cUQsU0FBdEIsQ0FDQSxNQUFPckMsT0FBUCxDQUNELENBRUQsUUFBUzZ0RCxPQUFULEVBQWtCLENBQ2hCLEdBQUlmLE9BQU8sR0FBS3pxRCxTQUFoQixDQUEyQixDQUN6QnluQyxZQUFZLENBQUNnakIsT0FBRCxDQUFaLENBQ0QsQ0FDREUsY0FBYyxDQUFHLENBQWpCLENBQ0FMLFFBQVEsQ0FBR0ksWUFBWSxDQUFHSCxRQUFRLENBQUdFLE9BQU8sQ0FBR3pxRCxTQUEvQyxDQUNELENBRUQsUUFBU3lyRCxNQUFULEVBQWlCLENBQ2YsTUFBT2hCLFFBQU8sR0FBS3pxRCxTQUFaLENBQXdCckMsTUFBeEIsQ0FBaUM0dEQsWUFBWSxDQUFDeHNELEdBQUcsRUFBSixDQUFwRCxDQUNELENBRUQsUUFBUzJzRCxVQUFULEVBQXFCLENBQ25CLEdBQUlYLEtBQUksQ0FBR2hzRCxHQUFHLEVBQWQsQ0FDSTRzRCxVQUFVLENBQUdMLFlBQVksQ0FBQ1AsSUFBRCxDQUQ3QixDQUdBVCxRQUFRLENBQUd0aEQsU0FBWCxDQUNBdWhELFFBQVEsQ0FBRyxJQUFYLENBQ0FHLFlBQVksQ0FBR0ssSUFBZixDQUVBLEdBQUlZLFVBQUosQ0FBZ0IsQ0FDZCxHQUFJbEIsT0FBTyxHQUFLenFELFNBQWhCLENBQTJCLENBQ3pCLE1BQU9nckQsWUFBVyxDQUFDTixZQUFELENBQWxCLENBQ0QsQ0FDRCxHQUFJRyxNQUFKLENBQVksQ0FDVjtBQUNBcGpCLFlBQVksQ0FBQ2dqQixPQUFELENBQVosQ0FDQUEsT0FBTyxDQUFHN2lCLFVBQVUsQ0FBQ3FqQixZQUFELENBQWUvWixJQUFmLENBQXBCLENBQ0EsTUFBTzRaLFdBQVUsQ0FBQ0osWUFBRCxDQUFqQixDQUNELENBQ0YsQ0FDRCxHQUFJRCxPQUFPLEdBQUt6cUQsU0FBaEIsQ0FBMkIsQ0FDekJ5cUQsT0FBTyxDQUFHN2lCLFVBQVUsQ0FBQ3FqQixZQUFELENBQWUvWixJQUFmLENBQXBCLENBQ0QsQ0FDRCxNQUFPdnpDLE9BQVAsQ0FDRCxDQUNEK3RELFNBQVMsQ0FBQ0YsTUFBVixDQUFtQkEsTUFBbkIsQ0FDQUUsU0FBUyxDQUFDRCxLQUFWLENBQWtCQSxLQUFsQixDQUNBLE1BQU9DLFVBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlFLE1BQUssQ0FBR25ULFFBQVEsQ0FBQyxTQUFTN1gsSUFBVCxDQUFlMzNCLElBQWYsQ0FBcUIsQ0FDeEMsTUFBT2dvQyxVQUFTLENBQUNyUSxJQUFELENBQU8sQ0FBUCxDQUFVMzNCLElBQVYsQ0FBaEIsQ0FDRCxDQUZtQixDQUFwQixDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTRpRCxNQUFLLENBQUdwVCxRQUFRLENBQUMsU0FBUzdYLElBQVQsQ0FBZXNRLElBQWYsQ0FBcUJqb0MsSUFBckIsQ0FBMkIsQ0FDOUMsTUFBT2dvQyxVQUFTLENBQUNyUSxJQUFELENBQU82Z0IsUUFBUSxDQUFDdlEsSUFBRCxDQUFSLEVBQWtCLENBQXpCLENBQTRCam9DLElBQTVCLENBQWhCLENBQ0QsQ0FGbUIsQ0FBcEIsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeWUsS0FBVCxDQUFja1osSUFBZCxDQUFvQixDQUNsQixNQUFPMmhCLFdBQVUsQ0FBQzNoQixJQUFELENBQU9ySyxjQUFQLENBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU291QixRQUFULENBQWlCL2pCLElBQWpCLENBQXVCa3JCLFFBQXZCLENBQWlDLENBQy9CLEdBQUksTUFBT2xyQixLQUFQLEVBQWUsVUFBZixFQUE4QmtyQixRQUFRLEVBQUksSUFBWixFQUFvQixNQUFPQSxTQUFQLEVBQW1CLFVBQXpFLENBQXNGLENBQ3BGLEtBQU0sSUFBSTMxQyxVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNELEdBQUkyMkIsU0FBUSxDQUFHLFVBQVcsQ0FDeEIsR0FBSTlpRCxLQUFJLENBQUdELFNBQVgsQ0FDSVQsR0FBRyxDQUFHdWpELFFBQVEsQ0FBR0EsUUFBUSxDQUFDam1ELEtBQVQsQ0FBZSxJQUFmLENBQXFCb0QsSUFBckIsQ0FBSCxDQUFnQ0EsSUFBSSxDQUFDLENBQUQsQ0FEdEQsQ0FFSTZNLEtBQUssQ0FBR2kyQyxRQUFRLENBQUNqMkMsS0FGckIsQ0FJQSxHQUFJQSxLQUFLLENBQUNaLEdBQU4sQ0FBVTNNLEdBQVYsQ0FBSixDQUFvQixDQUNsQixNQUFPdU4sTUFBSyxDQUFDZCxHQUFOLENBQVV6TSxHQUFWLENBQVAsQ0FDRCxDQUNELEdBQUk1SyxPQUFNLENBQUdpakMsSUFBSSxDQUFDLzZCLEtBQUwsQ0FBVyxJQUFYLENBQWlCb0QsSUFBakIsQ0FBYixDQUNBOGlELFFBQVEsQ0FBQ2oyQyxLQUFULENBQWlCQSxLQUFLLENBQUNpRixHQUFOLENBQVV4UyxHQUFWLENBQWU1SyxNQUFmLEdBQTBCbVksS0FBM0MsQ0FDQSxNQUFPblksT0FBUCxDQUNELENBWEQsQ0FZQW91RCxRQUFRLENBQUNqMkMsS0FBVCxDQUFpQixJQUFLNnVDLE9BQU8sQ0FBQ3FILEtBQVIsRUFBaUJsZixRQUF0QixHQUFqQixDQUNBLE1BQU9pZixTQUFQLENBQ0QsQ0FFRDtBQUNBcEgsT0FBTyxDQUFDcUgsS0FBUixDQUFnQmxmLFFBQWhCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnZCxPQUFULENBQWdCeGhELFNBQWhCLENBQTJCLENBQ3pCLEdBQUksTUFBT0EsVUFBUCxFQUFvQixVQUF4QixDQUFvQyxDQUNsQyxLQUFNLElBQUk2TixVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNELE1BQU8sV0FBVyxDQUNoQixHQUFJbnNCLEtBQUksQ0FBR0QsU0FBWCxDQUNBLE9BQVFDLElBQUksQ0FBQ2hKLE1BQWIsRUFDRSxJQUFLLEVBQUwsQ0FBUSxNQUFPLENBQUNxSSxTQUFTLENBQUNqQixJQUFWLENBQWUsSUFBZixDQUFSLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBTyxDQUFDaUIsU0FBUyxDQUFDakIsSUFBVixDQUFlLElBQWYsQ0FBcUI0QixJQUFJLENBQUMsQ0FBRCxDQUF6QixDQUFSLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBTyxDQUFDWCxTQUFTLENBQUNqQixJQUFWLENBQWUsSUFBZixDQUFxQjRCLElBQUksQ0FBQyxDQUFELENBQXpCLENBQThCQSxJQUFJLENBQUMsQ0FBRCxDQUFsQyxDQUFSLENBQ1IsSUFBSyxFQUFMLENBQVEsTUFBTyxDQUFDWCxTQUFTLENBQUNqQixJQUFWLENBQWUsSUFBZixDQUFxQjRCLElBQUksQ0FBQyxDQUFELENBQXpCLENBQThCQSxJQUFJLENBQUMsQ0FBRCxDQUFsQyxDQUF1Q0EsSUFBSSxDQUFDLENBQUQsQ0FBM0MsQ0FBUixDQUpWLENBTUEsTUFBTyxDQUFDWCxTQUFTLENBQUN6QyxLQUFWLENBQWdCLElBQWhCLENBQXNCb0QsSUFBdEIsQ0FBUixDQUNELENBVEQsQ0FVRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnakQsS0FBVCxDQUFjcnJCLElBQWQsQ0FBb0IsQ0FDbEIsTUFBT3FwQixPQUFNLENBQUMsQ0FBRCxDQUFJcnBCLElBQUosQ0FBYixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJc3JCLFNBQVEsQ0FBRzlRLFFBQVEsQ0FBQyxTQUFTeGEsSUFBVCxDQUFlc2pCLFVBQWYsQ0FBMkIsQ0FDakRBLFVBQVUsQ0FBSUEsVUFBVSxDQUFDamtELE1BQVgsRUFBcUIsQ0FBckIsRUFBMEJxSCxPQUFPLENBQUM0OEMsVUFBVSxDQUFDLENBQUQsQ0FBWCxDQUFsQyxDQUNUeGlCLFFBQVEsQ0FBQ3dpQixVQUFVLENBQUMsQ0FBRCxDQUFYLENBQWdCeGdCLFNBQVMsQ0FBQ2lVLFdBQVcsRUFBWixDQUF6QixDQURDLENBRVRqVyxRQUFRLENBQUN3USxXQUFXLENBQUNnUyxVQUFELENBQWEsQ0FBYixDQUFaLENBQTZCeGdCLFNBQVMsQ0FBQ2lVLFdBQVcsRUFBWixDQUF0QyxDQUZaLENBSUEsR0FBSXdVLFlBQVcsQ0FBR2pJLFVBQVUsQ0FBQ2prRCxNQUE3QixDQUNBLE1BQU93NEMsU0FBUSxDQUFDLFNBQVN4dkMsSUFBVCxDQUFlLENBQzdCLEdBQUlkLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR3NvQyxTQUFTLENBQUN0L0IsSUFBSSxDQUFDaEosTUFBTixDQUFja3NELFdBQWQsQ0FEdEIsQ0FHQSxNQUFPLEVBQUVoa0QsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkJnSixJQUFJLENBQUNkLEtBQUQsQ0FBSixDQUFjKzdDLFVBQVUsQ0FBQy83QyxLQUFELENBQVYsQ0FBa0JkLElBQWxCLENBQXVCLElBQXZCLENBQTZCNEIsSUFBSSxDQUFDZCxLQUFELENBQWpDLENBQWQsQ0FDRCxDQUNELE1BQU90QyxNQUFLLENBQUMrNkIsSUFBRCxDQUFPLElBQVAsQ0FBYTMzQixJQUFiLENBQVosQ0FDRCxDQVJjLENBQWYsQ0FTRCxDQWZzQixDQUF2QixDQWlCQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJbWpELFFBQU8sQ0FBRzNULFFBQVEsQ0FBQyxTQUFTN1gsSUFBVCxDQUFlK2IsUUFBZixDQUF5QixDQUM5QyxHQUFJQyxRQUFPLENBQUc1WCxjQUFjLENBQUMyWCxRQUFELENBQVd1QyxTQUFTLENBQUNrTixPQUFELENBQXBCLENBQTVCLENBQ0EsTUFBTzdKLFdBQVUsQ0FBQzNoQixJQUFELENBQU96SyxpQkFBUCxDQUEwQm4yQixTQUExQixDQUFxQzI4QyxRQUFyQyxDQUErQ0MsT0FBL0MsQ0FBakIsQ0FDRCxDQUhxQixDQUF0QixDQUtBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJeVAsYUFBWSxDQUFHNVQsUUFBUSxDQUFDLFNBQVM3WCxJQUFULENBQWUrYixRQUFmLENBQXlCLENBQ25ELEdBQUlDLFFBQU8sQ0FBRzVYLGNBQWMsQ0FBQzJYLFFBQUQsQ0FBV3VDLFNBQVMsQ0FBQ21OLFlBQUQsQ0FBcEIsQ0FBNUIsQ0FDQSxNQUFPOUosV0FBVSxDQUFDM2hCLElBQUQsQ0FBT3hLLHVCQUFQLENBQWdDcDJCLFNBQWhDLENBQTJDMjhDLFFBQTNDLENBQXFEQyxPQUFyRCxDQUFqQixDQUNELENBSDBCLENBQTNCLENBS0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJMFAsTUFBSyxDQUFHOU0sUUFBUSxDQUFDLFNBQVM1ZSxJQUFULENBQWV3WCxPQUFmLENBQXdCLENBQzNDLE1BQU9tSyxXQUFVLENBQUMzaEIsSUFBRCxDQUFPdEssZUFBUCxDQUF3QnQyQixTQUF4QixDQUFtQ0EsU0FBbkMsQ0FBOENBLFNBQTlDLENBQXlEbzRDLE9BQXpELENBQWpCLENBQ0QsQ0FGbUIsQ0FBcEIsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN0bEIsS0FBVCxDQUFjOE4sSUFBZCxDQUFvQm5vQixLQUFwQixDQUEyQixDQUN6QixHQUFJLE1BQU9tb0IsS0FBUCxFQUFlLFVBQW5CLENBQStCLENBQzdCLEtBQU0sSUFBSXpxQixVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNEM2MsS0FBSyxDQUFHQSxLQUFLLEdBQUt6WSxTQUFWLENBQXNCeVksS0FBdEIsQ0FBOEJzNUIsU0FBUyxDQUFDdDVCLEtBQUQsQ0FBL0MsQ0FDQSxNQUFPZ2dDLFNBQVEsQ0FBQzdYLElBQUQsQ0FBT25vQixLQUFQLENBQWYsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzh6QyxPQUFULENBQWdCM3JCLElBQWhCLENBQXNCbm9CLEtBQXRCLENBQTZCLENBQzNCLEdBQUksTUFBT21vQixLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJenFCLFVBQUosQ0FBY2lmLGVBQWQsQ0FBTixDQUNELENBQ0QzYyxLQUFLLENBQUdBLEtBQUssRUFBSSxJQUFULENBQWdCLENBQWhCLENBQW9CNnZCLFNBQVMsQ0FBQ3lKLFNBQVMsQ0FBQ3Q1QixLQUFELENBQVYsQ0FBbUIsQ0FBbkIsQ0FBckMsQ0FDQSxNQUFPZ2dDLFNBQVEsQ0FBQyxTQUFTeHZDLElBQVQsQ0FBZSxDQUM3QixHQUFJOUUsTUFBSyxDQUFHOEUsSUFBSSxDQUFDd1AsS0FBRCxDQUFoQixDQUNJc3NDLFNBQVMsQ0FBRzFKLFNBQVMsQ0FBQ3B5QyxJQUFELENBQU8sQ0FBUCxDQUFVd1AsS0FBVixDQUR6QixDQUdBLEdBQUl0VSxLQUFKLENBQVcsQ0FDVHc5QixTQUFTLENBQUNvakIsU0FBRCxDQUFZNWdELEtBQVosQ0FBVCxDQUNELENBQ0QsTUFBTzBCLE1BQUssQ0FBQys2QixJQUFELENBQU8sSUFBUCxDQUFhbWtCLFNBQWIsQ0FBWixDQUNELENBUmMsQ0FBZixDQVNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5SCxTQUFULENBQWtCNXJCLElBQWxCLENBQXdCc1EsSUFBeEIsQ0FBOEIxeUMsT0FBOUIsQ0FBdUMsQ0FDckMsR0FBSW9zRCxRQUFPLENBQUcsSUFBZCxDQUNJbE0sUUFBUSxDQUFHLElBRGYsQ0FHQSxHQUFJLE1BQU85ZCxLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsS0FBTSxJQUFJenFCLFVBQUosQ0FBY2lmLGVBQWQsQ0FBTixDQUNELENBQ0QsR0FBSTZVLFFBQVEsQ0FBQ3pyQyxPQUFELENBQVosQ0FBdUIsQ0FDckJvc0QsT0FBTyxDQUFHLFdBQWFwc0QsUUFBYixDQUF1QixDQUFDLENBQUNBLE9BQU8sQ0FBQ29zRCxPQUFqQyxDQUEyQ0EsT0FBckQsQ0FDQWxNLFFBQVEsQ0FBRyxZQUFjbGdELFFBQWQsQ0FBd0IsQ0FBQyxDQUFDQSxPQUFPLENBQUNrZ0QsUUFBbEMsQ0FBNkNBLFFBQXhELENBQ0QsQ0FDRCxNQUFPMkwsU0FBUSxDQUFDenBCLElBQUQsQ0FBT3NRLElBQVAsQ0FBYSxDQUMxQixVQUFXMFosT0FEZSxDQUUxQixVQUFXMVosSUFGZSxDQUcxQixXQUFZd04sUUFIYyxDQUFiLENBQWYsQ0FLRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMrTixNQUFULENBQWU3ckIsSUFBZixDQUFxQixDQUNuQixNQUFPd2YsSUFBRyxDQUFDeGYsSUFBRCxDQUFPLENBQVAsQ0FBVixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTOHJCLEtBQVQsQ0FBY3ZyRCxLQUFkLENBQXFCbzlDLE9BQXJCLENBQThCLENBQzVCLE1BQU82TixRQUFPLENBQUNsUixZQUFZLENBQUNxRCxPQUFELENBQWIsQ0FBd0JwOUMsS0FBeEIsQ0FBZCxDQUNELENBRUQsNEVBNTJTaUQsQ0E4MlNqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTd3JELFVBQVQsRUFBcUIsQ0FDbkIsR0FBSSxDQUFDM2pELFNBQVMsQ0FBQy9JLE1BQWYsQ0FBdUIsQ0FDckIsTUFBTyxFQUFQLENBQ0QsQ0FDRCxHQUFJa0IsTUFBSyxDQUFHNkgsU0FBUyxDQUFDLENBQUQsQ0FBckIsQ0FDQSxNQUFPMUIsUUFBTyxDQUFDbkcsS0FBRCxDQUFQLENBQWlCQSxLQUFqQixDQUF5QixDQUFDQSxLQUFELENBQWhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUytwQyxNQUFULENBQWUvcEMsS0FBZixDQUFzQixDQUNwQixNQUFPd3VDLFVBQVMsQ0FBQ3h1QyxLQUFELENBQVF3MEIsa0JBQVIsQ0FBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2kzQixVQUFULENBQW1CenJELEtBQW5CLENBQTBCMHVDLFVBQTFCLENBQXNDLENBQ3BDQSxVQUFVLENBQUcsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0M3dkMsU0FBNUQsQ0FDQSxNQUFPMnZDLFVBQVMsQ0FBQ3h1QyxLQUFELENBQVF3MEIsa0JBQVIsQ0FBNEJrYSxVQUE1QixDQUFoQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dkLFVBQVQsQ0FBbUIxckQsS0FBbkIsQ0FBMEIsQ0FDeEIsTUFBT3d1QyxVQUFTLENBQUN4dUMsS0FBRCxDQUFRczBCLGVBQWUsQ0FBR0Usa0JBQTFCLENBQWhCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNtM0IsY0FBVCxDQUF1QjNyRCxLQUF2QixDQUE4QjB1QyxVQUE5QixDQUEwQyxDQUN4Q0EsVUFBVSxDQUFHLE1BQU9BLFdBQVAsRUFBcUIsVUFBckIsQ0FBa0NBLFVBQWxDLENBQStDN3ZDLFNBQTVELENBQ0EsTUFBTzJ2QyxVQUFTLENBQUN4dUMsS0FBRCxDQUFRczBCLGVBQWUsQ0FBR0Usa0JBQTFCLENBQThDa2EsVUFBOUMsQ0FBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrZCxXQUFULENBQW9CaHBELE1BQXBCLENBQTRCOEUsTUFBNUIsQ0FBb0MsQ0FDbEMsTUFBT0EsT0FBTSxFQUFJLElBQVYsRUFBa0Jtb0MsY0FBYyxDQUFDanRDLE1BQUQsQ0FBUzhFLE1BQVQsQ0FBaUIxQixJQUFJLENBQUMwQixNQUFELENBQXJCLENBQXZDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dtQyxHQUFULENBQVkxdEMsS0FBWixDQUFtQmtYLEtBQW5CLENBQTBCLENBQ3hCLE1BQU9sWCxNQUFLLEdBQUtrWCxLQUFWLEVBQW9CbFgsS0FBSyxHQUFLQSxLQUFWLEVBQW1Ca1gsS0FBSyxHQUFLQSxLQUF4RCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkyMEMsR0FBRSxDQUFHeEwseUJBQXlCLENBQUN2TyxNQUFELENBQWxDLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlnYSxJQUFHLENBQUd6TCx5QkFBeUIsQ0FBQyxTQUFTcmdELEtBQVQsQ0FBZ0JrWCxLQUFoQixDQUF1QixDQUN6RCxNQUFPbFgsTUFBSyxFQUFJa1gsS0FBaEIsQ0FDRCxDQUZrQyxDQUFuQyxDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk0MUIsWUFBVyxDQUFHNkYsZUFBZSxDQUFDLFVBQVcsQ0FBRSxNQUFPOXFDLFVBQVAsQ0FBbUIsQ0FBaEMsRUFBRCxDQUFmLENBQXNEOHFDLGVBQXRELENBQXdFLFNBQVMzeUMsS0FBVCxDQUFnQixDQUN4RyxNQUFPd29DLGFBQVksQ0FBQ3hvQyxLQUFELENBQVosRUFBdUI4RixjQUFjLENBQUNJLElBQWYsQ0FBb0JsRyxLQUFwQixDQUEyQixRQUEzQixDQUF2QixFQUNMLENBQUN5WixvQkFBb0IsQ0FBQ3ZULElBQXJCLENBQTBCbEcsS0FBMUIsQ0FBaUMsUUFBakMsQ0FESCxDQUVELENBSEQsQ0FLQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW1HLFFBQU8sQ0FBR3pKLEtBQUssQ0FBQ3lKLE9BQXBCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk2NEIsY0FBYSxDQUFHRCxpQkFBaUIsQ0FBR3dELFNBQVMsQ0FBQ3hELGlCQUFELENBQVosQ0FBa0M2VCxpQkFBdkUsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN2Z0MsWUFBVCxDQUFxQnJTLEtBQXJCLENBQTRCLENBQzFCLE1BQU9BLE1BQUssRUFBSSxJQUFULEVBQWlCMDBDLFFBQVEsQ0FBQzEwQyxLQUFLLENBQUNsQixNQUFQLENBQXpCLEVBQTJDLENBQUMyRixVQUFVLENBQUN6RSxLQUFELENBQTdELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpMkMsa0JBQVQsQ0FBMkJqMkMsS0FBM0IsQ0FBa0MsQ0FDaEMsTUFBT3dvQyxhQUFZLENBQUN4b0MsS0FBRCxDQUFaLEVBQXVCcVMsV0FBVyxDQUFDclMsS0FBRCxDQUF6QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMrckQsVUFBVCxDQUFtQi9yRCxLQUFuQixDQUEwQixDQUN4QixNQUFPQSxNQUFLLEdBQUssSUFBVixFQUFrQkEsS0FBSyxHQUFLLEtBQTVCLEVBQ0p3b0MsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCdTJCLE9BRC9DLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXVRLFNBQVEsQ0FBR0QsY0FBYyxFQUFJeWMsU0FBakMsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXBrQixPQUFNLENBQUdELFVBQVUsQ0FBR3NELFNBQVMsQ0FBQ3RELFVBQUQsQ0FBWixDQUEyQjRULFVBQWxELENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNtWixVQUFULENBQW1CaHNELEtBQW5CLENBQTBCLENBQ3hCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QkEsS0FBSyxDQUFDOFosUUFBTixHQUFtQixDQUExQyxFQUErQyxDQUFDcThCLGFBQWEsQ0FBQ24yQyxLQUFELENBQXBFLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaXdCLFFBQVQsQ0FBaUJqd0IsS0FBakIsQ0FBd0IsQ0FDdEIsR0FBSUEsS0FBSyxFQUFJLElBQWIsQ0FBbUIsQ0FDakIsTUFBTyxLQUFQLENBQ0QsQ0FDRCxHQUFJcVMsV0FBVyxDQUFDclMsS0FBRCxDQUFYLEdBQ0NtRyxPQUFPLENBQUNuRyxLQUFELENBQVAsRUFBa0IsTUFBT0EsTUFBUCxFQUFnQixRQUFsQyxFQUE4QyxNQUFPQSxNQUFLLENBQUNxaUIsTUFBYixFQUF1QixVQUFyRSxFQUNDeWtCLFFBQVEsQ0FBQzltQyxLQUFELENBRFQsRUFDb0J3L0IsWUFBWSxDQUFDeC9CLEtBQUQsQ0FEaEMsRUFDMkM4c0MsV0FBVyxDQUFDOXNDLEtBQUQsQ0FGdkQsQ0FBSixDQUVxRSxDQUNuRSxNQUFPLENBQUNBLEtBQUssQ0FBQ2xCLE1BQWQsQ0FDRCxDQUNELEdBQUlpd0MsSUFBRyxDQUFHQyxNQUFNLENBQUNodkMsS0FBRCxDQUFoQixDQUNBLEdBQUkrdUMsR0FBRyxFQUFJbFksTUFBUCxFQUFpQmtZLEdBQUcsRUFBSTNYLE1BQTVCLENBQW9DLENBQ2xDLE1BQU8sQ0FBQ3AzQixLQUFLLENBQUM5RSxJQUFkLENBQ0QsQ0FDRCxHQUFJKzVDLFdBQVcsQ0FBQ2oxQyxLQUFELENBQWYsQ0FBd0IsQ0FDdEIsTUFBTyxDQUFDZzFDLFFBQVEsQ0FBQ2gxQyxLQUFELENBQVIsQ0FBZ0JsQixNQUF4QixDQUNELENBQ0QsSUFBSyxHQUFJc0ksSUFBVCxHQUFnQnBILE1BQWhCLENBQXVCLENBQ3JCLEdBQUk4RixjQUFjLENBQUNJLElBQWYsQ0FBb0JsRyxLQUFwQixDQUEyQm9ILEdBQTNCLENBQUosQ0FBcUMsQ0FDbkMsTUFBTyxNQUFQLENBQ0QsQ0FDRixDQUNELE1BQU8sS0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNmtELFFBQVQsQ0FBaUJqc0QsS0FBakIsQ0FBd0JrWCxLQUF4QixDQUErQixDQUM3QixNQUFPNDdCLFlBQVcsQ0FBQzl5QyxLQUFELENBQVFrWCxLQUFSLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2cxQyxZQUFULENBQXFCbHNELEtBQXJCLENBQTRCa1gsS0FBNUIsQ0FBbUN3M0IsVUFBbkMsQ0FBK0MsQ0FDN0NBLFVBQVUsQ0FBRyxNQUFPQSxXQUFQLEVBQXFCLFVBQXJCLENBQWtDQSxVQUFsQyxDQUErQzd2QyxTQUE1RCxDQUNBLEdBQUlyQyxPQUFNLENBQUdreUMsVUFBVSxDQUFHQSxVQUFVLENBQUMxdUMsS0FBRCxDQUFRa1gsS0FBUixDQUFiLENBQThCclksU0FBckQsQ0FDQSxNQUFPckMsT0FBTSxHQUFLcUMsU0FBWCxDQUF1QmkwQyxXQUFXLENBQUM5eUMsS0FBRCxDQUFRa1gsS0FBUixDQUFlclksU0FBZixDQUEwQjZ2QyxVQUExQixDQUFsQyxDQUEwRSxDQUFDLENBQUNseUMsTUFBbkYsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMydkQsUUFBVCxDQUFpQm5zRCxLQUFqQixDQUF3QixDQUN0QixHQUFJLENBQUN3b0MsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBakIsQ0FBMEIsQ0FDeEIsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFJK3VDLElBQUcsQ0FBRzRDLFVBQVUsQ0FBQzN4QyxLQUFELENBQXBCLENBQ0EsTUFBTyt1QyxJQUFHLEVBQUlyWSxRQUFQLEVBQW1CcVksR0FBRyxFQUFJdFksU0FBMUIsRUFDSixNQUFPejJCLE1BQUssQ0FBQ3NCLE9BQWIsRUFBd0IsUUFBeEIsRUFBb0MsTUFBT3RCLE1BQUssQ0FBQ2QsSUFBYixFQUFxQixRQUF6RCxFQUFxRSxDQUFDaTNDLGFBQWEsQ0FBQ24yQyxLQUFELENBRHRGLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2duQyxTQUFULENBQWtCaG5DLEtBQWxCLENBQXlCLENBQ3ZCLE1BQU8sT0FBT0EsTUFBUCxFQUFnQixRQUFoQixFQUE0QittQyxjQUFjLENBQUMvbUMsS0FBRCxDQUFqRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5RSxXQUFULENBQW9CekUsS0FBcEIsQ0FBMkIsQ0FDekIsR0FBSSxDQUFDOG9DLFFBQVEsQ0FBQzlvQyxLQUFELENBQWIsQ0FBc0IsQ0FDcEIsTUFBTyxNQUFQLENBQ0QsQ0FDRDtBQUNBO0FBQ0EsR0FBSSt1QyxJQUFHLENBQUc0QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFwQixDQUNBLE1BQU8rdUMsSUFBRyxFQUFJcFksT0FBUCxFQUFrQm9ZLEdBQUcsRUFBSW5ZLE1BQXpCLEVBQW1DbVksR0FBRyxFQUFJelksUUFBMUMsRUFBc0R5WSxHQUFHLEVBQUk3WCxRQUFwRSxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrMUIsVUFBVCxDQUFtQnBzRCxLQUFuQixDQUEwQixDQUN4QixNQUFPLE9BQU9BLE1BQVAsRUFBZ0IsUUFBaEIsRUFBNEJBLEtBQUssRUFBSTR3QyxTQUFTLENBQUM1d0MsS0FBRCxDQUFyRCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMwMEMsU0FBVCxDQUFrQjEwQyxLQUFsQixDQUF5QixDQUN2QixNQUFPLE9BQU9BLE1BQVAsRUFBZ0IsUUFBaEIsRUFDTEEsS0FBSyxDQUFHLENBQUMsQ0FESixFQUNTQSxLQUFLLENBQUcsQ0FBUixFQUFhLENBRHRCLEVBQzJCQSxLQUFLLEVBQUk2MUIsZ0JBRDNDLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpVCxTQUFULENBQWtCOW9DLEtBQWxCLENBQXlCLENBQ3ZCLEdBQUkvRixLQUFJLENBQUcsTUFBTytGLE1BQWxCLENBQ0EsTUFBT0EsTUFBSyxFQUFJLElBQVQsR0FBa0IvRixJQUFJLEVBQUksUUFBUixFQUFvQkEsSUFBSSxFQUFJLFVBQTlDLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1dUMsYUFBVCxDQUFzQnhvQyxLQUF0QixDQUE2QixDQUMzQixNQUFPQSxNQUFLLEVBQUksSUFBVCxFQUFpQixNQUFPQSxNQUFQLEVBQWdCLFFBQXhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXFhLE1BQUssQ0FBRzhrQixTQUFTLENBQUdvRCxTQUFTLENBQUNwRCxTQUFELENBQVosQ0FBMEI0VSxTQUEvQyxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3NZLFFBQVQsQ0FBaUJ6cEQsTUFBakIsQ0FBeUI4RSxNQUF6QixDQUFpQyxDQUMvQixNQUFPOUUsT0FBTSxHQUFLOEUsTUFBWCxFQUFxQnNzQyxXQUFXLENBQUNweEMsTUFBRCxDQUFTOEUsTUFBVCxDQUFpQjZ0QyxZQUFZLENBQUM3dEMsTUFBRCxDQUE3QixDQUF2QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0a0QsWUFBVCxDQUFxQjFwRCxNQUFyQixDQUE2QjhFLE1BQTdCLENBQXFDZ25DLFVBQXJDLENBQWlELENBQy9DQSxVQUFVLENBQUcsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0M3dkMsU0FBNUQsQ0FDQSxNQUFPbTFDLFlBQVcsQ0FBQ3B4QyxNQUFELENBQVM4RSxNQUFULENBQWlCNnRDLFlBQVksQ0FBQzd0QyxNQUFELENBQTdCLENBQXVDZ25DLFVBQXZDLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNwb0MsTUFBVCxDQUFldEcsS0FBZixDQUFzQixDQUNwQjtBQUNBO0FBQ0E7QUFDQSxNQUFPdXNELFNBQVEsQ0FBQ3ZzRCxLQUFELENBQVIsRUFBbUJBLEtBQUssRUFBSSxDQUFDQSxLQUFwQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3c0QsU0FBVCxDQUFrQnhzRCxLQUFsQixDQUF5QixDQUN2QixHQUFJcWpELFVBQVUsQ0FBQ3JqRCxLQUFELENBQWQsQ0FBdUIsQ0FDckIsS0FBTSxJQUFJK0gsTUFBSixDQUFVaXNCLGVBQVYsQ0FBTixDQUNELENBQ0QsTUFBT29nQixhQUFZLENBQUNwMEMsS0FBRCxDQUFuQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN3RSxPQUFULENBQWdCeEUsS0FBaEIsQ0FBdUIsQ0FDckIsTUFBT0EsTUFBSyxHQUFLLElBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lzRCxNQUFULENBQWV6c0QsS0FBZixDQUFzQixDQUNwQixNQUFPQSxNQUFLLEVBQUksSUFBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdXNELFNBQVQsQ0FBa0J2c0QsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFFBQWhCLEVBQ0p3b0MsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCODJCLFNBRC9DLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxZixjQUFULENBQXVCbjJDLEtBQXZCLENBQThCLENBQzVCLEdBQUksQ0FBQ3dvQyxZQUFZLENBQUN4b0MsS0FBRCxDQUFiLEVBQXdCMnhDLFVBQVUsQ0FBQzN4QyxLQUFELENBQVYsRUFBcUJnM0IsU0FBakQsQ0FBNEQsQ0FDMUQsTUFBTyxNQUFQLENBQ0QsQ0FDRCxHQUFJNlIsTUFBSyxDQUFHaEQsWUFBWSxDQUFDN2xDLEtBQUQsQ0FBeEIsQ0FDQSxHQUFJNm9DLEtBQUssR0FBSyxJQUFkLENBQW9CLENBQ2xCLE1BQU8sS0FBUCxDQUNELENBQ0QsR0FBSXFVLEtBQUksQ0FBR3AzQyxjQUFjLENBQUNJLElBQWYsQ0FBb0IyaUMsS0FBcEIsQ0FBMkIsYUFBM0IsR0FBNkNBLEtBQUssQ0FBQzE3QixXQUE5RCxDQUNBLE1BQU8sT0FBTyt2QyxLQUFQLEVBQWUsVUFBZixFQUE2QkEsSUFBSSxXQUFZQSxLQUE3QyxFQUNMbFksWUFBWSxDQUFDOStCLElBQWIsQ0FBa0JnM0MsSUFBbEIsR0FBMkIzWCxnQkFEN0IsQ0FFRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJbEcsU0FBUSxDQUFHRCxZQUFZLENBQUdtRCxTQUFTLENBQUNuRCxZQUFELENBQVosQ0FBNkJtVixZQUF4RCxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNtWSxjQUFULENBQXVCMXNELEtBQXZCLENBQThCLENBQzVCLE1BQU9vc0QsVUFBUyxDQUFDcHNELEtBQUQsQ0FBVCxFQUFvQkEsS0FBSyxFQUFJLENBQUM2MUIsZ0JBQTlCLEVBQWtENzFCLEtBQUssRUFBSTYxQixnQkFBbEUsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJeEosTUFBSyxDQUFHaVQsU0FBUyxDQUFHaUQsU0FBUyxDQUFDakQsU0FBRCxDQUFaLENBQTBCa1YsU0FBL0MsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZULFNBQVQsQ0FBa0Jyb0QsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFFBQWhCLEVBQ0osQ0FBQ21HLE9BQU8sQ0FBQ25HLEtBQUQsQ0FBUixFQUFtQndvQyxZQUFZLENBQUN4b0MsS0FBRCxDQUEvQixFQUEwQzJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCcTNCLFNBRGxFLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3FaLFNBQVQsQ0FBa0Ixd0MsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxPQUFPQSxNQUFQLEVBQWdCLFFBQWhCLEVBQ0p3b0MsWUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCczNCLFNBRC9DLENBRUQsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWtJLGFBQVksQ0FBR0QsZ0JBQWdCLENBQUdnRCxTQUFTLENBQUNoRCxnQkFBRCxDQUFaLENBQWlDa1YsZ0JBQXBFLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNsd0MsWUFBVCxDQUFxQnZFLEtBQXJCLENBQTRCLENBQzFCLE1BQU9BLE1BQUssR0FBS25CLFNBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzh0RCxVQUFULENBQW1CM3NELEtBQW5CLENBQTBCLENBQ3hCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1Qmd2QyxNQUFNLENBQUNodkMsS0FBRCxDQUFOLEVBQWlCdzNCLFVBQS9DLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU28xQixVQUFULENBQW1CNXNELEtBQW5CLENBQTBCLENBQ3hCLE1BQU93b0MsYUFBWSxDQUFDeG9DLEtBQUQsQ0FBWixFQUF1QjJ4QyxVQUFVLENBQUMzeEMsS0FBRCxDQUFWLEVBQXFCeTNCLFVBQW5ELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW8xQixHQUFFLENBQUd4TSx5QkFBeUIsQ0FBQ2hMLE1BQUQsQ0FBbEMsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXlYLElBQUcsQ0FBR3pNLHlCQUF5QixDQUFDLFNBQVNyZ0QsS0FBVCxDQUFnQmtYLEtBQWhCLENBQXVCLENBQ3pELE1BQU9sWCxNQUFLLEVBQUlrWCxLQUFoQixDQUNELENBRmtDLENBQW5DLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM3WCxRQUFULENBQWlCVyxLQUFqQixDQUF3QixDQUN0QixHQUFJLENBQUNBLEtBQUwsQ0FBWSxDQUNWLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSXFTLFdBQVcsQ0FBQ3JTLEtBQUQsQ0FBZixDQUF3QixDQUN0QixNQUFPcW9ELFNBQVEsQ0FBQ3JvRCxLQUFELENBQVIsQ0FBa0Jta0MsYUFBYSxDQUFDbmtDLEtBQUQsQ0FBL0IsQ0FBeUM2cEMsU0FBUyxDQUFDN3BDLEtBQUQsQ0FBekQsQ0FDRCxDQUNELEdBQUlpbUMsV0FBVyxFQUFJam1DLEtBQUssQ0FBQ2ltQyxXQUFELENBQXhCLENBQXVDLENBQ3JDLE1BQU96QyxnQkFBZSxDQUFDeGpDLEtBQUssQ0FBQ2ltQyxXQUFELENBQUwsRUFBRCxDQUF0QixDQUNELENBQ0QsR0FBSThJLElBQUcsQ0FBR0MsTUFBTSxDQUFDaHZDLEtBQUQsQ0FBaEIsQ0FDSXkvQixJQUFJLENBQUdzUCxHQUFHLEVBQUlsWSxNQUFQLENBQWdCNE0sVUFBaEIsQ0FBOEJzTCxHQUFHLEVBQUkzWCxNQUFQLENBQWdCME0sVUFBaEIsQ0FBNkJwaEIsTUFEdEUsQ0FHQSxNQUFPK2MsS0FBSSxDQUFDei9CLEtBQUQsQ0FBWCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNvZ0QsU0FBVCxDQUFrQnBnRCxLQUFsQixDQUF5QixDQUN2QixHQUFJLENBQUNBLEtBQUwsQ0FBWSxDQUNWLE1BQU9BLE1BQUssR0FBSyxDQUFWLENBQWNBLEtBQWQsQ0FBc0IsQ0FBN0IsQ0FDRCxDQUNEQSxLQUFLLENBQUdzZ0QsUUFBUSxDQUFDdGdELEtBQUQsQ0FBaEIsQ0FDQSxHQUFJQSxLQUFLLEdBQUs0MUIsUUFBVixFQUFzQjUxQixLQUFLLEdBQUssQ0FBQzQxQixRQUFyQyxDQUErQyxDQUM3QyxHQUFJbTNCLEtBQUksQ0FBSS9zRCxLQUFLLENBQUcsQ0FBUixDQUFZLENBQUMsQ0FBYixDQUFpQixDQUE3QixDQUNBLE1BQU8rc0QsS0FBSSxDQUFHajNCLFdBQWQsQ0FDRCxDQUNELE1BQU85MUIsTUFBSyxHQUFLQSxLQUFWLENBQWtCQSxLQUFsQixDQUEwQixDQUFqQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0d0MsVUFBVCxDQUFtQjV3QyxLQUFuQixDQUEwQixDQUN4QixHQUFJeEQsT0FBTSxDQUFHNGpELFFBQVEsQ0FBQ3BnRCxLQUFELENBQXJCLENBQ0lndEQsU0FBUyxDQUFHeHdELE1BQU0sQ0FBRyxDQUR6QixDQUdBLE1BQU9BLE9BQU0sR0FBS0EsTUFBWCxDQUFxQnd3RCxTQUFTLENBQUd4d0QsTUFBTSxDQUFHd3dELFNBQVosQ0FBd0J4d0QsTUFBdEQsQ0FBZ0UsQ0FBdkUsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNxMEMsU0FBVCxDQUFrQjd3QyxLQUFsQixDQUF5QixDQUN2QixNQUFPQSxNQUFLLENBQUd1dEMsU0FBUyxDQUFDcUQsU0FBUyxDQUFDNXdDLEtBQUQsQ0FBVixDQUFtQixDQUFuQixDQUFzQmcyQixnQkFBdEIsQ0FBWixDQUFzRCxDQUFsRSxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNzcUIsU0FBVCxDQUFrQnRnRCxLQUFsQixDQUF5QixDQUN2QixHQUFJLE1BQU9BLE1BQVAsRUFBZ0IsUUFBcEIsQ0FBOEIsQ0FDNUIsTUFBT0EsTUFBUCxDQUNELENBQ0QsR0FBSTB3QyxRQUFRLENBQUMxd0MsS0FBRCxDQUFaLENBQXFCLENBQ25CLE1BQU8rMUIsSUFBUCxDQUNELENBQ0QsR0FBSStTLFFBQVEsQ0FBQzlvQyxLQUFELENBQVosQ0FBcUIsQ0FDbkIsR0FBSWtYLE1BQUssQ0FBRyxNQUFPbFgsTUFBSyxDQUFDK1YsT0FBYixFQUF3QixVQUF4QixDQUFxQy9WLEtBQUssQ0FBQytWLE9BQU4sRUFBckMsQ0FBdUQvVixLQUFuRSxDQUNBQSxLQUFLLENBQUc4b0MsUUFBUSxDQUFDNXhCLEtBQUQsQ0FBUixDQUFtQkEsS0FBSyxDQUFHLEVBQTNCLENBQWlDQSxLQUF6QyxDQUNELENBQ0QsR0FBSSxNQUFPbFgsTUFBUCxFQUFnQixRQUFwQixDQUE4QixDQUM1QixNQUFPQSxNQUFLLEdBQUssQ0FBVixDQUFjQSxLQUFkLENBQXNCLENBQUNBLEtBQTlCLENBQ0QsQ0FDREEsS0FBSyxDQUFHb2lDLFFBQVEsQ0FBQ3BpQyxLQUFELENBQWhCLENBQ0EsR0FBSWl0RCxTQUFRLENBQUdqekIsVUFBVSxDQUFDc0osSUFBWCxDQUFnQnRqQyxLQUFoQixDQUFmLENBQ0EsTUFBUWl0RCxTQUFRLEVBQUkveUIsU0FBUyxDQUFDb0osSUFBVixDQUFldGpDLEtBQWYsQ0FBYixDQUNIZytCLFlBQVksQ0FBQ2grQixLQUFLLENBQUN3QyxLQUFOLENBQVksQ0FBWixDQUFELENBQWlCeXFELFFBQVEsQ0FBRyxDQUFILENBQU8sQ0FBaEMsQ0FEVCxDQUVGbHpCLFVBQVUsQ0FBQ3VKLElBQVgsQ0FBZ0J0akMsS0FBaEIsRUFBeUIrMUIsR0FBekIsQ0FBK0IsQ0FBQy8xQixLQUZyQyxDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU28yQyxjQUFULENBQXVCcDJDLEtBQXZCLENBQThCLENBQzVCLE1BQU9pdUMsV0FBVSxDQUFDanVDLEtBQUQsQ0FBUW11QyxNQUFNLENBQUNudUMsS0FBRCxDQUFkLENBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTa3RELGNBQVQsQ0FBdUJsdEQsS0FBdkIsQ0FBOEIsQ0FDNUIsTUFBT0EsTUFBSyxDQUNSdXRDLFNBQVMsQ0FBQ3FELFNBQVMsQ0FBQzV3QyxLQUFELENBQVYsQ0FBbUIsQ0FBQzYxQixnQkFBcEIsQ0FBc0NBLGdCQUF0QyxDQURELENBRVA3MUIsS0FBSyxHQUFLLENBQVYsQ0FBY0EsS0FBZCxDQUFzQixDQUYzQixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2lHLFNBQVQsQ0FBa0JqRyxLQUFsQixDQUF5QixDQUN2QixNQUFPQSxNQUFLLEVBQUksSUFBVCxDQUFnQixFQUFoQixDQUFxQms1QyxZQUFZLENBQUNsNUMsS0FBRCxDQUF4QyxDQUNELENBRUQsNEVBNzZWaUQsQ0ErNlZqRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW10RCxPQUFNLENBQUd4USxjQUFjLENBQUMsU0FBUy81QyxNQUFULENBQWlCOEUsTUFBakIsQ0FBeUIsQ0FDbkQsR0FBSXV0QyxXQUFXLENBQUN2dEMsTUFBRCxDQUFYLEVBQXVCMkssV0FBVyxDQUFDM0ssTUFBRCxDQUF0QyxDQUFnRCxDQUM5Q3VtQyxVQUFVLENBQUN2bUMsTUFBRCxDQUFTMUIsSUFBSSxDQUFDMEIsTUFBRCxDQUFiLENBQXVCOUUsTUFBdkIsQ0FBVixDQUNBLE9BQ0QsQ0FDRCxJQUFLLEdBQUl3RSxJQUFULEdBQWdCTSxPQUFoQixDQUF3QixDQUN0QixHQUFJNUIsY0FBYyxDQUFDSSxJQUFmLENBQW9Cd0IsTUFBcEIsQ0FBNEJOLEdBQTVCLENBQUosQ0FBc0MsQ0FDcEN3bUMsV0FBVyxDQUFDaHJDLE1BQUQsQ0FBU3dFLEdBQVQsQ0FBY00sTUFBTSxDQUFDTixHQUFELENBQXBCLENBQVgsQ0FDRCxDQUNGLENBQ0YsQ0FWMEIsQ0FBM0IsQ0FZQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlnbUQsU0FBUSxDQUFHelEsY0FBYyxDQUFDLFNBQVMvNUMsTUFBVCxDQUFpQjhFLE1BQWpCLENBQXlCLENBQ3JEdW1DLFVBQVUsQ0FBQ3ZtQyxNQUFELENBQVN5bUMsTUFBTSxDQUFDem1DLE1BQUQsQ0FBZixDQUF5QjlFLE1BQXpCLENBQVYsQ0FDRCxDQUY0QixDQUE3QixDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJeXFELGFBQVksQ0FBRzFRLGNBQWMsQ0FBQyxTQUFTLzVDLE1BQVQsQ0FBaUI4RSxNQUFqQixDQUF5Qmt1QyxRQUF6QixDQUFtQ2xILFVBQW5DLENBQStDLENBQy9FVCxVQUFVLENBQUN2bUMsTUFBRCxDQUFTeW1DLE1BQU0sQ0FBQ3ptQyxNQUFELENBQWYsQ0FBeUI5RSxNQUF6QixDQUFpQzhyQyxVQUFqQyxDQUFWLENBQ0QsQ0FGZ0MsQ0FBakMsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk0ZSxXQUFVLENBQUczUSxjQUFjLENBQUMsU0FBUy81QyxNQUFULENBQWlCOEUsTUFBakIsQ0FBeUJrdUMsUUFBekIsQ0FBbUNsSCxVQUFuQyxDQUErQyxDQUM3RVQsVUFBVSxDQUFDdm1DLE1BQUQsQ0FBUzFCLElBQUksQ0FBQzBCLE1BQUQsQ0FBYixDQUF1QjlFLE1BQXZCLENBQStCOHJDLFVBQS9CLENBQVYsQ0FDRCxDQUY4QixDQUEvQixDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJNmUsR0FBRSxDQUFHbFAsUUFBUSxDQUFDalEsTUFBRCxDQUFqQixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2xoQyxPQUFULENBQWdCckksU0FBaEIsQ0FBMkIyb0QsVUFBM0IsQ0FBdUMsQ0FDckMsR0FBSWh4RCxPQUFNLENBQUdvc0MsVUFBVSxDQUFDL2pDLFNBQUQsQ0FBdkIsQ0FDQSxNQUFPMm9ELFdBQVUsRUFBSSxJQUFkLENBQXFCaHhELE1BQXJCLENBQThCd3hDLFVBQVUsQ0FBQ3h4QyxNQUFELENBQVNneEQsVUFBVCxDQUEvQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTlvQixTQUFRLENBQUc0UyxRQUFRLENBQUMsU0FBUzEwQyxNQUFULENBQWlCaTZDLE9BQWpCLENBQTBCLENBQ2hEajZDLE1BQU0sQ0FBR21ELE1BQU0sQ0FBQ25ELE1BQUQsQ0FBZixDQUVBLEdBQUlvRSxNQUFLLENBQUcsQ0FBQyxDQUFiLENBQ0EsR0FBSWxJLE9BQU0sQ0FBRys5QyxPQUFPLENBQUMvOUMsTUFBckIsQ0FDQSxHQUFJZytDLE1BQUssQ0FBR2grQyxNQUFNLENBQUcsQ0FBVCxDQUFhKzlDLE9BQU8sQ0FBQyxDQUFELENBQXBCLENBQTBCaCtDLFNBQXRDLENBRUEsR0FBSWkrQyxLQUFLLEVBQUlDLGNBQWMsQ0FBQ0YsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFhQSxPQUFPLENBQUMsQ0FBRCxDQUFwQixDQUF5QkMsS0FBekIsQ0FBM0IsQ0FBNEQsQ0FDMURoK0MsTUFBTSxDQUFHLENBQVQsQ0FDRCxDQUVELE1BQU8sRUFBRWtJLEtBQUYsQ0FBVWxJLE1BQWpCLENBQXlCLENBQ3ZCLEdBQUk0SSxPQUFNLENBQUdtMUMsT0FBTyxDQUFDNzFDLEtBQUQsQ0FBcEIsQ0FDQSxHQUFJbTdCLE1BQUssQ0FBR2dNLE1BQU0sQ0FBQ3ptQyxNQUFELENBQWxCLENBQ0EsR0FBSStsRCxXQUFVLENBQUcsQ0FBQyxDQUFsQixDQUNBLEdBQUlDLFlBQVcsQ0FBR3ZyQixLQUFLLENBQUNyakMsTUFBeEIsQ0FFQSxNQUFPLEVBQUUydUQsVUFBRixDQUFlQyxXQUF0QixDQUFtQyxDQUNqQyxHQUFJdG1ELElBQUcsQ0FBRys2QixLQUFLLENBQUNzckIsVUFBRCxDQUFmLENBQ0EsR0FBSXp0RCxNQUFLLENBQUc0QyxNQUFNLENBQUN3RSxHQUFELENBQWxCLENBRUEsR0FBSXBILEtBQUssR0FBS25CLFNBQVYsRUFDQzZ1QyxFQUFFLENBQUMxdEMsS0FBRCxDQUFROGtDLFdBQVcsQ0FBQzE5QixHQUFELENBQW5CLENBQUYsRUFBK0IsQ0FBQ3RCLGNBQWMsQ0FBQ0ksSUFBZixDQUFvQnRELE1BQXBCLENBQTRCd0UsR0FBNUIsQ0FEckMsQ0FDd0UsQ0FDdEV4RSxNQUFNLENBQUN3RSxHQUFELENBQU4sQ0FBY00sTUFBTSxDQUFDTixHQUFELENBQXBCLENBQ0QsQ0FDRixDQUNGLENBRUQsTUFBT3hFLE9BQVAsQ0FDRCxDQTdCc0IsQ0FBdkIsQ0ErQkE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJK3FELGFBQVksQ0FBR3JXLFFBQVEsQ0FBQyxTQUFTeHZDLElBQVQsQ0FBZSxDQUN6Q0EsSUFBSSxDQUFDbUMsSUFBTCxDQUFVcEwsU0FBVixDQUFxQjBpRCxtQkFBckIsRUFDQSxNQUFPNzhDLE1BQUssQ0FBQzhXLFNBQUQsQ0FBWTNjLFNBQVosQ0FBdUJpSixJQUF2QixDQUFaLENBQ0QsQ0FIMEIsQ0FBM0IsQ0FLQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3lvQixRQUFULENBQWlCM3RCLE1BQWpCLENBQXlCdUUsU0FBekIsQ0FBb0MsQ0FDbEMsTUFBTys1QixZQUFXLENBQUN0K0IsTUFBRCxDQUFTNHpDLFdBQVcsQ0FBQ3J2QyxTQUFELENBQVksQ0FBWixDQUFwQixDQUFvQ2twQyxVQUFwQyxDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMzZixZQUFULENBQXFCOXRCLE1BQXJCLENBQTZCdUUsU0FBN0IsQ0FBd0MsQ0FDdEMsTUFBTys1QixZQUFXLENBQUN0K0IsTUFBRCxDQUFTNHpDLFdBQVcsQ0FBQ3J2QyxTQUFELENBQVksQ0FBWixDQUFwQixDQUFvQ29wQyxlQUFwQyxDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTcWQsTUFBVCxDQUFlaHJELE1BQWYsQ0FBdUJpOUIsUUFBdkIsQ0FBaUMsQ0FDL0IsTUFBT2o5QixPQUFNLEVBQUksSUFBVixDQUNIQSxNQURHLENBRUhzdUMsT0FBTyxDQUFDdHVDLE1BQUQsQ0FBUzR6QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFwQixDQUFtQ3NPLE1BQW5DLENBRlgsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMGYsV0FBVCxDQUFvQmpyRCxNQUFwQixDQUE0Qmk5QixRQUE1QixDQUFzQyxDQUNwQyxNQUFPajlCLE9BQU0sRUFBSSxJQUFWLENBQ0hBLE1BREcsQ0FFSHd1QyxZQUFZLENBQUN4dUMsTUFBRCxDQUFTNHpDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQXBCLENBQW1Dc08sTUFBbkMsQ0FGaEIsQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJmLE9BQVQsQ0FBZ0JsckQsTUFBaEIsQ0FBd0JpOUIsUUFBeEIsQ0FBa0MsQ0FDaEMsTUFBT2o5QixPQUFNLEVBQUl5dEMsVUFBVSxDQUFDenRDLE1BQUQsQ0FBUzR6QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFwQixDQUEzQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrdUIsWUFBVCxDQUFxQm5yRCxNQUFyQixDQUE2Qmk5QixRQUE3QixDQUF1QyxDQUNyQyxNQUFPajlCLE9BQU0sRUFBSTJ0QyxlQUFlLENBQUMzdEMsTUFBRCxDQUFTNHpDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQXBCLENBQWhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzE5QixVQUFULENBQW1CUyxNQUFuQixDQUEyQixDQUN6QixNQUFPQSxPQUFNLEVBQUksSUFBVixDQUFpQixFQUFqQixDQUFzQnl1QyxhQUFhLENBQUN6dUMsTUFBRCxDQUFTb0QsSUFBSSxDQUFDcEQsTUFBRCxDQUFiLENBQTFDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU29yRCxZQUFULENBQXFCcHJELE1BQXJCLENBQTZCLENBQzNCLE1BQU9BLE9BQU0sRUFBSSxJQUFWLENBQWlCLEVBQWpCLENBQXNCeXVDLGFBQWEsQ0FBQ3p1QyxNQUFELENBQVN1ckMsTUFBTSxDQUFDdnJDLE1BQUQsQ0FBZixDQUExQyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaVIsSUFBVCxDQUFhalIsTUFBYixDQUFxQmtKLElBQXJCLENBQTJCOHpDLFlBQTNCLENBQXlDLENBQ3ZDLEdBQUlwakQsT0FBTSxDQUFHb0csTUFBTSxFQUFJLElBQVYsQ0FBaUIvRCxTQUFqQixDQUE2Qnl5QyxPQUFPLENBQUMxdUMsTUFBRCxDQUFTa0osSUFBVCxDQUFqRCxDQUNBLE1BQU90UCxPQUFNLEdBQUtxQyxTQUFYLENBQXVCK2dELFlBQXZCLENBQXNDcGpELE1BQTdDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdVgsSUFBVCxDQUFhblIsTUFBYixDQUFxQmtKLElBQXJCLENBQTJCLENBQ3pCLE1BQU9sSixPQUFNLEVBQUksSUFBVixFQUFrQi9CLE9BQU8sQ0FBQytCLE1BQUQsQ0FBU2tKLElBQVQsQ0FBZWltQyxPQUFmLENBQWhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzlnQixNQUFULENBQWVydUIsTUFBZixDQUF1QmtKLElBQXZCLENBQTZCLENBQzNCLE1BQU9sSixPQUFNLEVBQUksSUFBVixFQUFrQi9CLE9BQU8sQ0FBQytCLE1BQUQsQ0FBU2tKLElBQVQsQ0FBZWttQyxTQUFmLENBQWhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJaWMsT0FBTSxDQUFHek8sY0FBYyxDQUFDLFNBQVNoakQsTUFBVCxDQUFpQndELEtBQWpCLENBQXdCb0gsR0FBeEIsQ0FBNkIsQ0FDdkQsR0FBSXBILEtBQUssRUFBSSxJQUFULEVBQ0EsTUFBT0EsTUFBSyxDQUFDaUcsUUFBYixFQUF5QixVQUQ3QixDQUN5QyxDQUN2Q2pHLEtBQUssQ0FBR3NsQyxvQkFBb0IsQ0FBQ3AvQixJQUFyQixDQUEwQmxHLEtBQTFCLENBQVIsQ0FDRCxDQUVEeEQsTUFBTSxDQUFDd0QsS0FBRCxDQUFOLENBQWdCb0gsR0FBaEIsQ0FDRCxDQVAwQixDQU94Qnl3QyxRQUFRLENBQUNqRCxRQUFELENBUGdCLENBQTNCLENBU0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlzWixTQUFRLENBQUcxTyxjQUFjLENBQUMsU0FBU2hqRCxNQUFULENBQWlCd0QsS0FBakIsQ0FBd0JvSCxHQUF4QixDQUE2QixDQUN6RCxHQUFJcEgsS0FBSyxFQUFJLElBQVQsRUFDQSxNQUFPQSxNQUFLLENBQUNpRyxRQUFiLEVBQXlCLFVBRDdCLENBQ3lDLENBQ3ZDakcsS0FBSyxDQUFHc2xDLG9CQUFvQixDQUFDcC9CLElBQXJCLENBQTBCbEcsS0FBMUIsQ0FBUixDQUNELENBRUQsR0FBSThGLGNBQWMsQ0FBQ0ksSUFBZixDQUFvQjFKLE1BQXBCLENBQTRCd0QsS0FBNUIsQ0FBSixDQUF3QyxDQUN0Q3hELE1BQU0sQ0FBQ3dELEtBQUQsQ0FBTixDQUFjaUssSUFBZCxDQUFtQjdDLEdBQW5CLEVBQ0QsQ0FGRCxJQUVPLENBQ0w1SyxNQUFNLENBQUN3RCxLQUFELENBQU4sQ0FBZ0IsQ0FBQ29ILEdBQUQsQ0FBaEIsQ0FDRCxDQUNGLENBWDRCLENBVzFCb3ZDLFdBWDBCLENBQTdCLENBYUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTJYLE9BQU0sQ0FBRzdXLFFBQVEsQ0FBQzVFLFVBQUQsQ0FBckIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMxc0MsS0FBVCxDQUFjcEQsTUFBZCxDQUFzQixDQUNwQixNQUFPeVAsWUFBVyxDQUFDelAsTUFBRCxDQUFYLENBQXNCK3BDLGFBQWEsQ0FBQy9wQyxNQUFELENBQW5DLENBQThDb3lDLFFBQVEsQ0FBQ3B5QyxNQUFELENBQTdELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3VyQyxPQUFULENBQWdCdnJDLE1BQWhCLENBQXdCLENBQ3RCLE1BQU95UCxZQUFXLENBQUN6UCxNQUFELENBQVgsQ0FBc0IrcEMsYUFBYSxDQUFDL3BDLE1BQUQsQ0FBUyxJQUFULENBQW5DLENBQW9Ec3lDLFVBQVUsQ0FBQ3R5QyxNQUFELENBQXJFLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNnZCLFFBQVQsQ0FBaUI3dkIsTUFBakIsQ0FBeUJpOUIsUUFBekIsQ0FBbUMsQ0FDakMsR0FBSXJqQyxPQUFNLENBQUcsRUFBYixDQUNBcWpDLFFBQVEsQ0FBRzJXLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQXRCLENBRUF3USxVQUFVLENBQUN6dEMsTUFBRCxDQUFTLFNBQVM1QyxLQUFULENBQWdCb0gsR0FBaEIsQ0FBcUJ4RSxNQUFyQixDQUE2QixDQUM5QytxQyxlQUFlLENBQUNueEMsTUFBRCxDQUFTcWpDLFFBQVEsQ0FBQzcvQixLQUFELENBQVFvSCxHQUFSLENBQWF4RSxNQUFiLENBQWpCLENBQXVDNUMsS0FBdkMsQ0FBZixDQUNELENBRlMsQ0FBVixDQUdBLE1BQU94RCxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM0eEQsVUFBVCxDQUFtQnhyRCxNQUFuQixDQUEyQmk5QixRQUEzQixDQUFxQyxDQUNuQyxHQUFJcmpDLE9BQU0sQ0FBRyxFQUFiLENBQ0FxakMsUUFBUSxDQUFHMlcsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBdEIsQ0FFQXdRLFVBQVUsQ0FBQ3p0QyxNQUFELENBQVMsU0FBUzVDLEtBQVQsQ0FBZ0JvSCxHQUFoQixDQUFxQnhFLE1BQXJCLENBQTZCLENBQzlDK3FDLGVBQWUsQ0FBQ254QyxNQUFELENBQVM0SyxHQUFULENBQWN5NEIsUUFBUSxDQUFDNy9CLEtBQUQsQ0FBUW9ILEdBQVIsQ0FBYXhFLE1BQWIsQ0FBdEIsQ0FBZixDQUNELENBRlMsQ0FBVixDQUdBLE1BQU9wRyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk4ZSxNQUFLLENBQUdxaEMsY0FBYyxDQUFDLFNBQVMvNUMsTUFBVCxDQUFpQjhFLE1BQWpCLENBQXlCa3VDLFFBQXpCLENBQW1DLENBQzVERCxTQUFTLENBQUMveUMsTUFBRCxDQUFTOEUsTUFBVCxDQUFpQmt1QyxRQUFqQixDQUFULENBQ0QsQ0FGeUIsQ0FBMUIsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlwNkIsVUFBUyxDQUFHbWhDLGNBQWMsQ0FBQyxTQUFTLzVDLE1BQVQsQ0FBaUI4RSxNQUFqQixDQUF5Qmt1QyxRQUF6QixDQUFtQ2xILFVBQW5DLENBQStDLENBQzVFaUgsU0FBUyxDQUFDL3lDLE1BQUQsQ0FBUzhFLE1BQVQsQ0FBaUJrdUMsUUFBakIsQ0FBMkJsSCxVQUEzQixDQUFULENBQ0QsQ0FGNkIsQ0FBOUIsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTJmLEtBQUksQ0FBR2hRLFFBQVEsQ0FBQyxTQUFTejdDLE1BQVQsQ0FBaUJ5ckMsS0FBakIsQ0FBd0IsQ0FDMUMsR0FBSTd4QyxPQUFNLENBQUcsRUFBYixDQUNBLEdBQUlvRyxNQUFNLEVBQUksSUFBZCxDQUFvQixDQUNsQixNQUFPcEcsT0FBUCxDQUNELENBQ0QsR0FBSW15QyxPQUFNLENBQUcsS0FBYixDQUNBTixLQUFLLENBQUc5TixRQUFRLENBQUM4TixLQUFELENBQVEsU0FBU3ZpQyxJQUFULENBQWUsQ0FDckNBLElBQUksQ0FBR3lsQyxRQUFRLENBQUN6bEMsSUFBRCxDQUFPbEosTUFBUCxDQUFmLENBQ0ErckMsTUFBTSxHQUFLQSxNQUFNLENBQUc3aUMsSUFBSSxDQUFDaE4sTUFBTCxDQUFjLENBQTVCLENBQU4sQ0FDQSxNQUFPZ04sS0FBUCxDQUNELENBSmUsQ0FBaEIsQ0FLQW1pQyxVQUFVLENBQUNyckMsTUFBRCxDQUFTOHNDLFlBQVksQ0FBQzlzQyxNQUFELENBQXJCLENBQStCcEcsTUFBL0IsQ0FBVixDQUNBLEdBQUlteUMsTUFBSixDQUFZLENBQ1ZueUMsTUFBTSxDQUFHZ3lDLFNBQVMsQ0FBQ2h5QyxNQUFELENBQVM4M0IsZUFBZSxDQUFHQyxlQUFsQixDQUFvQ0Msa0JBQTdDLENBQWlFZ3RCLGVBQWpFLENBQWxCLENBQ0QsQ0FDRCxHQUFJMWlELE9BQU0sQ0FBR3V2QyxLQUFLLENBQUN2dkMsTUFBbkIsQ0FDQSxNQUFPQSxNQUFNLEVBQWIsQ0FBaUIsQ0FDZnE0QyxTQUFTLENBQUMzNkMsTUFBRCxDQUFTNnhDLEtBQUssQ0FBQ3Z2QyxNQUFELENBQWQsQ0FBVCxDQUNELENBQ0QsTUFBT3RDLE9BQVAsQ0FDRCxDQXBCa0IsQ0FBbkIsQ0FzQkE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVM4eEQsT0FBVCxDQUFnQjFyRCxNQUFoQixDQUF3QnVFLFNBQXhCLENBQW1DLENBQ2pDLE1BQU9vbkQsT0FBTSxDQUFDM3JELE1BQUQsQ0FBUytsRCxNQUFNLENBQUNuUyxXQUFXLENBQUNydkMsU0FBRCxDQUFaLENBQWYsQ0FBYixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl3OUIsS0FBSSxDQUFHMFosUUFBUSxDQUFDLFNBQVN6N0MsTUFBVCxDQUFpQnlyQyxLQUFqQixDQUF3QixDQUMxQyxNQUFPenJDLE9BQU0sRUFBSSxJQUFWLENBQWlCLEVBQWpCLENBQXNCK3pDLFFBQVEsQ0FBQy96QyxNQUFELENBQVN5ckMsS0FBVCxDQUFyQyxDQUNELENBRmtCLENBQW5CLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2tnQixPQUFULENBQWdCM3JELE1BQWhCLENBQXdCdUUsU0FBeEIsQ0FBbUMsQ0FDakMsR0FBSXZFLE1BQU0sRUFBSSxJQUFkLENBQW9CLENBQ2xCLE1BQU8sRUFBUCxDQUNELENBQ0QsR0FBSXUvQixNQUFLLENBQUc1QixRQUFRLENBQUNtUCxZQUFZLENBQUM5c0MsTUFBRCxDQUFiLENBQXVCLFNBQVM0ckQsSUFBVCxDQUFlLENBQ3hELE1BQU8sQ0FBQ0EsSUFBRCxDQUFQLENBQ0QsQ0FGbUIsQ0FBcEIsQ0FHQXJuRCxTQUFTLENBQUdxdkMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBdkIsQ0FDQSxNQUFPeXZDLFdBQVUsQ0FBQ2gwQyxNQUFELENBQVN1L0IsS0FBVCxDQUFnQixTQUFTbmlDLEtBQVQsQ0FBZ0I4TCxJQUFoQixDQUFzQixDQUNyRCxNQUFPM0UsVUFBUyxDQUFDbkgsS0FBRCxDQUFROEwsSUFBSSxDQUFDLENBQUQsQ0FBWixDQUFoQixDQUNELENBRmdCLENBQWpCLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3RQLE9BQVQsQ0FBZ0JvRyxNQUFoQixDQUF3QmtKLElBQXhCLENBQThCOHpDLFlBQTlCLENBQTRDLENBQzFDOXpDLElBQUksQ0FBR3lsQyxRQUFRLENBQUN6bEMsSUFBRCxDQUFPbEosTUFBUCxDQUFmLENBRUEsR0FBSW9FLE1BQUssQ0FBRyxDQUFDLENBQWIsQ0FDSWxJLE1BQU0sQ0FBR2dOLElBQUksQ0FBQ2hOLE1BRGxCLENBR0E7QUFDQSxHQUFJLENBQUNBLE1BQUwsQ0FBYSxDQUNYQSxNQUFNLENBQUcsQ0FBVCxDQUNBOEQsTUFBTSxDQUFHL0QsU0FBVCxDQUNELENBQ0QsTUFBTyxFQUFFbUksS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSWtCLE1BQUssQ0FBRzRDLE1BQU0sRUFBSSxJQUFWLENBQWlCL0QsU0FBakIsQ0FBNkIrRCxNQUFNLENBQUM0dUMsS0FBSyxDQUFDMWxDLElBQUksQ0FBQzlFLEtBQUQsQ0FBTCxDQUFOLENBQS9DLENBQ0EsR0FBSWhILEtBQUssR0FBS25CLFNBQWQsQ0FBeUIsQ0FDdkJtSSxLQUFLLENBQUdsSSxNQUFSLENBQ0FrQixLQUFLLENBQUc0L0MsWUFBUixDQUNELENBQ0RoOUMsTUFBTSxDQUFHNkIsVUFBVSxDQUFDekUsS0FBRCxDQUFWLENBQW9CQSxLQUFLLENBQUNrRyxJQUFOLENBQVd0RCxNQUFYLENBQXBCLENBQXlDNUMsS0FBbEQsQ0FDRCxDQUNELE1BQU80QyxPQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNnWCxJQUFULENBQWFoWCxNQUFiLENBQXFCa0osSUFBckIsQ0FBMkI5TCxLQUEzQixDQUFrQyxDQUNoQyxNQUFPNEMsT0FBTSxFQUFJLElBQVYsQ0FBaUJBLE1BQWpCLENBQTBCaTBDLE9BQU8sQ0FBQ2owQyxNQUFELENBQVNrSixJQUFULENBQWU5TCxLQUFmLENBQXhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeXVELFFBQVQsQ0FBaUI3ckQsTUFBakIsQ0FBeUJrSixJQUF6QixDQUErQjlMLEtBQS9CLENBQXNDMHVDLFVBQXRDLENBQWtELENBQ2hEQSxVQUFVLENBQUcsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0M3dkMsU0FBNUQsQ0FDQSxNQUFPK0QsT0FBTSxFQUFJLElBQVYsQ0FBaUJBLE1BQWpCLENBQTBCaTBDLE9BQU8sQ0FBQ2owQyxNQUFELENBQVNrSixJQUFULENBQWU5TCxLQUFmLENBQXNCMHVDLFVBQXRCLENBQXhDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJZ2dCLFFBQU8sQ0FBR3ZOLGFBQWEsQ0FBQ243QyxJQUFELENBQTNCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTJvRCxVQUFTLENBQUd4TixhQUFhLENBQUNoVCxNQUFELENBQTdCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3hLLFVBQVQsQ0FBbUIvZ0MsTUFBbkIsQ0FBMkJpOUIsUUFBM0IsQ0FBcUNDLFdBQXJDLENBQWtELENBQ2hELEdBQUltSyxNQUFLLENBQUc5akMsT0FBTyxDQUFDdkQsTUFBRCxDQUFuQixDQUNJZ3NELFNBQVMsQ0FBRzNrQixLQUFLLEVBQUluRCxRQUFRLENBQUNsa0MsTUFBRCxDQUFqQixFQUE2QjQ4QixZQUFZLENBQUM1OEIsTUFBRCxDQUR6RCxDQUdBaTlCLFFBQVEsQ0FBRzJXLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQXRCLENBQ0EsR0FBSUMsV0FBVyxFQUFJLElBQW5CLENBQXlCLENBQ3ZCLEdBQUlvZCxLQUFJLENBQUd0NkMsTUFBTSxFQUFJQSxNQUFNLENBQUN1SyxXQUE1QixDQUNBLEdBQUl5aEQsU0FBSixDQUFlLENBQ2I5dUIsV0FBVyxDQUFHbUssS0FBSyxDQUFHLEdBQUlpVCxLQUFKLEVBQUgsQ0FBYyxFQUFqQyxDQUNELENBRkQsSUFHSyxJQUFJcFUsUUFBUSxDQUFDbG1DLE1BQUQsQ0FBWixDQUFzQixDQUN6Qms5QixXQUFXLENBQUdyN0IsVUFBVSxDQUFDeTRDLElBQUQsQ0FBVixDQUFtQnRVLFVBQVUsQ0FBQy9DLFlBQVksQ0FBQ2pqQyxNQUFELENBQWIsQ0FBN0IsQ0FBc0QsRUFBcEUsQ0FDRCxDQUZJLElBR0EsQ0FDSGs5QixXQUFXLENBQUcsRUFBZCxDQUNELENBQ0YsQ0FDRCxDQUFDOHVCLFNBQVMsQ0FBRzd1QixTQUFILENBQWVzUSxVQUF6QixFQUFxQ3p0QyxNQUFyQyxDQUE2QyxTQUFTNUMsS0FBVCxDQUFnQmdILEtBQWhCLENBQXVCcEUsTUFBdkIsQ0FBK0IsQ0FDMUUsTUFBT2k5QixTQUFRLENBQUNDLFdBQUQsQ0FBYzkvQixLQUFkLENBQXFCZ0gsS0FBckIsQ0FBNEJwRSxNQUE1QixDQUFmLENBQ0QsQ0FGRCxFQUdBLE1BQU9rOUIsWUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUyt1QixNQUFULENBQWVqc0QsTUFBZixDQUF1QmtKLElBQXZCLENBQTZCLENBQzNCLE1BQU9sSixPQUFNLEVBQUksSUFBVixDQUFpQixJQUFqQixDQUF3QnUwQyxTQUFTLENBQUN2MEMsTUFBRCxDQUFTa0osSUFBVCxDQUF4QyxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3hOLE9BQVQsQ0FBZ0JzRSxNQUFoQixDQUF3QmtKLElBQXhCLENBQThCaVAsT0FBOUIsQ0FBdUMsQ0FDckMsTUFBT25ZLE9BQU0sRUFBSSxJQUFWLENBQWlCQSxNQUFqQixDQUEwQjAyQyxVQUFVLENBQUMxMkMsTUFBRCxDQUFTa0osSUFBVCxDQUFlaXVDLFlBQVksQ0FBQ2gvQixPQUFELENBQTNCLENBQTNDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTK3pDLFdBQVQsQ0FBb0Jsc0QsTUFBcEIsQ0FBNEJrSixJQUE1QixDQUFrQ2lQLE9BQWxDLENBQTJDMnpCLFVBQTNDLENBQXVELENBQ3JEQSxVQUFVLENBQUcsTUFBT0EsV0FBUCxFQUFxQixVQUFyQixDQUFrQ0EsVUFBbEMsQ0FBK0M3dkMsU0FBNUQsQ0FDQSxNQUFPK0QsT0FBTSxFQUFJLElBQVYsQ0FBaUJBLE1BQWpCLENBQTBCMDJDLFVBQVUsQ0FBQzEyQyxNQUFELENBQVNrSixJQUFULENBQWVpdUMsWUFBWSxDQUFDaC9CLE9BQUQsQ0FBM0IsQ0FBc0MyekIsVUFBdEMsQ0FBM0MsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaHNCLE9BQVQsQ0FBZ0I5ZixNQUFoQixDQUF3QixDQUN0QixNQUFPQSxPQUFNLEVBQUksSUFBVixDQUFpQixFQUFqQixDQUFzQjQvQixVQUFVLENBQUM1L0IsTUFBRCxDQUFTb0QsSUFBSSxDQUFDcEQsTUFBRCxDQUFiLENBQXZDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbXNELFNBQVQsQ0FBa0Juc0QsTUFBbEIsQ0FBMEIsQ0FDeEIsTUFBT0EsT0FBTSxFQUFJLElBQVYsQ0FBaUIsRUFBakIsQ0FBc0I0L0IsVUFBVSxDQUFDNS9CLE1BQUQsQ0FBU3VyQyxNQUFNLENBQUN2ckMsTUFBRCxDQUFmLENBQXZDLENBQ0QsQ0FFRCw0RUFweVlpRCxDQXN5WWpEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU29zRCxNQUFULENBQWUzcUQsTUFBZixDQUF1QmlxQyxLQUF2QixDQUE4QkMsS0FBOUIsQ0FBcUMsQ0FDbkMsR0FBSUEsS0FBSyxHQUFLMXZDLFNBQWQsQ0FBeUIsQ0FDdkIwdkMsS0FBSyxDQUFHRCxLQUFSLENBQ0FBLEtBQUssQ0FBR3p2QyxTQUFSLENBQ0QsQ0FDRCxHQUFJMHZDLEtBQUssR0FBSzF2QyxTQUFkLENBQXlCLENBQ3ZCMHZDLEtBQUssQ0FBRytSLFFBQVEsQ0FBQy9SLEtBQUQsQ0FBaEIsQ0FDQUEsS0FBSyxDQUFHQSxLQUFLLEdBQUtBLEtBQVYsQ0FBa0JBLEtBQWxCLENBQTBCLENBQWxDLENBQ0QsQ0FDRCxHQUFJRCxLQUFLLEdBQUt6dkMsU0FBZCxDQUF5QixDQUN2Qnl2QyxLQUFLLENBQUdnUyxRQUFRLENBQUNoUyxLQUFELENBQWhCLENBQ0FBLEtBQUssQ0FBR0EsS0FBSyxHQUFLQSxLQUFWLENBQWtCQSxLQUFsQixDQUEwQixDQUFsQyxDQUNELENBQ0QsTUFBT2YsVUFBUyxDQUFDK1MsUUFBUSxDQUFDajhDLE1BQUQsQ0FBVCxDQUFtQmlxQyxLQUFuQixDQUEwQkMsS0FBMUIsQ0FBaEIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNXFDLFFBQVQsQ0FBaUJVLE1BQWpCLENBQXlCaVQsS0FBekIsQ0FBZ0NoSCxHQUFoQyxDQUFxQyxDQUNuQ2dILEtBQUssQ0FBRzhvQyxRQUFRLENBQUM5b0MsS0FBRCxDQUFoQixDQUNBLEdBQUloSCxHQUFHLEdBQUt6UixTQUFaLENBQXVCLENBQ3JCeVIsR0FBRyxDQUFHZ0gsS0FBTixDQUNBQSxLQUFLLENBQUcsQ0FBUixDQUNELENBSEQsSUFHTyxDQUNMaEgsR0FBRyxDQUFHOHZDLFFBQVEsQ0FBQzl2QyxHQUFELENBQWQsQ0FDRCxDQUNEak0sTUFBTSxDQUFHaThDLFFBQVEsQ0FBQ2o4QyxNQUFELENBQWpCLENBQ0EsTUFBTzR0QyxZQUFXLENBQUM1dEMsTUFBRCxDQUFTaVQsS0FBVCxDQUFnQmhILEdBQWhCLENBQWxCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNrM0IsT0FBVCxDQUFnQjhHLEtBQWhCLENBQXVCQyxLQUF2QixDQUE4QjBnQixRQUE5QixDQUF3QyxDQUN0QyxHQUFJQSxRQUFRLEVBQUksTUFBT0EsU0FBUCxFQUFtQixTQUEvQixFQUE0Q2xTLGNBQWMsQ0FBQ3pPLEtBQUQsQ0FBUUMsS0FBUixDQUFlMGdCLFFBQWYsQ0FBOUQsQ0FBd0YsQ0FDdEYxZ0IsS0FBSyxDQUFHMGdCLFFBQVEsQ0FBR3B3RCxTQUFuQixDQUNELENBQ0QsR0FBSW93RCxRQUFRLEdBQUtwd0QsU0FBakIsQ0FBNEIsQ0FDMUIsR0FBSSxNQUFPMHZDLE1BQVAsRUFBZ0IsU0FBcEIsQ0FBK0IsQ0FDN0IwZ0IsUUFBUSxDQUFHMWdCLEtBQVgsQ0FDQUEsS0FBSyxDQUFHMXZDLFNBQVIsQ0FDRCxDQUhELElBSUssSUFBSSxNQUFPeXZDLE1BQVAsRUFBZ0IsU0FBcEIsQ0FBK0IsQ0FDbEMyZ0IsUUFBUSxDQUFHM2dCLEtBQVgsQ0FDQUEsS0FBSyxDQUFHenZDLFNBQVIsQ0FDRCxDQUNGLENBQ0QsR0FBSXl2QyxLQUFLLEdBQUt6dkMsU0FBVixFQUF1QjB2QyxLQUFLLEdBQUsxdkMsU0FBckMsQ0FBZ0QsQ0FDOUN5dkMsS0FBSyxDQUFHLENBQVIsQ0FDQUMsS0FBSyxDQUFHLENBQVIsQ0FDRCxDQUhELElBSUssQ0FDSEQsS0FBSyxDQUFHOFIsUUFBUSxDQUFDOVIsS0FBRCxDQUFoQixDQUNBLEdBQUlDLEtBQUssR0FBSzF2QyxTQUFkLENBQXlCLENBQ3ZCMHZDLEtBQUssQ0FBR0QsS0FBUixDQUNBQSxLQUFLLENBQUcsQ0FBUixDQUNELENBSEQsSUFHTyxDQUNMQyxLQUFLLENBQUc2UixRQUFRLENBQUM3UixLQUFELENBQWhCLENBQ0QsQ0FDRixDQUNELEdBQUlELEtBQUssQ0FBR0MsS0FBWixDQUFtQixDQUNqQixHQUFJMmdCLEtBQUksQ0FBRzVnQixLQUFYLENBQ0FBLEtBQUssQ0FBR0MsS0FBUixDQUNBQSxLQUFLLENBQUcyZ0IsSUFBUixDQUNELENBQ0QsR0FBSUQsUUFBUSxFQUFJM2dCLEtBQUssQ0FBRyxDQUFwQixFQUF5QkMsS0FBSyxDQUFHLENBQXJDLENBQXdDLENBQ3RDLEdBQUk2VixLQUFJLENBQUc3YyxZQUFZLEVBQXZCLENBQ0EsTUFBT0gsVUFBUyxDQUFDa0gsS0FBSyxDQUFJOFYsSUFBSSxFQUFJN1YsS0FBSyxDQUFHRCxLQUFSLENBQWdCeFEsY0FBYyxDQUFDLE9BQVMsQ0FBQ3NtQixJQUFJLENBQUcsRUFBUixFQUFZdGxELE1BQVosQ0FBcUIsQ0FBOUIsQ0FBRCxDQUFsQyxDQUFkLENBQXNGeXZDLEtBQXRGLENBQWhCLENBQ0QsQ0FDRCxNQUFPbkIsV0FBVSxDQUFDa0IsS0FBRCxDQUFRQyxLQUFSLENBQWpCLENBQ0QsQ0FFRCw0RUFqOFlpRCxDQW04WWpEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJNGdCLFVBQVMsQ0FBRzNSLGdCQUFnQixDQUFDLFNBQVNoaEQsTUFBVCxDQUFpQjR5RCxJQUFqQixDQUF1QnBvRCxLQUF2QixDQUE4QixDQUM3RG9vRCxJQUFJLENBQUdBLElBQUksQ0FBQ0MsV0FBTCxFQUFQLENBQ0EsTUFBTzd5RCxPQUFNLEVBQUl3SyxLQUFLLENBQUdzb0QsVUFBVSxDQUFDRixJQUFELENBQWIsQ0FBc0JBLElBQS9CLENBQWIsQ0FDRCxDQUgrQixDQUFoQyxDQUtBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNFLFdBQVQsQ0FBb0I5ckQsTUFBcEIsQ0FBNEIsQ0FDMUIsTUFBTytyRCxXQUFVLENBQUN0cEQsUUFBUSxDQUFDekMsTUFBRCxDQUFSLENBQWlCNnJELFdBQWpCLEVBQUQsQ0FBakIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMxUixPQUFULENBQWdCbjZDLE1BQWhCLENBQXdCLENBQ3RCQSxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBQ0EsTUFBT0EsT0FBTSxFQUFJQSxNQUFNLENBQUM4K0IsT0FBUCxDQUFlbEksT0FBZixDQUF3QjRJLFlBQXhCLEVBQXNDVixPQUF0QyxDQUE4Q3JGLFdBQTlDLENBQTJELEVBQTNELENBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3V5QixTQUFULENBQWtCaHNELE1BQWxCLENBQTBCaUUsTUFBMUIsQ0FBa0Nnb0QsUUFBbEMsQ0FBNEMsQ0FDMUNqc0QsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBaUUsTUFBTSxDQUFHeXhDLFlBQVksQ0FBQ3p4QyxNQUFELENBQXJCLENBRUEsR0FBSTNJLE9BQU0sQ0FBRzBFLE1BQU0sQ0FBQzFFLE1BQXBCLENBQ0Eyd0QsUUFBUSxDQUFHQSxRQUFRLEdBQUs1d0QsU0FBYixDQUNQQyxNQURPLENBRVB5dUMsU0FBUyxDQUFDcUQsU0FBUyxDQUFDNmUsUUFBRCxDQUFWLENBQXNCLENBQXRCLENBQXlCM3dELE1BQXpCLENBRmIsQ0FJQSxHQUFJd1IsSUFBRyxDQUFHbS9DLFFBQVYsQ0FDQUEsUUFBUSxFQUFJaG9ELE1BQU0sQ0FBQzNJLE1BQW5CLENBQ0EsTUFBTzJ3RCxTQUFRLEVBQUksQ0FBWixFQUFpQmpzRCxNQUFNLENBQUNoQixLQUFQLENBQWFpdEQsUUFBYixDQUF1Qm4vQyxHQUF2QixHQUErQjdJLE1BQXZELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpb0QsT0FBVCxDQUFnQmxzRCxNQUFoQixDQUF3QixDQUN0QkEsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBLE1BQVFBLE9BQU0sRUFBSW8xQixrQkFBa0IsQ0FBQzBLLElBQW5CLENBQXdCOS9CLE1BQXhCLENBQVgsQ0FDSEEsTUFBTSxDQUFDOCtCLE9BQVAsQ0FBZTdKLGVBQWYsQ0FBZ0N3SyxjQUFoQyxDQURHLENBRUh6L0IsTUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU21zRCxhQUFULENBQXNCbnNELE1BQXRCLENBQThCLENBQzVCQSxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBQ0EsTUFBUUEsT0FBTSxFQUFJNDFCLGVBQWUsQ0FBQ2tLLElBQWhCLENBQXFCOS9CLE1BQXJCLENBQVgsQ0FDSEEsTUFBTSxDQUFDOCtCLE9BQVAsQ0FBZW5KLFlBQWYsQ0FBNkIsTUFBN0IsQ0FERyxDQUVIMzFCLE1BRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlvc0QsVUFBUyxDQUFHcFMsZ0JBQWdCLENBQUMsU0FBU2hoRCxNQUFULENBQWlCNHlELElBQWpCLENBQXVCcG9ELEtBQXZCLENBQThCLENBQzdELE1BQU94SyxPQUFNLEVBQUl3SyxLQUFLLENBQUcsR0FBSCxDQUFTLEVBQWxCLENBQU4sQ0FBOEJvb0QsSUFBSSxDQUFDQyxXQUFMLEVBQXJDLENBQ0QsQ0FGK0IsQ0FBaEMsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSVEsVUFBUyxDQUFHclMsZ0JBQWdCLENBQUMsU0FBU2hoRCxNQUFULENBQWlCNHlELElBQWpCLENBQXVCcG9ELEtBQXZCLENBQThCLENBQzdELE1BQU94SyxPQUFNLEVBQUl3SyxLQUFLLENBQUcsR0FBSCxDQUFTLEVBQWxCLENBQU4sQ0FBOEJvb0QsSUFBSSxDQUFDQyxXQUFMLEVBQXJDLENBQ0QsQ0FGK0IsQ0FBaEMsQ0FJQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSVMsV0FBVSxDQUFHelMsZUFBZSxDQUFDLGFBQUQsQ0FBaEMsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzBTLElBQVQsQ0FBYXZzRCxNQUFiLENBQXFCMUUsTUFBckIsQ0FBNkJraEQsS0FBN0IsQ0FBb0MsQ0FDbEN4OEMsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBMUUsTUFBTSxDQUFHOHhDLFNBQVMsQ0FBQzl4QyxNQUFELENBQWxCLENBRUEsR0FBSWt4RCxVQUFTLENBQUdseEQsTUFBTSxDQUFHbWxDLFVBQVUsQ0FBQ3pnQyxNQUFELENBQWIsQ0FBd0IsQ0FBOUMsQ0FDQSxHQUFJLENBQUMxRSxNQUFELEVBQVdreEQsU0FBUyxFQUFJbHhELE1BQTVCLENBQW9DLENBQ2xDLE1BQU8wRSxPQUFQLENBQ0QsQ0FDRCxHQUFJNjBDLElBQUcsQ0FBRyxDQUFDdjVDLE1BQU0sQ0FBR2t4RCxTQUFWLEVBQXVCLENBQWpDLENBQ0EsTUFDRWpRLGNBQWEsQ0FBQ3BaLFdBQVcsQ0FBQzBSLEdBQUQsQ0FBWixDQUFtQjJILEtBQW5CLENBQWIsQ0FDQXg4QyxNQURBLENBRUF1OEMsYUFBYSxDQUFDclosVUFBVSxDQUFDMlIsR0FBRCxDQUFYLENBQWtCMkgsS0FBbEIsQ0FIZixDQUtELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpUSxPQUFULENBQWdCenNELE1BQWhCLENBQXdCMUUsTUFBeEIsQ0FBZ0NraEQsS0FBaEMsQ0FBdUMsQ0FDckN4OEMsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBMUUsTUFBTSxDQUFHOHhDLFNBQVMsQ0FBQzl4QyxNQUFELENBQWxCLENBRUEsR0FBSWt4RCxVQUFTLENBQUdseEQsTUFBTSxDQUFHbWxDLFVBQVUsQ0FBQ3pnQyxNQUFELENBQWIsQ0FBd0IsQ0FBOUMsQ0FDQSxNQUFRMUUsT0FBTSxFQUFJa3hELFNBQVMsQ0FBR2x4RCxNQUF2QixDQUNGMEUsTUFBTSxDQUFHdThDLGFBQWEsQ0FBQ2poRCxNQUFNLENBQUdreEQsU0FBVixDQUFxQmhRLEtBQXJCLENBRHBCLENBRUh4OEMsTUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMwc0QsU0FBVCxDQUFrQjFzRCxNQUFsQixDQUEwQjFFLE1BQTFCLENBQWtDa2hELEtBQWxDLENBQXlDLENBQ3ZDeDhDLE1BQU0sQ0FBR3lDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBakIsQ0FDQTFFLE1BQU0sQ0FBRzh4QyxTQUFTLENBQUM5eEMsTUFBRCxDQUFsQixDQUVBLEdBQUlreEQsVUFBUyxDQUFHbHhELE1BQU0sQ0FBR21sQyxVQUFVLENBQUN6Z0MsTUFBRCxDQUFiLENBQXdCLENBQTlDLENBQ0EsTUFBUTFFLE9BQU0sRUFBSWt4RCxTQUFTLENBQUdseEQsTUFBdkIsQ0FDRmloRCxhQUFhLENBQUNqaEQsTUFBTSxDQUFHa3hELFNBQVYsQ0FBcUJoUSxLQUFyQixDQUFiLENBQTJDeDhDLE1BRHpDLENBRUhBLE1BRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN5NkIsU0FBVCxDQUFrQno2QixNQUFsQixDQUEwQjJzRCxLQUExQixDQUFpQ3JULEtBQWpDLENBQXdDLENBQ3RDLEdBQUlBLEtBQUssRUFBSXFULEtBQUssRUFBSSxJQUF0QixDQUE0QixDQUMxQkEsS0FBSyxDQUFHLENBQVIsQ0FDRCxDQUZELElBRU8sSUFBSUEsS0FBSixDQUFXLENBQ2hCQSxLQUFLLENBQUcsQ0FBQ0EsS0FBVCxDQUNELENBQ0QsTUFBTzdvQixlQUFjLENBQUNyaEMsUUFBUSxDQUFDekMsTUFBRCxDQUFSLENBQWlCOCtCLE9BQWpCLENBQXlCakosV0FBekIsQ0FBc0MsRUFBdEMsQ0FBRCxDQUE0QzgyQixLQUFLLEVBQUksQ0FBckQsQ0FBckIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU0MsT0FBVCxDQUFnQjVzRCxNQUFoQixDQUF3Qm5ILENBQXhCLENBQTJCeWdELEtBQTNCLENBQWtDLENBQ2hDLEdBQUtBLEtBQUssQ0FBR0MsY0FBYyxDQUFDdjVDLE1BQUQsQ0FBU25ILENBQVQsQ0FBWXlnRCxLQUFaLENBQWpCLENBQXNDemdELENBQUMsR0FBS3dDLFNBQXRELENBQWtFLENBQ2hFeEMsQ0FBQyxDQUFHLENBQUosQ0FDRCxDQUZELElBRU8sQ0FDTEEsQ0FBQyxDQUFHdTBDLFNBQVMsQ0FBQ3YwQyxDQUFELENBQWIsQ0FDRCxDQUNELE1BQU9nN0MsV0FBVSxDQUFDcHhDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBVCxDQUFtQm5ILENBQW5CLENBQWpCLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNpbUMsUUFBVCxFQUFtQixDQUNqQixHQUFJeDZCLEtBQUksQ0FBR0QsU0FBWCxDQUNJckUsTUFBTSxDQUFHeUMsUUFBUSxDQUFDNkIsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQURyQixDQUdBLE1BQU9BLEtBQUksQ0FBQ2hKLE1BQUwsQ0FBYyxDQUFkLENBQWtCMEUsTUFBbEIsQ0FBMkJBLE1BQU0sQ0FBQzgrQixPQUFQLENBQWV4NkIsSUFBSSxDQUFDLENBQUQsQ0FBbkIsQ0FBd0JBLElBQUksQ0FBQyxDQUFELENBQTVCLENBQWxDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJdW9ELFVBQVMsQ0FBRzdTLGdCQUFnQixDQUFDLFNBQVNoaEQsTUFBVCxDQUFpQjR5RCxJQUFqQixDQUF1QnBvRCxLQUF2QixDQUE4QixDQUM3RCxNQUFPeEssT0FBTSxFQUFJd0ssS0FBSyxDQUFHLEdBQUgsQ0FBUyxFQUFsQixDQUFOLENBQThCb29ELElBQUksQ0FBQ0MsV0FBTCxFQUFyQyxDQUNELENBRitCLENBQWhDLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTcnVCLE1BQVQsQ0FBZXg5QixNQUFmLENBQXVCMm1CLFNBQXZCLENBQWtDbW1DLEtBQWxDLENBQXlDLENBQ3ZDLEdBQUlBLEtBQUssRUFBSSxNQUFPQSxNQUFQLEVBQWdCLFFBQXpCLEVBQXFDdlQsY0FBYyxDQUFDdjVDLE1BQUQsQ0FBUzJtQixTQUFULENBQW9CbW1DLEtBQXBCLENBQXZELENBQW1GLENBQ2pGbm1DLFNBQVMsQ0FBR21tQyxLQUFLLENBQUd6eEQsU0FBcEIsQ0FDRCxDQUNEeXhELEtBQUssQ0FBR0EsS0FBSyxHQUFLenhELFNBQVYsQ0FBc0JtM0IsZ0JBQXRCLENBQXlDczZCLEtBQUssR0FBSyxDQUEzRCxDQUNBLEdBQUksQ0FBQ0EsS0FBTCxDQUFZLENBQ1YsTUFBTyxFQUFQLENBQ0QsQ0FDRDlzRCxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBQ0EsR0FBSUEsTUFBTSxHQUNKLE1BQU8ybUIsVUFBUCxFQUFvQixRQUFwQixFQUNDQSxTQUFTLEVBQUksSUFBYixFQUFxQixDQUFDa1YsUUFBUSxDQUFDbFYsU0FBRCxDQUYzQixDQUFWLENBR08sQ0FDTEEsU0FBUyxDQUFHK3VCLFlBQVksQ0FBQy91QixTQUFELENBQXhCLENBQ0EsR0FBSSxDQUFDQSxTQUFELEVBQWNrWixVQUFVLENBQUM3L0IsTUFBRCxDQUE1QixDQUFzQyxDQUNwQyxNQUFPMDJDLFVBQVMsQ0FBQy9WLGFBQWEsQ0FBQzNnQyxNQUFELENBQWQsQ0FBd0IsQ0FBeEIsQ0FBMkI4c0QsS0FBM0IsQ0FBaEIsQ0FDRCxDQUNGLENBQ0QsTUFBTzlzRCxPQUFNLENBQUN3OUIsS0FBUCxDQUFhN1csU0FBYixDQUF3Qm1tQyxLQUF4QixDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJQyxVQUFTLENBQUcvUyxnQkFBZ0IsQ0FBQyxTQUFTaGhELE1BQVQsQ0FBaUI0eUQsSUFBakIsQ0FBdUJwb0QsS0FBdkIsQ0FBOEIsQ0FDN0QsTUFBT3hLLE9BQU0sRUFBSXdLLEtBQUssQ0FBRyxHQUFILENBQVMsRUFBbEIsQ0FBTixDQUE4QnVvRCxVQUFVLENBQUNILElBQUQsQ0FBL0MsQ0FDRCxDQUYrQixDQUFoQyxDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTb0IsV0FBVCxDQUFvQmh0RCxNQUFwQixDQUE0QmlFLE1BQTVCLENBQW9DZ29ELFFBQXBDLENBQThDLENBQzVDanNELE1BQU0sQ0FBR3lDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBakIsQ0FDQWlzRCxRQUFRLENBQUdBLFFBQVEsRUFBSSxJQUFaLENBQ1AsQ0FETyxDQUVQbGlCLFNBQVMsQ0FBQ3FELFNBQVMsQ0FBQzZlLFFBQUQsQ0FBVixDQUFzQixDQUF0QixDQUF5QmpzRCxNQUFNLENBQUMxRSxNQUFoQyxDQUZiLENBSUEySSxNQUFNLENBQUd5eEMsWUFBWSxDQUFDenhDLE1BQUQsQ0FBckIsQ0FDQSxNQUFPakUsT0FBTSxDQUFDaEIsS0FBUCxDQUFhaXRELFFBQWIsQ0FBdUJBLFFBQVEsQ0FBR2hvRCxNQUFNLENBQUMzSSxNQUF6QyxHQUFvRDJJLE1BQTNELENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2dwRCxTQUFULENBQWtCanRELE1BQWxCLENBQTBCbkcsT0FBMUIsQ0FBbUN5L0MsS0FBbkMsQ0FBMEMsQ0FDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBSS95QyxTQUFRLENBQUd3K0IsTUFBTSxDQUFDZSxnQkFBdEIsQ0FFQSxHQUFJd1QsS0FBSyxFQUFJQyxjQUFjLENBQUN2NUMsTUFBRCxDQUFTbkcsT0FBVCxDQUFrQnkvQyxLQUFsQixDQUEzQixDQUFxRCxDQUNuRHovQyxPQUFPLENBQUd3QixTQUFWLENBQ0QsQ0FDRDJFLE1BQU0sQ0FBR3lDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBakIsQ0FDQW5HLE9BQU8sQ0FBR2d3RCxZQUFZLENBQUMsRUFBRCxDQUFLaHdELE9BQUwsQ0FBYzBNLFFBQWQsQ0FBd0J1M0Msc0JBQXhCLENBQXRCLENBRUEsR0FBSW9QLFFBQU8sQ0FBR3JELFlBQVksQ0FBQyxFQUFELENBQUtod0QsT0FBTyxDQUFDcXpELE9BQWIsQ0FBc0IzbUQsUUFBUSxDQUFDMm1ELE9BQS9CLENBQXdDcFAsc0JBQXhDLENBQTFCLENBQ0lxUCxXQUFXLENBQUczcUQsSUFBSSxDQUFDMHFELE9BQUQsQ0FEdEIsQ0FFSUUsYUFBYSxDQUFHcHVCLFVBQVUsQ0FBQ2t1QixPQUFELENBQVVDLFdBQVYsQ0FGOUIsQ0FJQSxHQUFJRSxXQUFKLENBQ0lDLFlBREosQ0FFSTlwRCxLQUFLLENBQUcsQ0FGWixDQUdJK3BELFdBQVcsQ0FBRzF6RCxPQUFPLENBQUMwekQsV0FBUixFQUF1QjEyQixTQUh6QyxDQUlJM3lCLE1BQU0sQ0FBRyxVQUpiLENBTUE7QUFDQSxHQUFJc3BELGFBQVksQ0FBR3I0QixNQUFNLENBQ3ZCLENBQUN0N0IsT0FBTyxDQUFDcXlELE1BQVIsRUFBa0JyMUIsU0FBbkIsRUFBOEIzeUIsTUFBOUIsQ0FBdUMsR0FBdkMsQ0FDQXFwRCxXQUFXLENBQUNycEQsTUFEWixDQUNxQixHQURyQixDQUVBLENBQUNxcEQsV0FBVyxHQUFLaDRCLGFBQWhCLENBQWdDYyxZQUFoQyxDQUErQ1EsU0FBaEQsRUFBMkQzeUIsTUFGM0QsQ0FFb0UsR0FGcEUsQ0FHQSxDQUFDckssT0FBTyxDQUFDNHpELFFBQVIsRUFBb0I1MkIsU0FBckIsRUFBZ0MzeUIsTUFIaEMsQ0FHeUMsSUFKbEIsQ0FLdkIsR0FMdUIsQ0FBekIsQ0FPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUl3cEQsVUFBUyxDQUFHLGtCQUNicHJELGNBQWMsQ0FBQ0ksSUFBZixDQUFvQjdJLE9BQXBCLENBQTZCLFdBQTdCLEVBQ0csQ0FBQ0EsT0FBTyxDQUFDNnpELFNBQVIsQ0FBb0IsRUFBckIsRUFBeUI1dUIsT0FBekIsQ0FBaUMsS0FBakMsQ0FBd0MsR0FBeEMsQ0FESCxDQUVJLDBCQUE2QixHQUFFL0UsZUFBL0IsQ0FBa0QsR0FIekMsRUFJVixJQUpOLENBTUEvNUIsTUFBTSxDQUFDOCtCLE9BQVAsQ0FBZTB1QixZQUFmLENBQTZCLFNBQVMxdEQsS0FBVCxDQUFnQjZ0RCxXQUFoQixDQUE2QkMsZ0JBQTdCLENBQStDQyxlQUEvQyxDQUFnRUMsYUFBaEUsQ0FBK0V0bUQsTUFBL0UsQ0FBdUYsQ0FDbEhvbUQsZ0JBQWdCLEdBQUtBLGdCQUFnQixDQUFHQyxlQUF4QixDQUFoQixDQUVBO0FBQ0EzcEQsTUFBTSxFQUFJbEUsTUFBTSxDQUFDaEIsS0FBUCxDQUFhd0UsS0FBYixDQUFvQmdFLE1BQXBCLEVBQTRCczNCLE9BQTVCLENBQW9DaEksaUJBQXBDLENBQXVENEksZ0JBQXZELENBQVYsQ0FFQTtBQUNBLEdBQUlpdUIsV0FBSixDQUFpQixDQUNmTixVQUFVLENBQUcsSUFBYixDQUNBbnBELE1BQU0sRUFBSSxZQUFjeXBELFdBQWQsQ0FBNEIsUUFBdEMsQ0FDRCxDQUNELEdBQUlHLGFBQUosQ0FBbUIsQ0FDakJSLFlBQVksQ0FBRyxJQUFmLENBQ0FwcEQsTUFBTSxFQUFJLE9BQVM0cEQsYUFBVCxDQUF5QixhQUFuQyxDQUNELENBQ0QsR0FBSUYsZ0JBQUosQ0FBc0IsQ0FDcEIxcEQsTUFBTSxFQUFJLGlCQUFtQjBwRCxnQkFBbkIsQ0FBc0MsNkJBQWhELENBQ0QsQ0FDRHBxRCxLQUFLLENBQUdnRSxNQUFNLENBQUcxSCxLQUFLLENBQUN4RSxNQUF2QixDQUVBO0FBQ0E7QUFDQSxNQUFPd0UsTUFBUCxDQUNELENBdkJELEVBeUJBb0UsTUFBTSxFQUFJLE1BQVYsQ0FFQTtBQUNBO0FBQ0EsR0FBSTZwRCxTQUFRLENBQUd6ckQsY0FBYyxDQUFDSSxJQUFmLENBQW9CN0ksT0FBcEIsQ0FBNkIsVUFBN0IsR0FBNENBLE9BQU8sQ0FBQ2swRCxRQUFuRSxDQUNBLEdBQUksQ0FBQ0EsUUFBTCxDQUFlLENBQ2I3cEQsTUFBTSxDQUFHLGlCQUFtQkEsTUFBbkIsQ0FBNEIsT0FBckMsQ0FDRCxDQUNEO0FBQ0E7QUFKQSxJQUtLLElBQUlpeUIsMEJBQTBCLENBQUMySixJQUEzQixDQUFnQ2l1QixRQUFoQyxDQUFKLENBQStDLENBQ2xELEtBQU0sSUFBSXhwRCxNQUFKLENBQVVtc0IsNEJBQVYsQ0FBTixDQUNELENBRUQ7QUFDQXhzQixNQUFNLENBQUcsQ0FBQ29wRCxZQUFZLENBQUdwcEQsTUFBTSxDQUFDNDZCLE9BQVAsQ0FBZWpLLG9CQUFmLENBQXFDLEVBQXJDLENBQUgsQ0FBOEMzd0IsTUFBM0QsRUFDTjQ2QixPQURNLENBQ0VoSyxtQkFERixDQUN1QixJQUR2QixFQUVOZ0ssT0FGTSxDQUVFL0oscUJBRkYsQ0FFeUIsS0FGekIsQ0FBVCxDQUlBO0FBQ0E3d0IsTUFBTSxDQUFHLGFBQWU2cEQsUUFBUSxFQUFJLEtBQTNCLEVBQW9DLE9BQXBDLEVBQ05BLFFBQVEsQ0FDTCxFQURLLENBRUwsc0JBSEcsRUFLUCxtQkFMTyxFQU1OVixVQUFVLENBQ04sa0JBRE0sQ0FFTixFQVJFLEdBVU5DLFlBQVksQ0FDVCxrQ0FDQSx1REFGUyxDQUdULEtBYkcsRUFlUHBwRCxNQWZPLENBZ0JQLGVBaEJGLENBa0JBLEdBQUlsTCxPQUFNLENBQUdnMUQsT0FBTyxDQUFDLFVBQVcsQ0FDOUIsTUFBT256QixTQUFRLENBQUNzeUIsV0FBRCxDQUFjTyxTQUFTLENBQUcsU0FBWixDQUF3QnhwRCxNQUF0QyxDQUFSLENBQ0poRCxLQURJLENBQ0U3RixTQURGLENBQ2EreEQsYUFEYixDQUFQLENBRUQsQ0FIbUIsQ0FBcEIsQ0FLQTtBQUNBO0FBQ0FwMEQsTUFBTSxDQUFDa0wsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQSxHQUFJeWtELE9BQU8sQ0FBQzN2RCxNQUFELENBQVgsQ0FBcUIsQ0FDbkIsS0FBTUEsT0FBTixDQUNELENBQ0QsTUFBT0EsT0FBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2kxRCxRQUFULENBQWlCenhELEtBQWpCLENBQXdCLENBQ3RCLE1BQU9pRyxTQUFRLENBQUNqRyxLQUFELENBQVIsQ0FBZ0JxdkQsV0FBaEIsRUFBUCxDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3FDLFFBQVQsQ0FBaUIxeEQsS0FBakIsQ0FBd0IsQ0FDdEIsTUFBT2lHLFNBQVEsQ0FBQ2pHLEtBQUQsQ0FBUixDQUFnQjJ4RCxXQUFoQixFQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNDLEtBQVQsQ0FBY3B1RCxNQUFkLENBQXNCdzhDLEtBQXRCLENBQTZCbEQsS0FBN0IsQ0FBb0MsQ0FDbEN0NUMsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBLEdBQUlBLE1BQU0sR0FBS3M1QyxLQUFLLEVBQUlrRCxLQUFLLEdBQUtuaEQsU0FBeEIsQ0FBVixDQUE4QyxDQUM1QyxNQUFPdWpDLFNBQVEsQ0FBQzUrQixNQUFELENBQWYsQ0FDRCxDQUNELEdBQUksQ0FBQ0EsTUFBRCxFQUFXLEVBQUV3OEMsS0FBSyxDQUFHOUcsWUFBWSxDQUFDOEcsS0FBRCxDQUF0QixDQUFmLENBQStDLENBQzdDLE1BQU94OEMsT0FBUCxDQUNELENBQ0QsR0FBSW0vQixXQUFVLENBQUd3QixhQUFhLENBQUMzZ0MsTUFBRCxDQUE5QixDQUNJby9CLFVBQVUsQ0FBR3VCLGFBQWEsQ0FBQzZiLEtBQUQsQ0FEOUIsQ0FFSTFvQyxLQUFLLENBQUdvckIsZUFBZSxDQUFDQyxVQUFELENBQWFDLFVBQWIsQ0FGM0IsQ0FHSXR5QixHQUFHLENBQUd1eUIsYUFBYSxDQUFDRixVQUFELENBQWFDLFVBQWIsQ0FBYixDQUF3QyxDQUhsRCxDQUtBLE1BQU9zWCxVQUFTLENBQUN2WCxVQUFELENBQWFyckIsS0FBYixDQUFvQmhILEdBQXBCLENBQVQsQ0FBa0M2ZSxJQUFsQyxDQUF1QyxFQUF2QyxDQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMwaUMsUUFBVCxDQUFpQnJ1RCxNQUFqQixDQUF5Qnc4QyxLQUF6QixDQUFnQ2xELEtBQWhDLENBQXVDLENBQ3JDdDVDLE1BQU0sQ0FBR3lDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBakIsQ0FDQSxHQUFJQSxNQUFNLEdBQUtzNUMsS0FBSyxFQUFJa0QsS0FBSyxHQUFLbmhELFNBQXhCLENBQVYsQ0FBOEMsQ0FDNUMsTUFBTzJFLE9BQU0sQ0FBQ2hCLEtBQVAsQ0FBYSxDQUFiLENBQWdCNi9CLGVBQWUsQ0FBQzcrQixNQUFELENBQWYsQ0FBMEIsQ0FBMUMsQ0FBUCxDQUNELENBQ0QsR0FBSSxDQUFDQSxNQUFELEVBQVcsRUFBRXc4QyxLQUFLLENBQUc5RyxZQUFZLENBQUM4RyxLQUFELENBQXRCLENBQWYsQ0FBK0MsQ0FDN0MsTUFBT3g4QyxPQUFQLENBQ0QsQ0FDRCxHQUFJbS9CLFdBQVUsQ0FBR3dCLGFBQWEsQ0FBQzNnQyxNQUFELENBQTlCLENBQ0k4TSxHQUFHLENBQUd1eUIsYUFBYSxDQUFDRixVQUFELENBQWF3QixhQUFhLENBQUM2YixLQUFELENBQTFCLENBQWIsQ0FBa0QsQ0FENUQsQ0FHQSxNQUFPOUYsVUFBUyxDQUFDdlgsVUFBRCxDQUFhLENBQWIsQ0FBZ0JyeUIsR0FBaEIsQ0FBVCxDQUE4QjZlLElBQTlCLENBQW1DLEVBQW5DLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJpQyxVQUFULENBQW1CdHVELE1BQW5CLENBQTJCdzhDLEtBQTNCLENBQWtDbEQsS0FBbEMsQ0FBeUMsQ0FDdkN0NUMsTUFBTSxDQUFHeUMsUUFBUSxDQUFDekMsTUFBRCxDQUFqQixDQUNBLEdBQUlBLE1BQU0sR0FBS3M1QyxLQUFLLEVBQUlrRCxLQUFLLEdBQUtuaEQsU0FBeEIsQ0FBVixDQUE4QyxDQUM1QyxNQUFPMkUsT0FBTSxDQUFDOCtCLE9BQVAsQ0FBZWpKLFdBQWYsQ0FBNEIsRUFBNUIsQ0FBUCxDQUNELENBQ0QsR0FBSSxDQUFDNzFCLE1BQUQsRUFBVyxFQUFFdzhDLEtBQUssQ0FBRzlHLFlBQVksQ0FBQzhHLEtBQUQsQ0FBdEIsQ0FBZixDQUErQyxDQUM3QyxNQUFPeDhDLE9BQVAsQ0FDRCxDQUNELEdBQUltL0IsV0FBVSxDQUFHd0IsYUFBYSxDQUFDM2dDLE1BQUQsQ0FBOUIsQ0FDSThULEtBQUssQ0FBR29yQixlQUFlLENBQUNDLFVBQUQsQ0FBYXdCLGFBQWEsQ0FBQzZiLEtBQUQsQ0FBMUIsQ0FEM0IsQ0FHQSxNQUFPOUYsVUFBUyxDQUFDdlgsVUFBRCxDQUFhcnJCLEtBQWIsQ0FBVCxDQUE2QjZYLElBQTdCLENBQWtDLEVBQWxDLENBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzRpQyxTQUFULENBQWtCdnVELE1BQWxCLENBQTBCbkcsT0FBMUIsQ0FBbUMsQ0FDakMsR0FBSXlCLE9BQU0sQ0FBR3UyQixvQkFBYixDQUNJMjhCLFFBQVEsQ0FBRzE4QixzQkFEZixDQUdBLEdBQUl3VCxRQUFRLENBQUN6ckMsT0FBRCxDQUFaLENBQXVCLENBQ3JCLEdBQUk4c0IsVUFBUyxDQUFHLGFBQWU5c0IsUUFBZixDQUF5QkEsT0FBTyxDQUFDOHNCLFNBQWpDLENBQTZDQSxTQUE3RCxDQUNBcnJCLE1BQU0sQ0FBRyxVQUFZekIsUUFBWixDQUFzQnV6QyxTQUFTLENBQUN2ekMsT0FBTyxDQUFDeUIsTUFBVCxDQUEvQixDQUFrREEsTUFBM0QsQ0FDQWt6RCxRQUFRLENBQUcsWUFBYzMwRCxRQUFkLENBQXdCNjdDLFlBQVksQ0FBQzc3QyxPQUFPLENBQUMyMEQsUUFBVCxDQUFwQyxDQUF5REEsUUFBcEUsQ0FDRCxDQUNEeHVELE1BQU0sQ0FBR3lDLFFBQVEsQ0FBQ3pDLE1BQUQsQ0FBakIsQ0FFQSxHQUFJd3NELFVBQVMsQ0FBR3hzRCxNQUFNLENBQUMxRSxNQUF2QixDQUNBLEdBQUl1a0MsVUFBVSxDQUFDNy9CLE1BQUQsQ0FBZCxDQUF3QixDQUN0QixHQUFJbS9CLFdBQVUsQ0FBR3dCLGFBQWEsQ0FBQzNnQyxNQUFELENBQTlCLENBQ0F3c0QsU0FBUyxDQUFHcnRCLFVBQVUsQ0FBQzdqQyxNQUF2QixDQUNELENBQ0QsR0FBSUEsTUFBTSxFQUFJa3hELFNBQWQsQ0FBeUIsQ0FDdkIsTUFBT3hzRCxPQUFQLENBQ0QsQ0FDRCxHQUFJOE0sSUFBRyxDQUFHeFIsTUFBTSxDQUFHbWxDLFVBQVUsQ0FBQyt0QixRQUFELENBQTdCLENBQ0EsR0FBSTFoRCxHQUFHLENBQUcsQ0FBVixDQUFhLENBQ1gsTUFBTzBoRCxTQUFQLENBQ0QsQ0FDRCxHQUFJeDFELE9BQU0sQ0FBR21tQyxVQUFVLENBQ25CdVgsU0FBUyxDQUFDdlgsVUFBRCxDQUFhLENBQWIsQ0FBZ0JyeUIsR0FBaEIsQ0FBVCxDQUE4QjZlLElBQTlCLENBQW1DLEVBQW5DLENBRG1CLENBRW5CM3JCLE1BQU0sQ0FBQ2hCLEtBQVAsQ0FBYSxDQUFiLENBQWdCOE4sR0FBaEIsQ0FGSixDQUlBLEdBQUk2WixTQUFTLEdBQUt0ckIsU0FBbEIsQ0FBNkIsQ0FDM0IsTUFBT3JDLE9BQU0sQ0FBR3cxRCxRQUFoQixDQUNELENBQ0QsR0FBSXJ2QixVQUFKLENBQWdCLENBQ2RyeUIsR0FBRyxFQUFLOVQsTUFBTSxDQUFDc0MsTUFBUCxDQUFnQndSLEdBQXhCLENBQ0QsQ0FDRCxHQUFJK3VCLFFBQVEsQ0FBQ2xWLFNBQUQsQ0FBWixDQUF5QixDQUN2QixHQUFJM21CLE1BQU0sQ0FBQ2hCLEtBQVAsQ0FBYThOLEdBQWIsRUFBa0IyaEQsTUFBbEIsQ0FBeUI5bkMsU0FBekIsQ0FBSixDQUF5QyxDQUN2QyxHQUFJN21CLE1BQUosQ0FDSW1ELFNBQVMsQ0FBR2pLLE1BRGhCLENBR0EsR0FBSSxDQUFDMnRCLFNBQVMsQ0FBQ3ZkLE1BQWYsQ0FBdUIsQ0FDckJ1ZCxTQUFTLENBQUd3TyxNQUFNLENBQUN4TyxTQUFTLENBQUN6aUIsTUFBWCxDQUFtQnpCLFFBQVEsQ0FBQzZ6QixPQUFPLENBQUNzTCxJQUFSLENBQWFqYixTQUFiLENBQUQsQ0FBUixDQUFvQyxHQUF2RCxDQUFsQixDQUNELENBQ0RBLFNBQVMsQ0FBQ29hLFNBQVYsQ0FBc0IsQ0FBdEIsQ0FDQSxNQUFRamhDLEtBQUssQ0FBRzZtQixTQUFTLENBQUNpYixJQUFWLENBQWUzK0IsU0FBZixDQUFoQixDQUE0QyxDQUMxQyxHQUFJeXJELE9BQU0sQ0FBRzV1RCxLQUFLLENBQUMwRCxLQUFuQixDQUNELENBQ0R4SyxNQUFNLENBQUdBLE1BQU0sQ0FBQ2dHLEtBQVAsQ0FBYSxDQUFiLENBQWdCMHZELE1BQU0sR0FBS3J6RCxTQUFYLENBQXVCeVIsR0FBdkIsQ0FBNkI0aEQsTUFBN0MsQ0FBVCxDQUNELENBQ0YsQ0FkRCxJQWNPLElBQUkxdUQsTUFBTSxDQUFDa0QsT0FBUCxDQUFld3lDLFlBQVksQ0FBQy91QixTQUFELENBQTNCLENBQXdDN1osR0FBeEMsR0FBZ0RBLEdBQXBELENBQXlELENBQzlELEdBQUl0SixNQUFLLENBQUd4SyxNQUFNLENBQUN3YSxXQUFQLENBQW1CbVQsU0FBbkIsQ0FBWixDQUNBLEdBQUluakIsS0FBSyxDQUFHLENBQUMsQ0FBYixDQUFnQixDQUNkeEssTUFBTSxDQUFHQSxNQUFNLENBQUNnRyxLQUFQLENBQWEsQ0FBYixDQUFnQndFLEtBQWhCLENBQVQsQ0FDRCxDQUNGLENBQ0QsTUFBT3hLLE9BQU0sQ0FBR3cxRCxRQUFoQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTRyxTQUFULENBQWtCM3VELE1BQWxCLENBQTBCLENBQ3hCQSxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBQ0EsTUFBUUEsT0FBTSxFQUFJazFCLGdCQUFnQixDQUFDNEssSUFBakIsQ0FBc0I5L0IsTUFBdEIsQ0FBWCxDQUNIQSxNQUFNLENBQUM4K0IsT0FBUCxDQUFlOUosYUFBZixDQUE4QjhMLGdCQUE5QixDQURHLENBRUg5Z0MsTUFGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk0dUQsVUFBUyxDQUFHNVUsZ0JBQWdCLENBQUMsU0FBU2hoRCxNQUFULENBQWlCNHlELElBQWpCLENBQXVCcG9ELEtBQXZCLENBQThCLENBQzdELE1BQU94SyxPQUFNLEVBQUl3SyxLQUFLLENBQUcsR0FBSCxDQUFTLEVBQWxCLENBQU4sQ0FBOEJvb0QsSUFBSSxDQUFDdUMsV0FBTCxFQUFyQyxDQUNELENBRitCLENBQWhDLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlwQyxXQUFVLENBQUdsUyxlQUFlLENBQUMsYUFBRCxDQUFoQyxDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU0ssTUFBVCxDQUFlbDZDLE1BQWYsQ0FBdUI4d0MsT0FBdkIsQ0FBZ0N3SSxLQUFoQyxDQUF1QyxDQUNyQ3Q1QyxNQUFNLENBQUd5QyxRQUFRLENBQUN6QyxNQUFELENBQWpCLENBQ0E4d0MsT0FBTyxDQUFHd0ksS0FBSyxDQUFHaitDLFNBQUgsQ0FBZXkxQyxPQUE5QixDQUVBLEdBQUlBLE9BQU8sR0FBS3oxQyxTQUFoQixDQUEyQixDQUN6QixNQUFPMGtDLGVBQWMsQ0FBQy8vQixNQUFELENBQWQsQ0FBeUJnaEMsWUFBWSxDQUFDaGhDLE1BQUQsQ0FBckMsQ0FBZ0R5OUIsVUFBVSxDQUFDejlCLE1BQUQsQ0FBakUsQ0FDRCxDQUNELE1BQU9BLE9BQU0sQ0FBQ0YsS0FBUCxDQUFhZ3hDLE9BQWIsR0FBeUIsRUFBaEMsQ0FDRCxDQUVELDRFQTVoYmlELENBOGhiakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJa2QsUUFBTyxDQUFHbGEsUUFBUSxDQUFDLFNBQVM3WCxJQUFULENBQWUzM0IsSUFBZixDQUFxQixDQUMxQyxHQUFJLENBQ0YsTUFBT3BELE1BQUssQ0FBQys2QixJQUFELENBQU81Z0MsU0FBUCxDQUFrQmlKLElBQWxCLENBQVosQ0FDRCxDQUFDLE1BQU9FLENBQVAsQ0FBVSxDQUNWLE1BQU9ta0QsUUFBTyxDQUFDbmtELENBQUQsQ0FBUCxDQUFhQSxDQUFiLENBQWlCLEdBQUlELE1BQUosQ0FBVUMsQ0FBVixDQUF4QixDQUNELENBQ0YsQ0FOcUIsQ0FBdEIsQ0FRQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXFxRCxRQUFPLENBQUdoVSxRQUFRLENBQUMsU0FBU3o3QyxNQUFULENBQWlCMHZELFdBQWpCLENBQThCLENBQ25EdnlCLFNBQVMsQ0FBQ3V5QixXQUFELENBQWMsU0FBU2xyRCxHQUFULENBQWMsQ0FDbkNBLEdBQUcsQ0FBR29xQyxLQUFLLENBQUNwcUMsR0FBRCxDQUFYLENBQ0F1bUMsZUFBZSxDQUFDL3FDLE1BQUQsQ0FBU3dFLEdBQVQsQ0FBY29DLElBQUksQ0FBQzVHLE1BQU0sQ0FBQ3dFLEdBQUQsQ0FBUCxDQUFjeEUsTUFBZCxDQUFsQixDQUFmLENBQ0QsQ0FIUSxDQUFULENBSUEsTUFBT0EsT0FBUCxDQUNELENBTnFCLENBQXRCLENBUUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMydkQsS0FBVCxDQUFjN2xCLEtBQWQsQ0FBcUIsQ0FDbkIsR0FBSTV0QyxPQUFNLENBQUc0dEMsS0FBSyxFQUFJLElBQVQsQ0FBZ0IsQ0FBaEIsQ0FBb0JBLEtBQUssQ0FBQzV0QyxNQUF2QyxDQUNJMmdELFVBQVUsQ0FBR2pKLFdBQVcsRUFENUIsQ0FHQTlKLEtBQUssQ0FBRyxDQUFDNXRDLE1BQUQsQ0FBVSxFQUFWLENBQWV5aEMsUUFBUSxDQUFDbU0sS0FBRCxDQUFRLFNBQVN1VSxJQUFULENBQWUsQ0FDcEQsR0FBSSxNQUFPQSxLQUFJLENBQUMsQ0FBRCxDQUFYLEVBQWtCLFVBQXRCLENBQWtDLENBQ2hDLEtBQU0sSUFBSWpzQyxVQUFKLENBQWNpZixlQUFkLENBQU4sQ0FDRCxDQUNELE1BQU8sQ0FBQ3dyQixVQUFVLENBQUN3QixJQUFJLENBQUMsQ0FBRCxDQUFMLENBQVgsQ0FBc0JBLElBQUksQ0FBQyxDQUFELENBQTFCLENBQVAsQ0FDRCxDQUw4QixDQUEvQixDQU9BLE1BQU8zSixTQUFRLENBQUMsU0FBU3h2QyxJQUFULENBQWUsQ0FDN0IsR0FBSWQsTUFBSyxDQUFHLENBQUMsQ0FBYixDQUNBLE1BQU8sRUFBRUEsS0FBRixDQUFVbEksTUFBakIsQ0FBeUIsQ0FDdkIsR0FBSW1pRCxLQUFJLENBQUd2VSxLQUFLLENBQUMxbEMsS0FBRCxDQUFoQixDQUNBLEdBQUl0QyxLQUFLLENBQUN1OEMsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFVLElBQVYsQ0FBZ0JuNUMsSUFBaEIsQ0FBVCxDQUFnQyxDQUM5QixNQUFPcEQsTUFBSyxDQUFDdThDLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBVSxJQUFWLENBQWdCbjVDLElBQWhCLENBQVosQ0FDRCxDQUNGLENBQ0YsQ0FSYyxDQUFmLENBU0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMHFELFNBQVQsQ0FBa0I5cUQsTUFBbEIsQ0FBMEIsQ0FDeEIsTUFBT2tvQyxhQUFZLENBQUNwQixTQUFTLENBQUM5bUMsTUFBRCxDQUFTNHNCLGVBQVQsQ0FBVixDQUFuQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTdWpCLFNBQVQsQ0FBa0I3M0MsS0FBbEIsQ0FBeUIsQ0FDdkIsTUFBTyxXQUFXLENBQ2hCLE1BQU9BLE1BQVAsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3l5RCxVQUFULENBQW1CenlELEtBQW5CLENBQTBCNC9DLFlBQTFCLENBQXdDLENBQ3RDLE1BQVE1L0MsTUFBSyxFQUFJLElBQVQsRUFBaUJBLEtBQUssR0FBS0EsS0FBNUIsQ0FBcUM0L0MsWUFBckMsQ0FBb0Q1L0MsS0FBM0QsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTB5RCxLQUFJLENBQUd0VSxVQUFVLEVBQXJCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXVVLFVBQVMsQ0FBR3ZVLFVBQVUsQ0FBQyxJQUFELENBQTFCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTeEosU0FBVCxDQUFrQjUwQyxLQUFsQixDQUF5QixDQUN2QixNQUFPQSxNQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTNi9CLFNBQVQsQ0FBa0JKLElBQWxCLENBQXdCLENBQ3RCLE1BQU9rVixhQUFZLENBQUMsTUFBT2xWLEtBQVAsRUFBZSxVQUFmLENBQTRCQSxJQUE1QixDQUFtQytPLFNBQVMsQ0FBQy9PLElBQUQsQ0FBT25MLGVBQVAsQ0FBN0MsQ0FBbkIsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTcytCLFFBQVQsQ0FBaUJsckQsTUFBakIsQ0FBeUIsQ0FDdkIsTUFBT290QyxZQUFXLENBQUN0RyxTQUFTLENBQUM5bUMsTUFBRCxDQUFTNHNCLGVBQVQsQ0FBVixDQUFsQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3UrQixnQkFBVCxDQUF5Qi9tRCxJQUF6QixDQUErQnFvQyxRQUEvQixDQUF5QyxDQUN2QyxNQUFPVSxvQkFBbUIsQ0FBQy9vQyxJQUFELENBQU8waUMsU0FBUyxDQUFDMkYsUUFBRCxDQUFXN2YsZUFBWCxDQUFoQixDQUExQixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSXcrQixPQUFNLENBQUd4YixRQUFRLENBQUMsU0FBU3hyQyxJQUFULENBQWVoRSxJQUFmLENBQXFCLENBQ3pDLE1BQU8sVUFBU2xGLE1BQVQsQ0FBaUIsQ0FDdEIsTUFBTzh2QyxXQUFVLENBQUM5dkMsTUFBRCxDQUFTa0osSUFBVCxDQUFlaEUsSUFBZixDQUFqQixDQUNELENBRkQsQ0FHRCxDQUpvQixDQUFyQixDQU1BO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJaXJELFNBQVEsQ0FBR3piLFFBQVEsQ0FBQyxTQUFTMTBDLE1BQVQsQ0FBaUJrRixJQUFqQixDQUF1QixDQUM3QyxNQUFPLFVBQVNnRSxJQUFULENBQWUsQ0FDcEIsTUFBTzRtQyxXQUFVLENBQUM5dkMsTUFBRCxDQUFTa0osSUFBVCxDQUFlaEUsSUFBZixDQUFqQixDQUNELENBRkQsQ0FHRCxDQUpzQixDQUF2QixDQU1BO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNoRCxNQUFULENBQWVsQyxNQUFmLENBQXVCOEUsTUFBdkIsQ0FBK0JySyxPQUEvQixDQUF3QyxDQUN0QyxHQUFJOGtDLE1BQUssQ0FBR244QixJQUFJLENBQUMwQixNQUFELENBQWhCLENBQ0k0cUQsV0FBVyxDQUFHamhCLGFBQWEsQ0FBQzNwQyxNQUFELENBQVN5NkIsS0FBVCxDQUQvQixDQUdBLEdBQUk5a0MsT0FBTyxFQUFJLElBQVgsRUFDQSxFQUFFeXJDLFFBQVEsQ0FBQ3BoQyxNQUFELENBQVIsR0FBcUI0cUQsV0FBVyxDQUFDeHpELE1BQVosRUFBc0IsQ0FBQ3FqQyxLQUFLLENBQUNyakMsTUFBbEQsQ0FBRixDQURKLENBQ2tFLENBQ2hFekIsT0FBTyxDQUFHcUssTUFBVixDQUNBQSxNQUFNLENBQUc5RSxNQUFULENBQ0FBLE1BQU0sQ0FBRyxJQUFULENBQ0EwdkQsV0FBVyxDQUFHamhCLGFBQWEsQ0FBQzNwQyxNQUFELENBQVMxQixJQUFJLENBQUMwQixNQUFELENBQWIsQ0FBM0IsQ0FDRCxDQUNELEdBQUkvSCxNQUFLLENBQUcsRUFBRW1wQyxRQUFRLENBQUN6ckMsT0FBRCxDQUFSLEVBQXFCLFNBQVdBLFFBQWxDLEdBQThDLENBQUMsQ0FBQ0EsT0FBTyxDQUFDc0MsS0FBcEUsQ0FDSXN2QyxNQUFNLENBQUd4cUMsVUFBVSxDQUFDN0IsTUFBRCxDQUR2QixDQUdBbTlCLFNBQVMsQ0FBQ3V5QixXQUFELENBQWMsU0FBU2hWLFVBQVQsQ0FBcUIsQ0FDMUMsR0FBSTdkLEtBQUksQ0FBRy8zQixNQUFNLENBQUM0MUMsVUFBRCxDQUFqQixDQUNBMTZDLE1BQU0sQ0FBQzA2QyxVQUFELENBQU4sQ0FBcUI3ZCxJQUFyQixDQUNBLEdBQUl3UCxNQUFKLENBQVksQ0FDVnJzQyxNQUFNLENBQUNpQyxTQUFQLENBQWlCeTRDLFVBQWpCLEVBQStCLFVBQVcsQ0FDeEMsR0FBSXRVLFNBQVEsQ0FBRyxLQUFLRyxTQUFwQixDQUNBLEdBQUl4cEMsS0FBSyxFQUFJcXBDLFFBQWIsQ0FBdUIsQ0FDckIsR0FBSXhzQyxPQUFNLENBQUdvRyxNQUFNLENBQUMsS0FBS3FtQyxXQUFOLENBQW5CLENBQ0l3USxPQUFPLENBQUdqOUMsTUFBTSxDQUFDMHNDLFdBQVAsQ0FBcUJXLFNBQVMsQ0FBQyxLQUFLWCxXQUFOLENBRDVDLENBR0F1USxPQUFPLENBQUN4dkMsSUFBUixDQUFhLENBQUUsT0FBUXcxQixJQUFWLENBQWdCLE9BQVE1M0IsU0FBeEIsQ0FBbUMsVUFBV2pGLE1BQTlDLENBQWIsRUFDQXBHLE1BQU0sQ0FBQzJzQyxTQUFQLENBQW1CSCxRQUFuQixDQUNBLE1BQU94c0MsT0FBUCxDQUNELENBQ0QsTUFBT2lqQyxLQUFJLENBQUMvNkIsS0FBTCxDQUFXOUIsTUFBWCxDQUFtQjQ5QixTQUFTLENBQUMsQ0FBQyxLQUFLeGdDLEtBQUwsRUFBRCxDQUFELENBQWlCNkgsU0FBakIsQ0FBNUIsQ0FBUCxDQUNELENBWEQsQ0FZRCxDQUNGLENBakJRLENBQVQsQ0FtQkEsTUFBT2pGLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU293RCxXQUFULEVBQXNCLENBQ3BCLEdBQUloekMsSUFBSSxDQUFDdmpCLENBQUwsR0FBVyxJQUFmLENBQXFCLENBQ25CdWpCLElBQUksQ0FBQ3ZqQixDQUFMLENBQVMrb0MsT0FBVCxDQUNELENBQ0QsTUFBTyxLQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTMGIsS0FBVCxFQUFnQixDQUNkO0FBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUytSLE9BQVQsQ0FBZ0I1MkQsQ0FBaEIsQ0FBbUIsQ0FDakJBLENBQUMsQ0FBR3UwQyxTQUFTLENBQUN2MEMsQ0FBRCxDQUFiLENBQ0EsTUFBT2k3QyxTQUFRLENBQUMsU0FBU3h2QyxJQUFULENBQWUsQ0FDN0IsTUFBT3V1QyxRQUFPLENBQUN2dUMsSUFBRCxDQUFPekwsQ0FBUCxDQUFkLENBQ0QsQ0FGYyxDQUFmLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJNjJELEtBQUksQ0FBR3JULFVBQVUsQ0FBQ3RmLFFBQUQsQ0FBckIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUk0eUIsVUFBUyxDQUFHdFQsVUFBVSxDQUFDNWYsVUFBRCxDQUExQixDQUVBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW16QixTQUFRLENBQUd2VCxVQUFVLENBQUNqZixTQUFELENBQXpCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTbVUsU0FBVCxDQUFrQmpwQyxJQUFsQixDQUF3QixDQUN0QixNQUFPMnBDLE1BQUssQ0FBQzNwQyxJQUFELENBQUwsQ0FBY2cxQixZQUFZLENBQUMwUSxLQUFLLENBQUMxbEMsSUFBRCxDQUFOLENBQTFCLENBQTBDZ3JDLGdCQUFnQixDQUFDaHJDLElBQUQsQ0FBakUsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVN1bkQsV0FBVCxDQUFvQnp3RCxNQUFwQixDQUE0QixDQUMxQixNQUFPLFVBQVNrSixJQUFULENBQWUsQ0FDcEIsTUFBT2xKLE9BQU0sRUFBSSxJQUFWLENBQWlCL0QsU0FBakIsQ0FBNkJ5eUMsT0FBTyxDQUFDMXVDLE1BQUQsQ0FBU2tKLElBQVQsQ0FBM0MsQ0FDRCxDQUZELENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSWxNLE1BQUssQ0FBR3VnRCxXQUFXLEVBQXZCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW1ULFdBQVUsQ0FBR25ULFdBQVcsQ0FBQyxJQUFELENBQTVCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3dDLFVBQVQsRUFBcUIsQ0FDbkIsTUFBTyxFQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVNXLFVBQVQsRUFBcUIsQ0FDbkIsTUFBTyxNQUFQLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTaVEsV0FBVCxFQUFzQixDQUNwQixNQUFPLEVBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU0MsV0FBVCxFQUFzQixDQUNwQixNQUFPLEVBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU0MsU0FBVCxFQUFvQixDQUNsQixNQUFPLEtBQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUy84QyxNQUFULENBQWVyYSxDQUFmLENBQWtCd2pDLFFBQWxCLENBQTRCLENBQzFCeGpDLENBQUMsQ0FBR3UwQyxTQUFTLENBQUN2MEMsQ0FBRCxDQUFiLENBQ0EsR0FBSUEsQ0FBQyxDQUFHLENBQUosRUFBU0EsQ0FBQyxDQUFHdzVCLGdCQUFqQixDQUFtQyxDQUNqQyxNQUFPLEVBQVAsQ0FDRCxDQUNELEdBQUk3dUIsTUFBSyxDQUFHZ3ZCLGdCQUFaLENBQ0lsM0IsTUFBTSxDQUFHc29DLFNBQVMsQ0FBQy9xQyxDQUFELENBQUkyNUIsZ0JBQUosQ0FEdEIsQ0FHQTZKLFFBQVEsQ0FBRzJXLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBdEIsQ0FDQXhqQyxDQUFDLEVBQUkyNUIsZ0JBQUwsQ0FFQSxHQUFJeDVCLE9BQU0sQ0FBR3lsQyxTQUFTLENBQUNuakMsTUFBRCxDQUFTK2dDLFFBQVQsQ0FBdEIsQ0FDQSxNQUFPLEVBQUU3NEIsS0FBRixDQUFVM0ssQ0FBakIsQ0FBb0IsQ0FDbEJ3akMsUUFBUSxDQUFDNzRCLEtBQUQsQ0FBUixDQUNELENBQ0QsTUFBT3hLLE9BQVAsQ0FDRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTazNELE9BQVQsQ0FBZ0IxekQsS0FBaEIsQ0FBdUIsQ0FDckIsR0FBSW1HLE9BQU8sQ0FBQ25HLEtBQUQsQ0FBWCxDQUFvQixDQUNsQixNQUFPdWdDLFNBQVEsQ0FBQ3ZnQyxLQUFELENBQVF3eEMsS0FBUixDQUFmLENBQ0QsQ0FDRCxNQUFPZCxTQUFRLENBQUMxd0MsS0FBRCxDQUFSLENBQWtCLENBQUNBLEtBQUQsQ0FBbEIsQ0FBNEI2cEMsU0FBUyxDQUFDbVEsWUFBWSxDQUFDL3pDLFFBQVEsQ0FBQ2pHLEtBQUQsQ0FBVCxDQUFiLENBQTVDLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzJ6RCxTQUFULENBQWtCQyxNQUFsQixDQUEwQixDQUN4QixHQUFJenBELEdBQUUsQ0FBRyxFQUFFODZCLFNBQVgsQ0FDQSxNQUFPaC9CLFNBQVEsQ0FBQzJ0RCxNQUFELENBQVIsQ0FBbUJ6cEQsRUFBMUIsQ0FDRCxDQUVELDRFQXgrY2lELENBMCtjakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSTVOLElBQUcsQ0FBR21qRCxtQkFBbUIsQ0FBQyxTQUFTbVUsTUFBVCxDQUFpQkMsTUFBakIsQ0FBeUIsQ0FDckQsTUFBT0QsT0FBTSxDQUFHQyxNQUFoQixDQUNELENBRjRCLENBRTFCLENBRjBCLENBQTdCLENBSUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW44QyxLQUFJLENBQUdvcEMsV0FBVyxDQUFDLE1BQUQsQ0FBdEIsQ0FFQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxHQUFJZ1QsT0FBTSxDQUFHclUsbUJBQW1CLENBQUMsU0FBU3NVLFFBQVQsQ0FBbUJDLE9BQW5CLENBQTRCLENBQzNELE1BQU9ELFNBQVEsQ0FBR0MsT0FBbEIsQ0FDRCxDQUYrQixDQUU3QixDQUY2QixDQUFoQyxDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUkxcEQsTUFBSyxDQUFHdzJDLFdBQVcsQ0FBQyxPQUFELENBQXZCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3J4QyxJQUFULENBQWExTSxLQUFiLENBQW9CLENBQ2xCLE1BQVFBLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSDJ4QyxZQUFZLENBQUN6dEMsS0FBRCxDQUFRNHhDLFFBQVIsQ0FBa0I5QyxNQUFsQixDQURULENBRUhqekMsU0FGSixDQUdELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLFFBQVMweUIsTUFBVCxDQUFldnVCLEtBQWYsQ0FBc0I2OEIsUUFBdEIsQ0FBZ0MsQ0FDOUIsTUFBUTc4QixNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQ0gyeEMsWUFBWSxDQUFDenRDLEtBQUQsQ0FBUXd6QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFuQixDQUFrQ2lTLE1BQWxDLENBRFQsQ0FFSGp6QyxTQUZKLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3ExRCxLQUFULENBQWNseEQsS0FBZCxDQUFxQixDQUNuQixNQUFPMCtCLFNBQVEsQ0FBQzErQixLQUFELENBQVE0eEMsUUFBUixDQUFmLENBQ0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU3VmLE9BQVQsQ0FBZ0JueEQsS0FBaEIsQ0FBdUI2OEIsUUFBdkIsQ0FBaUMsQ0FDL0IsTUFBTzZCLFNBQVEsQ0FBQzErQixLQUFELENBQVF3ekMsV0FBVyxDQUFDM1csUUFBRCxDQUFXLENBQVgsQ0FBbkIsQ0FBZixDQUNELENBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBU2x2QixJQUFULENBQWEzTixLQUFiLENBQW9CLENBQ2xCLE1BQVFBLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSDJ4QyxZQUFZLENBQUN6dEMsS0FBRCxDQUFRNHhDLFFBQVIsQ0FBa0JTLE1BQWxCLENBRFQsQ0FFSHgyQyxTQUZKLENBR0QsQ0FFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksUUFBUzZ5QixNQUFULENBQWUxdUIsS0FBZixDQUFzQjY4QixRQUF0QixDQUFnQyxDQUM5QixNQUFRNzhCLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSDJ4QyxZQUFZLENBQUN6dEMsS0FBRCxDQUFRd3pDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBQW5CLENBQWtDd1YsTUFBbEMsQ0FEVCxDQUVIeDJDLFNBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUl1MUQsU0FBUSxDQUFHMVUsbUJBQW1CLENBQUMsU0FBUzJVLFVBQVQsQ0FBcUJDLFlBQXJCLENBQW1DLENBQ3BFLE1BQU9ELFdBQVUsQ0FBR0MsWUFBcEIsQ0FDRCxDQUZpQyxDQUUvQixDQUYrQixDQUFsQyxDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUNJLEdBQUlDLE1BQUssQ0FBR3hULFdBQVcsQ0FBQyxPQUFELENBQXZCLENBRUE7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQ0ksR0FBSW4wQixTQUFRLENBQUc4eUIsbUJBQW1CLENBQUMsU0FBUzhVLE9BQVQsQ0FBa0JDLFVBQWxCLENBQThCLENBQy9ELE1BQU9ELFFBQU8sQ0FBR0MsVUFBakIsQ0FDRCxDQUZpQyxDQUUvQixDQUYrQixDQUFsQyxDQUlBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTL3FDLElBQVQsQ0FBYTFtQixLQUFiLENBQW9CLENBQ2xCLE1BQVFBLE1BQUssRUFBSUEsS0FBSyxDQUFDbEUsTUFBaEIsQ0FDSDZpQyxPQUFPLENBQUMzK0IsS0FBRCxDQUFRNHhDLFFBQVIsQ0FESixDQUVILENBRkosQ0FHRCxDQUVEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSSxRQUFTOGYsTUFBVCxDQUFlMXhELEtBQWYsQ0FBc0I2OEIsUUFBdEIsQ0FBZ0MsQ0FDOUIsTUFBUTc4QixNQUFLLEVBQUlBLEtBQUssQ0FBQ2xFLE1BQWhCLENBQ0g2aUMsT0FBTyxDQUFDMytCLEtBQUQsQ0FBUXd6QyxXQUFXLENBQUMzVyxRQUFELENBQVcsQ0FBWCxDQUFuQixDQURKLENBRUgsQ0FGSixDQUdELENBRUQsNEVBbjBkaUQsQ0FxMGRqRDtBQUNBMEksTUFBTSxDQUFDOW1CLEtBQVAsQ0FBZUEsS0FBZixDQUNBOG1CLE1BQU0sQ0FBQzBXLEdBQVAsQ0FBYUEsR0FBYixDQUNBMVcsTUFBTSxDQUFDNGtCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0E1a0IsTUFBTSxDQUFDNmtCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E3a0IsTUFBTSxDQUFDOGtCLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0E5a0IsTUFBTSxDQUFDK2tCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0Eva0IsTUFBTSxDQUFDZ2xCLEVBQVAsQ0FBWUEsRUFBWixDQUNBaGxCLE1BQU0sQ0FBQ3VnQixNQUFQLENBQWdCQSxNQUFoQixDQUNBdmdCLE1BQU0sQ0FBQy8rQixJQUFQLENBQWNBLElBQWQsQ0FDQSsrQixNQUFNLENBQUM4cEIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTlwQixNQUFNLENBQUN3Z0IsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXhnQixNQUFNLENBQUNpakIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQWpqQixNQUFNLENBQUM1b0MsS0FBUCxDQUFlQSxLQUFmLENBQ0E0b0MsTUFBTSxDQUFDZ2MsS0FBUCxDQUFlQSxLQUFmLENBQ0FoYyxNQUFNLENBQUNpYyxPQUFQLENBQWlCQSxPQUFqQixDQUNBamMsTUFBTSxDQUFDMy9CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0EyL0IsTUFBTSxDQUFDZ3FCLElBQVAsQ0FBY0EsSUFBZCxDQUNBaHFCLE1BQU0sQ0FBQ2lxQixRQUFQLENBQWtCQSxRQUFsQixDQUNBanFCLE1BQU0sQ0FBQ3NQLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F0UCxNQUFNLENBQUNyWSxPQUFQLENBQWlCQSxPQUFqQixDQUNBcVksTUFBTSxDQUFDcjdCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FxN0IsTUFBTSxDQUFDeWdCLEtBQVAsQ0FBZUEsS0FBZixDQUNBemdCLE1BQU0sQ0FBQzBnQixVQUFQLENBQW9CQSxVQUFwQixDQUNBMWdCLE1BQU0sQ0FBQzJnQixRQUFQLENBQWtCQSxRQUFsQixDQUNBM2dCLE1BQU0sQ0FBQzdELFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E2RCxNQUFNLENBQUNvbEIsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQXBsQixNQUFNLENBQUNraUIsS0FBUCxDQUFlQSxLQUFmLENBQ0FsaUIsTUFBTSxDQUFDbWlCLEtBQVAsQ0FBZUEsS0FBZixDQUNBbmlCLE1BQU0sQ0FBQ2tjLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0FsYyxNQUFNLENBQUNtYyxZQUFQLENBQXNCQSxZQUF0QixDQUNBbmMsTUFBTSxDQUFDb2MsY0FBUCxDQUF3QkEsY0FBeEIsQ0FDQXBjLE1BQU0sQ0FBQ3FjLElBQVAsQ0FBY0EsSUFBZCxDQUNBcmMsTUFBTSxDQUFDc2MsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXRjLE1BQU0sQ0FBQ3VjLGNBQVAsQ0FBd0JBLGNBQXhCLENBQ0F2YyxNQUFNLENBQUN3YyxTQUFQLENBQW1CQSxTQUFuQixDQUNBeGMsTUFBTSxDQUFDeWMsSUFBUCxDQUFjQSxJQUFkLENBQ0F6YyxNQUFNLENBQUNsOUIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWs5QixNQUFNLENBQUMxb0MsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQTBvQyxNQUFNLENBQUMyZixXQUFQLENBQXFCQSxXQUFyQixDQUNBM2YsTUFBTSxDQUFDNGYsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQTVmLE1BQU0sQ0FBQzllLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E4ZSxNQUFNLENBQUMwYyxXQUFQLENBQXFCQSxXQUFyQixDQUNBMWMsTUFBTSxDQUFDMmMsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQTNjLE1BQU0sQ0FBQ2hpQixJQUFQLENBQWNBLElBQWQsQ0FDQWdpQixNQUFNLENBQUNtcUIsSUFBUCxDQUFjQSxJQUFkLENBQ0FucUIsTUFBTSxDQUFDb3FCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FwcUIsTUFBTSxDQUFDNGMsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTVjLE1BQU0sQ0FBQ3BtQyxTQUFQLENBQW1CQSxTQUFuQixDQUNBb21DLE1BQU0sQ0FBQ3lsQixXQUFQLENBQXFCQSxXQUFyQixDQUNBemxCLE1BQU0sQ0FBQ3ZYLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F1WCxNQUFNLENBQUM2YyxPQUFQLENBQWlCQSxPQUFqQixDQUNBN2MsTUFBTSxDQUFDOGMsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQTljLE1BQU0sQ0FBQ2dkLGNBQVAsQ0FBd0JBLGNBQXhCLENBQ0FoZCxNQUFNLENBQUNpZCxnQkFBUCxDQUEwQkEsZ0JBQTFCLENBQ0FqZCxNQUFNLENBQUMwbEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTFsQixNQUFNLENBQUMybEIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTNsQixNQUFNLENBQUMrZixTQUFQLENBQW1CQSxTQUFuQixDQUNBL2YsTUFBTSxDQUFDMUksUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQTBJLE1BQU0sQ0FBQ2dnQixLQUFQLENBQWVBLEtBQWYsQ0FDQWhnQixNQUFNLENBQUN2aUMsSUFBUCxDQUFjQSxJQUFkLENBQ0F1aUMsTUFBTSxDQUFDNEYsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTVGLE1BQU0sQ0FBQ2pwQyxHQUFQLENBQWFBLEdBQWIsQ0FDQWlwQyxNQUFNLENBQUM5VixPQUFQLENBQWlCQSxPQUFqQixDQUNBOFYsTUFBTSxDQUFDNmxCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0E3bEIsTUFBTSxDQUFDcXFCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FycUIsTUFBTSxDQUFDc3FCLGVBQVAsQ0FBeUJBLGVBQXpCLENBQ0F0cUIsTUFBTSxDQUFDaWIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWpiLE1BQU0sQ0FBQ2p0QixLQUFQLENBQWVBLEtBQWYsQ0FDQWl0QixNQUFNLENBQUMvc0IsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQStzQixNQUFNLENBQUN1cUIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQXZxQixNQUFNLENBQUN3cUIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXhxQixNQUFNLENBQUN6akMsS0FBUCxDQUFlQSxLQUFmLENBQ0F5akMsTUFBTSxDQUFDb2dCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FwZ0IsTUFBTSxDQUFDMHFCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0ExcUIsTUFBTSxDQUFDOGxCLElBQVAsQ0FBY0EsSUFBZCxDQUNBOWxCLE1BQU0sQ0FBQytsQixNQUFQLENBQWdCQSxNQUFoQixDQUNBL2xCLE1BQU0sQ0FBQ3VpQixJQUFQLENBQWNBLElBQWQsQ0FDQXZpQixNQUFNLENBQUNpZ0IsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWpnQixNQUFNLENBQUMycUIsSUFBUCxDQUFjQSxJQUFkLENBQ0EzcUIsTUFBTSxDQUFDd2lCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F4aUIsTUFBTSxDQUFDNHFCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0E1cUIsTUFBTSxDQUFDNnFCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E3cUIsTUFBTSxDQUFDMGlCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0ExaUIsTUFBTSxDQUFDMmlCLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0EzaUIsTUFBTSxDQUFDa2dCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FsZ0IsTUFBTSxDQUFDNUQsSUFBUCxDQUFjQSxJQUFkLENBQ0E0RCxNQUFNLENBQUNnbUIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWhtQixNQUFNLENBQUN3TSxRQUFQLENBQWtCQSxRQUFsQixDQUNBeE0sTUFBTSxDQUFDOHFCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0E5cUIsTUFBTSxDQUFDbWQsSUFBUCxDQUFjQSxJQUFkLENBQ0FuZCxNQUFNLENBQUNvZCxPQUFQLENBQWlCQSxPQUFqQixDQUNBcGQsTUFBTSxDQUFDcWQsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXJkLE1BQU0sQ0FBQ3NkLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0F0ZCxNQUFNLENBQUN1ZCxNQUFQLENBQWdCQSxNQUFoQixDQUNBdmQsTUFBTSxDQUFDM29DLEtBQVAsQ0FBZUEsS0FBZixDQUNBMm9DLE1BQU0sQ0FBQytxQixVQUFQLENBQW9CQSxVQUFwQixDQUNBL3FCLE1BQU0sQ0FBQzRpQixLQUFQLENBQWVBLEtBQWYsQ0FDQTVpQixNQUFNLENBQUNtZ0IsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQW5nQixNQUFNLENBQUMxdEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTB0QixNQUFNLENBQUM1VyxJQUFQLENBQWNBLElBQWQsQ0FDQTRXLE1BQU0sQ0FBQ3gxQixPQUFQLENBQWlCQSxPQUFqQixDQUNBdzFCLE1BQU0sQ0FBQ3FnQixVQUFQLENBQW9CQSxVQUFwQixDQUNBcmdCLE1BQU0sQ0FBQzN1QixHQUFQLENBQWFBLEdBQWIsQ0FDQTJ1QixNQUFNLENBQUNrbUIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWxtQixNQUFNLENBQUNzZ0IsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQXRnQixNQUFNLENBQUMvbEMsS0FBUCxDQUFlQSxLQUFmLENBQ0ErbEMsTUFBTSxDQUFDM3JDLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0EyckMsTUFBTSxDQUFDOGQsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQTlkLE1BQU0sQ0FBQytkLFlBQVAsQ0FBc0JBLFlBQXRCLENBQ0EvZCxNQUFNLENBQUN2SCxLQUFQLENBQWVBLEtBQWYsQ0FDQXVILE1BQU0sQ0FBQzZpQixNQUFQLENBQWdCQSxNQUFoQixDQUNBN2lCLE1BQU0sQ0FBQ3JrQixJQUFQLENBQWNBLElBQWQsQ0FDQXFrQixNQUFNLENBQUN0VyxJQUFQLENBQWNBLElBQWQsQ0FDQXNXLE1BQU0sQ0FBQ2dlLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FoZSxNQUFNLENBQUNpZSxjQUFQLENBQXdCQSxjQUF4QixDQUNBamUsTUFBTSxDQUFDcFcsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQW9XLE1BQU0sQ0FBQ2dmLEdBQVAsQ0FBYUEsR0FBYixDQUNBaGYsTUFBTSxDQUFDOGlCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E5aUIsTUFBTSxDQUFDaVcsSUFBUCxDQUFjQSxJQUFkLENBQ0FqVyxNQUFNLENBQUNscEMsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWtwQyxNQUFNLENBQUNtbUIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQW5tQixNQUFNLENBQUNvbUIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXBtQixNQUFNLENBQUNtckIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQW5yQixNQUFNLENBQUM2TixhQUFQLENBQXVCQSxhQUF2QixDQUNBN04sTUFBTSxDQUFDNUUsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTRFLE1BQU0sQ0FBQytpQixLQUFQLENBQWVBLEtBQWYsQ0FDQS9pQixNQUFNLENBQUM5YixLQUFQLENBQWVBLEtBQWYsQ0FDQThiLE1BQU0sQ0FBQ2tlLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FsZSxNQUFNLENBQUNtZSxTQUFQLENBQW1CQSxTQUFuQixDQUNBbmUsTUFBTSxDQUFDb2UsSUFBUCxDQUFjQSxJQUFkLENBQ0FwZSxNQUFNLENBQUNxZSxNQUFQLENBQWdCQSxNQUFoQixDQUNBcmUsTUFBTSxDQUFDc2UsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXRlLE1BQU0sQ0FBQ3NtQixLQUFQLENBQWVBLEtBQWYsQ0FDQXRtQixNQUFNLENBQUN1ZSxLQUFQLENBQWVBLEtBQWYsQ0FDQXZlLE1BQU0sQ0FBQ3llLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F6ZSxNQUFNLENBQUNqcUMsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWlxQyxNQUFNLENBQUN1bUIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXZtQixNQUFNLENBQUM3bEIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQTZsQixNQUFNLENBQUN3bUIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXhtQixNQUFNLENBQUMwZSxPQUFQLENBQWlCQSxPQUFqQixDQUNBMWUsTUFBTSxDQUFDbVYsS0FBUCxDQUFlQSxLQUFmLENBQ0FuVixNQUFNLENBQUNnakIsSUFBUCxDQUFjQSxJQUFkLENBQ0FoakIsTUFBTSxDQUFDMmUsR0FBUCxDQUFhQSxHQUFiLENBQ0EzZSxNQUFNLENBQUM0ZSxLQUFQLENBQWVBLEtBQWYsQ0FDQTVlLE1BQU0sQ0FBQzZlLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E3ZSxNQUFNLENBQUNsVixHQUFQLENBQWFBLEdBQWIsQ0FDQWtWLE1BQU0sQ0FBQzhlLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0E5ZSxNQUFNLENBQUMrZSxhQUFQLENBQXVCQSxhQUF2QixDQUNBL2UsTUFBTSxDQUFDaFYsT0FBUCxDQUFpQkEsT0FBakIsQ0FFQTtBQUNBZ1YsTUFBTSxDQUFDbnlCLE9BQVAsQ0FBaUJzNEMsT0FBakIsQ0FDQW5tQixNQUFNLENBQUNvc0IsU0FBUCxDQUFtQmhHLFNBQW5CLENBQ0FwbUIsTUFBTSxDQUFDcXNCLE1BQVAsQ0FBZ0J4SCxRQUFoQixDQUNBN2tCLE1BQU0sQ0FBQ3NzQixVQUFQLENBQW9CeEgsWUFBcEIsQ0FFQTtBQUNBdm9ELEtBQUssQ0FBQ3lqQyxNQUFELENBQVNBLE1BQVQsQ0FBTCxDQUVBLDRFQXIrZGlELENBdStkakQ7QUFDQUEsTUFBTSxDQUFDaHNDLEdBQVAsQ0FBYUEsR0FBYixDQUNBZ3NDLE1BQU0sQ0FBQ2lwQixPQUFQLENBQWlCQSxPQUFqQixDQUNBanBCLE1BQU0sQ0FBQzRtQixTQUFQLENBQW1CQSxTQUFuQixDQUNBNW1CLE1BQU0sQ0FBQyttQixVQUFQLENBQW9CQSxVQUFwQixDQUNBL21CLE1BQU0sQ0FBQzV3QixJQUFQLENBQWNBLElBQWQsQ0FDQTR3QixNQUFNLENBQUN5bUIsS0FBUCxDQUFlQSxLQUFmLENBQ0F6bUIsTUFBTSxDQUFDd0IsS0FBUCxDQUFlQSxLQUFmLENBQ0F4QixNQUFNLENBQUNtakIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQW5qQixNQUFNLENBQUNvakIsYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQXBqQixNQUFNLENBQUNrakIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQWxqQixNQUFNLENBQUNxakIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXJqQixNQUFNLENBQUNvVixNQUFQLENBQWdCQSxNQUFoQixDQUNBcFYsTUFBTSxDQUFDa3FCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FscUIsTUFBTSxDQUFDd3JCLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0F4ckIsTUFBTSxDQUFDaW5CLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FqbkIsTUFBTSxDQUFDbUYsRUFBUCxDQUFZQSxFQUFaLENBQ0FuRixNQUFNLENBQUNtbkIsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQW5uQixNQUFNLENBQUNvbkIsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQXBuQixNQUFNLENBQUNseUIsS0FBUCxDQUFlQSxLQUFmLENBQ0FreUIsTUFBTSxDQUFDbFosSUFBUCxDQUFjQSxJQUFkLENBQ0FrWixNQUFNLENBQUMzVixTQUFQLENBQW1CQSxTQUFuQixDQUNBMlYsTUFBTSxDQUFDaFksT0FBUCxDQUFpQkEsT0FBakIsQ0FDQWdZLE1BQU0sQ0FBQy9YLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0ErWCxNQUFNLENBQUN2VixhQUFQLENBQXVCQSxhQUF2QixDQUNBdVYsTUFBTSxDQUFDN1gsV0FBUCxDQUFxQkEsV0FBckIsQ0FDQTZYLE1BQU0sQ0FBQ2grQixLQUFQLENBQWVBLEtBQWYsQ0FDQWcrQixNQUFNLENBQUM5cEMsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQThwQyxNQUFNLENBQUM2ZixZQUFQLENBQXNCQSxZQUF0QixDQUNBN2YsTUFBTSxDQUFDcWxCLEtBQVAsQ0FBZUEsS0FBZixDQUNBcmxCLE1BQU0sQ0FBQ3NsQixVQUFQLENBQW9CQSxVQUFwQixDQUNBdGxCLE1BQU0sQ0FBQ3VsQixNQUFQLENBQWdCQSxNQUFoQixDQUNBdmxCLE1BQU0sQ0FBQ3dsQixXQUFQLENBQXFCQSxXQUFyQixDQUNBeGxCLE1BQU0sQ0FBQzEwQixHQUFQLENBQWFBLEdBQWIsQ0FDQTAwQixNQUFNLENBQUNzakIsRUFBUCxDQUFZQSxFQUFaLENBQ0F0akIsTUFBTSxDQUFDdWpCLEdBQVAsQ0FBYUEsR0FBYixDQUNBdmpCLE1BQU0sQ0FBQ3gwQixHQUFQLENBQWFBLEdBQWIsQ0FDQXcwQixNQUFNLENBQUN0WCxLQUFQLENBQWVBLEtBQWYsQ0FDQXNYLE1BQU0sQ0FBQ3hhLElBQVAsQ0FBY0EsSUFBZCxDQUNBd2EsTUFBTSxDQUFDcU0sUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXJNLE1BQU0sQ0FBQ3p4QixRQUFQLENBQWtCQSxRQUFsQixDQUNBeXhCLE1BQU0sQ0FBQzdoQyxPQUFQLENBQWlCQSxPQUFqQixDQUNBNmhDLE1BQU0sQ0FBQzVrQyxPQUFQLENBQWlCQSxPQUFqQixDQUNBNGtDLE1BQU0sQ0FBQzRsQixNQUFQLENBQWdCQSxNQUFoQixDQUNBNWxCLE1BQU0sQ0FBQ3VFLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0F2RSxNQUFNLENBQUNwaUMsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQW9pQyxNQUFNLENBQUN2SixhQUFQLENBQXVCQSxhQUF2QixDQUNBdUosTUFBTSxDQUFDbDJCLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0FrMkIsTUFBTSxDQUFDME4saUJBQVAsQ0FBMkJBLGlCQUEzQixDQUNBMU4sTUFBTSxDQUFDd2pCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F4akIsTUFBTSxDQUFDekIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXlCLE1BQU0sQ0FBQ3JKLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FxSixNQUFNLENBQUN5akIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQXpqQixNQUFNLENBQUN0WSxPQUFQLENBQWlCQSxPQUFqQixDQUNBc1ksTUFBTSxDQUFDMGpCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0ExakIsTUFBTSxDQUFDMmpCLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0EzakIsTUFBTSxDQUFDNGpCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E1akIsTUFBTSxDQUFDdkIsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXVCLE1BQU0sQ0FBQzlqQyxVQUFQLENBQW9CQSxVQUFwQixDQUNBOGpDLE1BQU0sQ0FBQzZqQixTQUFQLENBQW1CQSxTQUFuQixDQUNBN2pCLE1BQU0sQ0FBQ21NLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FuTSxNQUFNLENBQUNsdUIsS0FBUCxDQUFlQSxLQUFmLENBQ0FrdUIsTUFBTSxDQUFDOGpCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0E5akIsTUFBTSxDQUFDK2pCLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0EvakIsTUFBTSxDQUFDamlDLEtBQVAsQ0FBZUEsS0FBZixDQUNBaWlDLE1BQU0sQ0FBQ2lrQixRQUFQLENBQWtCQSxRQUFsQixDQUNBamtCLE1BQU0sQ0FBQ2trQixLQUFQLENBQWVBLEtBQWYsQ0FDQWxrQixNQUFNLENBQUMvakMsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQStqQyxNQUFNLENBQUNna0IsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQWhrQixNQUFNLENBQUNPLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FQLE1BQU0sQ0FBQ0MsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQUQsTUFBTSxDQUFDNE4sYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQTVOLE1BQU0sQ0FBQ2xKLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FrSixNQUFNLENBQUNta0IsYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQW5rQixNQUFNLENBQUNsYyxLQUFQLENBQWVBLEtBQWYsQ0FDQWtjLE1BQU0sQ0FBQzhmLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E5ZixNQUFNLENBQUNtSSxRQUFQLENBQWtCQSxRQUFsQixDQUNBbkksTUFBTSxDQUFDL0ksWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQStJLE1BQU0sQ0FBQ2hrQyxXQUFQLENBQXFCQSxXQUFyQixDQUNBZ2tDLE1BQU0sQ0FBQ29rQixTQUFQLENBQW1CQSxTQUFuQixDQUNBcGtCLE1BQU0sQ0FBQ3FrQixTQUFQLENBQW1CQSxTQUFuQixDQUNBcmtCLE1BQU0sQ0FBQ3BaLElBQVAsQ0FBY0EsSUFBZCxDQUNBb1osTUFBTSxDQUFDcW5CLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FybkIsTUFBTSxDQUFDdnJDLElBQVAsQ0FBY0EsSUFBZCxDQUNBdXJDLE1BQU0sQ0FBQ3Z4QixXQUFQLENBQXFCQSxXQUFyQixDQUNBdXhCLE1BQU0sQ0FBQ3NuQixTQUFQLENBQW1CQSxTQUFuQixDQUNBdG5CLE1BQU0sQ0FBQ3VuQixVQUFQLENBQW9CQSxVQUFwQixDQUNBdm5CLE1BQU0sQ0FBQ3NrQixFQUFQLENBQVlBLEVBQVosQ0FDQXRrQixNQUFNLENBQUN1a0IsR0FBUCxDQUFhQSxHQUFiLENBQ0F2a0IsTUFBTSxDQUFDNzRCLEdBQVAsQ0FBYUEsR0FBYixDQUNBNjRCLE1BQU0sQ0FBQ2hYLEtBQVAsQ0FBZUEsS0FBZixDQUNBZ1gsTUFBTSxDQUFDMnJCLElBQVAsQ0FBY0EsSUFBZCxDQUNBM3JCLE1BQU0sQ0FBQzRyQixNQUFQLENBQWdCQSxNQUFoQixDQUNBNXJCLE1BQU0sQ0FBQzUzQixHQUFQLENBQWFBLEdBQWIsQ0FDQTQzQixNQUFNLENBQUM3VyxLQUFQLENBQWVBLEtBQWYsQ0FDQTZXLE1BQU0sQ0FBQ29hLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0FwYSxNQUFNLENBQUMrYSxTQUFQLENBQW1CQSxTQUFuQixDQUNBL2EsTUFBTSxDQUFDZ3JCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0FockIsTUFBTSxDQUFDaXJCLFVBQVAsQ0FBb0JBLFVBQXBCLENBQ0FqckIsTUFBTSxDQUFDa3JCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FsckIsTUFBTSxDQUFDNnJCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E3ckIsTUFBTSxDQUFDa2QsR0FBUCxDQUFhQSxHQUFiLENBQ0FsZCxNQUFNLENBQUN5cUIsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQXpxQixNQUFNLENBQUMyWSxJQUFQLENBQWNBLElBQWQsQ0FDQTNZLE1BQU0sQ0FBQzNxQyxHQUFQLENBQWFBLEdBQWIsQ0FDQTJxQyxNQUFNLENBQUN3bkIsR0FBUCxDQUFhQSxHQUFiLENBQ0F4bkIsTUFBTSxDQUFDMG5CLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0ExbkIsTUFBTSxDQUFDMm5CLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0EzbkIsTUFBTSxDQUFDdEssUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXNLLE1BQU0sQ0FBQ2YsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQWUsTUFBTSxDQUFDcmdDLE1BQVAsQ0FBZ0JBLE1BQWhCLENBQ0FxZ0MsTUFBTSxDQUFDelksV0FBUCxDQUFxQkEsV0FBckIsQ0FDQXlZLE1BQU0sQ0FBQzZuQixNQUFQLENBQWdCQSxNQUFoQixDQUNBN25CLE1BQU0sQ0FBQ2pHLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0FpRyxNQUFNLENBQUMvckMsTUFBUCxDQUFnQkEsTUFBaEIsQ0FDQStyQyxNQUFNLENBQUNnc0IsS0FBUCxDQUFlQSxLQUFmLENBQ0Foc0IsTUFBTSxDQUFDOUQsWUFBUCxDQUFzQkEsWUFBdEIsQ0FDQThELE1BQU0sQ0FBQ3JxQyxNQUFQLENBQWdCQSxNQUFoQixDQUNBcXFDLE1BQU0sQ0FBQ3J0QyxJQUFQLENBQWNBLElBQWQsQ0FDQXF0QyxNQUFNLENBQUM4bkIsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQTluQixNQUFNLENBQUN2ZCxJQUFQLENBQWNBLElBQWQsQ0FDQXVkLE1BQU0sQ0FBQ3dkLFdBQVAsQ0FBcUJBLFdBQXJCLENBQ0F4ZCxNQUFNLENBQUN5ZCxhQUFQLENBQXVCQSxhQUF2QixDQUNBemQsTUFBTSxDQUFDMGQsYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQTFkLE1BQU0sQ0FBQzJkLGVBQVAsQ0FBeUJBLGVBQXpCLENBQ0EzZCxNQUFNLENBQUM0ZCxpQkFBUCxDQUEyQkEsaUJBQTNCLENBQ0E1ZCxNQUFNLENBQUM2ZCxpQkFBUCxDQUEyQkEsaUJBQTNCLENBQ0E3ZCxNQUFNLENBQUNnb0IsU0FBUCxDQUFtQkEsU0FBbkIsQ0FDQWhvQixNQUFNLENBQUNpb0IsVUFBUCxDQUFvQkEsVUFBcEIsQ0FDQWpvQixNQUFNLENBQUMzYixRQUFQLENBQWtCQSxRQUFsQixDQUNBMmIsTUFBTSxDQUFDN2UsR0FBUCxDQUFhQSxHQUFiLENBQ0E2ZSxNQUFNLENBQUNtc0IsS0FBUCxDQUFlQSxLQUFmLENBQ0Fuc0IsTUFBTSxDQUFDa29CLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0Fsb0IsTUFBTSxDQUFDN3hCLEtBQVAsQ0FBZUEsS0FBZixDQUNBNnhCLE1BQU0sQ0FBQzZYLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E3WCxNQUFNLENBQUNxSSxTQUFQLENBQW1CQSxTQUFuQixDQUNBckksTUFBTSxDQUFDc0ksUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXRJLE1BQU0sQ0FBQ2twQixPQUFQLENBQWlCQSxPQUFqQixDQUNBbHBCLE1BQU0sQ0FBQytYLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0EvWCxNQUFNLENBQUMya0IsYUFBUCxDQUF1QkEsYUFBdkIsQ0FDQTNrQixNQUFNLENBQUN0aUMsUUFBUCxDQUFrQkEsUUFBbEIsQ0FDQXNpQyxNQUFNLENBQUNtcEIsT0FBUCxDQUFpQkEsT0FBakIsQ0FDQW5wQixNQUFNLENBQUNxcEIsSUFBUCxDQUFjQSxJQUFkLENBQ0FycEIsTUFBTSxDQUFDc3BCLE9BQVAsQ0FBaUJBLE9BQWpCLENBQ0F0cEIsTUFBTSxDQUFDdXBCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0F2cEIsTUFBTSxDQUFDd3BCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0F4cEIsTUFBTSxDQUFDNHBCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0E1cEIsTUFBTSxDQUFDb3JCLFFBQVAsQ0FBa0JBLFFBQWxCLENBQ0FwckIsTUFBTSxDQUFDNnBCLFNBQVAsQ0FBbUJBLFNBQW5CLENBQ0E3cEIsTUFBTSxDQUFDZ25CLFVBQVAsQ0FBb0JBLFVBQXBCLENBRUE7QUFDQWhuQixNQUFNLENBQUN1c0IsSUFBUCxDQUFjcjJELE9BQWQsQ0FDQThwQyxNQUFNLENBQUN3c0IsU0FBUCxDQUFtQjNNLFlBQW5CLENBQ0E3ZixNQUFNLENBQUM1WCxLQUFQLENBQWU1QyxJQUFmLENBRUFqcEIsS0FBSyxDQUFDeWpDLE1BQUQsQ0FBVSxVQUFXLENBQ3hCLEdBQUk3Z0MsT0FBTSxDQUFHLEVBQWIsQ0FDQTJvQyxVQUFVLENBQUM5SCxNQUFELENBQVMsU0FBUzlJLElBQVQsQ0FBZTZkLFVBQWYsQ0FBMkIsQ0FDNUMsR0FBSSxDQUFDeDNDLGNBQWMsQ0FBQ0ksSUFBZixDQUFvQnFpQyxNQUFNLENBQUMxakMsU0FBM0IsQ0FBc0N5NEMsVUFBdEMsQ0FBTCxDQUF3RCxDQUN0RDUxQyxNQUFNLENBQUM0MUMsVUFBRCxDQUFOLENBQXFCN2QsSUFBckIsQ0FDRCxDQUNGLENBSlMsQ0FBVixDQUtBLE1BQU8vM0IsT0FBUCxDQUNELENBUmMsRUFBVixDQVFDLENBQUUsUUFBUyxLQUFYLENBUkQsQ0FBTCxDQVVBLDRFQTdvZWlELENBK29lakQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FDSTZnQyxNQUFNLENBQUN6VSxPQUFQLENBQWlCQSxPQUFqQixDQUVBO0FBQ0FpTSxTQUFTLENBQUMsQ0FBQyxNQUFELENBQVMsU0FBVCxDQUFvQixPQUFwQixDQUE2QixZQUE3QixDQUEyQyxTQUEzQyxDQUFzRCxjQUF0RCxDQUFELENBQXdFLFNBQVN1ZCxVQUFULENBQXFCLENBQ3BHL1UsTUFBTSxDQUFDK1UsVUFBRCxDQUFOLENBQW1CdmEsV0FBbkIsQ0FBaUN3RixNQUFqQyxDQUNELENBRlEsQ0FBVCxDQUlBO0FBQ0F4SSxTQUFTLENBQUMsQ0FBQyxNQUFELENBQVMsTUFBVCxDQUFELENBQW1CLFNBQVN1ZCxVQUFULENBQXFCdDJDLEtBQXJCLENBQTRCLENBQ3REeWhDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCeTRDLFVBQXRCLEVBQW9DLFNBQVNqaEQsQ0FBVCxDQUFZLENBQzlDQSxDQUFDLENBQUdBLENBQUMsR0FBS3dDLFNBQU4sQ0FBa0IsQ0FBbEIsQ0FBc0Jzb0MsU0FBUyxDQUFDeUosU0FBUyxDQUFDdjBDLENBQUQsQ0FBVixDQUFlLENBQWYsQ0FBbkMsQ0FFQSxHQUFJRyxPQUFNLENBQUksS0FBS2d0QyxZQUFMLEVBQXFCLENBQUN4aUMsS0FBdkIsQ0FDVCxHQUFJeWhDLFlBQUosQ0FBZ0IsSUFBaEIsQ0FEUyxDQUVULEtBQUtzQixLQUFMLEVBRkosQ0FJQSxHQUFJdnRDLE1BQU0sQ0FBQ2d0QyxZQUFYLENBQXlCLENBQ3ZCaHRDLE1BQU0sQ0FBQ2t0QyxhQUFQLENBQXVCdEMsU0FBUyxDQUFDL3FDLENBQUQsQ0FBSUcsTUFBTSxDQUFDa3RDLGFBQVgsQ0FBaEMsQ0FDRCxDQUZELElBRU8sQ0FDTGx0QyxNQUFNLENBQUNtdEMsU0FBUCxDQUFpQjEvQixJQUFqQixDQUFzQixDQUNwQixPQUFRbTlCLFNBQVMsQ0FBQy9xQyxDQUFELENBQUkyNUIsZ0JBQUosQ0FERyxDQUVwQixPQUFRc25CLFVBQVUsRUFBSTlnRCxNQUFNLENBQUMrc0MsT0FBUCxDQUFpQixDQUFqQixDQUFxQixPQUFyQixDQUErQixFQUFuQyxDQUZFLENBQXRCLEVBSUQsQ0FDRCxNQUFPL3NDLE9BQVAsQ0FDRCxDQWhCRCxDQWtCQWlzQyxXQUFXLENBQUM1akMsU0FBWixDQUFzQnk0QyxVQUFVLENBQUcsT0FBbkMsRUFBOEMsU0FBU2poRCxDQUFULENBQVksQ0FDeEQsTUFBTyxNQUFLMFcsT0FBTCxHQUFldXFDLFVBQWYsRUFBMkJqaEQsQ0FBM0IsRUFBOEIwVyxPQUE5QixFQUFQLENBQ0QsQ0FGRCxDQUdELENBdEJRLENBQVQsQ0F3QkE7QUFDQWd0QixTQUFTLENBQUMsQ0FBQyxRQUFELENBQVcsS0FBWCxDQUFrQixXQUFsQixDQUFELENBQWlDLFNBQVN1ZCxVQUFULENBQXFCdDJDLEtBQXJCLENBQTRCLENBQ3BFLEdBQUkvTSxLQUFJLENBQUcrTSxLQUFLLENBQUcsQ0FBbkIsQ0FDSWd1RCxRQUFRLENBQUcvNkQsSUFBSSxFQUFJdzdCLGdCQUFSLEVBQTRCeDdCLElBQUksRUFBSTA3QixlQURuRCxDQUdBOFMsV0FBVyxDQUFDNWpDLFNBQVosQ0FBc0J5NEMsVUFBdEIsRUFBb0MsU0FBU3pkLFFBQVQsQ0FBbUIsQ0FDckQsR0FBSXJqQyxPQUFNLENBQUcsS0FBS3V0QyxLQUFMLEVBQWIsQ0FDQXZ0QyxNQUFNLENBQUNpdEMsYUFBUCxDQUFxQngvQixJQUFyQixDQUEwQixDQUN4QixXQUFZdXNDLFdBQVcsQ0FBQzNXLFFBQUQsQ0FBVyxDQUFYLENBREMsQ0FFeEIsT0FBUTVsQyxJQUZnQixDQUExQixFQUlBdUMsTUFBTSxDQUFDZ3RDLFlBQVAsQ0FBc0JodEMsTUFBTSxDQUFDZ3RDLFlBQVAsRUFBdUJ3ckIsUUFBN0MsQ0FDQSxNQUFPeDRELE9BQVAsQ0FDRCxDQVJELENBU0QsQ0FiUSxDQUFULENBZUE7QUFDQXVqQyxTQUFTLENBQUMsQ0FBQyxNQUFELENBQVMsTUFBVCxDQUFELENBQW1CLFNBQVN1ZCxVQUFULENBQXFCdDJDLEtBQXJCLENBQTRCLENBQ3RELEdBQUlpdUQsU0FBUSxDQUFHLFFBQVVqdUQsS0FBSyxDQUFHLE9BQUgsQ0FBYSxFQUE1QixDQUFmLENBRUF5aEMsV0FBVyxDQUFDNWpDLFNBQVosQ0FBc0J5NEMsVUFBdEIsRUFBb0MsVUFBVyxDQUM3QyxNQUFPLE1BQUsyWCxRQUFMLEVBQWUsQ0FBZixFQUFrQmoxRCxLQUFsQixHQUEwQixDQUExQixDQUFQLENBQ0QsQ0FGRCxDQUdELENBTlEsQ0FBVCxDQVFBO0FBQ0ErL0IsU0FBUyxDQUFDLENBQUMsU0FBRCxDQUFZLE1BQVosQ0FBRCxDQUFzQixTQUFTdWQsVUFBVCxDQUFxQnQyQyxLQUFyQixDQUE0QixDQUN6RCxHQUFJa3VELFNBQVEsQ0FBRyxRQUFVbHVELEtBQUssQ0FBRyxFQUFILENBQVEsT0FBdkIsQ0FBZixDQUVBeWhDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCeTRDLFVBQXRCLEVBQW9DLFVBQVcsQ0FDN0MsTUFBTyxNQUFLOVQsWUFBTCxDQUFvQixHQUFJZixZQUFKLENBQWdCLElBQWhCLENBQXBCLENBQTRDLEtBQUt5c0IsUUFBTCxFQUFlLENBQWYsQ0FBbkQsQ0FDRCxDQUZELENBR0QsQ0FOUSxDQUFULENBUUF6c0IsV0FBVyxDQUFDNWpDLFNBQVosQ0FBc0IyL0MsT0FBdEIsQ0FBZ0MsVUFBVyxDQUN6QyxNQUFPLE1BQUtuNUMsTUFBTCxDQUFZdXBDLFFBQVosQ0FBUCxDQUNELENBRkQsQ0FJQW5NLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCd3FCLElBQXRCLENBQTZCLFNBQVNsb0IsU0FBVCxDQUFvQixDQUMvQyxNQUFPLE1BQUtrRSxNQUFMLENBQVlsRSxTQUFaLEVBQXVCNG1CLElBQXZCLEVBQVAsQ0FDRCxDQUZELENBSUEwYSxXQUFXLENBQUM1akMsU0FBWixDQUFzQjJyQixRQUF0QixDQUFpQyxTQUFTcnBCLFNBQVQsQ0FBb0IsQ0FDbkQsTUFBTyxNQUFLNEwsT0FBTCxHQUFlc2MsSUFBZixDQUFvQmxvQixTQUFwQixDQUFQLENBQ0QsQ0FGRCxDQUlBc2hDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCeWpELFNBQXRCLENBQWtDaFIsUUFBUSxDQUFDLFNBQVN4ckMsSUFBVCxDQUFlaEUsSUFBZixDQUFxQixDQUM5RCxHQUFJLE1BQU9nRSxLQUFQLEVBQWUsVUFBbkIsQ0FBK0IsQ0FDN0IsTUFBTyxJQUFJMjhCLFlBQUosQ0FBZ0IsSUFBaEIsQ0FBUCxDQUNELENBQ0QsTUFBTyxNQUFLbnBDLEdBQUwsQ0FBUyxTQUFTVSxLQUFULENBQWdCLENBQzlCLE1BQU8weUMsV0FBVSxDQUFDMXlDLEtBQUQsQ0FBUThMLElBQVIsQ0FBY2hFLElBQWQsQ0FBakIsQ0FDRCxDQUZNLENBQVAsQ0FHRCxDQVB5QyxDQUExQyxDQVNBMmdDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCNmpELE1BQXRCLENBQStCLFNBQVN2aEQsU0FBVCxDQUFvQixDQUNqRCxNQUFPLE1BQUtrRSxNQUFMLENBQVlzOUMsTUFBTSxDQUFDblMsV0FBVyxDQUFDcnZDLFNBQUQsQ0FBWixDQUFsQixDQUFQLENBQ0QsQ0FGRCxDQUlBc2hDLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCckMsS0FBdEIsQ0FBOEIsU0FBUzhVLEtBQVQsQ0FBZ0JoSCxHQUFoQixDQUFxQixDQUNqRGdILEtBQUssQ0FBR3M1QixTQUFTLENBQUN0NUIsS0FBRCxDQUFqQixDQUVBLEdBQUk5YSxPQUFNLENBQUcsSUFBYixDQUNBLEdBQUlBLE1BQU0sQ0FBQ2d0QyxZQUFQLEdBQXdCbHlCLEtBQUssQ0FBRyxDQUFSLEVBQWFoSCxHQUFHLENBQUcsQ0FBM0MsQ0FBSixDQUFtRCxDQUNqRCxNQUFPLElBQUltNEIsWUFBSixDQUFnQmpzQyxNQUFoQixDQUFQLENBQ0QsQ0FDRCxHQUFJOGEsS0FBSyxDQUFHLENBQVosQ0FBZSxDQUNiOWEsTUFBTSxDQUFHQSxNQUFNLENBQUMrcEQsU0FBUCxDQUFpQixDQUFDanZDLEtBQWxCLENBQVQsQ0FDRCxDQUZELElBRU8sSUFBSUEsS0FBSixDQUFXLENBQ2hCOWEsTUFBTSxDQUFHQSxNQUFNLENBQUNvb0QsSUFBUCxDQUFZdHRDLEtBQVosQ0FBVCxDQUNELENBQ0QsR0FBSWhILEdBQUcsR0FBS3pSLFNBQVosQ0FBdUIsQ0FDckJ5UixHQUFHLENBQUdzZ0MsU0FBUyxDQUFDdGdDLEdBQUQsQ0FBZixDQUNBOVQsTUFBTSxDQUFHOFQsR0FBRyxDQUFHLENBQU4sQ0FBVTlULE1BQU0sQ0FBQ3FvRCxTQUFQLENBQWlCLENBQUN2MEMsR0FBbEIsQ0FBVixDQUFtQzlULE1BQU0sQ0FBQ3kxQixJQUFQLENBQVkzaEIsR0FBRyxDQUFHZ0gsS0FBbEIsQ0FBNUMsQ0FDRCxDQUNELE1BQU85YSxPQUFQLENBQ0QsQ0FqQkQsQ0FtQkFpc0MsV0FBVyxDQUFDNWpDLFNBQVosQ0FBc0IyaEQsY0FBdEIsQ0FBdUMsU0FBU3IvQyxTQUFULENBQW9CLENBQ3pELE1BQU8sTUFBSzRMLE9BQUwsR0FBZW9mLFNBQWYsQ0FBeUJockIsU0FBekIsRUFBb0M0TCxPQUFwQyxFQUFQLENBQ0QsQ0FGRCxDQUlBMDFCLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCeEYsT0FBdEIsQ0FBZ0MsVUFBVyxDQUN6QyxNQUFPLE1BQUs0eUIsSUFBTCxDQUFVK0QsZ0JBQVYsQ0FBUCxDQUNELENBRkQsQ0FJQTtBQUNBcWEsVUFBVSxDQUFDNUgsV0FBVyxDQUFDNWpDLFNBQWIsQ0FBd0IsU0FBUzQ2QixJQUFULENBQWU2ZCxVQUFmLENBQTJCLENBQzNELEdBQUk2WCxjQUFhLENBQUcscUNBQXFDN3hCLElBQXJDLENBQTBDZ2EsVUFBMUMsQ0FBcEIsQ0FDSThYLE9BQU8sQ0FBRyxrQkFBa0I5eEIsSUFBbEIsQ0FBdUJnYSxVQUF2QixDQURkLENBRUkrWCxVQUFVLENBQUc5c0IsTUFBTSxDQUFDNnNCLE9BQU8sQ0FBSSxRQUFVOVgsVUFBVSxFQUFJLE1BQWQsQ0FBdUIsT0FBdkIsQ0FBaUMsRUFBM0MsQ0FBSixDQUFzREEsVUFBOUQsQ0FGdkIsQ0FHSWdZLFlBQVksQ0FBR0YsT0FBTyxFQUFJLFFBQVE5eEIsSUFBUixDQUFhZ2EsVUFBYixDQUg5QixDQUtBLEdBQUksQ0FBQytYLFVBQUwsQ0FBaUIsQ0FDZixPQUNELENBQ0Q5c0IsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJ5NEMsVUFBakIsRUFBK0IsVUFBVyxDQUN4QyxHQUFJdDlDLE1BQUssQ0FBRyxLQUFLaXBDLFdBQWpCLENBQ0luaEMsSUFBSSxDQUFHc3RELE9BQU8sQ0FBRyxDQUFDLENBQUQsQ0FBSCxDQUFTdnRELFNBRDNCLENBRUkwdEQsTUFBTSxDQUFHdjFELEtBQUssV0FBWXlvQyxZQUY5QixDQUdJNUksUUFBUSxDQUFHLzNCLElBQUksQ0FBQyxDQUFELENBSG5CLENBSUkwdEQsT0FBTyxDQUFHRCxNQUFNLEVBQUlwdkQsT0FBTyxDQUFDbkcsS0FBRCxDQUovQixDQU1BLEdBQUl3bkQsWUFBVyxDQUFHLFNBQVN4bkQsS0FBVCxDQUFnQixDQUNoQyxHQUFJeEQsT0FBTSxDQUFHNjRELFVBQVUsQ0FBQzN3RCxLQUFYLENBQWlCNmpDLE1BQWpCLENBQXlCL0gsU0FBUyxDQUFDLENBQUN4Z0MsS0FBRCxDQUFELENBQVU4SCxJQUFWLENBQWxDLENBQWIsQ0FDQSxNQUFRc3RELFFBQU8sRUFBSXBzQixRQUFaLENBQXdCeHNDLE1BQU0sQ0FBQyxDQUFELENBQTlCLENBQW9DQSxNQUEzQyxDQUNELENBSEQsQ0FLQSxHQUFJZzVELE9BQU8sRUFBSUwsYUFBWCxFQUE0QixNQUFPdDFCLFNBQVAsRUFBbUIsVUFBL0MsRUFBNkRBLFFBQVEsQ0FBQy9nQyxNQUFULEVBQW1CLENBQXBGLENBQXVGLENBQ3JGO0FBQ0F5MkQsTUFBTSxDQUFHQyxPQUFPLENBQUcsS0FBbkIsQ0FDRCxDQUNELEdBQUl4c0IsU0FBUSxDQUFHLEtBQUtHLFNBQXBCLENBQ0lzc0IsUUFBUSxDQUFHLENBQUMsQ0FBQyxLQUFLdnNCLFdBQUwsQ0FBaUJwcUMsTUFEbEMsQ0FFSTQyRCxXQUFXLENBQUdKLFlBQVksRUFBSSxDQUFDdHNCLFFBRm5DLENBR0kyc0IsUUFBUSxDQUFHSixNQUFNLEVBQUksQ0FBQ0UsUUFIMUIsQ0FLQSxHQUFJLENBQUNILFlBQUQsRUFBaUJFLE9BQXJCLENBQThCLENBQzVCeDFELEtBQUssQ0FBRzIxRCxRQUFRLENBQUczMUQsS0FBSCxDQUFXLEdBQUl5b0MsWUFBSixDQUFnQixJQUFoQixDQUEzQixDQUNBLEdBQUlqc0MsT0FBTSxDQUFHaWpDLElBQUksQ0FBQy82QixLQUFMLENBQVcxRSxLQUFYLENBQWtCOEgsSUFBbEIsQ0FBYixDQUNBdEwsTUFBTSxDQUFDMHNDLFdBQVAsQ0FBbUJqL0IsSUFBbkIsQ0FBd0IsQ0FBRSxPQUFRdTBDLElBQVYsQ0FBZ0IsT0FBUSxDQUFDZ0osV0FBRCxDQUF4QixDQUF1QyxVQUFXM29ELFNBQWxELENBQXhCLEVBQ0EsTUFBTyxJQUFJNnBDLGNBQUosQ0FBa0Jsc0MsTUFBbEIsQ0FBMEJ3c0MsUUFBMUIsQ0FBUCxDQUNELENBQ0QsR0FBSTBzQixXQUFXLEVBQUlDLFFBQW5CLENBQTZCLENBQzNCLE1BQU9sMkIsS0FBSSxDQUFDLzZCLEtBQUwsQ0FBVyxJQUFYLENBQWlCb0QsSUFBakIsQ0FBUCxDQUNELENBQ0R0TCxNQUFNLENBQUcsS0FBS2dpRCxJQUFMLENBQVVnSixXQUFWLENBQVQsQ0FDQSxNQUFPa08sWUFBVyxDQUFJTixPQUFPLENBQUc1NEQsTUFBTSxDQUFDd0QsS0FBUCxHQUFlLENBQWYsQ0FBSCxDQUF1QnhELE1BQU0sQ0FBQ3dELEtBQVAsRUFBbEMsQ0FBb0R4RCxNQUF0RSxDQUNELENBaENELENBaUNELENBMUNTLENBQVYsQ0E0Q0E7QUFDQXVqQyxTQUFTLENBQUMsQ0FBQyxLQUFELENBQVEsTUFBUixDQUFnQixPQUFoQixDQUF5QixNQUF6QixDQUFpQyxRQUFqQyxDQUEyQyxTQUEzQyxDQUFELENBQXdELFNBQVN1ZCxVQUFULENBQXFCLENBQ3BGLEdBQUk3ZCxLQUFJLENBQUdtRixVQUFVLENBQUMwWSxVQUFELENBQXJCLENBQ0lzWSxTQUFTLENBQUcsMEJBQTBCdHlCLElBQTFCLENBQStCZ2EsVUFBL0IsRUFBNkMsS0FBN0MsQ0FBcUQsTUFEckUsQ0FFSWdZLFlBQVksQ0FBRyxrQkFBa0JoeUIsSUFBbEIsQ0FBdUJnYSxVQUF2QixDQUZuQixDQUlBL1UsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJ5NEMsVUFBakIsRUFBK0IsVUFBVyxDQUN4QyxHQUFJeDFDLEtBQUksQ0FBR0QsU0FBWCxDQUNBLEdBQUl5dEQsWUFBWSxFQUFJLENBQUMsS0FBS25zQixTQUExQixDQUFxQyxDQUNuQyxHQUFJbnBDLE1BQUssQ0FBRyxLQUFLQSxLQUFMLEVBQVosQ0FDQSxNQUFPeS9CLEtBQUksQ0FBQy82QixLQUFMLENBQVd5QixPQUFPLENBQUNuRyxLQUFELENBQVAsQ0FBaUJBLEtBQWpCLENBQXlCLEVBQXBDLENBQXdDOEgsSUFBeEMsQ0FBUCxDQUNELENBQ0QsTUFBTyxNQUFLOHRELFNBQUwsRUFBZ0IsU0FBUzUxRCxLQUFULENBQWdCLENBQ3JDLE1BQU95L0IsS0FBSSxDQUFDLzZCLEtBQUwsQ0FBV3lCLE9BQU8sQ0FBQ25HLEtBQUQsQ0FBUCxDQUFpQkEsS0FBakIsQ0FBeUIsRUFBcEMsQ0FBd0M4SCxJQUF4QyxDQUFQLENBQ0QsQ0FGTSxDQUFQLENBR0QsQ0FURCxDQVVELENBZlEsQ0FBVCxDQWlCQTtBQUNBdW9DLFVBQVUsQ0FBQzVILFdBQVcsQ0FBQzVqQyxTQUFiLENBQXdCLFNBQVM0NkIsSUFBVCxDQUFlNmQsVUFBZixDQUEyQixDQUMzRCxHQUFJK1gsV0FBVSxDQUFHOXNCLE1BQU0sQ0FBQytVLFVBQUQsQ0FBdkIsQ0FDQSxHQUFJK1gsVUFBSixDQUFnQixDQUNkLEdBQUlqdUQsSUFBRyxDQUFHaXVELFVBQVUsQ0FBQ24yRCxJQUFYLENBQWtCLEVBQTVCLENBQ0EsR0FBSSxDQUFDNEcsY0FBYyxDQUFDSSxJQUFmLENBQW9CNGhDLFNBQXBCLENBQStCMWdDLEdBQS9CLENBQUwsQ0FBMEMsQ0FDeEMwZ0MsU0FBUyxDQUFDMWdDLEdBQUQsQ0FBVCxDQUFpQixFQUFqQixDQUNELENBQ0QwZ0MsU0FBUyxDQUFDMWdDLEdBQUQsQ0FBVCxDQUFlNkMsSUFBZixDQUFvQixDQUFFLE9BQVFxekMsVUFBVixDQUFzQixPQUFRK1gsVUFBOUIsQ0FBcEIsRUFDRCxDQUNGLENBVFMsQ0FBVixDQVdBdnRCLFNBQVMsQ0FBQ21XLFlBQVksQ0FBQ3AvQyxTQUFELENBQVkrMUIsa0JBQVosQ0FBWixDQUE0QzExQixJQUE3QyxDQUFULENBQThELENBQUMsQ0FDN0QsT0FBUSxTQURxRCxDQUU3RCxPQUFRTCxTQUZxRCxDQUFELENBQTlELENBS0E7QUFDQTRwQyxXQUFXLENBQUM1akMsU0FBWixDQUFzQmtsQyxLQUF0QixDQUE4QkgsU0FBOUIsQ0FDQW5CLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCa08sT0FBdEIsQ0FBZ0MrMkIsV0FBaEMsQ0FDQXJCLFdBQVcsQ0FBQzVqQyxTQUFaLENBQXNCN0UsS0FBdEIsQ0FBOEJncUMsU0FBOUIsQ0FFQTtBQUNBekIsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUIwb0QsRUFBakIsQ0FBc0I5RixTQUF0QixDQUNBbGYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJsRixLQUFqQixDQUF5QituRCxZQUF6QixDQUNBbmYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJneEQsTUFBakIsQ0FBMEJsTyxhQUExQixDQUNBcGYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJzTSxJQUFqQixDQUF3QnkyQyxXQUF4QixDQUNBcmYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJnNkMsS0FBakIsQ0FBeUJpSixZQUF6QixDQUNBdmYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJrTyxPQUFqQixDQUEyQmcxQyxjQUEzQixDQUNBeGYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUJncUIsTUFBakIsQ0FBMEIwWixNQUFNLENBQUMxakMsU0FBUCxDQUFpQmtSLE9BQWpCLENBQTJCd3lCLE1BQU0sQ0FBQzFqQyxTQUFQLENBQWlCN0UsS0FBakIsQ0FBeUJpb0QsWUFBOUUsQ0FFQTtBQUNBMWYsTUFBTSxDQUFDMWpDLFNBQVAsQ0FBaUI4ckIsS0FBakIsQ0FBeUI0WCxNQUFNLENBQUMxakMsU0FBUCxDQUFpQmtwQixJQUExQyxDQUVBLEdBQUlrWSxXQUFKLENBQWlCLENBQ2ZzQyxNQUFNLENBQUMxakMsU0FBUCxDQUFpQm9oQyxXQUFqQixFQUFnQzRoQixpQkFBaEMsQ0FDRCxDQUNELE1BQU90ZixPQUFQLENBQ0QsQ0FqM2VELENBbTNlQSw4RUFseGhCVyxDQW94aEJYO0FBQ0EsR0FBSTlyQyxFQUFDLENBQUdnb0MsWUFBWSxFQUFwQixDQUVBO0FBQ0EsR0FBSSxJQUFKLENBQWdGLENBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0F6a0IsSUFBSSxDQUFDdmpCLENBQUwsQ0FBU0EsQ0FBVCxDQUVBO0FBQ0E7QUFDQWlOLG1DQUFPLFVBQVcsQ0FDaEIsTUFBT2pOLEVBQVAsQ0FDRCxDQUZLO0FBQUEsb0dBQU4sQ0FHRCxDQUNEO0FBYkEsSUFjSyxHQVVOLENBaHpoQkMsRUFnemhCQXlKLElBaHpoQkEsQ0FnemhCSyxJQWh6aEJMLENBQUQsQzs7Ozs7Ozs7Ozs7O0FDUkQsSUFBSTR2RCxDQUFKLEMsQ0FFQTs7QUFDQUEsQ0FBQyxHQUFJLFlBQVc7QUFDZixTQUFPLElBQVA7QUFDQSxDQUZHLEVBQUo7O0FBSUEsSUFBSTtBQUNIO0FBQ0FBLEdBQUMsR0FBR0EsQ0FBQyxJQUFJLElBQUl6M0IsUUFBSixDQUFhLGFBQWIsR0FBVDtBQUNBLENBSEQsQ0FHRSxPQUFPcjJCLENBQVAsRUFBVTtBQUNYO0FBQ0EsTUFBSSxPQUFPK3RELE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0NELENBQUMsR0FBR0MsTUFBSjtBQUNoQyxDLENBRUQ7QUFDQTtBQUNBOzs7QUFFQXJwRCxNQUFNLENBQUNDLE9BQVAsR0FBaUJtcEQsQ0FBakIsQzs7Ozs7Ozs7Ozs7QUNuQkFwcEQsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFVBQVNELE1BQVQsRUFBaUI7QUFDakMsTUFBSSxDQUFDQSxNQUFNLENBQUNzcEQsZUFBWixFQUE2QjtBQUM1QnRwRCxVQUFNLENBQUN1cEQsU0FBUCxHQUFtQixZQUFXLENBQUUsQ0FBaEM7O0FBQ0F2cEQsVUFBTSxDQUFDMmhDLEtBQVAsR0FBZSxFQUFmLENBRjRCLENBRzVCOztBQUNBLFFBQUksQ0FBQzNoQyxNQUFNLENBQUN3cEQsUUFBWixFQUFzQnhwRCxNQUFNLENBQUN3cEQsUUFBUCxHQUFrQixFQUFsQjtBQUN0Qm53RCxVQUFNLENBQUNtRCxjQUFQLENBQXNCd0QsTUFBdEIsRUFBOEIsUUFBOUIsRUFBd0M7QUFDdkN0RCxnQkFBVSxFQUFFLElBRDJCO0FBRXZDeUssU0FBRyxFQUFFLFlBQVc7QUFDZixlQUFPbkgsTUFBTSxDQUFDeXBELENBQWQ7QUFDQTtBQUpzQyxLQUF4QztBQU1BcHdELFVBQU0sQ0FBQ21ELGNBQVAsQ0FBc0J3RCxNQUF0QixFQUE4QixJQUE5QixFQUFvQztBQUNuQ3RELGdCQUFVLEVBQUUsSUFEdUI7QUFFbkN5SyxTQUFHLEVBQUUsWUFBVztBQUNmLGVBQU9uSCxNQUFNLENBQUNsRixDQUFkO0FBQ0E7QUFKa0MsS0FBcEM7QUFNQWtGLFVBQU0sQ0FBQ3NwRCxlQUFQLEdBQXlCLENBQXpCO0FBQ0E7O0FBQ0QsU0FBT3RwRCxNQUFQO0FBQ0EsQ0FyQkQsQyIsImZpbGUiOiJNb250ZUNhcmxvVHJlZVNlYXJjaFdlYldvcmtlci5idW5kbGUud29ya2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuL2pzL2RlY2lkZXJzL01vbnRlQ2FybG9UcmVlU2VhcmNoV2ViV29ya2VyLmpzXCIpO1xuIiwiaW1wb3J0IHsgVElMRV9DSE9TRU4gfSBmcm9tICcuLi9jb25zdGFudHMvQWN0aW9uVHlwZXMuanMnO1xuaW1wb3J0IGNoZWNrIGZyb20gJ2NoZWNrLXR5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbGVDaG9zZW4oYWN0aW9uKSB7XG4gIGNoZWNrLmFzc2VydC5hc3NpZ25lZChhY3Rpb24udGlsZUlkLCAndGlsZUlkIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgY2hlY2suYXNzZXJ0LmFzc2lnbmVkKGFjdGlvbi5jb2xvdXIsICdjb2xvdXIgbXVzdCBiZSBwcm92aWRlZCcpO1xuICBjb25zdCB7IHRpbGVJZCwgY29sb3VyIH0gPSBhY3Rpb247XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUSUxFX0NIT1NFTixcbiAgICB0aWxlSWQsXG4gICAgY29sb3VyXG4gIH07XG59XG4iLCJleHBvcnQgY29uc3QgUExBWUVSU19KT0lOID0gJ1BMQVlFUlNfSk9JTic7XG5leHBvcnQgY29uc3QgVElMRV9DSE9TRU4gPSAnVElMRV9DSE9TRU4nO1xuIiwiZXhwb3J0IGNvbnN0IENPTE9VUl9ORVVUUkFMID0gMDtcbmV4cG9ydCBjb25zdCBDT0xPVVJfQkxVRSA9IDE7XG5leHBvcnQgY29uc3QgQ09MT1VSX1JFRCA9IDI7XG5leHBvcnQgY29uc3QgQk9SREVSX0xFRlQgPSAzO1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9UT1AgPSA0O1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9UT1BfUklHSFQgPSA1O1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9SSUdIVCA9IDY7XG5leHBvcnQgY29uc3QgQk9SREVSX0JPVFRPTV9SSUdIVCA9IDc7XG5leHBvcnQgY29uc3QgQk9SREVSX0JPVFRPTSA9IDg7XG5leHBvcnQgY29uc3QgQk9SREVSX0JPVFRPTV9MRUZUID0gOTtcbmV4cG9ydCBjb25zdCBCT1JERVJfVE9QX0xFRlRfQkxVRSA9IDEwO1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9UT1BfTEVGVF9SRUQgPSAxMTtcbmV4cG9ydCBjb25zdCBCT1JERVJfQk9UVE9NX1JJR0hUX0JMVUUgPSAxMjtcbmV4cG9ydCBjb25zdCBCT1JERVJfQk9UVE9NX1JJR0hUX1JFRCA9IDEzO1xuIiwiLy8gVGhpcyBpcyB0aGUgd2lkdGggb2YgdGhlIGdhbWUgYm9hcmQuXG4vLyBUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGxheWluZyBhcmVhIGlzIHRoaXMgbWludXMgMi5cbmNvbnN0IHNpemUgPSA3O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHdpZHRoOiBzaXplLFxuICBoZWlnaHQ6IHNpemUsXG4gIGxheW91dDogJ29kZC1yJyxcbiAgb3JpZW50YXRpb246ICdwb2ludHktdG9wcGVkJyxcbiAgc2hhcGU6ICdwYXJhbGxlbG9ncmFtJyxcbiAgdmFsaWRhdGU6IGZhbHNlXG59O1xuIiwiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBnYW1lUmVkdWNlciBmcm9tICcuLi9yZWR1Y2Vycy9oZXhidXN0ZXJzLmpzJztcbmltcG9ydCB7XG4gIGdldEFjdGlvbnMsXG4gIGdldFJhbmRvbUFjdGlvbixcbiAgZ2V0Q3VycmVudFBsYXllclxufSBmcm9tICcuLi9oZXhidXN0ZXJzL2hlbHBlcnMuanMnO1xuXG5jbGFzcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoeyBhY3Rpb24gPSBudWxsLCBwYXJlbnQgPSBudWxsLCBzdGF0ZSA9IG51bGwgfSkge1xuICAgIC8vIFRoZSBhY3Rpb24gdGhhdCBsZWQgdG8gdGhpcyBub2RlLiBOdWxsIGZvciB0aGUgcm9vdCBub2RlLlxuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgLy8gTnVsbCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnQ7XG4gICAgdGhpcy5jaGlsZE5vZGVzID0gbmV3IFNldChbXSk7XG4gICAgdGhpcy53aW5zID0gMDtcbiAgICB0aGlzLnZpc2l0cyA9IDA7XG4gICAgdGhpcy51bnRyaWVkQWN0aW9ucyA9IG5ldyBTZXQoZ2V0QWN0aW9ucyhzdGF0ZSkpO1xuICAgIHRoaXMuY3VycmVudFBsYXllciA9IGdldEN1cnJlbnRQbGF5ZXIoc3RhdGUpO1xuICB9XG5cbiAgYWRkQ2hpbGQoYWN0aW9uLCBzdGF0ZSkge1xuICAgIGNvbnN0IG4gPSBuZXcgTm9kZSh7IGFjdGlvbiwgc3RhdGUsIHBhcmVudDogdGhpcyB9KTtcbiAgICB0aGlzLnVudHJpZWRBY3Rpb25zLmRlbGV0ZShhY3Rpb24pO1xuICAgIHRoaXMuY2hpbGROb2Rlcy5hZGQobik7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICB1cGRhdGUocmVzdWx0KSB7XG4gICAgdGhpcy52aXNpdHMgKz0gMTtcbiAgICB0aGlzLndpbnMgKz0gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgVUNCMSBmb3JtdWxhIHRvIHNlbGVjdCBhIGNoaWxkIG5vZGUuXG4gICAqL1xuICBVQ0IxU2VsZWN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIF8oQXJyYXkuZnJvbSh0aGlzLmNoaWxkTm9kZXMpKVxuICAgICAgLnNvcnRCeShcbiAgICAgICAgKG4pID0+XG4gICAgICAgICAgbi53aW5zIC8gbi52aXNpdHMgKyBNYXRoLnNxcnQoKDIgKiBNYXRoLmxvZyh0aGlzLnZpc2l0cykpIC8gbi52aXNpdHMpXG4gICAgICApXG4gICAgICAubGFzdCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlVmFsdWUoc3RhdGUsIHBsYXllcikge1xuICBpZiAocGxheWVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHN0YXRlLndpbm5lcikge1xuICAgIGNhc2UgcGxheWVyLmNvbG91cjpcbiAgICAgIHJldHVybiAtMTtcbiAgICBjYXNlIG51bGw6XG4gICAgICAvLyBTdGFsZW1hdGUuXG4gICAgICByZXR1cm4gMDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDE7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9udGVDYXJsb1RyZWVTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAvKipcbiAgICAgKiBIb3cgbXVjaCB0aW1lIHRvIHNwZW5kIHRoaW5raW5nLlxuICAgICAqL1xuICAgIHRoaXMudGltZUxpbWl0TXMgPSBvcHRpb25zLnRpbWVMaW1pdE1zIHx8IDEwMDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG91dHB1dCBkZWJ1ZyBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldEJlc3RBY3Rpb24ocGxheWVyQ29sb3VyLCByb290U3RhdGUpIHtcbiAgICBjb25zdCBkYXRlTGltaXQgPSBEYXRlLm5vdygpICsgdGhpcy50aW1lTGltaXRNcztcbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBOb2RlKHsgc3RhdGU6IHJvb3RTdGF0ZSB9KTtcblxuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGRhdGVMaW1pdCkge1xuICAgICAgbGV0IG5vZGUgPSByb290Tm9kZTtcbiAgICAgIGxldCBzdGF0ZSA9IHJvb3RTdGF0ZTtcblxuICAgICAgLy8gU2VsZWN0IHVudGlsIGEgbmV3IGZyaW5nZSBub2RlIGlzIGZvdW5kLlxuICAgICAgd2hpbGUgKG5vZGUudW50cmllZEFjdGlvbnMuc2l6ZSA9PT0gMCAmJiBub2RlLmNoaWxkTm9kZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuVUNCMVNlbGVjdENoaWxkKCk7XG4gICAgICAgIHN0YXRlID0gZ2FtZVJlZHVjZXIoc3RhdGUsIG5vZGUuYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhwYW5kIHRoZSBuZXcgbm9kZS5cbiAgICAgIGlmIChub2RlLnVudHJpZWRBY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIGxldCBhY3Rpb24gPSBfLnNhbXBsZShBcnJheS5mcm9tKG5vZGUudW50cmllZEFjdGlvbnMpKTtcbiAgICAgICAgc3RhdGUgPSBnYW1lUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYWRkQ2hpbGQoYWN0aW9uLCBzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJvbGxvdXQgdG8gYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgIC8vIFJhbmRvbSB3YWxrIHRoZSB0cmVlIHRvIGEgdGVybWluYWwgbm9kZS5cbiAgICAgIGxldCByYW5kb21BY3Rpb24gPSBnZXRSYW5kb21BY3Rpb24oc3RhdGUpO1xuICAgICAgd2hpbGUgKHJhbmRvbUFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZSA9IGdhbWVSZWR1Y2VyKHN0YXRlLCByYW5kb21BY3Rpb24pO1xuICAgICAgICByYW5kb21BY3Rpb24gPSBnZXRSYW5kb21BY3Rpb24oc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCYWNrIHByb3BhZ2F0ZSB0aGUgdGVybWluYWwgc3RhdGUncyB2YWx1ZS5cbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUudXBkYXRlKGdldFN0YXRlVmFsdWUoc3RhdGUsIG5vZGUuY3VycmVudFBsYXllcikpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgfVxuXG4gICAgY29uc3QgcmFua2VkTm9kZXMgPSBfKEFycmF5LmZyb20ocm9vdE5vZGUuY2hpbGROb2RlcykpLnNvcnRCeSgndmlzaXRzJyk7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc3Qgb3JkZXJlZE5vZGVzID0gXyhBcnJheS5mcm9tKHJvb3ROb2RlLmNoaWxkTm9kZXMpKS5zb3J0QnkoXG4gICAgICAgICdhY3Rpb24udGlsZUlkJ1xuICAgICAgKTtcbiAgICAgIG9yZGVyZWROb2Rlcy5mb3JFYWNoKChuKSA9PlxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgJHtuLnZpc2l0c30gPT4gJHtuLndpbnN9IHdpbnMgOjogdGlsZUlkPSR7bi5hY3Rpb24udGlsZUlkfWBcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmVzdEFjdGlvbjogcmFua2VkTm9kZXMubGFzdCgpLmFjdGlvbixcbiAgICAgIGl0ZXJhdGlvbnNcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyB0aWxlQ2hvc2VuIH0gZnJvbSAnLi4vYWN0aW9ucy9QbGF5ZXJBY3Rpb25zLmpzJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IGdldEN1cnJlbnRQbGF5ZXIgPSAoc3RhdGUpID0+IHtcbiAgaWYgKHN0YXRlLnBsYXllcnMgPT09IHVuZGVmaW5lZCB8fCBzdGF0ZS5wbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLnBsYXllcnNbc3RhdGUuY3VycmVudFBsYXllcklkeCAlIHN0YXRlLm51bVBsYXllcnNdO1xufTtcblxuY29uc3QgaXNDdXJyZW50UGxheWVyID0gKHN0YXRlLCBwbGF5ZXIpID0+IHtcbiAgaWYgKHN0YXRlLnBsYXllcnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRQbGF5ZXIgPSBnZXRDdXJyZW50UGxheWVyKHN0YXRlKTtcbiAgaWYgKGN1cnJlbnRQbGF5ZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBsYXllci5uYW1lID09PSBwbGF5ZXIubmFtZTtcbn07XG5cbmNvbnN0IGdldEFjdGlvbnMgPSAoc3RhdGUpID0+IHtcbiAgaWYgKHN0YXRlLndpbm5lcikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS50aWxlcy5uZXV0cmFsLnRvQXJyYXkoKS5tYXAoKHRpbGVJZCkgPT4ge1xuICAgIHJldHVybiB0aWxlQ2hvc2VuKHtcbiAgICAgIHRpbGVJZDogdGlsZUlkLFxuICAgICAgY29sb3VyOiBnZXRDdXJyZW50UGxheWVyKHN0YXRlKS5jb2xvdXJcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCBnZXRSYW5kb21BY3Rpb24gPSAoc3RhdGUpID0+IHtcbiAgaWYgKHN0YXRlLndpbm5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQ29udmVydCBpbW11dGFibGUuanMgc2V0IHRvIGFuIGFycmF5LlxuICBjb25zdCBuZXV0cmFsVGlsZXMgPSBzdGF0ZS50aWxlcy5uZXV0cmFsLnRvQXJyYXkoKTtcbiAgaWYgKG5ldXRyYWxUaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aWxlQ2hvc2VuKHtcbiAgICB0aWxlSWQ6IF8uc2FtcGxlKG5ldXRyYWxUaWxlcyksXG4gICAgY29sb3VyOiBnZXRDdXJyZW50UGxheWVyKHN0YXRlKS5jb2xvdXJcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBnZXRDdXJyZW50UGxheWVyLCBpc0N1cnJlbnRQbGF5ZXIsIGdldEFjdGlvbnMsIGdldFJhbmRvbUFjdGlvbiB9O1xuIiwiaW1wb3J0IHsgZ2V0VGlsZUlkcywgZ2V0VGlsZUlkQnlDb29yZGluYXRlcyB9IGZyb20gJ2hleC1ncmlkJztcbmltcG9ydCB7IENPTE9VUl9SRUQsIENPTE9VUl9CTFVFIH0gZnJvbSAnLi4vY29uc3RhbnRzL0NvbG91cnMuanMnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNldCB9IGZyb20gJ2ltbXV0YWJsZSc7XG5cbi8vIFdlIGNhbid0IHN0b3JlIHRoZSB0aWxlcyBhcyBhIFNldCBiZWNhdXNlIGl0J3Mgbm90IHN1cHBvcnRlZCBpbiB0aGUgd2ViIGJyb3dzZXIuXG4vLyBcIlNldCBpcyBub3QgZnVuY3Rpb25cIi5cbmV4cG9ydCBkZWZhdWx0IChncmlkKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudFBsYXllcklkeDogMCxcbiAgICBncmlkOiBncmlkLFxuICAgIG1lc3NhZ2VzOiBbXSxcbiAgICBudW1QbGF5ZXJzOiAyLFxuICAgIHBsYXllcnM6IFtdLFxuICAgIHN0YXJ0VGlsZXM6IHtcbiAgICAgIFtDT0xPVVJfUkVEXTogXy5jaGFpbihfLnJhbmdlKDAsIGdyaWQud2lkdGgpKVxuICAgICAgICAuZmxhdE1hcCgoeCkgPT4gW2dldFRpbGVJZEJ5Q29vcmRpbmF0ZXMoZ3JpZCwgeCwgMCldKVxuICAgICAgICAudmFsdWUoKSxcbiAgICAgIFtDT0xPVVJfQkxVRV06IF8uY2hhaW4oXy5yYW5nZSgwLCBncmlkLmhlaWdodCkpXG4gICAgICAgIC5mbGF0TWFwKCh5KSA9PiBbZ2V0VGlsZUlkQnlDb29yZGluYXRlcyhncmlkLCAwLCB5KV0pXG4gICAgICAgIC52YWx1ZSgpXG4gICAgfSxcbiAgICBlbmRUaWxlczoge1xuICAgICAgW0NPTE9VUl9SRURdOiBfLmNoYWluKF8ucmFuZ2UoMCwgZ3JpZC53aWR0aCkpXG4gICAgICAgIC5mbGF0TWFwKCh4KSA9PiBbZ2V0VGlsZUlkQnlDb29yZGluYXRlcyhncmlkLCB4LCBncmlkLmhlaWdodCAtIDEpXSlcbiAgICAgICAgLnZhbHVlKCksXG4gICAgICBbQ09MT1VSX0JMVUVdOiBfLmNoYWluKF8ucmFuZ2UoMCwgZ3JpZC5oZWlnaHQpKVxuICAgICAgICAuZmxhdE1hcCgoeSkgPT4gW2dldFRpbGVJZEJ5Q29vcmRpbmF0ZXMoZ3JpZCwgZ3JpZC53aWR0aCAtIDEsIHkpXSlcbiAgICAgICAgLnZhbHVlKClcbiAgICB9LFxuICAgIHRpbGVzOiB7XG4gICAgICBuZXV0cmFsOiBuZXcgU2V0KGdldFRpbGVJZHMoZ3JpZCkpLFxuICAgICAgYmx1ZTogbmV3IFNldCgpLFxuICAgICAgcmVkOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIHdpbm5lcjogbnVsbFxuICB9O1xufTtcbiIsImltcG9ydCB7IFBMQVlFUlNfSk9JTiwgVElMRV9DSE9TRU4gfSBmcm9tICcuLi9jb25zdGFudHMvQWN0aW9uVHlwZXMuanMnO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFBsYXllciB9IGZyb20gJy4uL2hleGJ1c3RlcnMvaGVscGVycy5qcyc7XG5pbXBvcnQgaW5pdCBmcm9tICcuLi9oZXhidXN0ZXJzL2luaXQuanMnO1xuaW1wb3J0IHsgQ09MT1VSX1JFRCwgQ09MT1VSX0JMVUUgfSBmcm9tICcuLi9jb25zdGFudHMvQ29sb3Vycy5qcyc7XG5pbXBvcnQgR1JJRCBmcm9tICcuLi9jb25zdGFudHMvR3JpZC5qcyc7XG5pbXBvcnQgeyBoYXNQYXRoIH0gZnJvbSAnaGV4LWdyaWQnO1xuXG5mdW5jdGlvbiByZWR1Y2VUaWxlcyh0aWxlcywgdGlsZUlkLCBjdXJyZW50UGxheWVyKSB7XG4gIHJldHVybiB7XG4gICAgcmVkOlxuICAgICAgY3VycmVudFBsYXllci5jb2xvdXIgPT09IENPTE9VUl9SRUQgPyB0aWxlcy5yZWQuYWRkKHRpbGVJZCkgOiB0aWxlcy5yZWQsXG4gICAgYmx1ZTpcbiAgICAgIGN1cnJlbnRQbGF5ZXIuY29sb3VyID09PSBDT0xPVVJfQkxVRVxuICAgICAgICA/IHRpbGVzLmJsdWUuYWRkKHRpbGVJZClcbiAgICAgICAgOiB0aWxlcy5ibHVlLFxuICAgIG5ldXRyYWw6IHRpbGVzLm5ldXRyYWwuZGVsZXRlKHRpbGVJZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hlY2tXaW4odGlsZUlkLCBjb2xvdXIsIHRpbGVzLCBzdGFydFRpbGVzLCBlbmRUaWxlcywgZ3JpZCkge1xuICBjb25zdCBjb2xvdXJUaWxlcyA9IGNvbG91ciA9PT0gQ09MT1VSX1JFRCA/IHRpbGVzLnJlZCA6IHRpbGVzLmJsdWU7XG5cbiAgLy8gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBlbm9ybW91c2x5LlxuICBjb25zdCBjb2xvdXJUaWxlc09iaiA9IGNvbG91clRpbGVzLnRvT2JqZWN0KCk7XG4gIGNvbnN0IHBhdGhGbiA9ICh0aWxlSWQpID0+IGNvbG91clRpbGVzT2JqW3RpbGVJZF0gIT09IHVuZGVmaW5lZDtcblxuICBjb25zdCBwYXRoVG9TdGFydCA9IGhhc1BhdGgoZ3JpZCwgW3RpbGVJZF0sIHN0YXJ0VGlsZXMsIHtcbiAgICBpc1BhdGhhYmxlOiBwYXRoRm5cbiAgfSk7XG4gIGNvbnN0IHBhdGhUb0VuZCA9IGhhc1BhdGgoZ3JpZCwgW3RpbGVJZF0sIGVuZFRpbGVzLCB7IGlzUGF0aGFibGU6IHBhdGhGbiB9KTtcblxuICBpZiAocGF0aFRvU3RhcnQgJiYgcGF0aFRvRW5kKSB7XG4gICAgcmV0dXJuIGNvbG91cjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VHYW1lKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaW5pdChHUklEKTtcbiAgfVxuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFBMQVlFUlNfSk9JTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBwbGF5ZXJzOiBhY3Rpb24ucGxheWVyc1xuICAgICAgfTtcblxuICAgIGNhc2UgVElMRV9DSE9TRU46XG4gICAgICBpZiAoc3RhdGUud2lubmVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBUcmllZCB0byBjaG9vc2UgYSB0aWxlIGFmdGVyIHRoZSBnYW1lIGlzIG92ZXIhYCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLnRpbGVzLm5ldXRyYWwuY29udGFpbnMoYWN0aW9uLnRpbGVJZCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmllZCB0byBjaG9vc2UgYW4gb2NjdXBpZWQgdGlsZScsIGFjdGlvbi50aWxlSWQpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3Rpb24uY29sb3VyICE9PSBnZXRDdXJyZW50UGxheWVyKHN0YXRlKS5jb2xvdXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dyb25nIHBsYXllciB0cmllZCB0byBnbyEnKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50UGxheWVyID0gZ2V0Q3VycmVudFBsYXllcihzdGF0ZSk7XG4gICAgICBsZXQgbnMgPSB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICB0aWxlczogcmVkdWNlVGlsZXMoc3RhdGUudGlsZXMsIGFjdGlvbi50aWxlSWQsIGN1cnJlbnRQbGF5ZXIpLFxuICAgICAgICBjdXJyZW50UGxheWVySWR4OiBzdGF0ZS5jdXJyZW50UGxheWVySWR4ICsgMVxuICAgICAgfTtcblxuICAgICAgbnMud2lubmVyID0gY2hlY2tXaW4oXG4gICAgICAgIGFjdGlvbi50aWxlSWQsXG4gICAgICAgIGN1cnJlbnRQbGF5ZXIuY29sb3VyLFxuICAgICAgICBucy50aWxlcyxcbiAgICAgICAgbnMuc3RhcnRUaWxlc1tjdXJyZW50UGxheWVyLmNvbG91cl0sXG4gICAgICAgIG5zLmVuZFRpbGVzW2N1cnJlbnRQbGF5ZXIuY29sb3VyXSxcbiAgICAgICAgbnMuZ3JpZFxuICAgICAgKTtcbiAgICAgIHJldHVybiBucztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1lbnYgd29ya2VyICovXG5pbXBvcnQgTW9udGVDYXJsb1RyZWVTZWFyY2ggZnJvbSAnLi9Nb250ZUNhcmxvVHJlZVNlYXJjaC5qcyc7XG5pbXBvcnQgeyBTZXQsIGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5cbi8qKlxuICogVGhlIHNsaWdodGx5IG9kZCBsb29raW5nIGNvZGUgd2l0aCBvbm1lc3NhZ2UgYW5kIHBvc3RtZXNzYWdlIGlzIGJlY2F1c2Ugd2hlblxuICogdGhpcyBjb2RlIGlzIHJhbiBpbiBhIHdlYiB3b3JrZXIgdGhvc2UgZnVuY3Rpb25zIGFyZSBnbG9iYWxseSBkZWZpbmVkLiBXaGVuXG4gKiByYW4gaW4gdGhlIHRlc3RzLCB0aGV5J3JlIG5vdC5cbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtNb250ZUNhcmxvVHJlZVNlYXJjaFdlYldvcmtlcl0gR290IG1lc3NhZ2VgLCBtZXNzYWdlKTtcblxuICBjb25zdCBtZXNzYWdlT2JqID1cbiAgICB0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgPyBtZXNzYWdlLmRhdGEgOiBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuXG4gIHN3aXRjaCAobWVzc2FnZU9iai5hY3Rpb24pIHtcbiAgICBjYXNlICdnZXRCZXN0QWN0aW9uJzpcbiAgICAgIC8vIFdlIGNhbid0IHN0b3JlIHRoZSB0aWxlcyBhcyBhIFNldCBiZWNhdXNlIGl0J3Mgbm90IHN1cHBvcnRlZCBpbiB0aGUgd2ViIGJyb3dzZXIuXG4gICAgICAvLyBcIlNldCBpcyBub3QgZnVuY3Rpb25cIi5cbiAgICAgIGNvbnN0IHsgZGVidWcsIHBsYXllckNvbG91ciwgc3RhdGUsIHRpbWVMaW1pdE1zID0gNTAwMCB9ID0gbWVzc2FnZU9iajtcblxuICAgICAgLy8gQ29udmVydCB0aGUgaW1tdXRhYmxlLmpzIHNldHMgYmFjayB0byBzZXRzLlxuICAgICAgc3RhdGUudGlsZXMubmV1dHJhbCA9IG5ldyBTZXQoZnJvbUpTKHN0YXRlLnRpbGVzLm5ldXRyYWwpKTtcbiAgICAgIHN0YXRlLnRpbGVzLnJlZCA9IG5ldyBTZXQoZnJvbUpTKHN0YXRlLnRpbGVzLnJlZCkpO1xuICAgICAgc3RhdGUudGlsZXMuYmx1ZSA9IG5ldyBTZXQoZnJvbUpTKHN0YXRlLnRpbGVzLmJsdWUpKTtcblxuICAgICAgY29uc3QgbWN0cyA9IG5ldyBNb250ZUNhcmxvVHJlZVNlYXJjaCh7IHRpbWVMaW1pdE1zLCBkZWJ1ZyB9KTtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IG1jdHMuZ2V0QmVzdEFjdGlvbihwbGF5ZXJDb2xvdXIsIHN0YXRlKTtcbiAgICAgIGNvbnNvbGUubG9nKGBCZXN0IGFjdGlvbiBpc2AsIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zdE1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybihgVW5oYW5kbGVkIG1lc3NhZ2UgYWN0aW9uOiAke21lc3NhZ2UuZGF0YS5hY3Rpb259YCk7XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBvbm1lc3NhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnNvbGUubG9nKGBJbml0aWFsaXNpbmcgb25tZXNzYWdlYCk7XG4gIG9ubWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZU1lc3NhZ2U7XG4iLCIvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIFN5bWJvbCAqL1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgZnVuY3Rpb25zIGZvciBjaGVja2luZyB0eXBlc1xuICogYW5kIHRocm93aW5nIGV4Y2VwdGlvbnMuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1lc3NhZ2VzLCBwcmVkaWNhdGVzLCBmdW5jdGlvbnMsIGFzc2VydCwgbm90LCBtYXliZSwgZWl0aGVyLCBjb2xsZWN0aW9ucywgc2xpY2U7XG5cbiAgICBtZXNzYWdlcyA9IHtcbiAgICAgICAgbGlrZTogJ0ludmFsaWQgdHlwZScsXG4gICAgICAgIGluc3RhbmNlOiAnSW52YWxpZCB0eXBlJyxcbiAgICAgICAgZW1wdHlPYmplY3Q6ICdJbnZhbGlkIG9iamVjdCcsXG4gICAgICAgIG9iamVjdDogJ0ludmFsaWQgb2JqZWN0JyxcbiAgICAgICAgYXNzaWduZWQ6ICdJbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgdW5kZWZpbmVkOiAnSW52YWxpZCB2YWx1ZScsXG4gICAgICAgIG51bGw6ICdJbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgaGFzTGVuZ3RoOiAnSW52YWxpZCBsZW5ndGgnLFxuICAgICAgICBlbXB0eUFycmF5OiAnSW52YWxpZCBhcnJheScsXG4gICAgICAgIGFycmF5OiAnSW52YWxpZCBhcnJheScsXG4gICAgICAgIGFycmF5TGlrZTogJ0ludmFsaWQgYXJyYXktbGlrZSBvYmplY3QnLFxuICAgICAgICBpdGVyYWJsZTogJ0ludmFsaWQgaXRlcmFibGUnLFxuICAgICAgICBkYXRlOiAnSW52YWxpZCBkYXRlJyxcbiAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGVycm9yJyxcbiAgICAgICAgZnVuY3Rpb246ICdJbnZhbGlkIGZ1bmN0aW9uJyxcbiAgICAgICAgbWF0Y2g6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIGNvbnRhaW5zOiAnSW52YWxpZCBzdHJpbmcnLFxuICAgICAgICB1bmVtcHR5U3RyaW5nOiAnSW52YWxpZCBzdHJpbmcnLFxuICAgICAgICBzdHJpbmc6ICdJbnZhbGlkIHN0cmluZycsXG4gICAgICAgIG9kZDogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgZXZlbjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgaW5SYW5nZTogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgZ3JlYXRlck9yRXF1YWw6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIGxlc3NPckVxdWFsOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBiZXR3ZWVuOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBncmVhdGVyOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBsZXNzOiAnSW52YWxpZCBudW1iZXInLFxuICAgICAgICBwb3NpdGl2ZTogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgbmVnYXRpdmU6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIGludGVnZXI6ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIHplcm86ICdJbnZhbGlkIG51bWJlcicsXG4gICAgICAgIG51bWJlcjogJ0ludmFsaWQgbnVtYmVyJyxcbiAgICAgICAgYm9vbGVhbjogJ0ludmFsaWQgYm9vbGVhbidcbiAgICB9O1xuXG4gICAgcHJlZGljYXRlcyA9IHtcbiAgICAgICAgbGlrZTogbGlrZSxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICBlbXB0eU9iamVjdDogZW1wdHlPYmplY3QsXG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBhc3NpZ25lZDogYXNzaWduZWQsXG4gICAgICAgIHVuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gICAgICAgIG51bGw6IGlzTnVsbCxcbiAgICAgICAgaGFzTGVuZ3RoOiBoYXNMZW5ndGgsXG4gICAgICAgIGVtcHR5QXJyYXk6IGVtcHR5QXJyYXksXG4gICAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgICAgYXJyYXlMaWtlOiBhcnJheUxpa2UsXG4gICAgICAgIGl0ZXJhYmxlOiBpdGVyYWJsZSxcbiAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICBjb250YWluczogY29udGFpbnMsXG4gICAgICAgIHVuZW1wdHlTdHJpbmc6IHVuZW1wdHlTdHJpbmcsXG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICBvZGQ6IG9kZCxcbiAgICAgICAgZXZlbjogZXZlbixcbiAgICAgICAgaW5SYW5nZTogaW5SYW5nZSxcbiAgICAgICAgZ3JlYXRlck9yRXF1YWw6IGdyZWF0ZXJPckVxdWFsLFxuICAgICAgICBsZXNzT3JFcXVhbDogbGVzc09yRXF1YWwsXG4gICAgICAgIGJldHdlZW46IGJldHdlZW4sXG4gICAgICAgIGdyZWF0ZXI6IGdyZWF0ZXIsXG4gICAgICAgIGxlc3M6IGxlc3MsXG4gICAgICAgIHBvc2l0aXZlOiBwb3NpdGl2ZSxcbiAgICAgICAgbmVnYXRpdmU6IG5lZ2F0aXZlLFxuICAgICAgICBpbnRlZ2VyIDogaW50ZWdlcixcbiAgICAgICAgemVybzogemVybyxcbiAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgIGJvb2xlYW46IGJvb2xlYW5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb25zID0ge1xuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgYW55OiBhbnlcbiAgICB9O1xuXG4gICAgY29sbGVjdGlvbnMgPSBbICdhcnJheScsICdhcnJheUxpa2UnLCAnaXRlcmFibGUnLCAnb2JqZWN0JyBdO1xuICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgZnVuY3Rpb25zID0gbWl4aW4oZnVuY3Rpb25zLCBwcmVkaWNhdGVzKTtcbiAgICBhc3NlcnQgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMoYXNzZXJ0TW9kaWZpZXIsIGFzc2VydEltcGwpO1xuICAgIG5vdCA9IGNyZWF0ZU1vZGlmaWVkUHJlZGljYXRlcyhub3RNb2RpZmllciwgbm90SW1wbCk7XG4gICAgbWF5YmUgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMobWF5YmVNb2RpZmllciwgbWF5YmVJbXBsKTtcbiAgICBlaXRoZXIgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMoZWl0aGVyTW9kaWZpZXIpO1xuICAgIGFzc2VydC5ub3QgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBub3QpO1xuICAgIGFzc2VydC5tYXliZSA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlKTtcbiAgICBhc3NlcnQuZWl0aGVyID0gY3JlYXRlTW9kaWZpZWRNb2RpZmllcihhc3NlcnRFaXRoZXJNb2RpZmllciwgcHJlZGljYXRlcyk7XG5cbiAgICBjb2xsZWN0aW9ucy5mb3JFYWNoKGNyZWF0ZU9mUHJlZGljYXRlcyk7XG4gICAgY3JlYXRlT2ZNb2RpZmllcnMoYXNzZXJ0LCBhc3NlcnRNb2RpZmllcik7XG4gICAgY3JlYXRlT2ZNb2RpZmllcnMobm90LCBub3RNb2RpZmllcik7XG4gICAgY29sbGVjdGlvbnMuZm9yRWFjaChjcmVhdGVNYXliZU9mTW9kaWZpZXJzKTtcblxuICAgIGV4cG9ydEZ1bmN0aW9ucyhtaXhpbihmdW5jdGlvbnMsIHtcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vdDogbm90LFxuICAgICAgICBtYXliZTogbWF5YmUsXG4gICAgICAgIGVpdGhlcjogZWl0aGVyXG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBsaWtlYC5cbiAgICAgKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYW4gb2JqZWN0ICdxdWFja3MgbGlrZSBhIGR1Y2snLlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBoYXMgYWxsIG9mXG4gICAgICogdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNlY29uZCwgYXJjaGV0eXBhbCBhcmd1bWVudFxuICAgICAqICh0aGUgJ2R1Y2snKS4gUmV0dXJucyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpa2UgKGRhdGEsIGR1Y2spIHtcbiAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgZm9yIChuYW1lIGluIGR1Y2spIHtcbiAgICAgICAgICAgIGlmIChkdWNrLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IGZhbHNlIHx8IHR5cGVvZiBkYXRhW25hbWVdICE9PSB0eXBlb2YgZHVja1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdChkYXRhW25hbWVdKSAmJiBsaWtlKGRhdGFbbmFtZV0sIGR1Y2tbbmFtZV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBwcm90b3R5cGUsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnN0YW5jZSAoZGF0YSwgcHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGlzRnVuY3Rpb24ocHJvdG90eXBlKSAmJiBkYXRhIGluc3RhbmNlb2YgcHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGVtcHR5T2JqZWN0YC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBlbXB0eSBvYmplY3QsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbXB0eU9iamVjdCAoZGF0YSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBwbGFpbi1vbGQgSlMgb2JqZWN0LFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgYXNzaWduZWRgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbmVkIChkYXRhKSB7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGF0YSkgJiYgIWlzTnVsbChkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgdW5kZWZpbmVkLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG51bGxgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIG51bGwsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBoYXNMZW5ndGhgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGhhcyBhIGxlbmd0aCBwcm9wZXJ0eVxuICAgICAqIHRoYXQgZXF1YWxzIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzTGVuZ3RoIChkYXRhLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXNzaWduZWQoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZW1wdHlBcnJheWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYW4gZW1wdHkgYXJyYXksXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbXB0eUFycmF5IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIHNvbWV0aGluZyBpcyBhbiBhcnJheSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5IChkYXRhKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgYXJyYXlMaWtlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIHNvbWV0aGluZyBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gYXNzaWduZWQoZGF0YSkgJiYgbnVtYmVyKGRhdGEubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGl0ZXJhYmxlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIHNvbWV0aGluZyBpcyBhbiBpdGVyYWJsZSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhYmxlIChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGFycmF5TGlrZSBwcmVkaWNhdGUgaW4gcHJlLUVTNiBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlMaWtlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGlzRnVuY3Rpb24oZGF0YVtTeW1ib2wuaXRlcmF0b3JdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGRhdGVgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgc29tZXRoaW5nIGlzIGEgdmFsaWQgZGF0ZSxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRhdGUgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmXG4gICAgICAgICAgICAhaXNOYU4oZGF0YS5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZXJyb3JgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVycm9yIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBmdW5jdGlvbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgZnVuY3Rpb24sXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG1hdGNoYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIHN0cmluZ1xuICAgICAqIHRoYXQgbWF0Y2hlcyBgcmVnZXhgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoIChkYXRhLCByZWdleCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmICEhZGF0YS5tYXRjaChyZWdleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBjb250YWluc2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBzdHJpbmdcbiAgICAgKiB0aGF0IGNvbnRhaW5zIGBzdWJzdHJpbmdgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zIChkYXRhLCBzdWJzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyhkYXRhKSAmJiBkYXRhLmluZGV4T2Yoc3Vic3RyaW5nKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGB1bmVtcHR5U3RyaW5nYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVtcHR5U3RyaW5nIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgc3RyaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZyAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgb2RkYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBvZGQgbnVtYmVyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2RkIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyKGRhdGEpICYmICFldmVuKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZXZlbmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYW4gZXZlbiBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVuIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZGF0YSkgJiYgZGF0YSAlIDIgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBpbnRlZ2VyYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhbiBpbnRlZ2VyLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZWdlciAoZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyKGRhdGEpICYmIGRhdGEgJSAxID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgaW5SYW5nZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBudW1iZXIgaW5cbiAgICAgKiB0aGUgcmFuZ2UgYGFgIC4uIGBiYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlIChkYXRhLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGdyZWF0ZXJPckVxdWFsKGRhdGEsIGEpICYmIGxlc3NPckVxdWFsKGRhdGEsIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlc3NPckVxdWFsKGRhdGEsIGEpICYmIGdyZWF0ZXJPckVxdWFsKGRhdGEsIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZ3JlYXRlck9yRXF1YWxgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgbnVtYmVyIGdyZWF0ZXJcbiAgICAgKiB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ3JlYXRlck9yRXF1YWwgKGRhdGEsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIoZGF0YSkgJiYgZGF0YSA+PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGxlc3NPckVxdWFsYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG51bWJlciBsZXNzXG4gICAgICogdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxlc3NPckVxdWFsIChkYXRhLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyKGRhdGEpICYmIGRhdGEgPD0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBiZXR3ZWVuYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG51bWJlclxuICAgICAqIGJldHdlZW4gYGFgIGFuZCBgYmAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2VlbiAoZGF0YSwgYSwgYikge1xuICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmVhdGVyKGRhdGEsIGEpICYmIGxlc3MoZGF0YSwgYik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVzcyhkYXRhLCBhKSAmJiBncmVhdGVyKGRhdGEsIGIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgZ3JlYXRlcmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBudW1iZXJcbiAgICAgKiBncmVhdGVyIHRoYW4gYHZhbHVlYCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncmVhdGVyIChkYXRhLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyKGRhdGEpICYmIGRhdGEgPiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGxlc3NgLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgc29tZXRoaW5nIGlzIGEgbnVtYmVyXG4gICAgICogbGVzcyB0aGFuIGB2YWx1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGVzcyAoZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcihkYXRhKSAmJiBkYXRhIDwgdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBwb3NpdGl2ZWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgYSBwb3NpdGl2ZSBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZSAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5lZ2F0aXZlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHNvbWV0aGluZyBpcyBhIG5lZ2F0aXZlIG51bWJlcixcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhICAgICAgICAgIFRoZSB0aGluZyB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBsZXNzKGRhdGEsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgbnVtYmVyYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGRhdGEgaXMgYSBudW1iZXIsXG4gICAgICogYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudW1iZXIgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJiBpc05hTihkYXRhKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgIGRhdGEgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJlxuICAgICAgICAgICAgICAgZGF0YSAhPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiBgemVyb2AuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBzb21ldGhpbmcgaXMgemVybyxcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhICAgICAgICAgIFRoZSB0aGluZyB0byB0ZXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHplcm8gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBib29sZWFuYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGRhdGEgaXMgYSBib29sZWFuIHZhbHVlLFxuICAgICAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYm9vbGVhbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YSA9PT0gZmFsc2UgfHwgZGF0YSA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBkYXRhIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByZWRpY2F0ZSBhbmQgcmV0dXJuc1xuICAgICAqIHRoZSByZXN1bHQgYXJyYXkuIElmIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICAgKiBkYXRhLCBhIHNpbmdsZSBwcmVkaWNhdGUgZnVuY3Rpb24gbWF5IGJlIHBhc3NlZCBpbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5IChkYXRhLCBwcmVkaWNhdGVzKSB7XG4gICAgICAgIGFzc2VydC5hcnJheShkYXRhKTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcmVkaWNhdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGVzKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0LmFycmF5KHByZWRpY2F0ZXMpO1xuICAgICAgICBhc3NlcnQuaGFzTGVuZ3RoKGRhdGEsIHByZWRpY2F0ZXMubGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNbaW5kZXhdKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIGZ1bmN0aW9uIGBtYXBgLlxuICAgICAqXG4gICAgICogTWFwcyBlYWNoIHZhbHVlIGZyb20gdGhlIGRhdGEgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAgICogdGhlIHJlc3VsdCBvYmplY3QuIFN1cHBvcnRzIG5lc3RlZCBvYmplY3RzLiBJZiB0aGUgZGF0YSBpcyBub3QgbmVzdGVkIGFuZFxuICAgICAqIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiBpdCwgYSBzaW5nbGUgcHJlZGljYXRlXG4gICAgICogZnVuY3Rpb24gbWF5IGJlIHBhc3NlZCBpbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcCAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwU2ltcGxlKGRhdGEsIHByZWRpY2F0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0Lm9iamVjdChwcmVkaWNhdGVzKTtcblxuICAgICAgICByZXR1cm4gbWFwQ29tcGxleChkYXRhLCBwcmVkaWNhdGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBTaW1wbGUgKGRhdGEsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHByZWRpY2F0ZShkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcENvbXBsZXggKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub3QuYXNzaWduZWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAhIXByZWRpY2F0ZS5faXNNYXliZWZpZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwcmVkaWNhdGUoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdChwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBDb21wbGV4KGRhdGFba2V5XSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFsbGBcbiAgICAgKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIGJvb2xlYW4gdmFsdWVzIGFyZSB0cnVlXG4gICAgICogaW4gYW4gYXJyYXkgKHJldHVybmVkIGZyb20gYGFwcGx5YClcbiAgICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWxsIChkYXRhKSB7XG4gICAgICAgIGlmIChhcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RBcnJheShkYXRhLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0T2JqZWN0KGRhdGEsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0QXJyYXkgKGRhdGEsIHJlc3VsdCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0T2JqZWN0IChkYXRhLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YVtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCh2YWx1ZSkgJiYgdGVzdE9iamVjdCh2YWx1ZSwgcmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFueWBcbiAgICAgKlxuICAgICAqIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGJvb2xlYW4gdmFsdWUgaXMgdHJ1ZVxuICAgICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAgICogb3Igb2JqZWN0IChyZXR1cm5lZCBmcm9tIGBtYXBgKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFueSAoZGF0YSkge1xuICAgICAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0T2JqZWN0KGRhdGEsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1peGluICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbW9kaWZpZXIgYGFzc2VydGAuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2VydE1vZGlmaWVyIChwcmVkaWNhdGUsIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBhcmd1bWVudHMsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUgKHByZWRpY2F0ZSwgYXJncywgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGFzc2VydEltcGwocHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3MpLCB1bmVtcHR5U3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRJbXBsICh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0RWl0aGVyTW9kaWZpZXIgKHByZWRpY2F0ZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRQcmVkaWNhdGUocHJlZGljYXRlLCBhcmd1bWVudHMsIGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3I6IE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLnJlZHVjZShkZWxheWVkQXNzZXJ0LCB7fSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5ZWRBc3NlcnQgKHJlc3VsdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiAhcHJlZGljYXRlc1trZXldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBub3RgLlxuICAgICAqXG4gICAgICogTmVnYXRlcyBgcHJlZGljYXRlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3RNb2RpZmllciAocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm90SW1wbChwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90SW1wbCAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbW9kaWZpZXIgYG1heWJlYC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHByZWRpY2F0ZSBhcmd1bWVudCBpcyAgYG51bGxgIG9yIGB1bmRlZmluZWRgLFxuICAgICAqIG90aGVyd2lzZSBwcm9wYWdhdGVzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBgcHJlZGljYXRlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXliZU1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVkUHJlZGljYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFhc3NpZ25lZChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIYWNraXNobHkgaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGEgbWF5YmUueHh4IHByZWRpY2F0ZS5cbiAgICAgICAgLy8gV2l0aG91dCB0aGlzIGZsYWcsIHRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBpdGVyYXRlXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIG1heWJlIHByZWRpY2F0ZXMgb3IgdXNlIGluZGV4T2YgdG8gY2hlY2ssXG4gICAgICAgIC8vIHdoaWNoIHdvdWxkIGJlIHRpbWUtY29uc3VtaW5nLlxuICAgICAgICBtb2RpZmllZFByZWRpY2F0ZS5faXNNYXliZWZpZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBtb2RpZmllZFByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXliZUltcGwgKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NpZ25lZCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbW9kaWZpZXIgYGVpdGhlcmAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBlaXRoZXIgcHJlZGljYXRlIGlzIHRydWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWl0aGVyTW9kaWZpZXIgKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNob3J0Y3V0ID0gcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3I6IE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLnJlZHVjZShub3BPclByZWRpY2F0ZSwge30pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBub3BPclByZWRpY2F0ZSAocmVzdWx0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHNob3J0Y3V0ID8gbm9wIDogcHJlZGljYXRlc1trZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gbm9wICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1vZGlmaWVyIGBvZmAuXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIHRoZSBjaGFpbmVkIHByZWRpY2F0ZSB0byBtZW1iZXJzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9mTW9kaWZpZXIgKHRhcmdldCwgdHlwZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiwgYXJncztcblxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKCF0eXBlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gY29lcmNlQ29sbGVjdGlvbih0eXBlLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXQgIT09ICdtYXliZScgfHwgYXNzaWduZWQoaXRlbSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcHJlZGljYXRlLmFwcGx5KG51bGwsIFsgaXRlbSBdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQUNLOiBJZGVhbGx5IHdlJ2QgdXNlIGEgZm9yLi4ub2YgbG9vcCBhbmQgcmV0dXJuIGhlcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBidXQgdGhhdCBzeW50YXggaXMgbm90IHN1cHBvcnRlZCBieSBFUzUuIFdlIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICB1c2UgYSB0cmFuc3BpbGVyIGFuZCBhIGJ1aWxkIHN0ZXAgYnV0IEknbSBoYXBweVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgZW5vdWdoIHdpdGggdGhpcyB1bnRpbCBFUzYgaXMgdGhlIGJhc2VsaW5lLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2VyY2VDb2xsZWN0aW9uICh0eXBlLCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBhcnJheUxpa2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29sbGVjdGlvbik7XG4gICAgICAgICAgICBjYXNlIG9iamVjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29sbGVjdGlvbikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMgKG1vZGlmaWVyLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFsgbW9kaWZpZXIsIHByZWRpY2F0ZXMsIG9iamVjdCBdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyAoYXJncykge1xuICAgICAgICB2YXIgbW9kaWZpZXIsIG9iamVjdCwgZnVuY3Rpb25zLCByZXN1bHQ7XG5cbiAgICAgICAgbW9kaWZpZXIgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIG9iamVjdCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGZ1bmN0aW9ucyA9IGFyZ3MucG9wKCk7XG5cbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0IHx8IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKGZ1bmN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RpZmllci5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmdW5jdGlvbnNba2V5XSwgbWVzc2FnZXNba2V5XSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZE1vZGlmaWVyIChtb2RpZmllciwgbW9kaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFsgbW9kaWZpZXIsIG1vZGlmaWVkLCBudWxsIF0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9mUHJlZGljYXRlcyAoa2V5KSB7XG4gICAgICAgIHByZWRpY2F0ZXNba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFxuICAgICAgICAgICAgWyBvZk1vZGlmaWVyLmJpbmQobnVsbCwgbnVsbCksIHByZWRpY2F0ZXNba2V5XSwgcHJlZGljYXRlcywgbnVsbCBdXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlT2ZNb2RpZmllcnMgKGJhc2UsIG1vZGlmaWVyKSB7XG4gICAgICAgIGNvbGxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgYmFzZVtrZXldLm9mID0gY3JlYXRlTW9kaWZpZWRNb2RpZmllcihtb2RpZmllciwgcHJlZGljYXRlc1trZXldLm9mKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF5YmVPZk1vZGlmaWVycyAoa2V5KSB7XG4gICAgICAgIG1heWJlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhcbiAgICAgICAgICAgIFsgb2ZNb2RpZmllci5iaW5kKG51bGwsICdtYXliZScpLCBwcmVkaWNhdGVzW2tleV0sIHByZWRpY2F0ZXMsIG51bGwgXVxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQubWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlW2tleV0ub2YpO1xuICAgICAgICBhc3NlcnQubm90W2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKGFzc2VydE1vZGlmaWVyLCBub3Rba2V5XS5vZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0RnVuY3Rpb25zIChmdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICE9PSBudWxsICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbHMuY2hlY2sgPSBmdW5jdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG59KHRoaXMpKTtcbiIsIi8vIHZpbTogZXhwYW5kdGFiOnRzPTI6c3c9MlxuXG4vKipcbiAqIFRoZSB2YWxpZCBkaXJlY3Rpb25zIGZvciBlYWNoIG9yaWVudGF0aW9uLlxuICpcbiAqIFRoZSBwb2ludHktdG9wcGVkIG9yaWVudGF0aW9uIGRvZXMgbm90IGhhdmUgdGhlIGNvbmNlcHQgb2YgXCJub3J0aFwiIGZvclxuICogZXhhbXBsZS5cbiAqL1xudmFyIF92YWxpZERpcmVjdGlvbnMgPSB7XG4gICdmbGF0LXRvcHBlZCc6IFtcbiAgICAnbm9ydGgnLFxuICAgICdub3J0aGVhc3QnLFxuICAgICdzb3V0aGVhc3QnLFxuICAgICdzb3V0aCcsXG4gICAgJ3NvdXRod2VzdCcsXG4gICAgJ25vcnRod2VzdCdcbiAgXSxcbiAgJ3BvaW50eS10b3BwZWQnOiBbXG4gICAgJ25vcnRoZWFzdCcsXG4gICAgJ2Vhc3QnLFxuICAgICdzb3V0aGVhc3QnLFxuICAgICdzb3V0aHdlc3QnLFxuICAgICd3ZXN0JyxcbiAgICAnbm9ydGh3ZXN0J1xuICBdXG59O1xuXG4vKipcbiAqIFRoZSB2YWxpZCBsYXlvdXRzIGZvciBlYWNoIG9yaWVudGF0aW9uLlxuICovXG52YXIgX3ZhbGlkTGF5b3V0cyA9IHtcbiAgJ2ZsYXQtdG9wcGVkJzogWydvZGQtcScsICdldmVuLXEnXSxcbiAgJ3BvaW50eS10b3BwZWQnOiBbJ29kZC1yJywgJ2V2ZW4tciddXG59O1xuXG52YXIgX3ZhbGlkU2hhcGVzID0gWydyZWN0YW5nbGUnLCAncGFyYWxsZWxvZ3JhbSddO1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgVGhlIGhleCBncmlkIHNldHRpbmdzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNldHRpbmdzLndpZHRoIFRoZSB3aWR0aCBvZiB0aGUgZ3JpZCwgaW4gaGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2V0dGluZ3MuaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGdyaWQsIGluIGhleGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHNldHRpbmdzLm9yaWVudGF0aW9uIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgaGV4ZXMsIGVpdGhlclxuICogXCJmbGF0LXRvcHBlZFwiIG9yIFwicG9pbnR5LXRvcHBlZFwiLlxuICogQHBhcmFtIHtzdHJpbmd9IHNldHRpbmdzLmxheW91dCBUaGUgbGF5b3V0IG9mIHRoZSBoZXhlcy4gRm9yIGZsYXQtdG9wcGVkLFxuICogZWl0aGVyIFwib2RkLXFcIiBvciBcImV2ZW4tcVwiLiBGb3IgcG9pbnR5LXRvcHBlZCwgZWl0aGVyIFwib2RkLXJcIiBvciBcImV2ZW4tclwiLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzZXR0aW5ncy5zaGFwZT1yZWN0YW5nbGVdIFRoZSBzaGFwZSBvZiB0aGUgaGV4IGdyaWQuIFNob3VsZFxuICogYmUgZWl0aGVyIFwicmVjdGFuZ2xlXCIgb3IgXCJwYXJhbGxlbG9ncmFtXCIuXG4gKiBAdGhyb3dzIEVycm9yIFdoZW4gdGhlIHNldHRpbmdzIGFyZSBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBtdXN0IGJlIGFuIG9iamVjdC4gR290ICcgKyB0eXBlb2Ygc2V0dGluZ3MpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy53aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzLndpZHRoIG11c3QgYmUgYSBudW1iZXIuIEdvdCAnICsgdHlwZW9mIHdpZHRoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0dGluZ3MuaGVpZ2h0IG11c3QgYmUgYSBudW1iZXIuIEdvdCAnICsgdHlwZW9mIGhlaWdodCk7XG4gIH1cblxuICBpZiAoX3ZhbGlkTGF5b3V0c1tzZXR0aW5ncy5vcmllbnRhdGlvbl0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcmllbnRhdGlvbjogJyArIHNldHRpbmdzLm9yaWVudGF0aW9uICtcbiAgICAgICcuIE11c3QgYmUgb25lIG9mOiAnICsgT2JqZWN0LmtleXMoX3ZhbGlkTGF5b3V0cykgKyAnLicpO1xuICB9XG5cbiAgaWYgKF92YWxpZExheW91dHNbc2V0dGluZ3Mub3JpZW50YXRpb25dLmluZGV4T2Yoc2V0dGluZ3MubGF5b3V0KSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGF5b3V0IGZvciBnaXZlbiBvcmllbnRhdGlvbjogJyArIHNldHRpbmdzLmxheW91dCArXG4gICAgICAnLiBNdXN0IGJlIG9uZSBvZjogJyArIF92YWxpZExheW91dHNbc2V0dGluZ3Mub3JpZW50YXRpb25dICsgJy4nKTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5zaGFwZSAmJiBfdmFsaWRTaGFwZXMuaW5kZXhPZihzZXR0aW5ncy5zaGFwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNoYXBlLiBNdXN0IGJlIG9uZSBvZjogJyArIF92YWxpZFNoYXBlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRpbGVJZHMuXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgVGhlIGhleCBncmlkIHNldHRpbmdzLlxuICovXG5mdW5jdGlvbiBnZXRUaWxlSWRzKHNldHRpbmdzKSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgfVxuXG4gIHZhciB0aWxlSWRzID0gW107XG4gIGZvciAodmFyIHggPSAwOyB4IDwgc2V0dGluZ3Mud2lkdGg7IHggKz0gMSkge1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2V0dGluZ3MuaGVpZ2h0OyB5ICs9IDEpIHtcbiAgICAgIHRpbGVJZHMucHVzaChnZXRUaWxlSWRCeUNvb3JkaW5hdGVzKHNldHRpbmdzLCB4LCB5KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpbGVJZHM7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGEgY29vcmRpbmF0ZSBpcyB3aXRoaW4gdGhlIGdyaWQgYm91bmRhcmllcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgaGV4IGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2x9IFdoZXRoZXIgdGhlIGNvb3JkaW5hdGUgaXMgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZVxuICogZ3JpZC5cbiAqL1xuZnVuY3Rpb24gaXNXaXRoaW5Cb3VuZGFyaWVzKHNldHRpbmdzLCB4LCB5KSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggbXVzdCBiZSBhIG51bWJlci4gR290ICcgKyB0eXBlb2YgeCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigneCBtdXN0IGJlIGEgbnVtYmVyLiBHb3QgJyArIHR5cGVvZiB5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geCA8PSBzZXR0aW5ncy53aWR0aCAtIDEgJiZcbiAgICB4ID49IDAgJiZcbiAgICB5IDw9IHNldHRpbmdzLmhlaWdodCAtIDEgJiZcbiAgICB5ID49IDA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdGlsZUlkIGdpdmVuIHRoZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgaGV4IGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge3RpbGV8bnVsbH0gVGhlIHRpbGUuIE51bGwgaWYgbm90IGEgdmFsaWQgY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VGlsZUlkQnlDb29yZGluYXRlcyhzZXR0aW5ncywgeCwgeSkge1xuICBpZiAoc2V0dGluZ3MudmFsaWRhdGUgIT09IGZhbHNlKSB7XG4gICAgdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IG11c3QgYmUgYSBudW1iZXIuIEdvdCAnICsgdHlwZW9mIHgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggbXVzdCBiZSBhIG51bWJlci4gR290ICcgKyB0eXBlb2YgeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzV2l0aGluQm91bmRhcmllcyhzZXR0aW5ncywgeCwgeSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWQgPSB5ICogc2V0dGluZ3Mud2lkdGggKyB4O1xuICByZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogV2hldGhlciBhIGdpdmVuIGRpcmVjdGlvbiBpcyB2YWxpZCBmb3IgdGhpcyBtYXAgbGF5b3V0LlxuICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIFRoZSBoZXggZ3JpZCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2x9IFdoZXRoZXIgdGhlIGRpcmVjdGlvbiBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZERpcmVjdGlvbihzZXR0aW5ncywgZGlyZWN0aW9uKSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBpZiAodHlwZW9mIGRpcmVjdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGlyZWN0aW9uIG11c3QgYmUgYSBzdHJpbmcuIEdvdCAnICsgdHlwZW9mIGRpcmVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChfdmFsaWREaXJlY3Rpb25zW3NldHRpbmdzLm9yaWVudGF0aW9uXS5pbmRleE9mKGRpcmVjdGlvbikgPj0gMCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSB0aWxlIGdpdmVuIGl0cyBJRC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgaGV4IGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZUlkIFRoZSBJRCBvZiB0aGUgdGlsZS5cbiAqIEByZXR1cm4ge29iamVjdHxudWxsfSBBbiBvYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMuXG4gKiBAdGhyb3dzIEVycm9yIElmIHRoZSB0aWxlSWQgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBnZXRUaWxlQ29vcmRpbmF0ZXNCeUlkKHNldHRpbmdzLCB0aWxlSWQpIHtcbiAgaWYgKHNldHRpbmdzLnZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGlmICh0eXBlb2YgdGlsZUlkICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aWxlSWQgbXVzdCBiZSBhIG51bWJlci4gR290ICcgKyB0eXBlb2YgdGlsZUlkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHRpbGVJZCAlIHNldHRpbmdzLndpZHRoLFxuICAgIHk6IE1hdGguZmxvb3IodGlsZUlkIC8gc2V0dGluZ3Mud2lkdGgpXG4gIH07XG59XG5cbi8qKlxuICogR2V0cyBhIHRpbGUncyBuZWlnaGJvdXIgZ2l2ZW4gaXRzIGNvb3JkaW5hdGVzIGFuZCBhIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgZ3JpZCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpciBBIGRpcmVjdGlvbi4gT25lIG9mOiBub3J0aCwgbm9ydGhlYXN0LCBlYXN0LFxuICogc291dGhlYXN0LCBzb3V0aCwgc291dGh3ZXN0LCB3ZXN0LCBub3J0aHdlc3QuXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gVGhlIG5laWdoYm91cmluZyB0aWxlLlxuICovXG5mdW5jdGlvbiBnZXROZWlnaGJvdXJUaWxlSWRCeUNvb3JkaW5hdGVzKHNldHRpbmdzLCB4LCB5LCBkaXIpIHtcbiAgaWYgKHNldHRpbmdzLnZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGlmIChpc1ZhbGlkRGlyZWN0aW9uKHNldHRpbmdzLCBkaXIpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBkaXJlY3Rpb246ICcgKyBkaXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb3dJc0V2ZW4gPSAoeSAlIDIgPT09IDApO1xuICB2YXIgY29sSXNFdmVuID0gKHggJSAyID09PSAwKTtcblxuICB2YXIgeE9mZnNldCA9IDA7XG4gIGlmIChcbiAgICBzZXR0aW5ncy5vcmllbnRhdGlvbiA9PT0gJ2ZsYXQtdG9wcGVkJyB8fFxuICAgIChzZXR0aW5ncy5sYXlvdXQgPT09ICdvZGQtcicgJiYgcm93SXNFdmVuID09PSBmYWxzZSAmJiAoZGlyID09PSAnbm9ydGhlYXN0JyB8fCBkaXIgPT09ICdzb3V0aGVhc3QnKSkgfHxcbiAgICAoc2V0dGluZ3MubGF5b3V0ID09PSAnb2RkLXInICYmIHJvd0lzRXZlbiA9PT0gdHJ1ZSAmJiAoZGlyID09PSAnbm9ydGh3ZXN0JyB8fCBkaXIgPT09ICdzb3V0aHdlc3QnKSkgfHxcbiAgICAoc2V0dGluZ3MubGF5b3V0ID09PSAnZXZlbi1yJyAmJiByb3dJc0V2ZW4gPT09IHRydWUgJiYgKGRpciA9PT0gJ25vcnRoZWFzdCcgfHwgZGlyID09PSAnc291dGhlYXN0JykpIHx8XG4gICAgKHNldHRpbmdzLmxheW91dCA9PT0gJ2V2ZW4tcicgJiYgcm93SXNFdmVuID09PSBmYWxzZSAmJiAoZGlyID09PSAnbm9ydGh3ZXN0JyB8fCBkaXIgPT09ICdzb3V0aHdlc3QnKSlcbiAgKSB7XG4gICAgeE9mZnNldCA9IDE7XG4gIH1cblxuICB2YXIgeU9mZnNldCA9IDA7XG4gIGlmIChcbiAgICBzZXR0aW5ncy5vcmllbnRhdGlvbiA9PT0gJ3BvaW50eS10b3BwZWQnIHx8XG4gICAgKHNldHRpbmdzLmxheW91dCA9PT0gJ29kZC1xJyAmJiBjb2xJc0V2ZW4gPT09IGZhbHNlICYmIChkaXIgPT09ICdub3J0aGVhc3QnIHx8IGRpciA9PT0gJ3NvdXRoZWFzdCcpKSB8fFxuICAgIChzZXR0aW5ncy5sYXlvdXQgPT09ICdvZGQtcScgJiYgY29sSXNFdmVuID09PSB0cnVlICYmIChkaXIgPT09ICdub3J0aHdlc3QnIHx8IGRpciA9PT0gJ3NvdXRod2VzdCcpKSB8fFxuICAgIChzZXR0aW5ncy5sYXlvdXQgPT09ICdldmVuLXEnICYmIGNvbElzRXZlbiA9PT0gdHJ1ZSAmJiAoZGlyID09PSAnbm9ydGhlYXN0JyB8fCBkaXIgPT09ICdzb3V0aGVhc3QnKSkgfHxcbiAgICAoc2V0dGluZ3MubGF5b3V0ID09PSAnZXZlbi1xJyAmJiBjb2xJc0V2ZW4gPT09IGZhbHNlICYmIChkaXIgPT09ICdub3J0aHdlc3QnIHx8IGRpciA9PT0gJ3NvdXRod2VzdCcpKVxuICApIHtcbiAgICB5T2Zmc2V0ID0gMTtcbiAgfVxuXG4gIHZhciB4UCA9IDA7XG4gIGlmIChzZXR0aW5ncy5zaGFwZSAgJiYgc2V0dGluZ3Muc2hhcGUgPT09ICdwYXJhbGxlbG9ncmFtJykge1xuICAgIGlmIChyb3dJc0V2ZW4pIHtcbiAgICAgIGlmIChkaXIgPT09ICdub3J0aCcgfHwgZGlyID09PSAnbm9ydGh3ZXN0JyB8fCBkaXIgPT09ICdub3J0aGVhc3QnKSB7XG4gICAgICAgIHhQID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFAgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlyID09PSAnc291dGgnIHx8IGRpciA9PT0gJ3NvdXRod2VzdCcgfHwgZGlyID09PSAnc291dGhlYXN0Jykge1xuICAgICAgICB4UCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvZmZzZXRzID0ge1xuICAgICdub3J0aCc6IHt4OiAwLCB5OiAtMX0sXG4gICAgJ2Vhc3QnOiB7eDogKzEsIHk6IDB9LFxuICAgICdzb3V0aCc6IHt4OiAwLCB5OiArMX0sXG4gICAgJ3dlc3QnOiB7eDogLTEsIHk6IDB9LFxuICAgICdub3J0aGVhc3QnOiB7eDogeE9mZnNldCArIHhQLCB5OiB5T2Zmc2V0ICogLTF9LFxuICAgICdzb3V0aGVhc3QnOiB7eDogeE9mZnNldCArIHhQLCB5OiB5T2Zmc2V0fSxcbiAgICAnc291dGh3ZXN0Jzoge3g6ICh4T2Zmc2V0ICogLTEpICsgeFAsIHk6IHlPZmZzZXR9LFxuICAgICdub3J0aHdlc3QnOiB7eDogKHhPZmZzZXQgKiAtMSkgKyB4UCwgeTogeU9mZnNldCAqIC0xfVxuICB9O1xuXG4gIHZhciBvZmZzZXQgPSBvZmZzZXRzW2Rpcl07XG4gIHJldHVybiBnZXRUaWxlSWRCeUNvb3JkaW5hdGVzKHNldHRpbmdzLCB4ICsgb2Zmc2V0LngsIHkgKyBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogR2V0cyBhIHRpbGUncyBuZWlnaGJvdXIgZ2l2ZW4gdGhlIHRpbGUncyBJRCBhbmQgYSBkaXJlY3Rpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgVGhlIGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZUlkIFRoZSB0aWxlJ3MgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIEEgZGlyZWN0aW9uLiBPbmUgb2Y6IG5vcnRoLCBub3J0aGVhc3QsIGVhc3QsXG4gKiBzb3V0aGVhc3QsIHNvdXRoLCBzb3V0aHdlc3QsIHdlc3QsIG5vcnRod2VzdC5cbiAqIEByZXR1cm4ge29iamVjdHxudWxsfSBUaGUgbmVpZ2hib3VyaW5nIHRpbGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5laWdoYm91cklkQnlUaWxlSWQoc2V0dGluZ3MsIHRpbGVJZCwgZGlyZWN0aW9uKSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBpZiAodHlwZW9mIHRpbGVJZCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGlsZUlkIG11c3QgYmUgYSBudW1iZXIuIEdvdCAnICsgdHlwZW9mIHRpbGVJZCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlyZWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXIgbXVzdCBiZSBhIHN0cmluZy4gR290ICcgKyB0eXBlb2YgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29vcmRzID0gZ2V0VGlsZUNvb3JkaW5hdGVzQnlJZChzZXR0aW5ncywgdGlsZUlkKTtcbiAgcmV0dXJuIGdldE5laWdoYm91clRpbGVJZEJ5Q29vcmRpbmF0ZXMoc2V0dGluZ3MsIGNvb3Jkcy54LCBjb29yZHMueSwgZGlyZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXRzIElEcyBhbGwgbmVpZ2hib3VycyBvZiBhIHRpbGUgZ2l2ZW4gdGhlIHRpbGUncyBJRC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgZ3JpZCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlSWQgVGhlIHRpbGUncyBJRC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBUaGUgbmVpZ2hib3VyaW5nIHRpbGVzJyBJRHMuXG4gKi9cbmZ1bmN0aW9uIGdldE5laWdoYm91cklkc0J5VGlsZUlkKHNldHRpbmdzLCB0aWxlSWQpIHtcbiAgaWYgKHNldHRpbmdzLnZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgIHZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICB9XG5cbiAgdmFyIGNvb3JkcyA9IGdldFRpbGVDb29yZGluYXRlc0J5SWQoc2V0dGluZ3MsIHRpbGVJZCk7XG4gIGlmIChzZXR0aW5ncy5vcmllbnRhdGlvbiA9PT0gJ3BvaW50eS10b3BwZWQnICYmIHNldHRpbmdzLnNoYXBlID09PSAncGFyYWxsZWxvZ3JhbScpIHtcbiAgICB2YXIgbmVpZ2hib3VySWRzID0gW107XG4gICAgaWYgKGNvb3Jkcy54ID4gMCkge1xuICAgICAgLy8gV2VzdC5cbiAgICAgIG5laWdoYm91cklkcy5wdXNoKHRpbGVJZCAtIDEpO1xuXG4gICAgICAvLyBTb3V0aHdlc3QuXG4gICAgICBpZiAoY29vcmRzLnkgPCBzZXR0aW5ncy5oZWlnaHQgLSAxKSB7XG4gICAgICAgIG5laWdoYm91cklkcy5wdXNoKHRpbGVJZCArIHNldHRpbmdzLndpZHRoIC0gMSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoY29vcmRzLnggPCBzZXR0aW5ncy53aWR0aCAtIDEpIHtcbiAgICAgIC8vIEVhc3QuXG4gICAgICBuZWlnaGJvdXJJZHMucHVzaCh0aWxlSWQgKyAxKTtcblxuICAgICAgLy8gTm9ydGhlYXN0LlxuICAgICAgaWYgKGNvb3Jkcy55ID4gMCkge1xuICAgICAgICBuZWlnaGJvdXJJZHMucHVzaCgxICsgdGlsZUlkIC0gc2V0dGluZ3Mud2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcnRod2VzdC5cbiAgICBpZiAoY29vcmRzLnkgPiAwKSB7XG4gICAgICBuZWlnaGJvdXJJZHMucHVzaCh0aWxlSWQgLSBzZXR0aW5ncy53aWR0aCk7XG4gICAgfVxuXG4gICAgLy8gU291dGhlYXN0LlxuICAgIGlmIChjb29yZHMueSA8IHNldHRpbmdzLmhlaWdodCAtIDEpIHtcbiAgICAgIG5laWdoYm91cklkcy5wdXNoKHRpbGVJZCArIHNldHRpbmdzLndpZHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3VySWRzO1xuICB9XG5cbiAgcmV0dXJuIF92YWxpZERpcmVjdGlvbnNbc2V0dGluZ3Mub3JpZW50YXRpb25dLm1hcChmdW5jdGlvbiAoZGlyKSB7XG4gICAgcmV0dXJuIGdldE5laWdoYm91clRpbGVJZEJ5Q29vcmRpbmF0ZXMoc2V0dGluZ3MsIGNvb3Jkcy54LCBjb29yZHMueSwgZGlyKTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgcmV0dXJuIHRpbGUgIT09IG51bGw7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgdGlsZSBieSBpdHMgY29vcmRpbmF0ZXMuIER1ZSB0byB0aGUgd2F5XG4gKiBoZXhhZ29uYWwgZ3JpZHMgd29yaywgdGhlIHBvc2l0aW9uIG9mIGhhbGYgb2YgdGhlIHRpbGVzIGFyZSBvZmZzZXQgYnlcbiAqIDAuNS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFRpbGVQb3NpdGlvbkJ5Q29vcmRzKHNldHRpbmdzLCB4LCB5KSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHkgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd4IGFuZCB5IG11c3QgYmUgaW50ZWdlcnMnKTtcbiAgfVxuXG4gIHZhciB4T2Zmc2V0ID0gMCxcbiAgICB5T2Zmc2V0ID0gMDtcblxuICBzd2l0Y2ggKHNldHRpbmdzLmxheW91dCkge1xuICAvLyBGbGF0IHRvcC5cbiAgY2FzZSAnb2RkLXEnOlxuICAgIC8vIE9kZCBjb2x1bW5zIGFyZSBvZmZzZXQgYnkgaGFsZi5cbiAgICBpZiAoeCAlIDIgPT09IDEpIHtcbiAgICAgIHlPZmZzZXQgKz0gMC41O1xuICAgIH1cbiAgICBicmVhaztcblxuICBjYXNlICdldmVuLXEnOlxuICAgIC8vIEV2ZW4gY29sdW1ucyBhcmUgb2Zmc2V0IGJ5IGhhbGYuXG4gICAgaWYgKHggJSAyID09PSAwKSB7XG4gICAgICB5T2Zmc2V0ICs9IDAuNTtcbiAgICB9XG4gICAgYnJlYWs7XG5cbiAgLy8gUG9pbnR5IHRvcC5cbiAgY2FzZSAnb2RkLXInOlxuICAgIC8vIE9kZCByb3dzIGFyZSBvZmZzZXQgYnkgaGFsZi5cbiAgICBpZiAoeSAlIDIgPT09IDEpIHtcbiAgICAgIHhPZmZzZXQgKz0gMC41O1xuICAgIH1cblxuICAgIGJyZWFrO1xuXG4gIGNhc2UgJ2V2ZW4tcic6XG4gICAgLy8gRXZlbiByb3dzIGFyZSBvZmZzZXQgYnkgaGFsZi5cbiAgICBpZiAoeSAlIDIgPT09IDApIHtcbiAgICAgIHhPZmZzZXQgKz0gMC41O1xuICAgIH1cblxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdnZXRUaWxlUG9zaXRpb25CeUNvb3JkcyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yICcgKyBzZXR0aW5ncy5sYXlvdXQgKyAnLicpO1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLnNoYXBlICYmIHNldHRpbmdzLnNoYXBlID09PSAncGFyYWxsZWxvZ3JhbScpIHtcbiAgICB4T2Zmc2V0ICs9IE1hdGguZmxvb3IoeSAvIDIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgeE9mZnNldCxcbiAgICB5OiB5ICsgeU9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBvc2l0aW9uIG9mIGEgdGlsZSBieSBpdHMgSUQuXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgVGhlIGdyaWQgc2V0dGluZ3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGlsZUlkIFRoZSB0aWxlJ3MgSUQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VGlsZVBvc2l0aW9uQnlJZChzZXR0aW5ncywgdGlsZUlkKSB7XG4gIHZhciBjb29yZHMgPSBnZXRUaWxlQ29vcmRpbmF0ZXNCeUlkKHNldHRpbmdzLCB0aWxlSWQpO1xuICByZXR1cm4gZ2V0VGlsZVBvc2l0aW9uQnlDb29yZHMoc2V0dGluZ3MsIGNvb3Jkcy54LCBjb29yZHMueSk7XG59XG5cbi8qKlxuICogR2V0cyBzaG9ydGVzdCBwYXRocyBmcm9tIGEgZ2l2ZW4gc3RhcnRpbmcgdGlsZSB0byBhbGwgb3RoZXIgcmVhY2hhYmxlIHRpbGVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgZ3JpZCBzZXR0aW5ncy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlSWQgVGhlIHRpbGUncyBJRC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4Q29zdCBUaGUgbWF4aW11bSBhbGxvd2VkIGNvc3Qgb2YgYSBwYXRoLFxuICogb3IgUE9TSVRJVkVfSU5GSU5JVFkgaWYgbm90IHNwZWNpZmllZC4gSWYgc3BlY2lmaWVkLCBhIHBhdGhDb3N0IGZ1bmN0aW9uXG4gKiBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHtudW1iZXJ8ZnVuY3Rpb259IG9wdGlvbnMubW92ZUNvc3QgVGhlIGNvc3Qgb2YgbW92aW5nIGZyb20gb25lIHRpbGVcbiAqIHRvIGFub3RoZXIuIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCBsaWtlXG4gKiBgb3B0aW9ucy5wYXRoQ29zdChmcm9tVGlsZUlkLCB0b1RpbGVJZClgIGFuZCBpdCBzaG91bGQgcmV0dXJuIHRoZSBjb3N0IG9mXG4gKiBtb3ZpbmcgZnJvbSBmcm9tVGlsZSB0byB0b1RpbGUuIERlZmF1bHRzIHRvIDEuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmlzUGF0aGFibGUgQW4gb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggc2F5c1xuICogd2hldGhlciBhIHRpbGUgaXMgcGF0aGFibGUuIEl0IGlzIGNhbGxlZCBsaWtlIGBvcHRpb25zLnBhdGhhYmxlKHRpbGVJZClgXG4gKiBhbmQgc2hvdWxkIHJldHVybiBlaXRoZXIgdHJ1ZSBvciBmYWxzZS5cbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgZmluYWwgdGlsZUlkIGluIGEgcGF0aFxuICogYW5kIHRoZSB2YWx1ZXMgYXJlIFBhdGggb2JqZWN0cy4gVGhlIFBhdGggb2JqZWN0IGxvb2tzIGxpa2UgdGhpczpcbiAqIHtcbiAqICAgIHRpbGVJZHM6IFt0aWxlSWQxLCB0aWxlSWQyLCAuLi4sIHRpbGVJZE5dLFxuICogICAgY29zdDogMFxuICogfVxuICpcbiAqIFRoZSB0aWxlSWRzIGFyZSB0aGUgdGlsZSBJRHMgdHJhdmVyc2VkIGluIG9yZGVyLCBpbmNsdWRpbmcgdGhlIHN0YXJ0aW5nXG4gKiBhbmQgZmluYWwgdGlsZS5cbiAqXG4gKiBUaGUgY29zdCBpdCB0aGUgdG90YWwgY29zdCBvZiB0cmF2ZXJzaW5nIHRoZSBwYXRoLiBUaGUgY29zdCBvZiBlYWNoIHN0ZXBcbiAqIG9mIHRoZSBwYXRoIGlzIGRldGVybWluZWQgYnkgY2FsbGluZyBvcHRpb25zLnBhdGhDb3N0KGZyb21UaWxlLCB0b1RpbGUpLFxuICogb3IgMCBpZiBvcHRpb25zLnBhdGhDb3N0IGlzIG5vdCBzdXBwbGllZC5cbiAqXG4gKiBUaGUgemVyby1sZW5ndGggcGF0aCBmcm9tIGEgdGlsZSB0byBpdHNlbGYgaXMgbm90IHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBnZXRTaG9ydGVzdFBhdGhzRnJvbVRpbGVJZChzZXR0aW5ncywgdGlsZUlkLCBvcHRpb25zKSB7XG4gIGlmIChzZXR0aW5ncy52YWxpZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBpZiAodHlwZW9mKHRpbGVJZCkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RpbGVJZCBtdXN0IGJlIGEgc3RyaW5nLCBnb3Q6ICcgKyB0eXBlb2YgdGlsZUlkKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1heFBhdGhDb3N0ID0gb3B0aW9ucy5tYXhDb3N0O1xuICBpZiAobWF4UGF0aENvc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIG1heFBhdGhDb3N0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgdmFyIG1vdmVDb3N0ID0gb3B0aW9ucy5tb3ZlQ29zdDtcbiAgaWYgKG1vdmVDb3N0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtb3ZlQ29zdCA9IDE7XG4gIH1cblxuICAvLyBTdGFydCB3aXRoIHRoZSBpbnB1dCB0aWxlIGFzIHRoZSBmcm9udGllciB0aWxlIGFuZCBleHBsb3JlIGZyb20gdGhlcmUuXG4gIHZhciBmcm9udGllclRpbGVJZHMgPSBbdGlsZUlkXTtcblxuICAvLyBGb3IgZWFjaCB0aWxlLCByZWNvcmQgdGhlIHByZXZpb3VzIHRpbGUuXG4gIHZhciBmcm9tID0ge307XG4gIGZyb21bdGlsZUlkXSA9IG51bGw7XG5cbiAgLy8gRm9yIGVhY2ggZGVzdGluYXRpb24gdGlsZSBzdG9yZSBhIFBhdGggb2JqZWN0LlxuICB2YXIgcGF0aCA9IHt9O1xuXG4gIHdoaWxlIChmcm9udGllclRpbGVJZHMubGVuZ3RoKSB7XG4gICAgdmFyIGZyb250aWVyVGlsZUlkID0gZnJvbnRpZXJUaWxlSWRzLnNoaWZ0KCk7XG4gICAgaWYgKHBhdGhbZnJvbnRpZXJUaWxlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhdGhbZnJvbnRpZXJUaWxlSWRdID0ge1xuICAgICAgICB0aWxlSWRzOiBbZnJvbnRpZXJUaWxlSWRdLFxuICAgICAgICBjb3N0OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGdldE5laWdoYm91cklkc0J5VGlsZUlkKHNldHRpbmdzLCBmcm9udGllclRpbGVJZCkuZm9yRWFjaChmdW5jdGlvbiBleHBhbmRTZWFyY2gobmVpZ2hib3VyVGlsZUlkKSB7XG4gICAgICAvLyBQYXRoIGlzIHRvbyBjb3N0bHkuXG4gICAgICBpZiAocGF0aFtmcm9udGllclRpbGVJZF0uY29zdCA+IG1heFBhdGhDb3N0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxyZWFkeSBmb3VuZCBhIHBhdGggdG8gdGlsZS5pZC4gQnJlYWR0aC1maXJzdCBzZWFyY2hcbiAgICAgIC8vIGd1YXJhbnRlZXMgaXQgaXMgc2hvcnRlci5cbiAgICAgIGlmIChmcm9tW25laWdoYm91clRpbGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRpbGUgaXMgbm90IHBhdGhhYmxlLlxuICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmlzUGF0aGFibGUpID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIG9wdGlvbnMuaXNQYXRoYWJsZShuZWlnaGJvdXJUaWxlSWQpID09PSBmYWxzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvc3QgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBtb3ZlQ29zdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb3N0ID0gbW92ZUNvc3QoZnJvbnRpZXJUaWxlSWQsIG5laWdoYm91clRpbGVJZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY29zdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb3B0aW9ucy5tb3ZlQ29zdChmcm9tVGlsZUlkLCB0b1RpbGVJZCkgZGlkIG5vdCByZXR1cm4gYSBudW1iZXIuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvc3QgPSBtb3ZlQ29zdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhDb3N0ID0gcGF0aFtmcm9udGllclRpbGVJZF0uY29zdCArIGNvc3Q7XG4gICAgICBpZiAocGF0aENvc3QgPiBtYXhQYXRoQ29zdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZyb21bbmVpZ2hib3VyVGlsZUlkXSA9IGZyb250aWVyVGlsZUlkO1xuICAgICAgcGF0aFtuZWlnaGJvdXJUaWxlSWRdID0ge1xuICAgICAgICBjb3N0OiBwYXRoQ29zdCxcbiAgICAgICAgdGlsZUlkczogcGF0aFtmcm9udGllclRpbGVJZF0udGlsZUlkcy5jb25jYXQoW25laWdoYm91clRpbGVJZF0pXG4gICAgICB9O1xuXG4gICAgICBmcm9udGllclRpbGVJZHMucHVzaChuZWlnaGJvdXJUaWxlSWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gRXhjbHVkZSB0aGUgMCBsZW5ndGggcGF0aC5cbiAgZGVsZXRlIHBhdGhbdGlsZUlkXTtcblxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gaGFzUGF0aCAoc2V0dGluZ3MsIHN0YXJ0VGlsZXMsIGVuZFRpbGVzLCBvcHRpb25zKSB7XG4gIHZhciBpLCBqLCBmcm9udGllck5laWdoYm91cnM7XG5cbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICB2YXIgZW5kVGlsZXNPYmogPSB7fTtcbiAgZm9yIChpID0gMDsgaSA8IGVuZFRpbGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKG9wdGlvbnMuaXNQYXRoYWJsZShlbmRUaWxlc1tpXSkpIHtcbiAgICAgIGVuZFRpbGVzT2JqW2VuZFRpbGVzW2ldXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZyb250aWVyVGlsZXMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHN0YXJ0VGlsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAob3B0aW9ucy5pc1BhdGhhYmxlKHN0YXJ0VGlsZXNbaV0pKSB7XG4gICAgICBmcm9udGllclRpbGVzLnB1c2goc3RhcnRUaWxlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGZyb250aWVyVGlsZXMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmcm9udGllclRpbGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2aXNpdGVkW2Zyb250aWVyVGlsZXNbaV1dID0gdHJ1ZTtcbiAgICAgIGlmIChlbmRUaWxlc09ialtmcm9udGllclRpbGVzW2ldXSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9udGllck5laWdoYm91cnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbnRpZXJUaWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG5laWdoYm91cnMgPSBnZXROZWlnaGJvdXJJZHNCeVRpbGVJZChzZXR0aW5ncywgZnJvbnRpZXJUaWxlc1tpXSk7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBuZWlnaGJvdXJzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzUGF0aGFibGUobmVpZ2hib3Vyc1tqXSkgJiZcbiAgICAgICAgICBmcm9udGllck5laWdoYm91cnMuaW5kZXhPZihuZWlnaGJvdXJzW2pdKSA9PT0gLTEgJiZcbiAgICAgICAgICB2aXNpdGVkW25laWdoYm91cnNbal1dID09PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgZnJvbnRpZXJOZWlnaGJvdXJzLnB1c2gobmVpZ2hib3Vyc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9udGllclRpbGVzID0gZnJvbnRpZXJOZWlnaGJvdXJzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdGVTZXR0aW5nczogdmFsaWRhdGVTZXR0aW5ncyxcbiAgZ2V0VGlsZUlkczogZ2V0VGlsZUlkcyxcbiAgaXNXaXRoaW5Cb3VuZGFyaWVzOiBpc1dpdGhpbkJvdW5kYXJpZXMsXG4gIGdldFRpbGVJZEJ5Q29vcmRpbmF0ZXM6IGdldFRpbGVJZEJ5Q29vcmRpbmF0ZXMsXG4gIGlzVmFsaWREaXJlY3Rpb246IGlzVmFsaWREaXJlY3Rpb24sXG4gIGdldFRpbGVDb29yZGluYXRlc0J5SWQ6IGdldFRpbGVDb29yZGluYXRlc0J5SWQsXG4gIGdldE5laWdoYm91clRpbGVJZEJ5Q29vcmRpbmF0ZXM6IGdldE5laWdoYm91clRpbGVJZEJ5Q29vcmRpbmF0ZXMsXG4gIGdldE5laWdoYm91cklkQnlUaWxlSWQ6IGdldE5laWdoYm91cklkQnlUaWxlSWQsXG4gIGdldE5laWdoYm91cklkc0J5VGlsZUlkOiBnZXROZWlnaGJvdXJJZHNCeVRpbGVJZCxcbiAgZ2V0VGlsZVBvc2l0aW9uQnlDb29yZHM6IGdldFRpbGVQb3NpdGlvbkJ5Q29vcmRzLFxuICBnZXRUaWxlUG9zaXRpb25CeUlkOiBnZXRUaWxlUG9zaXRpb25CeUlkLFxuICBnZXRTaG9ydGVzdFBhdGhzRnJvbVRpbGVJZDogZ2V0U2hvcnRlc3RQYXRoc0Zyb21UaWxlSWQsXG4gIGhhc1BhdGg6IGhhc1BhdGhcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbC5JbW11dGFibGUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0Jzt2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhjdG9yLCBzdXBlckNsYXNzKSB7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJdGVyYWJsZSh2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG4gICAgfVxuXG5cbiAgY3JlYXRlQ2xhc3MoS2V5ZWRJdGVyYWJsZSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIEtleWVkSXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlIDogS2V5ZWRTZXEodmFsdWUpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKEluZGV4ZWRJdGVyYWJsZSwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW5kZXhlZCh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpO1xuICAgIH1cblxuXG4gIGNyZWF0ZUNsYXNzKFNldEl0ZXJhYmxlLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gU2V0SXRlcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0l0ZXJhYmxlKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IFNldFNlcSh2YWx1ZSk7XG4gICAgfVxuXG5cblxuICBmdW5jdGlvbiBpc0l0ZXJhYmxlKG1heWJlSXRlcmFibGUpIHtcbiAgICByZXR1cm4gISEobWF5YmVJdGVyYWJsZSAmJiBtYXliZUl0ZXJhYmxlW0lTX0lURVJBQkxFX1NFTlRJTkVMXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0tleWVkKG1heWJlS2V5ZWQpIHtcbiAgICByZXR1cm4gISEobWF5YmVLZXllZCAmJiBtYXliZUtleWVkW0lTX0tFWUVEX1NFTlRJTkVMXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0luZGV4ZWQobWF5YmVJbmRleGVkKSB7XG4gICAgcmV0dXJuICEhKG1heWJlSW5kZXhlZCAmJiBtYXliZUluZGV4ZWRbSVNfSU5ERVhFRF9TRU5USU5FTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBc3NvY2lhdGl2ZShtYXliZUFzc29jaWF0aXZlKSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQobWF5YmVBc3NvY2lhdGl2ZSkgfHwgaXNJbmRleGVkKG1heWJlQXNzb2NpYXRpdmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkKG1heWJlT3JkZXJlZCkge1xuICAgIHJldHVybiAhIShtYXliZU9yZGVyZWQgJiYgbWF5YmVPcmRlcmVkW0lTX09SREVSRURfU0VOVElORUxdKTtcbiAgfVxuXG4gIEl0ZXJhYmxlLmlzSXRlcmFibGUgPSBpc0l0ZXJhYmxlO1xuICBJdGVyYWJsZS5pc0tleWVkID0gaXNLZXllZDtcbiAgSXRlcmFibGUuaXNJbmRleGVkID0gaXNJbmRleGVkO1xuICBJdGVyYWJsZS5pc0Fzc29jaWF0aXZlID0gaXNBc3NvY2lhdGl2ZTtcbiAgSXRlcmFibGUuaXNPcmRlcmVkID0gaXNPcmRlcmVkO1xuXG4gIEl0ZXJhYmxlLktleWVkID0gS2V5ZWRJdGVyYWJsZTtcbiAgSXRlcmFibGUuSW5kZXhlZCA9IEluZGV4ZWRJdGVyYWJsZTtcbiAgSXRlcmFibGUuU2V0ID0gU2V0SXRlcmFibGU7XG5cblxuICB2YXIgSVNfSVRFUkFCTEVfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuICB2YXIgSVNfS0VZRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuICB2YXIgSVNfSU5ERVhFRF9TRU5USU5FTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcbiAgdmFyIElTX09SREVSRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbiAgLy8gVXNlZCBmb3Igc2V0dGluZyBwcm90b3R5cGUgbWV0aG9kcyB0aGF0IElFOCBjaG9rZXMgb24uXG4gIHZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuICAvLyBDb25zdGFudHMgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0cmllIG5vZGVzLlxuICB2YXIgU0hJRlQgPSA1OyAvLyBSZXN1bHRlZCBpbiBiZXN0IHBlcmZvcm1hbmNlIGFmdGVyIF9fX19fXz9cbiAgdmFyIFNJWkUgPSAxIDw8IFNISUZUO1xuICB2YXIgTUFTSyA9IFNJWkUgLSAxO1xuXG4gIC8vIEEgY29uc2lzdGVudCBzaGFyZWQgdmFsdWUgcmVwcmVzZW50aW5nIFwibm90IHNldFwiIHdoaWNoIGVxdWFscyBub3RoaW5nIG90aGVyXG4gIC8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG4gIHZhciBOT1RfU0VUID0ge307XG5cbiAgLy8gQm9vbGVhbiByZWZlcmVuY2VzLCBSb3VnaCBlcXVpdmFsZW50IG9mIGBib29sICZgLlxuICB2YXIgQ0hBTkdFX0xFTkdUSCA9IHsgdmFsdWU6IGZhbHNlIH07XG4gIHZhciBESURfQUxURVIgPSB7IHZhbHVlOiBmYWxzZSB9O1xuXG4gIGZ1bmN0aW9uIE1ha2VSZWYocmVmKSB7XG4gICAgcmVmLnZhbHVlID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNldFJlZihyZWYpIHtcbiAgICByZWYgJiYgKHJlZi52YWx1ZSA9IHRydWUpO1xuICB9XG5cbiAgLy8gQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgcmVwcmVzZW50aW5nIGFuIFwib3duZXJcIiBmb3IgdHJhbnNpZW50IHdyaXRlc1xuICAvLyB0byB0cmllcy4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIG9ubHkgZXZlciBlcXVhbCBpdHNlbGYsIGFuZCB3aWxsIG5vdCBlcXVhbFxuICAvLyB0aGUgcmV0dXJuIG9mIGFueSBzdWJzZXF1ZW50IGNhbGwgb2YgdGhpcyBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vY29weS1hcnJheS1pbmxpbmVcbiAgZnVuY3Rpb24gYXJyQ29weShhcnIsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1heCgwLCBhcnIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICB2YXIgbmV3QXJyID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgbmV3QXJyW2lpXSA9IGFycltpaSArIG9mZnNldF07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTaXplKGl0ZXIpIHtcbiAgICBpZiAoaXRlci5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXIuc2l6ZSA9IGl0ZXIuX19pdGVyYXRlKHJldHVyblRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5zaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcEluZGV4KGl0ZXIsIGluZGV4KSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIFwiaXMgYXJyYXkgaW5kZXhcIiB3aGljaCB0aGUgRUNNQVN0cmluZyBzcGVjIGRlZmluZXMgYXM6XG4gICAgLy9cbiAgICAvLyAgICAgQSBTdHJpbmcgcHJvcGVydHkgbmFtZSBQIGlzIGFuIGFycmF5IGluZGV4IGlmIGFuZCBvbmx5IGlmXG4gICAgLy8gICAgIFRvU3RyaW5nKFRvVWludDMyKFApKSBpcyBlcXVhbCB0byBQIGFuZCBUb1VpbnQzMihQKSBpcyBub3QgZXF1YWxcbiAgICAvLyAgICAgdG8gMl4zMuKIkjEuXG4gICAgLy9cbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXktZXhvdGljLW9iamVjdHNcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHVpbnQzMkluZGV4ID0gaW5kZXggPj4+IDA7IC8vIE4gPj4+IDAgaXMgc2hvcnRoYW5kIGZvciBUb1VpbnQzMlxuICAgICAgaWYgKCcnICsgdWludDMySW5kZXggIT09IGluZGV4IHx8IHVpbnQzMkluZGV4ID09PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICBpbmRleCA9IHVpbnQzMkluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggPCAwID8gZW5zdXJlU2l6ZShpdGVyKSArIGluZGV4IDogaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSB7XG4gICAgcmV0dXJuIChiZWdpbiA9PT0gMCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGJlZ2luIDw9IC1zaXplKSkgJiZcbiAgICAgIChlbmQgPT09IHVuZGVmaW5lZCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA+PSBzaXplKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBzaXplLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChlbmQsIHNpemUsIHNpemUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBzaXplLCBkZWZhdWx0SW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCA/XG4gICAgICBkZWZhdWx0SW5kZXggOlxuICAgICAgaW5kZXggPCAwID9cbiAgICAgICAgTWF0aC5tYXgoMCwgc2l6ZSArIGluZGV4KSA6XG4gICAgICAgIHNpemUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgaW5kZXggOlxuICAgICAgICAgIE1hdGgubWluKHNpemUsIGluZGV4KTtcbiAgfVxuXG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cblxuICB2YXIgSVRFUkFURV9LRVlTID0gMDtcbiAgdmFyIElURVJBVEVfVkFMVUVTID0gMTtcbiAgdmFyIElURVJBVEVfRU5UUklFUyA9IDI7XG5cbiAgdmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gUkVBTF9JVEVSQVRPUl9TWU1CT0wgfHwgRkFVWF9JVEVSQVRPUl9TWU1CT0w7XG5cblxuICBmdW5jdGlvbiBJdGVyYXRvcihuZXh0KSB7XG4gICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cblxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdbSXRlcmF0b3JdJztcbiAgICB9O1xuXG5cbiAgSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcbiAgSXRlcmF0b3IuVkFMVUVTID0gSVRFUkFURV9WQUxVRVM7XG4gIEl0ZXJhdG9yLkVOVFJJRVMgPSBJVEVSQVRFX0VOVFJJRVM7XG5cbiAgSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPVxuICBJdGVyYXRvci5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH1cbiAgSXRlcmF0b3IucHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICBmdW5jdGlvbiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIGl0ZXJhdG9yUmVzdWx0KSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZSA9PT0gMCA/IGsgOiB0eXBlID09PSAxID8gdiA6IFtrLCB2XTtcbiAgICBpdGVyYXRvclJlc3VsdCA/IChpdGVyYXRvclJlc3VsdC52YWx1ZSA9IHZhbHVlKSA6IChpdGVyYXRvclJlc3VsdCA9IHtcbiAgICAgIHZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JSZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRvckRvbmUoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSXRlcmF0b3IobWF5YmVJdGVyYWJsZSkge1xuICAgIHJldHVybiAhIWdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0l0ZXJhdG9yKG1heWJlSXRlcmF0b3IpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvciAmJiB0eXBlb2YgbWF5YmVJdGVyYXRvci5uZXh0ID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpO1xuICAgIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBpdGVyYWJsZSAmJiAoXG4gICAgICAoUkVBTF9JVEVSQVRPUl9TWU1CT0wgJiYgaXRlcmFibGVbUkVBTF9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgICAgaXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdXG4gICAgKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoU2VxLCBJdGVyYWJsZSk7XG4gICAgZnVuY3Rpb24gU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U2VxdWVuY2UoKSA6XG4gICAgICAgIGlzSXRlcmFibGUodmFsdWUpID8gdmFsdWUudG9TZXEoKSA6IHNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgU2VxLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIFNlcShhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICBTZXEucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NhY2hlICYmIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9jYWNoZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gYWJzdHJhY3QgX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpXG5cbiAgICBTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0ZSh0aGlzLCBmbiwgcmV2ZXJzZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHNlcUl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UsIHRydWUpO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKEtleWVkU2VxLCBTZXEpO1xuICAgIGZ1bmN0aW9uIEtleWVkU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIGVtcHR5U2VxdWVuY2UoKS50b0tleWVkU2VxKCkgOlxuICAgICAgICBpc0l0ZXJhYmxlKHZhbHVlKSA/XG4gICAgICAgICAgKGlzS2V5ZWQodmFsdWUpID8gdmFsdWUudG9TZXEoKSA6IHZhbHVlLmZyb21FbnRyeVNlcSgpKSA6XG4gICAgICAgICAga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIEtleWVkU2VxLnByb3RvdHlwZS50b0tleWVkU2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhJbmRleGVkU2VxLCBTZXEpO1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlTZXF1ZW5jZSgpIDpcbiAgICAgICAgIWlzSXRlcmFibGUodmFsdWUpID8gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkgOlxuICAgICAgICBpc0tleWVkKHZhbHVlKSA/IHZhbHVlLmVudHJ5U2VxKCkgOiB2YWx1ZS50b0luZGV4ZWRTZXEoKTtcbiAgICB9XG5cbiAgICBJbmRleGVkU2VxLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIEluZGV4ZWRTZXEoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9JbmRleGVkU2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXFJdGVyYXRlKHRoaXMsIGZuLCByZXZlcnNlLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSwgZmFsc2UpO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKFNldFNlcSwgU2VxKTtcbiAgICBmdW5jdGlvbiBTZXRTZXEodmFsdWUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNlcXVlbmNlKCkgOlxuICAgICAgICAhaXNJdGVyYWJsZSh2YWx1ZSkgPyBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSA6XG4gICAgICAgIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUuZW50cnlTZXEoKSA6IHZhbHVlXG4gICAgICApLnRvU2V0U2VxKCk7XG4gICAgfVxuXG4gICAgU2V0U2VxLm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIFNldFNlcShhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXRTZXEucHJvdG90eXBlLnRvU2V0U2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cblxuICBTZXEuaXNTZXEgPSBpc1NlcTtcbiAgU2VxLktleWVkID0gS2V5ZWRTZXE7XG4gIFNlcS5TZXQgPSBTZXRTZXE7XG4gIFNlcS5JbmRleGVkID0gSW5kZXhlZFNlcTtcblxuICB2YXIgSVNfU0VRX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfU0VRX19AQCc7XG5cbiAgU2VxLnByb3RvdHlwZVtJU19TRVFfU0VOVElORUxdID0gdHJ1ZTtcblxuXG5cbiAgY3JlYXRlQ2xhc3MoQXJyYXlTZXEsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEFycmF5U2VxKGFycmF5KSB7XG4gICAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5zaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cblxuICAgIEFycmF5U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl9hcnJheVt3cmFwSW5kZXgodGhpcywgaW5kZXgpXSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIG1heEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycmF5W3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldLCBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBBcnJheVNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIG1heEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgXG4gICAgICAgIHtyZXR1cm4gaWkgPiBtYXhJbmRleCA/XG4gICAgICAgICAgaXRlcmF0b3JEb25lKCkgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaWksIGFycmF5W3JldmVyc2UgPyBtYXhJbmRleCAtIGlpKysgOiBpaSsrXSl9XG4gICAgICApO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKE9iamVjdFNlcSwgS2V5ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFNlcShvYmplY3QpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdCA9IG9iamVjdDtcbiAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgICAgdGhpcy5zaXplID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAobm90U2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W2tleV07XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSk7XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICB2YXIgbWF4SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICBpZiAoZm4ob2JqZWN0W2tleV0sIGtleSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGlpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlpO1xuICAgIH07XG5cbiAgICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIG1heEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgcmV0dXJuIGlpKysgPiBtYXhJbmRleCA/XG4gICAgICAgICAgaXRlcmF0b3JEb25lKCkgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIE9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cbiAgY3JlYXRlQ2xhc3MoSXRlcmFibGVTZXEsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIEl0ZXJhYmxlU2VxKGl0ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgICAgdGhpcy5zaXplID0gaXRlcmFibGUubGVuZ3RoIHx8IGl0ZXJhYmxlLnNpemU7XG4gICAgfVxuXG4gICAgSXRlcmFibGVTZXEucHJvdG90eXBlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMuX2l0ZXJhYmxlO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoaXRlcmFibGUpO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaWYgKGlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG5cbiAgICBJdGVyYWJsZVNlcS5wcm90b3R5cGUuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5faXRlcmFibGU7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgICBpZiAoIWlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhJdGVyYXRvclNlcSwgSW5kZXhlZFNlcSk7XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JTZXEoaXRlcmF0b3IpIHtcbiAgICAgIHRoaXMuX2l0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICB0aGlzLl9pdGVyYXRvckNhY2hlID0gW107XG4gICAgfVxuXG4gICAgSXRlcmF0b3JTZXEucHJvdG90eXBlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXJhdG9yO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5faXRlcmF0b3JDYWNoZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHdoaWxlIChpdGVyYXRpb25zIDwgY2FjaGUubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmbihjYWNoZVtpdGVyYXRpb25zXSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0ZXA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIHZhciB2YWwgPSBzdGVwLnZhbHVlO1xuICAgICAgICBjYWNoZVtpdGVyYXRpb25zXSA9IHZhbDtcbiAgICAgICAgaWYgKGZuKHZhbCwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIEl0ZXJhdG9yU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyYXRvcjtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2l0ZXJhdG9yQ2FjaGU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gY2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhY2hlW2l0ZXJhdGlvbnNdID0gc3RlcC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zLCBjYWNoZVtpdGVyYXRpb25zKytdKTtcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG5cbiAgLy8gIyBwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGlzU2VxKG1heWJlU2VxKSB7XG4gICAgcmV0dXJuICEhKG1heWJlU2VxICYmIG1heWJlU2VxW0lTX1NFUV9TRU5USU5FTF0pO1xuICB9XG5cbiAgdmFyIEVNUFRZX1NFUTtcblxuICBmdW5jdGlvbiBlbXB0eVNlcXVlbmNlKCkge1xuICAgIHJldHVybiBFTVBUWV9TRVEgfHwgKEVNUFRZX1NFUSA9IG5ldyBBcnJheVNlcShbXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID1cbiAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gbmV3IEFycmF5U2VxKHZhbHVlKS5mcm9tRW50cnlTZXEoKSA6XG4gICAgICBpc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYXRvclNlcSh2YWx1ZSkuZnJvbUVudHJ5U2VxKCkgOlxuICAgICAgaGFzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhYmxlU2VxKHZhbHVlKS5mcm9tRW50cnlTZXEoKSA6XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gbmV3IE9iamVjdFNlcSh2YWx1ZSkgOlxuICAgICAgdW5kZWZpbmVkO1xuICAgIGlmICghc2VxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIFtrLCB2XSBlbnRyaWVzLCAnK1xuICAgICAgICAnb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzZXE7XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIHNlcSA9IG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKCFzZXEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdFeHBlY3RlZCBBcnJheSBvciBpdGVyYWJsZSBvYmplY3Qgb2YgdmFsdWVzOiAnICsgdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzZXE7XG4gIH1cblxuICBmdW5jdGlvbiBzZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKSB8fFxuICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgbmV3IE9iamVjdFNlcSh2YWx1ZSkpO1xuICAgIGlmICghc2VxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgaXRlcmFibGUgb2JqZWN0IG9mIHZhbHVlcywgb3Iga2V5ZWQgb2JqZWN0OiAnICsgdmFsdWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzZXE7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgaXNBcnJheUxpa2UodmFsdWUpID8gbmV3IEFycmF5U2VxKHZhbHVlKSA6XG4gICAgICBpc0l0ZXJhdG9yKHZhbHVlKSA/IG5ldyBJdGVyYXRvclNlcSh2YWx1ZSkgOlxuICAgICAgaGFzSXRlcmF0b3IodmFsdWUpID8gbmV3IEl0ZXJhYmxlU2VxKHZhbHVlKSA6XG4gICAgICB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VxSXRlcmF0ZShzZXEsIGZuLCByZXZlcnNlLCB1c2VLZXlzKSB7XG4gICAgdmFyIGNhY2hlID0gc2VxLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBtYXhJbmRleCA9IGNhY2hlLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgICBpZiAoZm4oZW50cnlbMV0sIHVzZUtleXMgPyBlbnRyeVswXSA6IGlpLCBzZXEpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBpaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpaTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcS5fX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXFJdGVyYXRvcihzZXEsIHR5cGUsIHJldmVyc2UsIHVzZUtleXMpIHtcbiAgICB2YXIgY2FjaGUgPSBzZXEuX2NhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgdmFyIG1heEluZGV4ID0gY2FjaGUubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIHJldHVybiBpaSsrID4gbWF4SW5kZXggP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBlbnRyeVswXSA6IGlpIC0gMSwgZW50cnlbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXEuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUpTKGpzb24sIGNvbnZlcnRlcikge1xuICAgIHJldHVybiBjb252ZXJ0ZXIgP1xuICAgICAgZnJvbUpTV2l0aChjb252ZXJ0ZXIsIGpzb24sICcnLCB7Jyc6IGpzb259KSA6XG4gICAgICBmcm9tSlNEZWZhdWx0KGpzb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIGpzb24sIGtleSwgcGFyZW50SlNPTikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICByZXR1cm4gY29udmVydGVyLmNhbGwocGFyZW50SlNPTiwga2V5LCBJbmRleGVkU2VxKGpzb24pLm1hcChmdW5jdGlvbih2LCBrKSAge3JldHVybiBmcm9tSlNXaXRoKGNvbnZlcnRlciwgdiwgaywganNvbil9KSk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqKGpzb24pKSB7XG4gICAgICByZXR1cm4gY29udmVydGVyLmNhbGwocGFyZW50SlNPTiwga2V5LCBLZXllZFNlcShqc29uKS5tYXAoZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pfSkpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21KU0RlZmF1bHQoanNvbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG4gICAgICByZXR1cm4gSW5kZXhlZFNlcShqc29uKS5tYXAoZnJvbUpTRGVmYXVsdCkudG9MaXN0KCk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqKGpzb24pKSB7XG4gICAgICByZXR1cm4gS2V5ZWRTZXEoanNvbikubWFwKGZyb21KU0RlZmF1bHQpLnRvTWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQbGFpbk9iaih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAodmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBleHRlbnNpb24gb2YgdGhlIFwic2FtZS12YWx1ZVwiIGFsZ29yaXRobSBhcyBbZGVzY3JpYmVkIGZvciB1c2UgYnkgRVM2IE1hcFxuICAgKiBhbmQgU2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjS2V5X2VxdWFsaXR5KVxuICAgKlxuICAgKiBOYU4gaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBOYU4sIGhvd2V2ZXIgLTAgYW5kIDAgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICogdmFsdWUsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGJ5XG4gICAqIFtgT2JqZWN0LmlzYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzKS5cbiAgICpcbiAgICogVGhpcyBpcyBleHRlbmRlZCBmdXJ0aGVyIHRvIGFsbG93IE9iamVjdHMgdG8gZGVzY3JpYmUgdGhlIHZhbHVlcyB0aGV5XG4gICAqIHJlcHJlc2VudCwgYnkgd2F5IG9mIGB2YWx1ZU9mYCBvciBgZXF1YWxzYCAoYW5kIGBoYXNoQ29kZWApLlxuICAgKlxuICAgKiBOb3RlOiBiZWNhdXNlIG9mIHRoaXMgZXh0ZW5zaW9uLCB0aGUga2V5IGVxdWFsaXR5IG9mIEltbXV0YWJsZS5NYXAgYW5kIHRoZVxuICAgKiB2YWx1ZSBlcXVhbGl0eSBvZiBJbW11dGFibGUuU2V0IHdpbGwgZGlmZmVyIGZyb20gRVM2IE1hcCBhbmQgU2V0LlxuICAgKlxuICAgKiAjIyMgRGVmaW5pbmcgY3VzdG9tIHZhbHVlc1xuICAgKlxuICAgKiBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhlIHZhbHVlIGFuIG9iamVjdCByZXByZXNlbnRzIGlzIGJ5IGltcGxlbWVudGluZ1xuICAgKiBgdmFsdWVPZmAuIEZvciBleGFtcGxlLCBgRGF0ZWAgcmVwcmVzZW50cyBhIHZhbHVlIGJ5IHJldHVybmluZyBhIHVuaXhcbiAgICogdGltZXN0YW1wIGZvciBgdmFsdWVPZmA6XG4gICAqXG4gICAqICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTsgLy8gRnJpIEZlYiAxMyAyMDA5IC4uLlxuICAgKiAgICAgdmFyIGRhdGUyID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7XG4gICAqICAgICBkYXRlMS52YWx1ZU9mKCk7IC8vIDEyMzQ1Njc4OTAwMDBcbiAgICogICAgIGFzc2VydCggZGF0ZTEgIT09IGRhdGUyICk7XG4gICAqICAgICBhc3NlcnQoIEltbXV0YWJsZS5pcyggZGF0ZTEsIGRhdGUyICkgKTtcbiAgICpcbiAgICogTm90ZTogb3ZlcnJpZGluZyBgdmFsdWVPZmAgbWF5IGhhdmUgb3RoZXIgaW1wbGljYXRpb25zIGlmIHlvdSB1c2UgdGhpcyBvYmplY3RcbiAgICogd2hlcmUgSmF2YVNjcmlwdCBleHBlY3RzIGEgcHJpbWl0aXZlLCBzdWNoIGFzIGltcGxpY2l0IHN0cmluZyBjb2VyY2lvbi5cbiAgICpcbiAgICogRm9yIG1vcmUgY29tcGxleCB0eXBlcywgZXNwZWNpYWxseSBjb2xsZWN0aW9ucywgaW1wbGVtZW50aW5nIGB2YWx1ZU9mYCBtYXlcbiAgICogbm90IGJlIHBlcmZvcm1hbnQuIEFuIGFsdGVybmF0aXZlIGlzIHRvIGltcGxlbWVudCBgZXF1YWxzYCBhbmQgYGhhc2hDb2RlYC5cbiAgICpcbiAgICogYGVxdWFsc2AgdGFrZXMgYW5vdGhlciBvYmplY3QsIHByZXN1bWFibHkgb2Ygc2ltaWxhciB0eXBlLCBhbmQgcmV0dXJucyB0cnVlXG4gICAqIGlmIHRoZSBpdCBpcyBlcXVhbC4gRXF1YWxpdHkgaXMgc3ltbWV0cmljYWwsIHNvIHRoZSBzYW1lIHJlc3VsdCBzaG91bGQgYmVcbiAgICogcmV0dXJuZWQgaWYgdGhpcyBhbmQgdGhlIGFyZ3VtZW50IGFyZSBmbGlwcGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCBhLmVxdWFscyhiKSA9PT0gYi5lcXVhbHMoYSkgKTtcbiAgICpcbiAgICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuICAgKiBiZSB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gc3RvcmUgdGhlIHZhbHVlIG9iamVjdCBpbiBhIE1hcCBvciBTZXQuIFlvdSBtdXN0XG4gICAqIHByb3ZpZGUgYm90aCBvciBuZWl0aGVyIG1ldGhvZHMsIG9uZSBtdXN0IG5vdCBleGlzdCB3aXRob3V0IHRoZSBvdGhlci5cbiAgICpcbiAgICogQWxzbywgYW4gaW1wb3J0YW50IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZXNlIG1ldGhvZHMgbXVzdCBiZSB1cGhlbGQ6IGlmIHR3b1xuICAgKiB2YWx1ZXMgYXJlIGVxdWFsLCB0aGV5ICptdXN0KiByZXR1cm4gdGhlIHNhbWUgaGFzaENvZGUuIElmIHRoZSB2YWx1ZXMgYXJlIG5vdFxuICAgKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuICAgKiBhbmQgd2hpbGUgdW5kZXNpcmFibGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0IGlzIGFjY2VwdGFibGUuXG4gICAqXG4gICAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAgICogICAgICAgYXNzZXJ0KCBhLmhhc2hDb2RlKCkgPT09IGIuaGFzaENvZGUoKSApO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBBbGwgSW1tdXRhYmxlIGNvbGxlY3Rpb25zIGltcGxlbWVudCBgZXF1YWxzYCBhbmQgYGhhc2hDb2RlYC5cbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGlzKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWVBLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlQi52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZUEgPSB2YWx1ZUEudmFsdWVPZigpO1xuICAgICAgdmFsdWVCID0gdmFsdWVCLnZhbHVlT2YoKTtcbiAgICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWVBLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWVCLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB2YWx1ZUEuZXF1YWxzKHZhbHVlQikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhaXNJdGVyYWJsZShiKSB8fFxuICAgICAgYS5zaXplICE9PSB1bmRlZmluZWQgJiYgYi5zaXplICE9PSB1bmRlZmluZWQgJiYgYS5zaXplICE9PSBiLnNpemUgfHxcbiAgICAgIGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiYgYi5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJiBhLl9faGFzaCAhPT0gYi5fX2hhc2ggfHxcbiAgICAgIGlzS2V5ZWQoYSkgIT09IGlzS2V5ZWQoYikgfHxcbiAgICAgIGlzSW5kZXhlZChhKSAhPT0gaXNJbmRleGVkKGIpIHx8XG4gICAgICBpc09yZGVyZWQoYSkgIT09IGlzT3JkZXJlZChiKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhLnNpemUgPT09IDAgJiYgYi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbm90QXNzb2NpYXRpdmUgPSAhaXNBc3NvY2lhdGl2ZShhKTtcblxuICAgIGlmIChpc09yZGVyZWQoYSkpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gYS5lbnRyaWVzKCk7XG4gICAgICByZXR1cm4gYi5ldmVyeShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzLm5leHQoKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGlzKGVudHJ5WzFdLCB2KSAmJiAobm90QXNzb2NpYXRpdmUgfHwgaXMoZW50cnlbMF0sIGspKTtcbiAgICAgIH0pICYmIGVudHJpZXMubmV4dCgpLmRvbmU7XG4gICAgfVxuXG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYS5jYWNoZVJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBfID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSBfO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gICAgdmFyIGJTaXplID0gYi5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgIGlmIChub3RBc3NvY2lhdGl2ZSA/ICFhLmhhcyh2KSA6XG4gICAgICAgICAgZmxpcHBlZCA/ICFpcyh2LCBhLmdldChrLCBOT1RfU0VUKSkgOiAhaXMoYS5nZXQoaywgTk9UX1NFVCksIHYpKSB7XG4gICAgICAgIGFsbEVxdWFsID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhbGxFcXVhbCAmJiBhLnNpemUgPT09IGJTaXplO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUmVwZWF0LCBJbmRleGVkU2VxKTtcblxuICAgIGZ1bmN0aW9uIFJlcGVhdCh2YWx1ZSwgdGltZXMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwZWF0KHZhbHVlLCB0aW1lcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zaXplID0gdGltZXMgPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogTWF0aC5tYXgoMCwgdGltZXMpO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZX1JFUEVBVDtcbiAgICAgICAgfVxuICAgICAgICBFTVBUWV9SRVBFQVQgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIFJlcGVhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdSZXBlYXQgW10nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSZXBlYXQgWyAnICsgdGhpcy5fdmFsdWUgKyAnICcgKyB0aGlzLnNpemUgKyAnIHRpbWVzIF0nO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/IHRoaXMuX3ZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpID8gdGhpcyA6XG4gICAgICAgIG5ldyBSZXBlYXQodGhpcy5fdmFsdWUsIHJlc29sdmVFbmQoZW5kLCBzaXplKSAtIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSkpO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHRoaXMuc2l6ZTsgaWkrKykge1xuICAgICAgICBpZiAoZm4odGhpcy5fdmFsdWUsIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgXG4gICAgICAgIHtyZXR1cm4gaWkgPCB0aGlzJDAuc2l6ZSA/IGl0ZXJhdG9yVmFsdWUodHlwZSwgaWkrKywgdGhpcyQwLl92YWx1ZSkgOiBpdGVyYXRvckRvbmUoKX1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJlcGVhdCA/XG4gICAgICAgIGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpIDpcbiAgICAgICAgZGVlcEVxdWFsKG90aGVyKTtcbiAgICB9O1xuXG5cbiAgdmFyIEVNUFRZX1JFUEVBVDtcblxuICBmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBlcnJvcikge1xuICAgIGlmICghY29uZGl0aW9uKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoUmFuZ2UsIEluZGV4ZWRTZXEpO1xuXG4gICAgZnVuY3Rpb24gUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KHN0ZXAgIT09IDAsICdDYW5ub3Qgc3RlcCBhIFJhbmdlIGJ5IDAnKTtcbiAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5hYnMoc3RlcCk7XG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgc3RlcCA9IC1zdGVwO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhcnQgPSBzdGFydDtcbiAgICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgICAgdGhpcy5zaXplID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwIC0gMSkgKyAxKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JBTkdFKSB7XG4gICAgICAgICAgcmV0dXJuIEVNUFRZX1JBTkdFO1xuICAgICAgICB9XG4gICAgICAgIEVNUFRZX1JBTkdFID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBSYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdSYW5nZSBbXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1JhbmdlIFsgJyArXG4gICAgICAgIHRoaXMuX3N0YXJ0ICsgJy4uLicgKyB0aGlzLl9lbmQgK1xuICAgICAgICAodGhpcy5fc3RlcCAhPT0gMSA/ICcgYnkgJyArIHRoaXMuX3N0ZXAgOiAnJykgK1xuICAgICAgJyBdJztcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKGluZGV4KSA/XG4gICAgICAgIHRoaXMuX3N0YXJ0ICsgd3JhcEluZGV4KHRoaXMsIGluZGV4KSAqIHRoaXMuX3N0ZXAgOlxuICAgICAgICBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBwb3NzaWJsZUluZGV4ID0gKHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQpIC8gdGhpcy5fc3RlcDtcbiAgICAgIHJldHVybiBwb3NzaWJsZUluZGV4ID49IDAgJiZcbiAgICAgICAgcG9zc2libGVJbmRleCA8IHRoaXMuc2l6ZSAmJlxuICAgICAgICBwb3NzaWJsZUluZGV4ID09PSBNYXRoLmZsb29yKHBvc3NpYmxlSW5kZXgpO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgICBlbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICAgIGlmIChlbmQgPD0gYmVnaW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSgwLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5nZXQoYmVnaW4sIHRoaXMuX2VuZCksIHRoaXMuZ2V0KGVuZCwgdGhpcy5fZW5kKSwgdGhpcy5fc3RlcCk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXRWYWx1ZSA9IHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBpZiAob2Zmc2V0VmFsdWUgJSB0aGlzLl9zdGVwID09PSAwKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG9mZnNldFZhbHVlIC8gdGhpcy5fc3RlcDtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG1heEluZGV4ID0gdGhpcy5zaXplIC0gMTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIG1heEluZGV4ICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgICBpZiAoZm4odmFsdWUsIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gaWkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG1heEluZGV4ID0gdGhpcy5zaXplIC0gMTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIG1heEluZGV4ICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgdiA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgICByZXR1cm4gaWkgPiBtYXhJbmRleCA/IGl0ZXJhdG9yRG9uZSgpIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpaSsrLCB2KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJhbmdlID9cbiAgICAgICAgdGhpcy5fc3RhcnQgPT09IG90aGVyLl9zdGFydCAmJlxuICAgICAgICB0aGlzLl9lbmQgPT09IG90aGVyLl9lbmQgJiZcbiAgICAgICAgdGhpcy5fc3RlcCA9PT0gb3RoZXIuX3N0ZXAgOlxuICAgICAgICBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH07XG5cblxuICB2YXIgRU1QVFlfUkFOR0U7XG5cbiAgY3JlYXRlQ2xhc3MoQ29sbGVjdGlvbiwgSXRlcmFibGUpO1xuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0Fic3RyYWN0Jyk7XG4gICAgfVxuXG5cbiAgY3JlYXRlQ2xhc3MoS2V5ZWRDb2xsZWN0aW9uLCBDb2xsZWN0aW9uKTtmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24oKSB7fVxuXG4gIGNyZWF0ZUNsYXNzKEluZGV4ZWRDb2xsZWN0aW9uLCBDb2xsZWN0aW9uKTtmdW5jdGlvbiBJbmRleGVkQ29sbGVjdGlvbigpIHt9XG5cbiAgY3JlYXRlQ2xhc3MoU2V0Q29sbGVjdGlvbiwgQ29sbGVjdGlvbik7ZnVuY3Rpb24gU2V0Q29sbGVjdGlvbigpIHt9XG5cblxuICBDb2xsZWN0aW9uLktleWVkID0gS2V5ZWRDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLkluZGV4ZWQgPSBJbmRleGVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5TZXQgPSBTZXRDb2xsZWN0aW9uO1xuXG4gIHZhciBpbXVsID1cbiAgICB0eXBlb2YgTWF0aC5pbXVsID09PSAnZnVuY3Rpb24nICYmIE1hdGguaW11bCgweGZmZmZmZmZmLCAyKSA9PT0gLTIgP1xuICAgIE1hdGguaW11bCA6XG4gICAgZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICBhID0gYSB8IDA7IC8vIGludFxuICAgICAgYiA9IGIgfCAwOyAvLyBpbnRcbiAgICAgIHZhciBjID0gYSAmIDB4ZmZmZjtcbiAgICAgIHZhciBkID0gYiAmIDB4ZmZmZjtcbiAgICAgIC8vIFNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydC5cbiAgICAgIHJldHVybiAoYyAqIGQpICsgKCgoKGEgPj4+IDE2KSAqIGQgKyBjICogKGIgPj4+IDE2KSkgPDwgMTYpID4+PiAwKSB8IDA7IC8vIGludFxuICAgIH07XG5cbiAgLy8gdjggaGFzIGFuIG9wdGltaXphdGlvbiBmb3Igc3RvcmluZyAzMS1iaXQgc2lnbmVkIG51bWJlcnMuXG4gIC8vIFZhbHVlcyB3aGljaCBoYXZlIGVpdGhlciAwMCBvciAxMSBhcyB0aGUgaGlnaCBvcmRlciBiaXRzIHF1YWxpZnkuXG4gIC8vIFRoaXMgZnVuY3Rpb24gZHJvcHMgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0IGluIGEgc2lnbmVkIG51bWJlciwgbWFpbnRhaW5pbmdcbiAgLy8gdGhlIHNpZ24gYml0LlxuICBmdW5jdGlvbiBzbWkoaTMyKSB7XG4gICAgcmV0dXJuICgoaTMyID4+PiAxKSAmIDB4NDAwMDAwMDApIHwgKGkzMiAmIDB4QkZGRkZGRkYpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaChvKSB7XG4gICAgaWYgKG8gPT09IGZhbHNlIHx8IG8gPT09IG51bGwgfHwgbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG8gPSBvLnZhbHVlT2YoKTtcbiAgICAgIGlmIChvID09PSBmYWxzZSB8fCBvID09PSBudWxsIHx8IG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG8gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKG8gIT09IG8gfHwgbyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgaCA9IG8gfCAwO1xuICAgICAgaWYgKGggIT09IG8pIHtcbiAgICAgICAgaCBePSBvICogMHhGRkZGRkZGRjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvID4gMHhGRkZGRkZGRikge1xuICAgICAgICBvIC89IDB4RkZGRkZGRkY7XG4gICAgICAgIGggXj0gbztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbWkoaCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID4gU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA/IGNhY2hlZEhhc2hTdHJpbmcobykgOiBoYXNoU3RyaW5nKG8pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG8uaGFzaENvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvLmhhc2hDb2RlKCk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGhhc2hKU09iaihvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaGFzaFN0cmluZyhvLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGUgKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBoYXNoID0gc3RyaW5nSGFzaENhY2hlW3N0cmluZ107XG4gICAgaWYgKGhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID09PSBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSkge1xuICAgICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgICB9XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFKys7XG4gICAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2g7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vaGFzaGluZy1zdHJpbmdzXG4gIGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgaGFzaCBmcm9tIEpWTVxuICAgIC8vIFRoZSBoYXNoIGNvZGUgZm9yIGEgc3RyaW5nIGlzIGNvbXB1dGVkIGFzXG4gICAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcbiAgICAvLyB3aGVyZSBzW2ldIGlzIHRoZSBpdGggY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgYW5kIG4gaXMgdGhlIGxlbmd0aCBvZlxuICAgIC8vIHRoZSBzdHJpbmcuIFdlIFwibW9kXCIgdGhlIHJlc3VsdCB0byBtYWtlIGl0IGJldHdlZW4gMCAoaW5jbHVzaXZlKSBhbmQgMl4zMVxuICAgIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGhhc2ggPSAzMSAqIGhhc2ggKyBzdHJpbmcuY2hhckNvZGVBdChpaSkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gc21pKGhhc2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEpTT2JqKG9iaikge1xuICAgIHZhciBoYXNoO1xuICAgIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICAgIGhhc2ggPSB3ZWFrTWFwLmdldChvYmopO1xuICAgICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoID0gb2JqW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgaGFzaCA9IG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXTtcbiAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSBnZXRJRU5vZGVIYXNoKG9iaik7XG4gICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2ggPSArK29iakhhc2hVSUQ7XG4gICAgaWYgKG9iakhhc2hVSUQgJiAweDQwMDAwMDAwKSB7XG4gICAgICBvYmpIYXNoVUlEID0gMDtcbiAgICB9XG5cbiAgICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgICB3ZWFrTWFwLnNldChvYmosIGhhc2gpO1xuICAgIH0gZWxzZSBpZiAoaXNFeHRlbnNpYmxlICE9PSB1bmRlZmluZWQgJiYgaXNFeHRlbnNpYmxlKG9iaikgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leHRlbnNpYmxlIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkIGFzIGtleXMuJyk7XG4gICAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgVUlEX0hBU0hfS0VZLCB7XG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3dyaXRhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGhhc2hcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAob2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSkge1xuICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG9iamVjdFxuICAgICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG4gICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBvYmoucHJvcGVydHlJc0VudW1lcmFibGVbVUlEX0hBU0hfS0VZXSA9IGhhc2g7XG4gICAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjb3VsZG4ndCBnZXQgdGhlIElFIGB1bmlxdWVJRGAgdG8gdXNlIGFzIGEgaGFzaFxuICAgICAgLy8gYW5kIHdlIGNvdWxkbid0IHVzZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHRvIGV4cGxvaXQgdGhlXG4gICAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAgIC8vIGl0c2VsZi5cbiAgICAgIG9ialtVSURfSEFTSF9LRVldID0gaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9XG5cbiAgLy8gR2V0IHJlZmVyZW5jZXMgdG8gRVM1IG9iamVjdCBtZXRob2RzLlxuICB2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuICAvLyBUcnVlIGlmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB3b3JrcyBhcyBleHBlY3RlZC4gSUU4IGZhaWxzIHRoaXMgdGVzdC5cbiAgdmFyIGNhbkRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdAJywge30pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSgpKTtcblxuICAvLyBJRSBoYXMgYSBgdW5pcXVlSURgIHByb3BlcnR5IG9uIERPTSBub2Rlcy4gV2UgY2FuIGNvbnN0cnVjdCB0aGUgaGFzaCBmcm9tIGl0XG4gIC8vIGFuZCBhdm9pZCBtZW1vcnkgbGVha3MgZnJvbSB0aGUgSUUgY2xvbmVOb2RlIGJ1Zy5cbiAgZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA+IDApIHtcbiAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gbm9kZS51bmlxdWVJRDtcbiAgICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBwb3NzaWJsZSwgdXNlIGEgV2Vha01hcC5cbiAgdmFyIHVzaW5nV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xuICB2YXIgd2Vha01hcDtcbiAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgIHdlYWtNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIG9iakhhc2hVSUQgPSAwO1xuXG4gIHZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFVJRF9IQVNIX0tFWSA9IFN5bWJvbChVSURfSEFTSF9LRVkpO1xuICB9XG5cbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcbiAgdmFyIFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFID0gMjU1O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gIHZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxuICBmdW5jdGlvbiBhc3NlcnROb3RJbmZpbml0ZShzaXplKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgc2l6ZSAhPT0gSW5maW5pdHksXG4gICAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBhY3Rpb24gd2l0aCBhbiBpbmZpbml0ZSBzaXplLidcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoTWFwLCBLZXllZENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIE1hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eU1hcCgpIDpcbiAgICAgICAgaXNNYXAodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eU1hcCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obWFwICkge1xuICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gbWFwLnNldChrLCB2KX0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBNYXAub2YgPSBmdW5jdGlvbigpIHt2YXIga2V5VmFsdWVzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICByZXR1cm4gZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKG1hcCApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaSArIDEgPj0ga2V5VmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZhbHVlIGZvciBrZXk6ICcgKyBrZXlWYWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuc2V0KGtleVZhbHVlc1tpXSwga2V5VmFsdWVzW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdNYXAgeycsICd9Jyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdCA/XG4gICAgICAgIHRoaXMuX3Jvb3QuZ2V0KDAsIHVuZGVmaW5lZCwgaywgbm90U2V0VmFsdWUpIDpcbiAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuc2V0SW4gPSBmdW5jdGlvbihrZXlQYXRoLCB2KSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihrZXlQYXRoLCBOT1RfU0VULCBmdW5jdGlvbigpICB7cmV0dXJuIHZ9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZUluID0gZnVuY3Rpb24oa2V5UGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW4oa2V5UGF0aCwgZnVuY3Rpb24oKSAge3JldHVybiBOT1RfU0VUfSk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cbiAgICAgICAgayh0aGlzKSA6XG4gICAgICAgIHRoaXMudXBkYXRlSW4oW2tdLCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUudXBkYXRlSW4gPSBmdW5jdGlvbihrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgICAgaWYgKCF1cGRhdGVyKSB7XG4gICAgICAgIHVwZGF0ZXIgPSBub3RTZXRWYWx1ZTtcbiAgICAgICAgbm90U2V0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlZFZhbHVlID0gdXBkYXRlSW5EZWVwTWFwKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmb3JjZUl0ZXJhdG9yKGtleVBhdGgpLFxuICAgICAgICBub3RTZXRWYWx1ZSxcbiAgICAgICAgdXBkYXRlclxuICAgICAgKTtcbiAgICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyB1bmRlZmluZWQgOiB1cGRhdGVkVmFsdWU7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigvKi4uLml0ZXJzKi8pIHtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZVdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIG1lcmdlciwgaXRlcnMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlSW4gPSBmdW5jdGlvbihrZXlQYXRoKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVJbihcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgZW1wdHlNYXAoKSxcbiAgICAgICAgZnVuY3Rpb24obSApIHtyZXR1cm4gdHlwZW9mIG0ubWVyZ2UgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG0ubWVyZ2UuYXBwbHkobSwgaXRlcnMpIDpcbiAgICAgICAgICBpdGVyc1tpdGVycy5sZW5ndGggLSAxXX1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUubWVyZ2VEZWVwID0gZnVuY3Rpb24oLyouLi5pdGVycyovKSB7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlciksIGl0ZXJzKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5tZXJnZURlZXBJbiA9IGZ1bmN0aW9uKGtleVBhdGgpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUluKFxuICAgICAgICBrZXlQYXRoLFxuICAgICAgICBlbXB0eU1hcCgpLFxuICAgICAgICBmdW5jdGlvbihtICkge3JldHVybiB0eXBlb2YgbS5tZXJnZURlZXAgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG0ubWVyZ2VEZWVwLmFwcGx5KG0sIGl0ZXJzKSA6XG4gICAgICAgICAgaXRlcnNbaXRlcnMubGVuZ3RoIC0gMV19XG4gICAgICApO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgTWFwLnByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhciBtdXRhYmxlID0gdGhpcy5hc011dGFibGUoKTtcbiAgICAgIGZuKG11dGFibGUpO1xuICAgICAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuYXNNdXRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmFzSW1tdXRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2Vuc3VyZU93bmVyKCk7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QuaXRlcmF0ZShmdW5jdGlvbihlbnRyeSApIHtcbiAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDApO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU1hcCh0aGlzLnNpemUsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNNYXAobWF5YmVNYXApIHtcbiAgICByZXR1cm4gISEobWF5YmVNYXAgJiYgbWF5YmVNYXBbSVNfTUFQX1NFTlRJTkVMXSk7XG4gIH1cblxuICBNYXAuaXNNYXAgPSBpc01hcDtcblxuICB2YXIgSVNfTUFQX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfTUFQX19AQCc7XG5cbiAgdmFyIE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG4gIE1hcFByb3RvdHlwZVtJU19NQVBfU0VOVElORUxdID0gdHJ1ZTtcbiAgTWFwUHJvdG90eXBlW0RFTEVURV0gPSBNYXBQcm90b3R5cGUucmVtb3ZlO1xuICBNYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW47XG5cblxuICAvLyAjcHJhZ21hIFRyaWUgTm9kZXNcblxuXG5cbiAgICBmdW5jdGlvbiBBcnJheU1hcE5vZGUob3duZXJJRCwgZW50cmllcykge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgfVxuXG4gICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgICByZXR1cm4gZW50cmllc1tpaV1bMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICBmb3IgKHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcblxuICAgICAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgaWR4ID09PSBsZW4gLSAxID8gbmV3RW50cmllcy5wb3AoKSA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdFbnRyaWVzW2lkeF0gPSBba2V5LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VudHJpZXMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXdFbnRyaWVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3RW50cmllcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBiaXQgPSAoMSA8PCAoKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0spKTtcbiAgICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICAgIHJldHVybiAoYml0bWFwICYgYml0KSA9PT0gMCA/IG5vdFNldFZhbHVlIDpcbiAgICAgICAgdGhpcy5ub2Rlc1twb3BDb3VudChiaXRtYXAgJiAoYml0IC0gMSkpXS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSk7XG4gICAgfTtcblxuICAgIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlIYXNoRnJhZyA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgICAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG4gICAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgICB2YXIgZXhpc3RzID0gKGJpdG1hcCAmIGJpdCkgIT09IDA7XG5cbiAgICAgIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgICB2YXIgbm9kZSA9IGV4aXN0cyA/IG5vZGVzW2lkeF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuXG4gICAgICBpZiAobmV3Tm9kZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGtleUhhc2hGcmFnLCBuZXdOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4aXN0cyAmJiAhbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPT09IDIgJiYgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgICB2YXIgbmV3Qml0bWFwID0gZXhpc3RzID8gbmV3Tm9kZSA/IGJpdG1hcCA6IGJpdG1hcCBeIGJpdCA6IGJpdG1hcCB8IGJpdDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IGV4aXN0cyA/IG5ld05vZGUgP1xuICAgICAgICBzZXRJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKSA6XG4gICAgICAgIHNwbGljZU91dChub2RlcywgaWR4LCBpc0VkaXRhYmxlKSA6XG4gICAgICAgIHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmJpdG1hcCA9IG5ld0JpdG1hcDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgZnVuY3Rpb24gSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCwgbm9kZXMpIHtcbiAgICAgIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgfVxuXG4gICAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICAgICAgcmV0dXJuIG5vZGUgPyBub2RlLmdldChzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuXG4gICAgICBpZiAocmVtb3ZlZCAmJiAhbm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIG5ld0NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgICAgIG5ld0NvdW50LS07XG4gICAgICAgIGlmIChuZXdDb3VudCA8IE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IHNldEluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBuZXdDb3VudCwgbmV3Tm9kZXMpO1xuICAgIH07XG5cblxuXG5cbiAgICBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgfVxuXG4gICAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICAgIGlmIChrZXlIYXNoICE9PSB0aGlzLmtleUhhc2gpIHtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgZm9yICh2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gICAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICAgIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIGVudHJpZXNbaWR4IF4gMV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgICAgdmFyIG5ld0VudHJpZXMgPSBpc0VkaXRhYmxlID8gZW50cmllcyA6IGFyckNvcHkoZW50cmllcyk7XG5cbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICBpZHggPT09IGxlbiAtIDEgPyBuZXdFbnRyaWVzLnBvcCgpIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VudHJpZXNbaWR4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllcy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgbmV3RW50cmllcyk7XG4gICAgfTtcblxuXG5cblxuICAgIGZ1bmN0aW9uIFZhbHVlTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyeSkge1xuICAgICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgICB0aGlzLmVudHJ5ID0gZW50cnk7XG4gICAgfVxuXG4gICAgVmFsdWVOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFZhbHVlTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgICAgdmFyIGtleU1hdGNoID0gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKTtcbiAgICAgIGlmIChrZXlNYXRjaCA/IHZhbHVlID09PSB0aGlzLmVudHJ5WzFdIDogcmVtb3ZlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5TWF0Y2gpIHtcbiAgICAgICAgaWYgKG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEKSB7XG4gICAgICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICB9O1xuXG5cblxuICAvLyAjcHJhZ21hIEl0ZXJhdG9yc1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID1cbiAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5pdGVyYXRlKGZuLCByZXZlcnNlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFZhbHVlTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBmbih0aGlzLmVudHJ5KTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1hcEl0ZXJhdG9yLCBJdGVyYXRvcik7XG5cbiAgICBmdW5jdGlvbiBNYXBJdGVyYXRvcihtYXAsIHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgICB0aGlzLl9zdGFjayA9IG1hcC5fcm9vdCAmJiBtYXBJdGVyYXRvckZyYW1lKG1hcC5fcm9vdCk7XG4gICAgfVxuXG4gICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgICAgd2hpbGUgKHN0YWNrKSB7XG4gICAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2suaW5kZXgrKztcbiAgICAgICAgdmFyIG1heEluZGV4O1xuICAgICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cmllcykge1xuICAgICAgICAgIG1heEluZGV4ID0gbm9kZS5lbnRyaWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJpZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJOb2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IG1hcEl0ZXJhdG9yRnJhbWUoc3ViTm9kZSwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnkpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBpbmRleDogMCxcbiAgICAgIF9fcHJldjogcHJldlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTWFwKHNpemUsIHJvb3QsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShNYXBQcm90b3R5cGUpO1xuICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICBtYXAuX3Jvb3QgPSByb290O1xuICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuICAgIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX01BUDtcbiAgZnVuY3Rpb24gZW1wdHlNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX01BUCB8fCAoRU1QVFlfTUFQID0gbWFrZU1hcCgwKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNYXAobWFwLCBrLCB2KSB7XG4gICAgdmFyIG5ld1Jvb3Q7XG4gICAgdmFyIG5ld1NpemU7XG4gICAgaWYgKCFtYXAuX3Jvb3QpIHtcbiAgICAgIGlmICh2ID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9XG4gICAgICBuZXdTaXplID0gMTtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgQXJyYXlNYXBOb2RlKG1hcC5fX293bmVySUQsIFtbaywgdl1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpZENoYW5nZVNpemUgPSBNYWtlUmVmKENIQU5HRV9MRU5HVEgpO1xuICAgICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZihESURfQUxURVIpO1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUobWFwLl9yb290LCBtYXAuX19vd25lcklELCAwLCB1bmRlZmluZWQsIGssIHYsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKTtcbiAgICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSBtYXAuc2l6ZSArIChkaWRDaGFuZ2VTaXplLnZhbHVlID8gdiA9PT0gTk9UX1NFVCA/IC0xIDogMSA6IDApO1xuICAgIH1cbiAgICBpZiAobWFwLl9fb3duZXJJRCkge1xuICAgICAgbWFwLnNpemUgPSBuZXdTaXplO1xuICAgICAgbWFwLl9yb290ID0gbmV3Um9vdDtcbiAgICAgIG1hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBtYXAuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHJldHVybiBuZXdSb290ID8gbWFrZU1hcChuZXdTaXplLCBuZXdSb290KSA6IGVtcHR5TWFwKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnVwZGF0ZShvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMZWFmTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgaWYgKG5vZGUua2V5SGFzaCA9PT0ga2V5SGFzaCkge1xuICAgICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBbbm9kZS5lbnRyeSwgZW50cnldKTtcbiAgICB9XG5cbiAgICB2YXIgaWR4MSA9IChzaGlmdCA9PT0gMCA/IG5vZGUua2V5SGFzaCA6IG5vZGUua2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgaWR4MiA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuXG4gICAgdmFyIG5ld05vZGU7XG4gICAgdmFyIG5vZGVzID0gaWR4MSA9PT0gaWR4MiA/XG4gICAgICBbbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBrZXlIYXNoLCBlbnRyeSldIDpcbiAgICAgICgobmV3Tm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpKSwgaWR4MSA8IGlkeDIgPyBbbm9kZSwgbmV3Tm9kZV0gOiBbbmV3Tm9kZSwgbm9kZV0pO1xuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBvd25lcklEID0gbmV3IE93bmVySUQoKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZW50cmllcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaWldO1xuICAgICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIGNvdW50LCBleGNsdWRpbmcpIHtcbiAgICB2YXIgYml0bWFwID0gMDtcbiAgICB2YXIgcGFja2VkSUkgPSAwO1xuICAgIHZhciBwYWNrZWROb2RlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBiaXQgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrLCBiaXQgPDw9IDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGluY2x1ZGluZywgbm9kZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGV4cGFuZGVkTm9kZXMgPSBuZXcgQXJyYXkoU0laRSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBiaXRtYXAgIT09IDA7IGlpKyssIGJpdG1hcCA+Pj49IDEpIHtcbiAgICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTWFwV2l0aChtYXAsIG1lcmdlciwgaXRlcmFibGVzKSB7XG4gICAgdmFyIGl0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJhYmxlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgICB2YXIgaXRlciA9IEtleWVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgaWYgKCFpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICBpdGVyID0gaXRlci5tYXAoZnVuY3Rpb24odiApIHtyZXR1cm4gZnJvbUpTKHYpfSk7XG4gICAgICB9XG4gICAgICBpdGVycy5wdXNoKGl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgobWFwLCBtZXJnZXIsIGl0ZXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwICYmIGlzSXRlcmFibGUodmFsdWUpID9cbiAgICAgIGV4aXN0aW5nLm1lcmdlRGVlcCh2YWx1ZSkgOlxuICAgICAgaXMoZXhpc3RpbmcsIHZhbHVlKSA/IGV4aXN0aW5nIDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXhpc3RpbmcsIHZhbHVlLCBrZXkpICB7XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcubWVyZ2VEZWVwV2l0aCAmJiBpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmcubWVyZ2VEZWVwV2l0aChtZXJnZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0VmFsdWUgPSBtZXJnZXIoZXhpc3RpbmcsIHZhbHVlLCBrZXkpO1xuICAgICAgcmV0dXJuIGlzKGV4aXN0aW5nLCBuZXh0VmFsdWUpID8gZXhpc3RpbmcgOiBuZXh0VmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKGNvbGxlY3Rpb24sIG1lcmdlciwgaXRlcnMpIHtcbiAgICBpdGVycyA9IGl0ZXJzLmZpbHRlcihmdW5jdGlvbih4ICkge3JldHVybiB4LnNpemUgIT09IDB9KTtcbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24uc2l6ZSA9PT0gMCAmJiAhY29sbGVjdGlvbi5fX293bmVySUQgJiYgaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oY29sbGVjdGlvbiApIHtcbiAgICAgIHZhciBtZXJnZUludG9NYXAgPSBtZXJnZXIgP1xuICAgICAgICBmdW5jdGlvbih2YWx1ZSwga2V5KSAge1xuICAgICAgICAgIGNvbGxlY3Rpb24udXBkYXRlKGtleSwgTk9UX1NFVCwgZnVuY3Rpb24oZXhpc3RpbmcgKVxuICAgICAgICAgICAge3JldHVybiBleGlzdGluZyA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSwga2V5KX1cbiAgICAgICAgICApO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24odmFsdWUsIGtleSkgIHtcbiAgICAgICAgICBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBpdGVyc1tpaV0uZm9yRWFjaChtZXJnZUludG9NYXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5EZWVwTWFwKGV4aXN0aW5nLCBrZXlQYXRoSXRlciwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICB2YXIgaXNOb3RTZXQgPSBleGlzdGluZyA9PT0gTk9UX1NFVDtcbiAgICB2YXIgc3RlcCA9IGtleVBhdGhJdGVyLm5leHQoKTtcbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGlzTm90U2V0ID8gbm90U2V0VmFsdWUgOiBleGlzdGluZztcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHVwZGF0ZXIoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBpc05vdFNldCB8fCAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc2V0KSxcbiAgICAgICdpbnZhbGlkIGtleVBhdGgnXG4gICAgKTtcbiAgICB2YXIga2V5ID0gc3RlcC52YWx1ZTtcbiAgICB2YXIgbmV4dEV4aXN0aW5nID0gaXNOb3RTZXQgPyBOT1RfU0VUIDogZXhpc3RpbmcuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwTWFwKFxuICAgICAgbmV4dEV4aXN0aW5nLFxuICAgICAga2V5UGF0aEl0ZXIsXG4gICAgICBub3RTZXRWYWx1ZSxcbiAgICAgIHVwZGF0ZXJcbiAgICApO1xuICAgIHJldHVybiBuZXh0VXBkYXRlZCA9PT0gbmV4dEV4aXN0aW5nID8gZXhpc3RpbmcgOlxuICAgICAgbmV4dFVwZGF0ZWQgPT09IE5PVF9TRVQgPyBleGlzdGluZy5yZW1vdmUoa2V5KSA6XG4gICAgICAoaXNOb3RTZXQgPyBlbXB0eU1hcCgpIDogZXhpc3RpbmcpLnNldChrZXksIG5leHRVcGRhdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcENvdW50KHgpIHtcbiAgICB4ID0geCAtICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICAgIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKCh4ID4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICB4ID0geCArICh4ID4+IDgpO1xuICAgIHggPSB4ICsgKHggPj4gMTYpO1xuICAgIHJldHVybiB4ICYgMHg3ZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdBcnJheSA9IGNhbkVkaXQgPyBhcnJheSA6IGFyckNvcHkoYXJyYXkpO1xuICAgIG5ld0FycmF5W2lkeF0gPSB2YWw7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaWNlSW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCArIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ICsgMSA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheVtpZHhdID0gdmFsO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IHZhbDtcbiAgICAgICAgYWZ0ZXIgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VPdXQoYXJyYXksIGlkeCwgY2FuRWRpdCkge1xuICAgIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG4gICAgICBhcnJheS5wb3AoKTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgdmFyIGFmdGVyID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgICBhZnRlciA9IDE7XG4gICAgICB9XG4gICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgdmFyIE1BWF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuICB2YXIgTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUgPSBTSVpFIC8gMjtcbiAgdmFyIE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG5cbiAgY3JlYXRlQ2xhc3MoTGlzdCwgSW5kZXhlZENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIExpc3QodmFsdWUpIHtcbiAgICAgIHZhciBlbXB0eSA9IGVtcHR5TGlzdCgpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgICAgfVxuICAgICAgaWYgKGlzTGlzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXIgPSBJbmRleGVkSXRlcmFibGUodmFsdWUpO1xuICAgICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShzaXplKTtcbiAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgU0laRSkge1xuICAgICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgbGlzdC5zZXRTaXplKHNpemUpO1xuICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24odiwgaSkgIHtyZXR1cm4gbGlzdC5zZXQoaSwgdil9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIExpc3Qub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnTGlzdCBbJywgJ10nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuICAgICAgICB2YXIgbm9kZSA9IGxpc3ROb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5hcnJheVtpbmRleCAmIE1BU0tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlzdCh0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhcyhpbmRleCkgPyB0aGlzIDpcbiAgICAgICAgaW5kZXggPT09IDAgPyB0aGlzLnNoaWZ0KCkgOlxuICAgICAgICBpbmRleCA9PT0gdGhpcy5zaXplIC0gMSA/IHRoaXMucG9wKCkgOlxuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX29yaWdpbiA9IHRoaXMuX2NhcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBTSElGVDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBvbGRTaXplICsgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQob2xkU2l6ZSArIGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgLTEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24obGlzdCApIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQoaWksIHZhbHVlc1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDEpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBMaXN0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gbWVyZ2VJbnRvTGlzdFdpdGgodGhpcywgbWVyZ2VyLCBpdGVycyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlRGVlcCA9IGZ1bmN0aW9uKC8qLi4uaXRlcnMqLykge1xuICAgICAgcmV0dXJuIG1lcmdlSW50b0xpc3RXaXRoKHRoaXMsIGRlZXBNZXJnZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBmdW5jdGlvbihtZXJnZXIpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9MaXN0V2l0aCh0aGlzLCBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpLCBpdGVycyk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAwLCBzaXplKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpLFxuICAgICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICAgICk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IERPTkUgP1xuICAgICAgICAgIGl0ZXJhdG9yRG9uZSgpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGluZGV4KyssIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHdoaWxlICgodmFsdWUgPSB2YWx1ZXMoKSkgIT09IERPTkUpIHtcbiAgICAgICAgaWYgKGZuKHZhbHVlLCBpbmRleCsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZUxpc3QodGhpcy5fb3JpZ2luLCB0aGlzLl9jYXBhY2l0eSwgdGhpcy5fbGV2ZWwsIHRoaXMuX3Jvb3QsIHRoaXMuX3RhaWwsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuICAgIHJldHVybiAhIShtYXliZUxpc3QgJiYgbWF5YmVMaXN0W0lTX0xJU1RfU0VOVElORUxdKTtcbiAgfVxuXG4gIExpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG4gIHZhciBJU19MSVNUX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfTElTVF9fQEAnO1xuXG4gIHZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG4gIExpc3RQcm90b3R5cGVbSVNfTElTVF9TRU5USU5FTF0gPSB0cnVlO1xuICBMaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbiAgTGlzdFByb3RvdHlwZS5zZXRJbiA9IE1hcFByb3RvdHlwZS5zZXRJbjtcbiAgTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9XG4gIExpc3RQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUucmVtb3ZlSW47XG4gIExpc3RQcm90b3R5cGUudXBkYXRlID0gTWFwUHJvdG90eXBlLnVwZGF0ZTtcbiAgTGlzdFByb3RvdHlwZS51cGRhdGVJbiA9IE1hcFByb3RvdHlwZS51cGRhdGVJbjtcbiAgTGlzdFByb3RvdHlwZS5tZXJnZUluID0gTWFwUHJvdG90eXBlLm1lcmdlSW47XG4gIExpc3RQcm90b3R5cGUubWVyZ2VEZWVwSW4gPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwSW47XG4gIExpc3RQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuICBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIExpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG4gIExpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xuXG5cblxuICAgIGZ1bmN0aW9uIFZOb2RlKGFycmF5LCBvd25lcklEKSB7XG4gICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHNlZW1zIGxpa2UgdGhlc2UgbWV0aG9kcyBhcmUgdmVyeSBzaW1pbGFyXG5cbiAgICBWTm9kZS5wcm90b3R5cGUucmVtb3ZlQmVmb3JlID0gZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6IDAgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb3JpZ2luSW5kZXggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBpZiAob3JpZ2luSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICAgICAgdmFyIG5ld0NoaWxkO1xuICAgICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgICBpZiAobmV3Q2hpbGQgPT09IG9sZENoaWxkICYmIHJlbW92aW5nRmlyc3QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbW92aW5nRmlyc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICAgIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgb3JpZ2luSW5kZXg7IGlpKyspIHtcbiAgICAgICAgICBlZGl0YWJsZS5hcnJheVtpaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0YWJsZTtcbiAgICB9O1xuXG4gICAgVk5vZGUucHJvdG90eXBlLnJlbW92ZUFmdGVyID0gZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IChsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwKSB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzaXplSW5kZXggPSAoKGluZGV4IC0gMSkgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICAgICAgbmV3Q2hpbGQgPSBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVBZnRlcihvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgc2l6ZUluZGV4ID09PSB0aGlzLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICAgICAgZWRpdGFibGUuYXJyYXkuc3BsaWNlKHNpemVJbmRleCArIDEpO1xuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIGVkaXRhYmxlLmFycmF5W3NpemVJbmRleF0gPSBuZXdDaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0YWJsZTtcbiAgICB9O1xuXG5cblxuICB2YXIgRE9ORSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVMaXN0KGxpc3QsIHJldmVyc2UpIHtcbiAgICB2YXIgbGVmdCA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgcmlnaHQgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgdGFpbFBvcyA9IGdldFRhaWxPZmZzZXQocmlnaHQpO1xuICAgIHZhciB0YWlsID0gbGlzdC5fdGFpbDtcblxuICAgIHJldHVybiBpdGVyYXRlTm9kZU9yTGVhZihsaXN0Ll9yb290LCBsaXN0Ll9sZXZlbCwgMCk7XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZU9yTGVhZihub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGV2ZWwgPT09IDAgP1xuICAgICAgICBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIDpcbiAgICAgICAgaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxlYWYobm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgYXJyYXkgPSBvZmZzZXQgPT09IHRhaWxQb3MgPyB0YWlsICYmIHRhaWwuYXJyYXkgOiBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogbGVmdCAtIG9mZnNldDtcbiAgICAgIHZhciB0byA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgICB0byA9IFNJWkU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICByZXR1cm4gRE9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheVtpZHhdO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgICB2YXIgdmFsdWVzO1xuICAgICAgdmFyIGFycmF5ID0gbm9kZSAmJiBub2RlLmFycmF5O1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IChsZWZ0IC0gb2Zmc2V0KSA+PiBsZXZlbDtcbiAgICAgIHZhciB0byA9ICgocmlnaHQgLSBvZmZzZXQpID4+IGxldmVsKSArIDE7XG4gICAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICAgIHRvID0gU0laRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpICB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gRE9ORSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgICAgdmFsdWVzID0gaXRlcmF0ZU5vZGVPckxlYWYoXG4gICAgICAgICAgICBhcnJheSAmJiBhcnJheVtpZHhdLCBsZXZlbCAtIFNISUZULCBvZmZzZXQgKyAoaWR4IDw8IGxldmVsKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTGlzdChvcmlnaW4sIGNhcGFjaXR5LCBsZXZlbCwgcm9vdCwgdGFpbCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBsaXN0ID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlKTtcbiAgICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcbiAgICBsaXN0Ll9vcmlnaW4gPSBvcmlnaW47XG4gICAgbGlzdC5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuICAgIGxpc3QuX3Jvb3QgPSByb290O1xuICAgIGxpc3QuX3RhaWwgPSB0YWlsO1xuICAgIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBsaXN0Ll9faGFzaCA9IGhhc2g7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHZhciBFTVBUWV9MSVNUO1xuICBmdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG4gICAgcmV0dXJuIEVNUFRZX0xJU1QgfHwgKEVNUFRZX0xJU1QgPSBtYWtlTGlzdCgwLCAwLCBTSElGVCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleChsaXN0LCBpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPj0gbGlzdC5zaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbihsaXN0ICkge1xuICAgICAgICBpbmRleCA8IDAgP1xuICAgICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgaW5kZXgpLnNldCgwLCB2YWx1ZSkgOlxuICAgICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG4gICAgdmFyIG5ld1RhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcbiAgICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKERJRF9BTFRFUik7XG4gICAgaWYgKGluZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgbGlzdC5fX293bmVySUQsIDAsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdSb290ID0gdXBkYXRlVk5vZGUobmV3Um9vdCwgbGlzdC5fX293bmVySUQsIGxpc3QuX2xldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIWRpZEFsdGVyLnZhbHVlKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5fX293bmVySUQpIHtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobGlzdC5fb3JpZ2luLCBsaXN0Ll9jYXBhY2l0eSwgbGlzdC5fbGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVk5vZGUobm9kZSwgb3duZXJJRCwgbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIHZhciBub2RlSGFzID0gbm9kZSAmJiBpZHggPCBub2RlLmFycmF5Lmxlbmd0aDtcbiAgICBpZiAoIW5vZGVIYXMgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgdmFyIG5ld05vZGU7XG5cbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgICB2YXIgbmV3TG93ZXJOb2RlID0gdXBkYXRlVk5vZGUobG93ZXJOb2RlLCBvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICAgIGlmIChuZXdMb3dlck5vZGUgPT09IGxvd2VyTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVIYXMgJiYgbm9kZS5hcnJheVtpZHhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGlkeCA9PT0gbmV3Tm9kZS5hcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICBuZXdOb2RlLmFycmF5LnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCAmJiBub2RlICYmIG93bmVySUQgPT09IG5vZGUub3duZXJJRCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZSA/IG5vZGUuYXJyYXkuc2xpY2UoKSA6IFtdLCBvd25lcklEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3ROb2RlRm9yKGxpc3QsIHJhd0luZGV4KSB7XG4gICAgaWYgKHJhd0luZGV4ID49IGdldFRhaWxPZmZzZXQobGlzdC5fY2FwYWNpdHkpKSB7XG4gICAgICByZXR1cm4gbGlzdC5fdGFpbDtcbiAgICB9XG4gICAgaWYgKHJhd0luZGV4IDwgMSA8PCAobGlzdC5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIHZhciBub2RlID0gbGlzdC5fcm9vdDtcbiAgICAgIHZhciBsZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgICAgd2hpbGUgKG5vZGUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5WyhyYXdJbmRleCA+Pj4gbGV2ZWwpICYgTUFTS107XG4gICAgICAgIGxldmVsIC09IFNISUZUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGlzdEJvdW5kcyhsaXN0LCBiZWdpbiwgZW5kKSB7XG4gICAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgICBpZiAoYmVnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmVnaW4gPSBiZWdpbiB8IDA7XG4gICAgfVxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gZW5kIHwgMDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gbGlzdC5fX293bmVySUQgfHwgbmV3IE93bmVySUQoKTtcbiAgICB2YXIgb2xkT3JpZ2luID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgICB2YXIgbmV3Q2FwYWNpdHkgPSBlbmQgPT09IHVuZGVmaW5lZCA/IG9sZENhcGFjaXR5IDogZW5kIDwgMCA/IG9sZENhcGFjaXR5ICsgZW5kIDogb2xkT3JpZ2luICsgZW5kO1xuICAgIGlmIChuZXdPcmlnaW4gPT09IG9sZE9yaWdpbiAmJiBuZXdDYXBhY2l0eSA9PT0gb2xkQ2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgZ29pbmcgdG8gZW5kIGFmdGVyIGl0IHN0YXJ0cywgaXQncyBlbXB0eS5cbiAgICBpZiAobmV3T3JpZ2luID49IG5ld0NhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gbGlzdC5jbGVhcigpO1xuICAgIH1cblxuICAgIHZhciBuZXdMZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgIHZhciBuZXdSb290ID0gbGlzdC5fcm9vdDtcblxuICAgIC8vIE5ldyBvcmlnaW4gbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHZhciBvZmZzZXRTaGlmdCA9IDA7XG4gICAgd2hpbGUgKG5ld09yaWdpbiArIG9mZnNldFNoaWZ0IDwgMCkge1xuICAgICAgbmV3Um9vdCA9IG5ldyBWTm9kZShuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW3VuZGVmaW5lZCwgbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgICBvZmZzZXRTaGlmdCArPSAxIDw8IG5ld0xldmVsO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICAgIG5ld09yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG9sZE9yaWdpbiArPSBvZmZzZXRTaGlmdDtcbiAgICAgIG5ld0NhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkQ2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuXG4gICAgdmFyIG9sZFRhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG9sZENhcGFjaXR5KTtcbiAgICB2YXIgbmV3VGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQobmV3Q2FwYWNpdHkpO1xuXG4gICAgLy8gTmV3IHNpemUgbWlnaHQgbmVlZCBjcmVhdGluZyBhIGhpZ2hlciByb290LlxuICAgIHdoaWxlIChuZXdUYWlsT2Zmc2V0ID49IDEgPDwgKG5ld0xldmVsICsgU0hJRlQpKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuICAgICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgfVxuXG4gICAgLy8gTG9jYXRlIG9yIGNyZWF0ZSB0aGUgbmV3IHRhaWwuXG4gICAgdmFyIG9sZFRhaWwgPSBsaXN0Ll90YWlsO1xuICAgIHZhciBuZXdUYWlsID0gbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQgP1xuICAgICAgbGlzdE5vZGVGb3IobGlzdCwgbmV3Q2FwYWNpdHkgLSAxKSA6XG4gICAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCA/IG5ldyBWTm9kZShbXSwgb3duZXIpIDogb2xkVGFpbDtcblxuICAgIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICAgIGlmIChvbGRUYWlsICYmIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmIG5ld09yaWdpbiA8IG9sZENhcGFjaXR5ICYmIG9sZFRhaWwuYXJyYXkubGVuZ3RoKSB7XG4gICAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgICB2YXIgbm9kZSA9IG5ld1Jvb3Q7XG4gICAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5W2lkeF0gPSBlZGl0YWJsZVZOb2RlKG5vZGUuYXJyYXlbaWR4XSwgb3duZXIpO1xuICAgICAgfVxuICAgICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaXplIGhhcyBiZWVuIHJlZHVjZWQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHRhaWwgbmVlZHMgdG8gYmUgdHJpbW1lZC5cbiAgICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVBZnRlcihvd25lciwgMCwgbmV3Q2FwYWNpdHkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdMZXZlbCA9IFNISUZUO1xuICAgICAgbmV3Um9vdCA9IG51bGw7XG4gICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICAgIH0gZWxzZSBpZiAobmV3T3JpZ2luID4gb2xkT3JpZ2luIHx8IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXRTaGlmdCA9IDA7XG5cbiAgICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgICB3aGlsZSAobmV3Um9vdCkge1xuICAgICAgICB2YXIgYmVnaW5JbmRleCA9IChuZXdPcmlnaW4gPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICAgIGlmIChiZWdpbkluZGV4ICE9PSAobmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgICAgb2Zmc2V0U2hpZnQgKz0gKDEgPDwgbmV3TGV2ZWwpICogYmVnaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QuYXJyYXlbYmVnaW5JbmRleF07XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdPcmlnaW4gPiBvbGRPcmlnaW4pIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld1Jvb3QgJiYgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QucmVtb3ZlQWZ0ZXIob3duZXIsIG5ld0xldmVsLCBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnQpO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFNoaWZ0KSB7XG4gICAgICAgIG5ld09yaWdpbiAtPSBvZmZzZXRTaGlmdDtcbiAgICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0LnNpemUgPSBuZXdDYXBhY2l0eSAtIG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgICBsaXN0Ll9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICAgIGxpc3QuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBtYWtlTGlzdChuZXdPcmlnaW4sIG5ld0NhcGFjaXR5LCBuZXdMZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUludG9MaXN0V2l0aChsaXN0LCBtZXJnZXIsIGl0ZXJhYmxlcykge1xuICAgIHZhciBpdGVycyA9IFtdO1xuICAgIHZhciBtYXhTaXplID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcmFibGVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVzW2lpXTtcbiAgICAgIHZhciBpdGVyID0gSW5kZXhlZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgIGlmIChpdGVyLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIG1heFNpemUgPSBpdGVyLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgIGl0ZXIgPSBpdGVyLm1hcChmdW5jdGlvbih2ICkge3JldHVybiBmcm9tSlModil9KTtcbiAgICAgIH1cbiAgICAgIGl0ZXJzLnB1c2goaXRlcik7XG4gICAgfVxuICAgIGlmIChtYXhTaXplID4gbGlzdC5zaXplKSB7XG4gICAgICBsaXN0ID0gbGlzdC5zZXRTaXplKG1heFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbnRvQ29sbGVjdGlvbldpdGgobGlzdCwgbWVyZ2VyLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYWlsT2Zmc2V0KHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKCgoc2l6ZSAtIDEpID4+PiBTSElGVCkgPDwgU0hJRlQpO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoT3JkZXJlZE1hcCwgTWFwKTtcblxuICAgIC8vIEBwcmFnbWEgQ29uc3RydWN0aW9uXG5cbiAgICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5T3JkZXJlZE1hcCgpIDpcbiAgICAgICAgaXNPcmRlcmVkTWFwKHZhbHVlKSA/IHZhbHVlIDpcbiAgICAgICAgZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbihtYXAgKSB7XG4gICAgICAgICAgdmFyIGl0ZXIgPSBLZXllZEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2LCBrKSAge3JldHVybiBtYXAuc2V0KGssIHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9tYXAuZ2V0KGspO1xuICAgICAgcmV0dXJuIGluZGV4ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9saXN0LmdldChpbmRleClbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrLCB2KSB7XG4gICAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX2xpc3Qud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbihlbnRyeSApIHtyZXR1cm4gZW50cnkgJiYgZm4oZW50cnlbMV0sIGVudHJ5WzBdLCB0aGlzJDApfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc09yZGVyZWRNYXAobWF5YmVPcmRlcmVkTWFwKSB7XG4gICAgcmV0dXJuIGlzTWFwKG1heWJlT3JkZXJlZE1hcCkgJiYgaXNPcmRlcmVkKG1heWJlT3JkZXJlZE1hcCk7XG4gIH1cblxuICBPcmRlcmVkTWFwLmlzT3JkZXJlZE1hcCA9IGlzT3JkZXJlZE1hcDtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZVtJU19PUkRFUkVEX1NFTlRJTkVMXSA9IHRydWU7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cblxuXG4gIGZ1bmN0aW9uIG1ha2VPcmRlcmVkTWFwKG1hcCwgbGlzdCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gICAgb21hcC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICAgIG9tYXAuX21hcCA9IG1hcDtcbiAgICBvbWFwLl9saXN0ID0gbGlzdDtcbiAgICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgb21hcC5fX2hhc2ggPSBoYXNoO1xuICAgIHJldHVybiBvbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX09SREVSRURfTUFQO1xuICBmdW5jdGlvbiBlbXB0eU9yZGVyZWRNYXAoKSB7XG4gICAgcmV0dXJuIEVNUFRZX09SREVSRURfTUFQIHx8IChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVPcmRlcmVkTWFwKG9tYXAsIGssIHYpIHtcbiAgICB2YXIgbWFwID0gb21hcC5fbWFwO1xuICAgIHZhciBsaXN0ID0gb21hcC5fbGlzdDtcbiAgICB2YXIgaSA9IG1hcC5nZXQoayk7XG4gICAgdmFyIGhhcyA9IGkgIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3TWFwO1xuICAgIHZhciBuZXdMaXN0O1xuICAgIGlmICh2ID09PSBOT1RfU0VUKSB7IC8vIHJlbW92ZWRcbiAgICAgIGlmICghaGFzKSB7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3Quc2l6ZSA+PSBTSVpFICYmIGxpc3Quc2l6ZSA+PSBtYXAuc2l6ZSAqIDIpIHtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKGVudHJ5LCBpZHgpICB7cmV0dXJuIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gaWR4fSk7XG4gICAgICAgIG5ld01hcCA9IG5ld0xpc3QudG9LZXllZFNlcSgpLm1hcChmdW5jdGlvbihlbnRyeSApIHtyZXR1cm4gZW50cnlbMF19KS5mbGlwKCkudG9NYXAoKTtcbiAgICAgICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICAgICAgbmV3TWFwLl9fb3duZXJJRCA9IG5ld0xpc3QuX19vd25lcklEID0gb21hcC5fX293bmVySUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld01hcCA9IG1hcC5yZW1vdmUoayk7XG4gICAgICAgIG5ld0xpc3QgPSBpID09PSBsaXN0LnNpemUgLSAxID8gbGlzdC5wb3AoKSA6IGxpc3Quc2V0KGksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMpIHtcbiAgICAgICAgaWYgKHYgPT09IGxpc3QuZ2V0KGkpWzFdKSB7XG4gICAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TWFwID0gbWFwO1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5zZXQoaSwgW2ssIHZdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld01hcCA9IG1hcC5zZXQoaywgbGlzdC5zaXplKTtcbiAgICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGxpc3Quc2l6ZSwgW2ssIHZdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICBvbWFwLnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIG9tYXAuX21hcCA9IG5ld01hcDtcbiAgICAgIG9tYXAuX2xpc3QgPSBuZXdMaXN0O1xuICAgICAgb21hcC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUb0tleWVkU2VxdWVuY2UsIEtleWVkU2VxKTtcbiAgICBmdW5jdGlvbiBUb0tleWVkU2VxdWVuY2UoaW5kZXhlZCwgdXNlS2V5cykge1xuICAgICAgdGhpcy5faXRlciA9IGluZGV4ZWQ7XG4gICAgICB0aGlzLl91c2VLZXlzID0gdXNlS2V5cztcbiAgICAgIHRoaXMuc2l6ZSA9IGluZGV4ZWQuc2l6ZTtcbiAgICB9XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmdldChrZXksIG5vdFNldFZhbHVlKTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmhhcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci52YWx1ZVNlcSgpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbigpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gdGhpcyQwLl9pdGVyLnRvU2VxKCkucmV2ZXJzZSgpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG1hcHBlciwgY29udGV4dCkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24oKSAge3JldHVybiB0aGlzJDAuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KX07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpaTtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShcbiAgICAgICAgdGhpcy5fdXNlS2V5cyA/XG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHtyZXR1cm4gZm4odiwgaywgdGhpcyQwKX0gOlxuICAgICAgICAgICgoaWkgPSByZXZlcnNlID8gcmVzb2x2ZVNpemUodGhpcykgOiAwKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIHJldmVyc2UgPyAtLWlpIDogaWkrKywgdGhpcyQwKX0pLFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAodGhpcy5fdXNlS2V5cykge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpaSA9IHJldmVyc2UgPyByZXNvbHZlU2l6ZSh0aGlzKSA6IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIHJldmVyc2UgPyAtLWlpIDogaWkrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG5cbiAgY3JlYXRlQ2xhc3MoVG9JbmRleGVkU2VxdWVuY2UsIEluZGV4ZWRTZXEpO1xuICAgIGZ1bmN0aW9uIFRvSW5kZXhlZFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKX0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcClcbiAgICAgIH0pO1xuICAgIH07XG5cblxuXG4gIGNyZWF0ZUNsYXNzKFRvU2V0U2VxdWVuY2UsIFNldFNlcSk7XG4gICAgZnVuY3Rpb24gVG9TZXRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKGtleSk7XG4gICAgfTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiApIHtyZXR1cm4gZm4odiwgdiwgdGhpcyQwKX0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOlxuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgc3RlcC52YWx1ZSwgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cblxuICBjcmVhdGVDbGFzcyhGcm9tRW50cmllc1NlcXVlbmNlLCBLZXllZFNlcSk7XG4gICAgZnVuY3Rpb24gRnJvbUVudHJpZXNTZXF1ZW5jZShlbnRyaWVzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICAgIHRoaXMuc2l6ZSA9IGVudHJpZXMuc2l6ZTtcbiAgICB9XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIudG9TZXEoKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbihlbnRyeSApIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgICAvLyBpbiB0aGUgcGFyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgICAgdmFyIGluZGV4ZWRJdGVyYWJsZSA9IGlzSXRlcmFibGUoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICAgIGluZGV4ZWRJdGVyYWJsZSA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICB0aGlzJDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHZhciBpbmRleGVkSXRlcmFibGUgPSBpc0l0ZXJhYmxlKGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBpbmRleGVkSXRlcmFibGUgPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgICAgaW5kZXhlZEl0ZXJhYmxlID8gZW50cnkuZ2V0KDEpIDogZW50cnlbMV0sXG4gICAgICAgICAgICAgIHN0ZXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIGNhY2hlUmVzdWx0VGhyb3VnaDtcblxuXG4gIGZ1bmN0aW9uIGZsaXBGYWN0b3J5KGl0ZXJhYmxlKSB7XG4gICAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgZmxpcFNlcXVlbmNlLl9pdGVyID0gaXRlcmFibGU7XG4gICAgZmxpcFNlcXVlbmNlLnNpemUgPSBpdGVyYWJsZS5zaXplO1xuICAgIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZX07XG4gICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IGl0ZXJhYmxlLnJldmVyc2UuYXBwbHkodGhpcyk7IC8vIHN1cGVyLnJldmVyc2UoKVxuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZS5yZXZlcnNlKCl9O1xuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5ICkge3JldHVybiBpdGVyYWJsZS5pbmNsdWRlcyhrZXkpfTtcbiAgICBmbGlwU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbihrZXkgKSB7cmV0dXJuIGl0ZXJhYmxlLmhhcyhrZXkpfTtcbiAgICBmbGlwU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKGssIHYsIHRoaXMkMCkgIT09IGZhbHNlfSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmICghc3RlcC5kb25lKSB7XG4gICAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgICBzdGVwLnZhbHVlWzBdID0gc3RlcC52YWx1ZVsxXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMV0gPSBrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRvcihcbiAgICAgICAgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgPyBJVEVSQVRFX0tFWVMgOiBJVEVSQVRFX1ZBTFVFUyxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWFwRmFjdG9yeShpdGVyYWJsZSwgbWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKSB7cmV0dXJuIGl0ZXJhYmxlLmhhcyhrZXkpfTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbihrZXksIG5vdFNldFZhbHVlKSAge1xuICAgICAgdmFyIHYgPSBpdGVyYWJsZS5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIHJldHVybiB2ID09PSBOT1RfU0VUID9cbiAgICAgICAgbm90U2V0VmFsdWUgOlxuICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrZXksIGl0ZXJhYmxlKTtcbiAgICB9O1xuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbih2LCBrLCBjKSAge3JldHVybiBmbihtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjKSwgaywgdGhpcyQwKSAhPT0gZmFsc2V9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH1cbiAgICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBpdGVyYWJsZSksXG4gICAgICAgICAgc3RlcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcmV2ZXJzZUZhY3RvcnkoaXRlcmFibGUsIHVzZUtleXMpIHtcbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5faXRlciA9IGl0ZXJhYmxlO1xuICAgIHJldmVyc2VkU2VxdWVuY2Uuc2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSAge3JldHVybiBpdGVyYWJsZX07XG4gICAgaWYgKGl0ZXJhYmxlLmZsaXApIHtcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGl0ZXJhYmxlKTtcbiAgICAgICAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpICB7cmV0dXJuIGl0ZXJhYmxlLmZsaXAoKX07XG4gICAgICAgIHJldHVybiBmbGlwU2VxdWVuY2U7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXZlcnNlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm90U2V0VmFsdWUpIFxuICAgICAge3JldHVybiBpdGVyYWJsZS5nZXQodXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5LCBub3RTZXRWYWx1ZSl9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24oa2V5IClcbiAgICAgIHtyZXR1cm4gaXRlcmFibGUuaGFzKHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSl9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXRlcmFibGUuaW5jbHVkZXModmFsdWUpfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIGZuKHYsIGssIHRoaXMkMCl9LCAhcmV2ZXJzZSk7XG4gICAgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0b3IgPVxuICAgICAgZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkgIHtyZXR1cm4gaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCAhcmV2ZXJzZSl9O1xuICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBmaWx0ZXJGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGlmICh1c2VLZXlzKSB7XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbihrZXkgKSB7XG4gICAgICAgIHZhciB2ID0gaXRlcmFibGUuZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICAgIHJldHVybiB2ICE9PSBOT1RfU0VUICYmICEhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSk7XG4gICAgICB9O1xuICAgICAgZmlsdGVyU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkgIHtcbiAgICAgICAgdmFyIHYgPSBpdGVyYWJsZS5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBpdGVyYWJsZSkgP1xuICAgICAgICAgIHYgOiBub3RTZXRWYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDApO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgZmlsdGVyU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgaXRlcmFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCB1c2VLZXlzID8ga2V5IDogaXRlcmF0aW9ucysrLCB2YWx1ZSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBjb3VudEJ5RmFjdG9yeShpdGVyYWJsZSwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgICBpdGVyYWJsZS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICAgIGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBpdGVyYWJsZSksXG4gICAgICAgIDAsXG4gICAgICAgIGZ1bmN0aW9uKGEgKSB7cmV0dXJuIGEgKyAxfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXBzLmFzSW1tdXRhYmxlKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGdyb3VwQnlGYWN0b3J5KGl0ZXJhYmxlLCBncm91cGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIGlzS2V5ZWRJdGVyID0gaXNLZXllZChpdGVyYWJsZSk7XG4gICAgdmFyIGdyb3VwcyA9IChpc09yZGVyZWQoaXRlcmFibGUpID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgZ3JvdXBzLnVwZGF0ZShcbiAgICAgICAgZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGl0ZXJhYmxlKSxcbiAgICAgICAgZnVuY3Rpb24oYSApIHtyZXR1cm4gKGEgPSBhIHx8IFtdLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSl9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHZhciBjb2VyY2UgPSBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbihhcnIgKSB7cmV0dXJuIHJlaWZ5KGl0ZXJhYmxlLCBjb2VyY2UoYXJyKSl9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gc2xpY2VGYWN0b3J5KGl0ZXJhYmxlLCBiZWdpbiwgZW5kLCB1c2VLZXlzKSB7XG4gICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGl0ZXJhYmxlLnNpemU7XG5cbiAgICAvLyBTYW5pdGl6ZSBiZWdpbiAmIGVuZCB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICAgIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiZWdpbiA9IGJlZ2luIHwgMDtcbiAgICB9XG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSBJbmZpbml0eSkge1xuICAgICAgICBlbmQgPSBvcmlnaW5hbFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBlbmQgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIG9yaWdpbmFsU2l6ZSkpIHtcbiAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgb3JpZ2luYWxTaXplKTtcbiAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAgIC8vIGJlZ2luIG9yIGVuZCB3aWxsIGJlIE5hTiBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYXMgbmVnYXRpdmUgbnVtYmVycyBhbmRcbiAgICAvLyB0aGlzIGl0ZXJhYmxlJ3Mgc2l6ZSBpcyB1bmtub3duLiBJbiB0aGF0IGNhc2UsIGNhY2hlIGZpcnN0IHNvIHRoZXJlIGlzXG4gICAgLy8gYSBrbm93biBzaXplIGFuZCB0aGVzZSBkbyBub3QgcmVzb2x2ZSB0byBOYU4uXG4gICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgICByZXR1cm4gc2xpY2VGYWN0b3J5KGl0ZXJhYmxlLnRvU2VxKCkuY2FjaGVSZXN1bHQoKSwgYmVnaW4sIGVuZCwgdXNlS2V5cyk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogcmVzb2x2ZWRFbmQgaXMgdW5kZWZpbmVkIHdoZW4gdGhlIG9yaWdpbmFsIHNlcXVlbmNlJ3MgbGVuZ3RoIGlzXG4gICAgLy8gdW5rbm93biBhbmQgdGhpcyBzbGljZSBkaWQgbm90IHN1cHBseSBhbiBlbmQgYW5kIHNob3VsZCBjb250YWluIGFsbFxuICAgIC8vIGVsZW1lbnRzIGFmdGVyIHJlc29sdmVkQmVnaW4uXG4gICAgLy8gSW4gdGhhdCBjYXNlLCByZXNvbHZlZFNpemUgd2lsbCBiZSBOYU4gYW5kIHNsaWNlU2l6ZSB3aWxsIHJlbWFpbiB1bmRlZmluZWQuXG4gICAgdmFyIHJlc29sdmVkU2l6ZSA9IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbjtcbiAgICB2YXIgc2xpY2VTaXplO1xuICAgIGlmIChyZXNvbHZlZFNpemUgPT09IHJlc29sdmVkU2l6ZSkge1xuICAgICAgc2xpY2VTaXplID0gcmVzb2x2ZWRTaXplIDwgMCA/IDAgOiByZXNvbHZlZFNpemU7XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlU2VxID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcblxuICAgIC8vIElmIGl0ZXJhYmxlLnNpemUgaXMgdW5kZWZpbmVkLCB0aGUgc2l6ZSBvZiB0aGUgcmVhbGl6ZWQgc2xpY2VTZXEgaXNcbiAgICAvLyB1bmtub3duIGF0IHRoaXMgcG9pbnQgdW5sZXNzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gc2xpY2UgaXMgMFxuICAgIHNsaWNlU2VxLnNpemUgPSBzbGljZVNpemUgPT09IDAgPyBzbGljZVNpemUgOiBpdGVyYWJsZS5zaXplICYmIHNsaWNlU2l6ZSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXVzZUtleXMgJiYgaXNTZXEoaXRlcmFibGUpICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgICBzbGljZVNlcS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBzbGljZVNpemUgP1xuICAgICAgICAgIGl0ZXJhYmxlLmdldChpbmRleCArIHJlc29sdmVkQmVnaW4sIG5vdFNldFZhbHVlKSA6XG4gICAgICAgICAgbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrKSAge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDApICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICBpdGVyYXRpb25zICE9PSBzbGljZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIHNsaWNlU2VxLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChzbGljZVNpemUgIT09IDAgJiYgcmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBib3RoZXIgaW5zdGFudGlhdGluZyBwYXJlbnQgaXRlcmF0b3IgaWYgdGFraW5nIDAuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBzbGljZVNpemUgIT09IDAgJiYgaXRlcmFibGUuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICB3aGlsZSAoc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikge1xuICAgICAgICAgIGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKytpdGVyYXRpb25zID4gc2xpY2VTaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlU2VxO1xuICB9XG5cblxuICBmdW5jdGlvbiB0YWtlV2hpbGVGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgdGFrZVNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpIFxuICAgICAgICB7cmV0dXJuIHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpICYmICsraXRlcmF0aW9ucyAmJiBmbih2LCBrLCB0aGlzJDApfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhYmxlLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIGlmICghaXRlcmF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDApKSB7XG4gICAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIHN0ZXApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGFrZVNlcXVlbmNlO1xuICB9XG5cblxuICBmdW5jdGlvbiBza2lwV2hpbGVGYWN0b3J5KGl0ZXJhYmxlLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgICB2YXIgc2tpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGl0ZXJhYmxlKTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGl0ZXJhYmxlLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbigpICB7XG4gICAgICAgIHZhciBzdGVwLCBrLCB2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICBpZiAodXNlS2V5cyB8fCB0eXBlID09PSBJVEVSQVRFX1ZBTFVFUykge1xuICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgayA9IGVudHJ5WzBdO1xuICAgICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDApKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcHBpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6XG4gICAgICAgICAgaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY29uY2F0RmFjdG9yeShpdGVyYWJsZSwgdmFsdWVzKSB7XG4gICAgdmFyIGlzS2V5ZWRJdGVyYWJsZSA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBpdGVycyA9IFtpdGVyYWJsZV0uY29uY2F0KHZhbHVlcykubWFwKGZ1bmN0aW9uKHYgKSB7XG4gICAgICBpZiAoIWlzSXRlcmFibGUodikpIHtcbiAgICAgICAgdiA9IGlzS2V5ZWRJdGVyYWJsZSA/XG4gICAgICAgICAga2V5ZWRTZXFGcm9tVmFsdWUodikgOlxuICAgICAgICAgIGluZGV4ZWRTZXFGcm9tVmFsdWUoQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbdl0pO1xuICAgICAgfSBlbHNlIGlmIChpc0tleWVkSXRlcmFibGUpIHtcbiAgICAgICAgdiA9IEtleWVkSXRlcmFibGUodik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24odiApIHtyZXR1cm4gdi5zaXplICE9PSAwfSk7XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgfVxuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHNpbmdsZXRvbiA9IGl0ZXJzWzBdO1xuICAgICAgaWYgKHNpbmdsZXRvbiA9PT0gaXRlcmFibGUgfHxcbiAgICAgICAgICBpc0tleWVkSXRlcmFibGUgJiYgaXNLZXllZChzaW5nbGV0b24pIHx8XG4gICAgICAgICAgaXNJbmRleGVkKGl0ZXJhYmxlKSAmJiBpc0luZGV4ZWQoc2luZ2xldG9uKSkge1xuICAgICAgICByZXR1cm4gc2luZ2xldG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb25jYXRTZXEgPSBuZXcgQXJyYXlTZXEoaXRlcnMpO1xuICAgIGlmIChpc0tleWVkSXRlcmFibGUpIHtcbiAgICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS50b0tleWVkU2VxKCk7XG4gICAgfSBlbHNlIGlmICghaXNJbmRleGVkKGl0ZXJhYmxlKSkge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG4gICAgfVxuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICAgIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKFxuICAgICAgZnVuY3Rpb24oc3VtLCBzZXEpICB7XG4gICAgICAgIGlmIChzdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICAgICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIGNvbmNhdFNlcTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmxhdHRlbkZhY3RvcnkoaXRlcmFibGUsIGRlcHRoLCB1c2VLZXlzKSB7XG4gICAgdmFyIGZsYXRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShpdGVyYWJsZSk7XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBjdXJyZW50RGVwdGggPCBkZXB0aCkgJiYgaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMrKywgdGhpcyQwKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gIXN0b3BwZWQ7XG4gICAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgZmxhdERlZXAoaXRlcmFibGUsIDApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfVxuICAgIGZsYXRTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHYgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgICAgIHYgPSB2WzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKCFkZXB0aCB8fCBzdGFjay5sZW5ndGggPCBkZXB0aCkgJiYgaXNJdGVyYWJsZSh2KSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChpdGVyYXRvcik7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHYuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUtleXMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHYsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRTZXF1ZW5jZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZmxhdE1hcEZhY3RvcnkoaXRlcmFibGUsIG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciBjb2VyY2UgPSBpdGVyYWJsZUNsYXNzKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmFibGUudG9TZXEoKS5tYXAoXG4gICAgICBmdW5jdGlvbih2LCBrKSAge3JldHVybiBjb2VyY2UobWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgaXRlcmFibGUpKX1cbiAgICApLmZsYXR0ZW4odHJ1ZSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGludGVycG9zZUZhY3RvcnkoaXRlcmFibGUsIHNlcGFyYXRvcikge1xuICAgIHZhciBpbnRlcnBvc2VkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoaXRlcmFibGUpO1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gaXRlcmFibGUuc2l6ZSAmJiBpdGVyYWJsZS5zaXplICogMiAtMTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgaXRlcmFibGUuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspIFxuICAgICAgICB7cmV0dXJuICghaXRlcmF0aW9ucyB8fCBmbihzZXBhcmF0b3IsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKSAhPT0gZmFsc2UpICYmXG4gICAgICAgIGZuKHYsIGl0ZXJhdGlvbnMrKywgdGhpcyQwKSAhPT0gZmFsc2V9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmFibGUuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAoIXN0ZXAgfHwgaXRlcmF0aW9ucyAlIDIpIHtcbiAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0aW9ucyAlIDIgP1xuICAgICAgICAgIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzZXBhcmF0b3IpIDpcbiAgICAgICAgICBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBpbnRlcnBvc2VkU2VxdWVuY2U7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNvcnRGYWN0b3J5KGl0ZXJhYmxlLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgdmFyIGlzS2V5ZWRJdGVyYWJsZSA9IGlzS2V5ZWQoaXRlcmFibGUpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGVudHJpZXMgPSBpdGVyYWJsZS50b1NlcSgpLm1hcChcbiAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIFtrLCB2LCBpbmRleCsrLCBtYXBwZXIgPyBtYXBwZXIodiwgaywgaXRlcmFibGUpIDogdl19XG4gICAgKS50b0FycmF5KCk7XG4gICAgZW50cmllcy5zb3J0KGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIGNvbXBhcmF0b3IoYVszXSwgYlszXSkgfHwgYVsyXSAtIGJbMl19KS5mb3JFYWNoKFxuICAgICAgaXNLZXllZEl0ZXJhYmxlID9cbiAgICAgIGZ1bmN0aW9uKHYsIGkpICB7IGVudHJpZXNbaV0ubGVuZ3RoID0gMjsgfSA6XG4gICAgICBmdW5jdGlvbih2LCBpKSAgeyBlbnRyaWVzW2ldID0gdlsxXTsgfVxuICAgICk7XG4gICAgcmV0dXJuIGlzS2V5ZWRJdGVyYWJsZSA/IEtleWVkU2VxKGVudHJpZXMpIDpcbiAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkU2VxKGVudHJpZXMpIDpcbiAgICAgIFNldFNlcShlbnRyaWVzKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWF4RmFjdG9yeShpdGVyYWJsZSwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChtYXBwZXIpIHtcbiAgICAgIHZhciBlbnRyeSA9IGl0ZXJhYmxlLnRvU2VxKClcbiAgICAgICAgLm1hcChmdW5jdGlvbih2LCBrKSAge3JldHVybiBbdiwgbWFwcGVyKHYsIGssIGl0ZXJhYmxlKV19KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIG1heENvbXBhcmUoY29tcGFyYXRvciwgYVsxXSwgYlsxXSkgPyBiIDogYX0pO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlcmFibGUucmVkdWNlKGZ1bmN0aW9uKGEsIGIpICB7cmV0dXJuIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikgPyBiIDogYX0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1heENvbXBhcmUoY29tcGFyYXRvciwgYSwgYikge1xuICAgIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcbiAgICAvLyBiIGlzIGNvbnNpZGVyZWQgdGhlIG5ldyBtYXggaWYgdGhlIGNvbXBhcmF0b3IgZGVjbGFyZXMgdGhlbSBlcXVhbCwgYnV0XG4gICAgLy8gdGhleSBhcmUgbm90IGVxdWFsIGFuZCBiIGlzIGluIGZhY3QgYSBudWxsaXNoIHZhbHVlLlxuICAgIHJldHVybiAoY29tcCA9PT0gMCAmJiBiICE9PSBhICYmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiICE9PSBiKSkgfHwgY29tcCA+IDA7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHppcFdpdGhGYWN0b3J5KGtleUl0ZXIsIHppcHBlciwgaXRlcnMpIHtcbiAgICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG4gICAgemlwU2VxdWVuY2Uuc2l6ZSA9IG5ldyBBcnJheVNlcShpdGVycykubWFwKGZ1bmN0aW9uKGkgKSB7cmV0dXJuIGkuc2l6ZX0pLm1pbigpO1xuICAgIC8vIE5vdGU6IHRoaXMgYSBnZW5lcmljIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgX19pdGVyYXRlIGluIHRlcm1zIG9mXG4gICAgLy8gX19pdGVyYXRvciB3aGljaCBtYXkgYmUgbW9yZSBnZW5lcmljYWxseSB1c2VmdWwgaW4gdGhlIGZ1dHVyZS5cbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgLyogZ2VuZXJpYzpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWVbMV0sIHN0ZXAudmFsdWVbMF0sIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAgICovXG4gICAgICAvLyBpbmRleGVkOlxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JzID0gaXRlcnMubWFwKGZ1bmN0aW9uKGkgKVxuICAgICAgICB7cmV0dXJuIChpID0gSXRlcmFibGUoaSksIGdldEl0ZXJhdG9yKHJldmVyc2UgPyBpLnJldmVyc2UoKSA6IGkpKX1cbiAgICAgICk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgaXNEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgdmFyIHN0ZXBzO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbihpICkge3JldHVybiBpLm5leHQoKX0pO1xuICAgICAgICAgIGlzRG9uZSA9IHN0ZXBzLnNvbWUoZnVuY3Rpb24ocyApIHtyZXR1cm4gcy5kb25lfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGl0ZXJhdGlvbnMrKyxcbiAgICAgICAgICB6aXBwZXIuYXBwbHkobnVsbCwgc3RlcHMubWFwKGZ1bmN0aW9uKHMgKSB7cmV0dXJuIHMudmFsdWV9KSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHppcFNlcXVlbmNlXG4gIH1cblxuXG4gIC8vICNwcmFnbWEgSGVscGVyIEZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIHJlaWZ5KGl0ZXIsIHNlcSkge1xuICAgIHJldHVybiBpc1NlcShpdGVyKSA/IHNlcSA6IGl0ZXIuY29uc3RydWN0b3Ioc2VxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRW50cnkoZW50cnkpIHtcbiAgICBpZiAoZW50cnkgIT09IE9iamVjdChlbnRyeSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFtLLCBWXSB0dXBsZTogJyArIGVudHJ5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlU2l6ZShpdGVyKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICByZXR1cm4gZW5zdXJlU2l6ZShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhYmxlQ2xhc3MoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gaXNLZXllZChpdGVyYWJsZSkgPyBLZXllZEl0ZXJhYmxlIDpcbiAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkSXRlcmFibGUgOlxuICAgICAgU2V0SXRlcmFibGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2VxdWVuY2UoaXRlcmFibGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAgIChcbiAgICAgICAgaXNLZXllZChpdGVyYWJsZSkgPyBLZXllZFNlcSA6XG4gICAgICAgIGlzSW5kZXhlZChpdGVyYWJsZSkgPyBJbmRleGVkU2VxIDpcbiAgICAgICAgU2V0U2VxXG4gICAgICApLnByb3RvdHlwZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZVJlc3VsdFRocm91Z2goKSB7XG4gICAgaWYgKHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQpIHtcbiAgICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2l0ZXIuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZUl0ZXJhdG9yKGtleVBhdGgpIHtcbiAgICB2YXIgaXRlciA9IGdldEl0ZXJhdG9yKGtleVBhdGgpO1xuICAgIGlmICghaXRlcikge1xuICAgICAgLy8gQXJyYXkgbWlnaHQgbm90IGJlIGl0ZXJhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQsIHNvIHdlIG5lZWQgYSBmYWxsYmFja1xuICAgICAgLy8gdG8gb3VyIHdyYXBwZWQgdHlwZS5cbiAgICAgIGlmICghaXNBcnJheUxpa2Uoa2V5UGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgaXRlcmFibGUgb3IgYXJyYXktbGlrZTogJyArIGtleVBhdGgpO1xuICAgICAgfVxuICAgICAgaXRlciA9IGdldEl0ZXJhdG9yKEl0ZXJhYmxlKGtleVBhdGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXI7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhSZWNvcmQsIEtleWVkQ29sbGVjdGlvbik7XG5cbiAgICBmdW5jdGlvbiBSZWNvcmQoZGVmYXVsdFZhbHVlcywgbmFtZSkge1xuICAgICAgdmFyIGhhc0luaXRpYWxpemVkO1xuXG4gICAgICB2YXIgUmVjb3JkVHlwZSA9IGZ1bmN0aW9uIFJlY29yZCh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0VmFsdWVzKTtcbiAgICAgICAgICBzZXRQcm9wcyhSZWNvcmRUeXBlUHJvdG90eXBlLCBrZXlzKTtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLnNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9uYW1lID0gbmFtZTtcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9rZXlzID0ga2V5cztcbiAgICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9kZWZhdWx0VmFsdWVzID0gZGVmYXVsdFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAgPSBNYXAodmFsdWVzKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBSZWNvcmRUeXBlUHJvdG90eXBlID0gUmVjb3JkVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlY29yZFByb3RvdHlwZSk7XG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcblxuICAgICAgcmV0dXJuIFJlY29yZFR5cGU7XG4gICAgfVxuXG4gICAgUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZyhyZWNvcmROYW1lKHRoaXMpICsgJyB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIFJlY29yZC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZXMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaywgbm90U2V0VmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcbiAgICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGRlZmF1bHRWYWwgPSB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcCA/IHRoaXMuX21hcC5nZXQoaywgZGVmYXVsdFZhbCkgOiBkZWZhdWx0VmFsO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgUmVjb3JkVHlwZSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gUmVjb3JkVHlwZS5fZW1wdHkgfHwgKFJlY29yZFR5cGUuX2VtcHR5ID0gbWFrZVJlY29yZCh0aGlzLCBlbXB0eU1hcCgpKSk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaywgdikge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgdW5rbm93biBrZXkgXCInICsgayArICdcIiBvbiAnICsgcmVjb3JkTmFtZSh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbWFwICYmICF0aGlzLl9tYXAuaGFzKGspKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdFZhbHVlc1trXTtcbiAgICAgICAgaWYgKHYgPT09IGRlZmF1bHRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAuc2V0KGssIHYpO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEIHx8IG5ld01hcCA9PT0gdGhpcy5fbWFwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcCAmJiB0aGlzLl9tYXAucmVtb3ZlKGspO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEIHx8IG5ld01hcCA9PT0gdGhpcy5fbWFwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgUmVjb3JkLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIEtleWVkSXRlcmFibGUodGhpcy5fZGVmYXVsdFZhbHVlcykubWFwKGZ1bmN0aW9uKF8sIGspICB7cmV0dXJuIHRoaXMkMC5nZXQoayl9KS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7dmFyIHRoaXMkMCA9IHRoaXM7XG4gICAgICByZXR1cm4gS2V5ZWRJdGVyYWJsZSh0aGlzLl9kZWZhdWx0VmFsdWVzKS5tYXAoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gdGhpcyQwLmdldChrKX0pLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFJlY29yZC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwLCBvd25lcklEKTtcbiAgICB9O1xuXG5cbiAgdmFyIFJlY29yZFByb3RvdHlwZSA9IFJlY29yZC5wcm90b3R5cGU7XG4gIFJlY29yZFByb3RvdHlwZVtERUxFVEVdID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZTtcbiAgUmVjb3JkUHJvdG90eXBlLmRlbGV0ZUluID1cbiAgUmVjb3JkUHJvdG90eXBlLnJlbW92ZUluID0gTWFwUHJvdG90eXBlLnJlbW92ZUluO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBNYXBQcm90b3R5cGUubWVyZ2U7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZVdpdGggPSBNYXBQcm90b3R5cGUubWVyZ2VXaXRoO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VJbiA9IE1hcFByb3RvdHlwZS5tZXJnZUluO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcDtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwV2l0aDtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcEluID0gTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluO1xuICBSZWNvcmRQcm90b3R5cGUuc2V0SW4gPSBNYXBQcm90b3R5cGUuc2V0SW47XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGUgPSBNYXBQcm90b3R5cGUudXBkYXRlO1xuICBSZWNvcmRQcm90b3R5cGUudXBkYXRlSW4gPSBNYXBQcm90b3R5cGUudXBkYXRlSW47XG4gIFJlY29yZFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnM7XG4gIFJlY29yZFByb3RvdHlwZS5hc011dGFibGUgPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlO1xuICBSZWNvcmRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5cblxuICBmdW5jdGlvbiBtYWtlUmVjb3JkKGxpa2VSZWNvcmQsIG1hcCwgb3duZXJJRCkge1xuICAgIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gICAgcmVjb3JkLl9tYXAgPSBtYXA7XG4gICAgcmVjb3JkLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZE5hbWUocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZC5fbmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3BzKHByb3RvdHlwZSwgbmFtZXMpIHtcbiAgICB0cnkge1xuICAgICAgbmFtZXMuZm9yRWFjaChzZXRQcm9wLmJpbmQodW5kZWZpbmVkLCBwcm90b3R5cGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGZhaWxlZC4gUHJvYmFibHkgSUU4LlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFByb3AocHJvdG90eXBlLCBuYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaW52YXJpYW50KHRoaXMuX19vd25lcklELCAnQ2Fubm90IHNldCBvbiBhbiBpbW11dGFibGUgcmVjb3JkLicpO1xuICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTZXQsIFNldENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyBlbXB0eVNldCgpIDpcbiAgICAgICAgaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICAgIHZhciBpdGVyID0gU2V0SXRlcmFibGUodmFsdWUpO1xuICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uKHYgKSB7cmV0dXJuIHNldC5hZGQodil9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgU2V0Lm9mID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgU2V0LmZyb21LZXlzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzKEtleWVkSXRlcmFibGUodmFsdWUpLmtleVNlcSgpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAuc2V0KHZhbHVlLCB0cnVlKSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnJlbW92ZSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5jbGVhcigpKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKCkge3ZhciBpdGVycyA9IFNMSUNFJDAuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24oeCApIHtyZXR1cm4geC5zaXplICE9PSAwfSk7XG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGl0ZXJzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgaXRlcnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgU2V0SXRlcmFibGUoaXRlcnNbaWldKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiBzZXQuYWRkKHZhbHVlKX0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbigpIHt2YXIgaXRlcnMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbihpdGVyICkge3JldHVybiBTZXRJdGVyYWJsZShpdGVyKX0pO1xuICAgICAgdmFyIG9yaWdpbmFsU2V0ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24oc2V0ICkge1xuICAgICAgICBvcmlnaW5hbFNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlICkge1xuICAgICAgICAgIGlmICghaXRlcnMuZXZlcnkoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSl9KSkge1xuICAgICAgICAgICAgc2V0LnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24oKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24oaXRlciApIHtyZXR1cm4gU2V0SXRlcmFibGUoaXRlcil9KTtcbiAgICAgIHZhciBvcmlnaW5hbFNldCA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgb3JpZ2luYWxTZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSApIHtcbiAgICAgICAgICBpZiAoaXRlcnMuc29tZShmdW5jdGlvbihpdGVyICkge3JldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKX0pKSB7XG4gICAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUubWVyZ2VXaXRoID0gZnVuY3Rpb24obWVyZ2VyKSB7dmFyIGl0ZXJzID0gU0xJQ0UkMC5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gdGhpcy51bmlvbi5hcHBseSh0aGlzLCBpdGVycyk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRTZXQoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge3ZhciB0aGlzJDAgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdGUoZnVuY3Rpb24oXywgaykgIHtyZXR1cm4gZm4oaywgaywgdGhpcyQwKX0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLm1hcChmdW5jdGlvbihfLCBrKSAge3JldHVybiBrfSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fbWFrZShuZXdNYXAsIG93bmVySUQpO1xuICAgIH07XG5cblxuICBmdW5jdGlvbiBpc1NldChtYXliZVNldCkge1xuICAgIHJldHVybiAhIShtYXliZVNldCAmJiBtYXliZVNldFtJU19TRVRfU0VOVElORUxdKTtcbiAgfVxuXG4gIFNldC5pc1NldCA9IGlzU2V0O1xuXG4gIHZhciBJU19TRVRfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9TRVRfX0BAJztcblxuICB2YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcbiAgU2V0UHJvdG90eXBlW0lTX1NFVF9TRU5USU5FTF0gPSB0cnVlO1xuICBTZXRQcm90b3R5cGVbREVMRVRFXSA9IFNldFByb3RvdHlwZS5yZW1vdmU7XG4gIFNldFByb3RvdHlwZS5tZXJnZURlZXAgPSBTZXRQcm90b3R5cGUubWVyZ2U7XG4gIFNldFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gU2V0UHJvdG90eXBlLm1lcmdlV2l0aDtcbiAgU2V0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgU2V0UHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG4gIFNldFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc0ltbXV0YWJsZTtcblxuICBTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5U2V0O1xuICBTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuICBmdW5jdGlvbiB1cGRhdGVTZXQoc2V0LCBuZXdNYXApIHtcbiAgICBpZiAoc2V0Ll9fb3duZXJJRCkge1xuICAgICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICAgIHNldC5fbWFwID0gbmV3TWFwO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcCA9PT0gc2V0Ll9tYXAgPyBzZXQgOlxuICAgICAgbmV3TWFwLnNpemUgPT09IDAgPyBzZXQuX19lbXB0eSgpIDpcbiAgICAgIHNldC5fX21ha2UobmV3TWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoU2V0UHJvdG90eXBlKTtcbiAgICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBzZXQuX21hcCA9IG1hcDtcbiAgICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgdmFyIEVNUFRZX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlTZXQoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhPcmRlcmVkU2V0LCBTZXQpO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIE9yZGVyZWRTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZW1wdHlPcmRlcmVkU2V0KCkgOlxuICAgICAgICBpc09yZGVyZWRTZXQodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eU9yZGVyZWRTZXQoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uKHNldCApIHtcbiAgICAgICAgICB2YXIgaXRlciA9IFNldEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbih2ICkge3JldHVybiBzZXQuYWRkKHYpfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE9yZGVyZWRTZXQub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LmZyb21LZXlzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzKEtleWVkSXRlcmFibGUodmFsdWUpLmtleVNlcSgpKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ09yZGVyZWRTZXQgeycsICd9Jyk7XG4gICAgfTtcblxuXG4gIGZ1bmN0aW9uIGlzT3JkZXJlZFNldChtYXliZU9yZGVyZWRTZXQpIHtcbiAgICByZXR1cm4gaXNTZXQobWF5YmVPcmRlcmVkU2V0KSAmJiBpc09yZGVyZWQobWF5YmVPcmRlcmVkU2V0KTtcbiAgfVxuXG4gIE9yZGVyZWRTZXQuaXNPcmRlcmVkU2V0ID0gaXNPcmRlcmVkU2V0O1xuXG4gIHZhciBPcmRlcmVkU2V0UHJvdG90eXBlID0gT3JkZXJlZFNldC5wcm90b3R5cGU7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGVbSVNfT1JERVJFRF9TRU5USU5FTF0gPSB0cnVlO1xuXG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5T3JkZXJlZFNldDtcbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlT3JkZXJlZFNldDtcblxuICBmdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkU2V0UHJvdG90eXBlKTtcbiAgICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBzZXQuX21hcCA9IG1hcDtcbiAgICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgdmFyIEVNUFRZX09SREVSRURfU0VUO1xuICBmdW5jdGlvbiBlbXB0eU9yZGVyZWRTZXQoKSB7XG4gICAgcmV0dXJuIEVNUFRZX09SREVSRURfU0VUIHx8IChFTVBUWV9PUkRFUkVEX1NFVCA9IG1ha2VPcmRlcmVkU2V0KGVtcHR5T3JkZXJlZE1hcCgpKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTdGFjaywgSW5kZXhlZENvbGxlY3Rpb24pO1xuXG4gICAgLy8gQHByYWdtYSBDb25zdHJ1Y3Rpb25cblxuICAgIGZ1bmN0aW9uIFN0YWNrKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGVtcHR5U3RhY2soKSA6XG4gICAgICAgIGlzU3RhY2sodmFsdWUpID8gdmFsdWUgOlxuICAgICAgICBlbXB0eVN0YWNrKCkudW5zaGlmdEFsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgU3RhY2sub2YgPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgd2hpbGUgKGhlYWQgJiYgaW5kZXgtLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWQgPyBoZWFkLnZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZCAmJiB0aGlzLl9oZWFkLnZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigvKi4uLnZhbHVlcyovKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGZvciAodmFyIGlpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgaGVhZCA9IHtcbiAgICAgICAgICB2YWx1ZTogYXJndW1lbnRzW2lpXSxcbiAgICAgICAgICBuZXh0OiBoZWFkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnB1c2hBbGwgPSBmdW5jdGlvbihpdGVyKSB7XG4gICAgICBpdGVyID0gSW5kZXhlZEl0ZXJhYmxlKGl0ZXIpO1xuICAgICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGl0ZXIucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24odmFsdWUgKSB7XG4gICAgICAgIG5ld1NpemUrKztcbiAgICAgICAgaGVhZCA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgbmV4dDogaGVhZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUudW5zaGlmdEFsbCA9IGZ1bmN0aW9uKGl0ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hBbGwoaXRlcik7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5zaXplKTtcbiAgICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLnNpemUpO1xuICAgICAgaWYgKHJlc29sdmVkRW5kICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgLy8gc3VwZXIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgICAgIHJldHVybiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTaXplID0gdGhpcy5zaXplIC0gcmVzb2x2ZWRCZWdpbjtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIHdoaWxlIChyZXNvbHZlZEJlZ2luLS0pIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24ob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZVN0YWNrKHRoaXMuc2l6ZSwgdGhpcy5faGVhZCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuX19pdGVyYXRlKGZuKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChmbihub2RlLnZhbHVlLCBpdGVyYXRpb25zKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuX19pdGVyYXRvcih0eXBlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24oKSAge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNTdGFjayhtYXliZVN0YWNrKSB7XG4gICAgcmV0dXJuICEhKG1heWJlU3RhY2sgJiYgbWF5YmVTdGFja1tJU19TVEFDS19TRU5USU5FTF0pO1xuICB9XG5cbiAgU3RhY2suaXNTdGFjayA9IGlzU3RhY2s7XG5cbiAgdmFyIElTX1NUQUNLX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfU1RBQ0tfX0BAJztcblxuICB2YXIgU3RhY2tQcm90b3R5cGUgPSBTdGFjay5wcm90b3R5cGU7XG4gIFN0YWNrUHJvdG90eXBlW0lTX1NUQUNLX1NFTlRJTkVMXSA9IHRydWU7XG4gIFN0YWNrUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSBNYXBQcm90b3R5cGUud2l0aE11dGF0aW9ucztcbiAgU3RhY2tQcm90b3R5cGUuYXNNdXRhYmxlID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZTtcbiAgU3RhY2tQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG4gIFN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSBNYXBQcm90b3R5cGUud2FzQWx0ZXJlZDtcblxuXG4gIGZ1bmN0aW9uIG1ha2VTdGFjayhzaXplLCBoZWFkLCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoU3RhY2tQcm90b3R5cGUpO1xuICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICBtYXAuX2hlYWQgPSBoZWFkO1xuICAgIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICAgIG1hcC5fX2hhc2ggPSBoYXNoO1xuICAgIG1hcC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgdmFyIEVNUFRZX1NUQUNLO1xuICBmdW5jdGlvbiBlbXB0eVN0YWNrKCkge1xuICAgIHJldHVybiBFTVBUWV9TVEFDSyB8fCAoRU1QVFlfU1RBQ0sgPSBtYWtlU3RhY2soMCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyaWJ1dGVzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBtaXhpbihjdG9yLCBtZXRob2RzKSB7XG4gICAgdmFyIGtleUNvcGllciA9IGZ1bmN0aW9uKGtleSApIHsgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTsgfTtcbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJlxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gICAgcmV0dXJuIGN0b3I7XG4gIH1cblxuICBJdGVyYWJsZS5JdGVyYXRvciA9IEl0ZXJhdG9yO1xuXG4gIG1peGluKEl0ZXJhYmxlLCB7XG5cbiAgICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMuc2l6ZSB8fCAwKTtcbiAgICAgIHRoaXMudmFsdWVTZXEoKS5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaSkgIHsgYXJyYXlbaV0gPSB2OyB9KTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgdG9JbmRleGVkU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVG9JbmRleGVkU2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIHRvSlM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlICkge3JldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KUyA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvSlMoKSA6IHZhbHVlfVxuICAgICAgKS5fX3RvSlMoKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU2VxKCkubWFwKFxuICAgICAgICBmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvSlNPTigpIDogdmFsdWV9XG4gICAgICApLl9fdG9KUygpO1xuICAgIH0sXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVG9LZXllZFNlcXVlbmNlKHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICB0b01hcDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGspICB7IG9iamVjdFtrXSA9IHY7IH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgdG9PcmRlcmVkTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgICB9LFxuXG4gICAgdG9PcmRlcmVkU2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVG9TZXRTZXF1ZW5jZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9TZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzSW5kZXhlZCh0aGlzKSA/IHRoaXMudG9JbmRleGVkU2VxKCkgOlxuICAgICAgICBpc0tleWVkKHRoaXMpID8gdGhpcy50b0tleWVkU2VxKCkgOlxuICAgICAgICB0aGlzLnRvU2V0U2VxKCk7XG4gICAgfSxcblxuICAgIHRvU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFN0YWNrKGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9MaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBMaXN0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgQ29tbW9uIEphdmFTY3JpcHQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICdbSXRlcmFibGVdJztcbiAgICB9LFxuXG4gICAgX190b1N0cmluZzogZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZCArICcgJyArIHRoaXMudG9TZXEoKS5tYXAodGhpcy5fX3RvU3RyaW5nTWFwcGVyKS5qb2luKCcsICcpICsgJyAnICsgdGFpbDtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBjb25jYXQ6IGZ1bmN0aW9uKCkge3ZhciB2YWx1ZXMgPSBTTElDRSQwLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBjb25jYXRGYWN0b3J5KHRoaXMsIHZhbHVlcykpO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlczogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24odmFsdWUgKSB7cmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSl9KTtcbiAgICB9LFxuXG4gICAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG4gICAgfSxcblxuICAgIGV2ZXJ5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24odiwgaywgYykgIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oc2lkZUVmZmVjdCwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gICAgfSxcblxuICAgIGpvaW46IGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gJycgKyBzZXBhcmF0b3IgOiAnLCc7XG4gICAgICB2YXIgam9pbmVkID0gJyc7XG4gICAgICB2YXIgaXNGaXJzdCA9IHRydWU7XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2ICkge1xuICAgICAgICBpc0ZpcnN0ID8gKGlzRmlyc3QgPSBmYWxzZSkgOiAoam9pbmVkICs9IHNlcGFyYXRvcik7XG4gICAgICAgIGpvaW5lZCArPSB2ICE9PSBudWxsICYmIHYgIT09IHVuZGVmaW5lZCA/IHYudG9TdHJpbmcoKSA6ICcnO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gam9pbmVkO1xuICAgIH0sXG5cbiAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcbiAgICB9LFxuXG4gICAgbWFwOiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBtYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICByZWR1Y2U6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgICB2YXIgcmVkdWN0aW9uO1xuICAgICAgdmFyIHVzZUZpcnN0O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHVzZUZpcnN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZHVjdGlvbiA9IGluaXRpYWxSZWR1Y3Rpb247XG4gICAgICB9XG4gICAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbih2LCBrLCBjKSAge1xuICAgICAgICBpZiAodXNlRmlyc3QpIHtcbiAgICAgICAgICB1c2VGaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIHJlZHVjdGlvbiA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVkdWN0aW9uID0gcmVkdWNlci5jYWxsKGNvbnRleHQsIHJlZHVjdGlvbiwgdiwgaywgYyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlZHVjdGlvbjtcbiAgICB9LFxuXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXZlcnNlZCA9IHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiByZXZlcnNlZC5yZWR1Y2UuYXBwbHkocmV2ZXJzZWQsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzb21lOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTKTtcbiAgICB9LFxuXG5cbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGJ1dExhc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24oKSAge3JldHVybiB0cnVlfSk7XG4gICAgfSxcblxuICAgIGNvdW50OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjb3VudEJ5OiBmdW5jdGlvbihncm91cGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY291bnRCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH0sXG5cbiAgICBlbnRyeVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSB0aGlzO1xuICAgICAgaWYgKGl0ZXJhYmxlLl9jYWNoZSkge1xuICAgICAgICAvLyBXZSBjYWNoZSBhcyBhbiBlbnRyaWVzIGFycmF5LCBzbyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGNhY2hlIVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5U2VxKGl0ZXJhYmxlLl9jYWNoZSk7XG4gICAgICB9XG4gICAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gaXRlcmFibGUudG9TZXEoKS5tYXAoZW50cnlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICAgICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyeVNlcSA9IGZ1bmN0aW9uKCkgIHtyZXR1cm4gaXRlcmFibGUudG9TZXEoKX07XG4gICAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuICAgIH0sXG5cbiAgICBmaWx0ZXJOb3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmluZEVudHJ5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uKHYsIGssIGMpICB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGZvdW5kID0gW2ssIHZdO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIGZpbmRLZXk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgICB9LFxuXG4gICAgZmluZExhc3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmluZExhc3RFbnRyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0S2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKHJldHVyblRydWUpO1xuICAgIH0sXG5cbiAgICBmbGF0TWFwOiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0TWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgZmxhdHRlbjogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBmcm9tRW50cnlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBGcm9tRW50cmllc1NlcXVlbmNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKHNlYXJjaEtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24oXywga2V5KSAge3JldHVybiBpcyhrZXksIHNlYXJjaEtleSl9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0SW46IGZ1bmN0aW9uKHNlYXJjaEtleVBhdGgsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgbmVzdGVkID0gdGhpcztcbiAgICAgIC8vIE5vdGU6IGluIGFuIEVTNiBlbnZpcm9ubWVudCwgd2Ugd291bGQgcHJlZmVyOlxuICAgICAgLy8gZm9yICh2YXIga2V5IG9mIHNlYXJjaEtleVBhdGgpIHtcbiAgICAgIHZhciBpdGVyID0gZm9yY2VJdGVyYXRvcihzZWFyY2hLZXlQYXRoKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIHZhciBrZXkgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWQgJiYgbmVzdGVkLmdldCA/IG5lc3RlZC5nZXQoa2V5LCBOT1RfU0VUKSA6IE5PVF9TRVQ7XG4gICAgICAgIGlmIChuZXN0ZWQgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXN0ZWQ7XG4gICAgfSxcblxuICAgIGdyb3VwQnk6IGZ1bmN0aW9uKGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBncm91cEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbihzZWFyY2hLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChzZWFyY2hLZXksIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICAgIH0sXG5cbiAgICBoYXNJbjogZnVuY3Rpb24oc2VhcmNoS2V5UGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW4oc2VhcmNoS2V5UGF0aCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gICAgfSxcblxuICAgIGlzU3Vic2V0OiBmdW5jdGlvbihpdGVyKSB7XG4gICAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaW5jbHVkZXMgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogSXRlcmFibGUoaXRlcik7XG4gICAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSl9KTtcbiAgICB9LFxuXG4gICAgaXNTdXBlcnNldDogZnVuY3Rpb24oaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmlzU3Vic2V0ID09PSAnZnVuY3Rpb24nID8gaXRlciA6IEl0ZXJhYmxlKGl0ZXIpO1xuICAgICAgcmV0dXJuIGl0ZXIuaXNTdWJzZXQodGhpcyk7XG4gICAgfSxcblxuICAgIGtleU9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEtleShmdW5jdGlvbih2YWx1ZSApIHtyZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKX0pO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TZXEoKS5tYXAoa2V5TWFwcGVyKS50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5maXJzdCgpO1xuICAgIH0sXG5cbiAgICBsYXN0S2V5T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbWF4Qnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKTtcbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBtaW5CeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gbWF4RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3IsIG1hcHBlcik7XG4gICAgfSxcblxuICAgIHJlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gICAgfSxcblxuICAgIHNraXA6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHNraXBMYXN0OiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0aGlzLnRvU2VxKCkucmV2ZXJzZSgpLnNraXAoYW1vdW50KS5yZXZlcnNlKCkpO1xuICAgIH0sXG5cbiAgICBza2lwV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNraXBVbnRpbDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5za2lwV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0Qnk6IGZ1bmN0aW9uKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH0sXG5cbiAgICB0YWtlOiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICB0YWtlTGFzdDogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGhpcy50b1NlcSgpLnJldmVyc2UoKS50YWtlKGFtb3VudCkucmV2ZXJzZSgpKTtcbiAgICB9LFxuXG4gICAgdGFrZVdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCB0YWtlV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICB0YWtlVW50aWw6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZVdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgdmFsdWVTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9JbmRleGVkU2VxKCk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIEhhc2hhYmxlIE9iamVjdFxuXG4gICAgaGFzaENvZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19oYXNoIHx8ICh0aGlzLl9faGFzaCA9IGhhc2hJdGVyYWJsZSh0aGlzKSk7XG4gICAgfVxuXG5cbiAgICAvLyAjIyMgSW50ZXJuYWxcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0ZShmbiwgcmV2ZXJzZSlcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSlcbiAgfSk7XG5cbiAgLy8gdmFyIElTX0lURVJBQkxFX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJztcbiAgLy8gdmFyIElTX0tFWUVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfS0VZRURfX0BAJztcbiAgLy8gdmFyIElTX0lOREVYRURfU0VOVElORUwgPSAnQEBfX0lNTVVUQUJMRV9JTkRFWEVEX19AQCc7XG4gIC8vIHZhciBJU19PUkRFUkVEX1NFTlRJTkVMID0gJ0BAX19JTU1VVEFCTEVfT1JERVJFRF9fQEAnO1xuXG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgSXRlcmFibGVQcm90b3R5cGVbSVNfSVRFUkFCTEVfU0VOVElORUxdID0gdHJ1ZTtcbiAgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IEl0ZXJhYmxlUHJvdG90eXBlLnZhbHVlcztcbiAgSXRlcmFibGVQcm90b3R5cGUuX190b0pTID0gSXRlcmFibGVQcm90b3R5cGUudG9BcnJheTtcbiAgSXRlcmFibGVQcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IHF1b3RlU3RyaW5nO1xuICBJdGVyYWJsZVByb3RvdHlwZS5pbnNwZWN0ID1cbiAgSXRlcmFibGVQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfTtcbiAgSXRlcmFibGVQcm90b3R5cGUuY2hhaW4gPSBJdGVyYWJsZVByb3RvdHlwZS5mbGF0TWFwO1xuICBJdGVyYWJsZVByb3RvdHlwZS5jb250YWlucyA9IEl0ZXJhYmxlUHJvdG90eXBlLmluY2x1ZGVzO1xuXG4gIG1peGluKEtleWVkSXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgZmxpcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICAgIH0sXG5cbiAgICBtYXBFbnRyaWVzOiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLFxuICAgICAgICB0aGlzLnRvU2VxKCkubWFwKFxuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7cmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIFtrLCB2XSwgaXRlcmF0aW9ucysrLCB0aGlzJDApfVxuICAgICAgICApLmZyb21FbnRyeVNlcSgpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBtYXBLZXlzOiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHt2YXIgdGhpcyQwID0gdGhpcztcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLFxuICAgICAgICB0aGlzLnRvU2VxKCkuZmxpcCgpLm1hcChcbiAgICAgICAgICBmdW5jdGlvbihrLCB2KSAge3JldHVybiBtYXBwZXIuY2FsbChjb250ZXh0LCBrLCB2LCB0aGlzJDApfVxuICAgICAgICApLmZsaXAoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIEtleWVkSXRlcmFibGVQcm90b3R5cGUgPSBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgS2V5ZWRJdGVyYWJsZVByb3RvdHlwZVtJU19LRVlFRF9TRU5USU5FTF0gPSB0cnVlO1xuICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzO1xuICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9KUyA9IEl0ZXJhYmxlUHJvdG90eXBlLnRvT2JqZWN0O1xuICBLZXllZEl0ZXJhYmxlUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBmdW5jdGlvbih2LCBrKSAge3JldHVybiBKU09OLnN0cmluZ2lmeShrKSArICc6ICcgKyBxdW90ZVN0cmluZyh2KX07XG5cblxuXG4gIG1peGluKEluZGV4ZWRJdGVyYWJsZSwge1xuXG4gICAgLy8gIyMjIENvbnZlcnNpb24gdG8gb3RoZXIgdHlwZXNcblxuICAgIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgZmFsc2UpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGZpbHRlcjogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgaW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmxhc3RLZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgc3BsaWNlOiBmdW5jdGlvbihpbmRleCwgcmVtb3ZlTnVtIC8qLCAuLi52YWx1ZXMqLykge1xuICAgICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgcmVtb3ZlTnVtID0gTWF0aC5tYXgocmVtb3ZlTnVtIHwgMCwgMCk7XG4gICAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cbiAgICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbnVtQXJncyA9PT0gMSA/XG4gICAgICAgICAgc3BsaWNlZCA6XG4gICAgICAgICAgc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICAgICk7XG4gICAgfSxcblxuXG4gICAgLy8gIyMjIE1vcmUgY29sbGVjdGlvbiBtZXRob2RzXG5cbiAgICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApO1xuICAgIH0sXG5cbiAgICBmbGF0dGVuOiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXR0ZW5GYWN0b3J5KHRoaXMsIGRlcHRoLCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIChpbmRleCA8IDAgfHwgKHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAodGhpcy5zaXplICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPiB0aGlzLnNpemUpKSkgP1xuICAgICAgICBub3RTZXRWYWx1ZSA6XG4gICAgICAgIHRoaXMuZmluZChmdW5jdGlvbihfLCBrZXkpICB7cmV0dXJuIGtleSA9PT0gaW5kZXh9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGhpcy5zaXplID09PSBJbmZpbml0eSB8fCBpbmRleCA8IHRoaXMuc2l6ZSA6XG4gICAgICAgIHRoaXMuaW5kZXhPZihpbmRleCkgIT09IC0xXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBpbnRlcnBvc2U6IGZ1bmN0aW9uKHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVycG9zZUZhY3RvcnkodGhpcywgc2VwYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIGludGVybGVhdmU6IGZ1bmN0aW9uKC8qLi4uaXRlcmFibGVzKi8pIHtcbiAgICAgIHZhciBpdGVyYWJsZXMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICB2YXIgemlwcGVkID0gemlwV2l0aEZhY3RvcnkodGhpcy50b1NlcSgpLCBJbmRleGVkU2VxLm9mLCBpdGVyYWJsZXMpO1xuICAgICAgdmFyIGludGVybGVhdmVkID0gemlwcGVkLmZsYXR0ZW4odHJ1ZSk7XG4gICAgICBpZiAoemlwcGVkLnNpemUpIHtcbiAgICAgICAgaW50ZXJsZWF2ZWQuc2l6ZSA9IHppcHBlZC5zaXplICogaXRlcmFibGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBpbnRlcmxlYXZlZCk7XG4gICAgfSxcblxuICAgIGtleVNlcTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUmFuZ2UoMCwgdGhpcy5zaXplKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoLTEpO1xuICAgIH0sXG5cbiAgICBza2lwV2hpbGU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNraXBXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgIH0sXG5cbiAgICB6aXA6IGZ1bmN0aW9uKC8qLCAuLi5pdGVyYWJsZXMgKi8pIHtcbiAgICAgIHZhciBpdGVyYWJsZXMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgaXRlcmFibGVzKSk7XG4gICAgfSxcblxuICAgIHppcFdpdGg6IGZ1bmN0aW9uKHppcHBlci8qLCAuLi5pdGVyYWJsZXMgKi8pIHtcbiAgICAgIHZhciBpdGVyYWJsZXMgPSBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gICAgICBpdGVyYWJsZXNbMF0gPSB0aGlzO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIHppcHBlciwgaXRlcmFibGVzKSk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGVbSVNfSU5ERVhFRF9TRU5USU5FTF0gPSB0cnVlO1xuICBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlW0lTX09SREVSRURfU0VOVElORUxdID0gdHJ1ZTtcblxuXG5cbiAgbWl4aW4oU2V0SXRlcmFibGUsIHtcblxuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGdldDogZnVuY3Rpb24odmFsdWUsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpID8gdmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9LFxuXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXModmFsdWUpO1xuICAgIH0sXG5cblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAga2V5U2VxOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlU2VxKCk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIFNldEl0ZXJhYmxlLnByb3RvdHlwZS5oYXMgPSBJdGVyYWJsZVByb3RvdHlwZS5pbmNsdWRlcztcbiAgU2V0SXRlcmFibGUucHJvdG90eXBlLmNvbnRhaW5zID0gU2V0SXRlcmFibGUucHJvdG90eXBlLmluY2x1ZGVzO1xuXG5cbiAgLy8gTWl4aW4gc3ViY2xhc3Nlc1xuXG4gIG1peGluKEtleWVkU2VxLCBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRTZXEsIEluZGV4ZWRJdGVyYWJsZS5wcm90b3R5cGUpO1xuICBtaXhpbihTZXRTZXEsIFNldEl0ZXJhYmxlLnByb3RvdHlwZSk7XG5cbiAgbWl4aW4oS2V5ZWRDb2xsZWN0aW9uLCBLZXllZEl0ZXJhYmxlLnByb3RvdHlwZSk7XG4gIG1peGluKEluZGV4ZWRDb2xsZWN0aW9uLCBJbmRleGVkSXRlcmFibGUucHJvdG90eXBlKTtcbiAgbWl4aW4oU2V0Q29sbGVjdGlvbiwgU2V0SXRlcmFibGUucHJvdG90eXBlKTtcblxuXG4gIC8vICNwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGtleU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyeU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIFtrLCB2XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFppcHBlcigpIHtcbiAgICByZXR1cm4gYXJyQ29weShhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdE5lZ0NvbXBhcmF0b3IoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IDEgOiBhID4gYiA/IC0xIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2hJdGVyYWJsZShpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZS5zaXplID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBvcmRlcmVkID0gaXNPcmRlcmVkKGl0ZXJhYmxlKTtcbiAgICB2YXIga2V5ZWQgPSBpc0tleWVkKGl0ZXJhYmxlKTtcbiAgICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgICB2YXIgc2l6ZSA9IGl0ZXJhYmxlLl9faXRlcmF0ZShcbiAgICAgIGtleWVkID9cbiAgICAgICAgb3JkZXJlZCA/XG4gICAgICAgICAgZnVuY3Rpb24odiwgaykgIHsgaCA9IDMxICogaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSB8IDA7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uKHYsIGspICB7IGggPSBoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpIHwgMDsgfSA6XG4gICAgICAgIG9yZGVyZWQgP1xuICAgICAgICAgIGZ1bmN0aW9uKHYgKSB7IGggPSAzMSAqIGggKyBoYXNoKHYpIHwgMDsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24odiApIHsgaCA9IGggKyBoYXNoKHYpIHwgMDsgfVxuICAgICk7XG4gICAgcmV0dXJuIG11cm11ckhhc2hPZlNpemUoc2l6ZSwgaCk7XG4gIH1cblxuICBmdW5jdGlvbiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpIHtcbiAgICBoID0gaW11bChoLCAweENDOUUyRDUxKTtcbiAgICBoID0gaW11bChoIDw8IDE1IHwgaCA+Pj4gLTE1LCAweDFCODczNTkzKTtcbiAgICBoID0gaW11bChoIDw8IDEzIHwgaCA+Pj4gLTEzLCA1KTtcbiAgICBoID0gKGggKyAweEU2NTQ2QjY0IHwgMCkgXiBzaXplO1xuICAgIGggPSBpbXVsKGggXiBoID4+PiAxNiwgMHg4NUVCQ0E2Qik7XG4gICAgaCA9IGltdWwoaCBeIGggPj4+IDEzLCAweEMyQjJBRTM1KTtcbiAgICBoID0gc21pKGggXiBoID4+PiAxNik7XG4gICAgcmV0dXJuIGg7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICAgIHJldHVybiBhIF4gYiArIDB4OUUzNzc5QjkgKyAoYSA8PCA2KSArIChhID4+IDIpIHwgMDsgLy8gaW50XG4gIH1cblxuICB2YXIgSW1tdXRhYmxlID0ge1xuXG4gICAgSXRlcmFibGU6IEl0ZXJhYmxlLFxuXG4gICAgU2VxOiBTZXEsXG4gICAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcbiAgICBNYXA6IE1hcCxcbiAgICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuICAgIExpc3Q6IExpc3QsXG4gICAgU3RhY2s6IFN0YWNrLFxuICAgIFNldDogU2V0LFxuICAgIE9yZGVyZWRTZXQ6IE9yZGVyZWRTZXQsXG5cbiAgICBSZWNvcmQ6IFJlY29yZCxcbiAgICBSYW5nZTogUmFuZ2UsXG4gICAgUmVwZWF0OiBSZXBlYXQsXG5cbiAgICBpczogaXMsXG4gICAgZnJvbUpTOiBmcm9tSlNcblxuICB9O1xuXG4gIHJldHVybiBJbW11dGFibGU7XG5cbn0pKTsiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9vcGVuanNmLm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cbjsoZnVuY3Rpb24oKSB7XG5cbiAgLyoqIFVzZWQgYXMgYSBzYWZlIHJlZmVyZW5jZSBmb3IgYHVuZGVmaW5lZGAgaW4gcHJlLUVTNSBlbnZpcm9ubWVudHMuICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLiAqL1xuICB2YXIgVkVSU0lPTiA9ICc0LjE3LjIxJztcblxuICAvKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbiAgdmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgQ09SRV9FUlJPUl9URVhUID0gJ1Vuc3VwcG9ydGVkIGNvcmUtanMgdXNlLiBUcnkgaHR0cHM6Ly9ucG1zLmlvL3NlYXJjaD9xPXBvbnlmaWxsLicsXG4gICAgICBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbicsXG4gICAgICBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gJ0ludmFsaWQgYHZhcmlhYmxlYCBvcHRpb24gcGFzc2VkIGludG8gYF8udGVtcGxhdGVgJztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG4gIHZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbiAgdmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG4gIHZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG4gIHZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgdmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQsXG4gICAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgICAgV1JBUF9GTElQX0ZMQUcgPSA1MTI7XG5cbiAgLyoqIFVzZWQgYXMgZGVmYXVsdCBvcHRpb25zIGZvciBgXy50cnVuY2F0ZWAuICovXG4gIHZhciBERUZBVUxUX1RSVU5DX0xFTkdUSCA9IDMwLFxuICAgICAgREVGQVVMVF9UUlVOQ19PTUlTU0lPTiA9ICcuLi4nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICAgIEhPVF9TUEFOID0gMTY7XG5cbiAgLyoqIFVzZWQgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGF6eSBpdGVyYXRlZXMuICovXG4gIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSxcbiAgICAgIExBWllfTUFQX0ZMQUcgPSAyLFxuICAgICAgTEFaWV9XSElMRV9GTEFHID0gMztcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgICBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xuICB2YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDQyOTQ5NjcyOTUsXG4gICAgICBNQVhfQVJSQVlfSU5ERVggPSBNQVhfQVJSQVlfTEVOR1RIIC0gMSxcbiAgICAgIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG5cbiAgLyoqIFVzZWQgdG8gYXNzb2NpYXRlIHdyYXAgbWV0aG9kcyB3aXRoIHRoZWlyIGJpdCBmbGFncy4gKi9cbiAgdmFyIHdyYXBGbGFncyA9IFtcbiAgICBbJ2FyeScsIFdSQVBfQVJZX0ZMQUddLFxuICAgIFsnYmluZCcsIFdSQVBfQklORF9GTEFHXSxcbiAgICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICAgIFsnY3VycnknLCBXUkFQX0NVUlJZX0ZMQUddLFxuICAgIFsnY3VycnlSaWdodCcsIFdSQVBfQ1VSUllfUklHSFRfRkxBR10sXG4gICAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICAgIFsncGFydGlhbCcsIFdSQVBfUEFSVElBTF9GTEFHXSxcbiAgICBbJ3BhcnRpYWxSaWdodCcsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHXSxcbiAgICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuICBdO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXScsXG4gICAgICB3ZWFrU2V0VGFnID0gJ1tvYmplY3QgV2Vha1NldF0nO1xuXG4gIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjMzkpOy9nLFxuICAgICAgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgICByZUhhc0VzY2FwZWRIdG1sID0gUmVnRXhwKHJlRXNjYXBlZEh0bWwuc291cmNlKSxcbiAgICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3cmFwIGRldGFpbCBjb21tZW50cy4gKi9cbiAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLFxuICAgICAgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICAgIHJlU3BsaXREZXRhaWxzID0gLyw/ICYgLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgdmFsaWRhdGVgIG9wdGlvbiBpbiBgXy50ZW1wbGF0ZWAgdmFyaWFibGUuXG4gICAqXG4gICAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XG4gICAqIC0gXCIoKSxcIiAobW9kaWZpY2F0aW9uIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gICAqIC0gXCI9XCIgKGRlZmF1bHQgdmFsdWUpXG4gICAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIi9cIiAoYmVnaW5uaW5nIG9mIGEgY29tbWVudClcbiAgICogLSB3aGl0ZXNwYWNlXG4gICAqL1xuICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2hcbiAgICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuICB2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xuICB2YXIgcmVMYXRpbiA9IC9bXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxceGZmXFx1MDEwMC1cXHUwMTdmXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG4gIHZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgICByc0xvd2VyUmFuZ2UgPSAnYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmJyxcbiAgICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgICAgcnNQdW5jdHVhdGlvblJhbmdlID0gJ1xcXFx1MjAwMC1cXFxcdTIwNmYnLFxuICAgICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnLFxuICAgICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbiAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLFxuICAgICAgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgICByc0RpZ2l0cyA9ICdcXFxcZCsnLFxuICAgICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgICAgcnNNaXNjID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyByc0JyZWFrUmFuZ2UgKyByc0RpZ2l0cyArIHJzRGluZ2JhdFJhbmdlICsgcnNMb3dlclJhbmdlICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgICByc1VwcGVyID0gJ1snICsgcnNVcHBlclJhbmdlICsgJ10nLFxuICAgICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbiAgdmFyIHJzTWlzY0xvd2VyID0gJyg/OicgKyByc0xvd2VyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNNaXNjVXBwZXIgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc09wdENvbnRyTG93ZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICAgIHJzT3B0Q29udHJVcHBlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OkR8TEx8TXxSRXxTfFR8VkUpKT8nLFxuICAgICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgICByc09yZExvd2VyID0gJ1xcXFxkKig/OjFzdHwybmR8M3JkfCg/IVsxMjNdKVxcXFxkdGgpKD89XFxcXGJ8W0EtWl9dKScsXG4gICAgICByc09yZFVwcGVyID0gJ1xcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKScsXG4gICAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcSxcbiAgICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xuICB2YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICAgKi9cbiAgdmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbiAgdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG4gIHZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgICByc1VwcGVyICsgJz8nICsgcnNMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzTWlzY1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc1VwcGVyICsgJz8nICsgcnNNaXNjTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIsXG4gICAgcnNVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlcixcbiAgICByc09yZFVwcGVyLFxuICAgIHJzT3JkTG93ZXIsXG4gICAgcnNEaWdpdHMsXG4gICAgcnNFbW9qaVxuICBdLmpvaW4oJ3wnKSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlV29yZCA9IC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4gIC8qKiBVc2VkIHRvIGFzc2lnbiBkZWZhdWx0IGBjb250ZXh0YCBvYmplY3QgcHJvcGVydGllcy4gKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQnVmZmVyJywgJ0RhdGFWaWV3JywgJ0RhdGUnLCAnRXJyb3InLCAnRmxvYXQzMkFycmF5JywgJ0Zsb2F0NjRBcnJheScsXG4gICAgJ0Z1bmN0aW9uJywgJ0ludDhBcnJheScsICdJbnQxNkFycmF5JywgJ0ludDMyQXJyYXknLCAnTWFwJywgJ01hdGgnLCAnT2JqZWN0JyxcbiAgICAnUHJvbWlzZScsICdSZWdFeHAnLCAnU2V0JywgJ1N0cmluZycsICdTeW1ib2wnLCAnVHlwZUVycm9yJywgJ1VpbnQ4QXJyYXknLFxuICAgICdVaW50OENsYW1wZWRBcnJheScsICdVaW50MTZBcnJheScsICdVaW50MzJBcnJheScsICdXZWFrTWFwJyxcbiAgICAnXycsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5LiAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xuICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG4gIHZhciBjbG9uZWFibGVUYWdzID0ge307XG4gIGNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgLy8gTGF0aW4tMSBTdXBwbGVtZW50IGJsb2NrLlxuICAgICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAgICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAgICdcXHhjNyc6ICdDJywgICdcXHhlNyc6ICdjJyxcbiAgICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgICAnXFx4ZTgnOiAnZScsICAnXFx4ZTknOiAnZScsICdcXHhlYSc6ICdlJywgJ1xceGViJzogJ2UnLFxuICAgICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgICAnXFx4ZDEnOiAnTicsICAnXFx4ZjEnOiAnbicsXG4gICAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICAgJ1xceGQ5JzogJ1UnLCAgJ1xceGRhJzogJ1UnLCAnXFx4ZGInOiAnVScsICdcXHhkYyc6ICdVJyxcbiAgICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAgICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAgICdcXHhjNic6ICdBZScsICdcXHhlNic6ICdhZScsXG4gICAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgICAnXFx4ZGYnOiAnc3MnLFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXG4gICAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICAgJ1xcdTAxMDYnOiAnQycsICAnXFx1MDEwOCc6ICdDJywgJ1xcdTAxMGEnOiAnQycsICdcXHUwMTBjJzogJ0MnLFxuICAgICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICAgJ1xcdTAxMTInOiAnRScsICAnXFx1MDExNCc6ICdFJywgJ1xcdTAxMTYnOiAnRScsICdcXHUwMTE4JzogJ0UnLCAnXFx1MDExYSc6ICdFJyxcbiAgICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAgICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgICAnXFx1MDExZCc6ICdnJywgICdcXHUwMTFmJzogJ2cnLCAnXFx1MDEyMSc6ICdnJywgJ1xcdTAxMjMnOiAnZycsXG4gICAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAgICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICAgJ1xcdTAxMjknOiAnaScsICAnXFx1MDEyYic6ICdpJywgJ1xcdTAxMmQnOiAnaScsICdcXHUwMTJmJzogJ2knLCAnXFx1MDEzMSc6ICdpJyxcbiAgICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAgICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAgICdcXHUwMTM5JzogJ0wnLCAgJ1xcdTAxM2InOiAnTCcsICdcXHUwMTNkJzogJ0wnLCAnXFx1MDEzZic6ICdMJywgJ1xcdTAxNDEnOiAnTCcsXG4gICAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICAgJ1xcdTAxNDQnOiAnbicsICAnXFx1MDE0Nic6ICduJywgJ1xcdTAxNDgnOiAnbicsICdcXHUwMTRiJzogJ24nLFxuICAgICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAgICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAgICdcXHUwMTU0JzogJ1InLCAgJ1xcdTAxNTYnOiAnUicsICdcXHUwMTU4JzogJ1InLFxuICAgICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAgICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgICAnXFx1MDE1Yic6ICdzJywgICdcXHUwMTVkJzogJ3MnLCAnXFx1MDE1Zic6ICdzJywgJ1xcdTAxNjEnOiAncycsXG4gICAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICAgJ1xcdTAxNjgnOiAnVScsICAnXFx1MDE2YSc6ICdVJywgJ1xcdTAxNmMnOiAnVScsICdcXHUwMTZlJzogJ1UnLCAnXFx1MDE3MCc6ICdVJywgJ1xcdTAxNzInOiAnVScsXG4gICAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgICAnXFx1MDE3Nic6ICdZJywgICdcXHUwMTc3JzogJ3knLCAnXFx1MDE3OCc6ICdZJyxcbiAgICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgICAnXFx1MDEzMic6ICdJSicsICdcXHUwMTMzJzogJ2lqJyxcbiAgICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAncydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy4gKi9cbiAgdmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VGbG9hdCA9IHBhcnNlRmxvYXQsXG4gICAgICBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbiAgdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4gIC8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xuICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICAgIGlmICh0eXBlcykge1xuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICAvKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xuICB2YXIgbm9kZUlzQXJyYXlCdWZmZXIgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0FycmF5QnVmZmVyLFxuICAgICAgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSxcbiAgICAgIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgICAgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHAsXG4gICAgICBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCxcbiAgICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFYWNoUmlnaHQoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKCFwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlUmlnaHRgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICB9XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYW4gQVNDSUkgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5maW5kS2V5YCBhbmQgYF8uZmluZExhc3RLZXlgLFxuICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gXG4gICAqIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQgb3IgaXRzIGtleSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kS2V5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZWFjaEZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mV2l0aChhcnJheSwgdmFsdWUsIGZyb21JbmRleCwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lYW5gIGFuZCBgXy5tZWFuQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VNZWFuKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gKGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCkgOiBOQU47XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAgICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAgICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICAgKiB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnN1bWAgYW5kIGBfLnN1bUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBjdXJyZW50IDogKHJlc3VsdCArIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAgICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gICAqIG9mIGtleS12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1BhaXJzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICAgIDogc3RyaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAgICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gICAqIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sXG4gICAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgY291bnQuXG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGFycmF5W2xlbmd0aF0gPT09IHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICsrcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZGVidXJyYCB0byBjb252ZXJ0IExhdGluLTEgU3VwcGxlbWVudCBhbmQgTGF0aW4gRXh0ZW5kZWQtQVxuICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICAgKi9cbiAgdmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBhIHdvcmQgY29tcG9zZWQgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBpdGVyYXRvcmAgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBpdGVyYXRvclRvQXJyYXkoaXRlcmF0b3IpIHtcbiAgICB2YXIgZGF0YSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIShkYXRhID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlaXIgaW5kZXhlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdG8gcmVwbGFjZS5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gUExBQ0VIT0xERVI7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubGFzdEluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ICsgMTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gICAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgdW5lc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxVbmVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgICArK3Jlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVbmljb2RlIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBgY29udGV4dGAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAxLjEuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWl4aW4oeyAnZm9vJzogXy5jb25zdGFudCgnZm9vJykgfSk7XG4gICAqXG4gICAqIHZhciBsb2Rhc2ggPSBfLnJ1bkluQ29udGV4dCgpO1xuICAgKiBsb2Rhc2gubWl4aW4oeyAnYmFyJzogbG9kYXNoLmNvbnN0YW50KCdiYXInKSB9KTtcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKF8uZm9vKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKiBfLmlzRnVuY3Rpb24oXy5iYXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guZm9vKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmJhcik7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogLy8gQ3JlYXRlIGEgc3VwZWQtdXAgYGRlZmVyYCBpbiBOb2RlLmpzLlxuICAgKiB2YXIgZGVmZXIgPSBfLnJ1bkluQ29udGV4dCh7ICdzZXRUaW1lb3V0Jzogc2V0SW1tZWRpYXRlIH0pLmRlZmVyO1xuICAgKi9cbiAgdmFyIHJ1bkluQ29udGV4dCA9IChmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0ID09IG51bGwgPyByb290IDogXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSk7XG5cbiAgICAvKiogQnVpbHQtaW4gY29uc3RydWN0b3IgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBFcnJvciA9IGNvbnRleHQuRXJyb3IsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICAgIHZhciBjb3JlSnNEYXRhID0gY29udGV4dFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gICAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gICAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy4gKi9cbiAgICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gICAgdmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAgICogb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xuICAgIHZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYF8ubm9Db25mbGljdGAuICovXG4gICAgdmFyIG9sZERhc2ggPSByb290Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuICAgIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sLFxuICAgICAgICBVaW50OEFycmF5ID0gY29udGV4dC5VaW50OEFycmF5LFxuICAgICAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgICAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltSXRlcmF0b3IgPSBTeW1ib2wgPyBTeW1ib2wuaXRlcmF0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0oKSk7XG5cbiAgICAvKiogTW9ja2VkIGJ1aWx0LWlucy4gKi9cbiAgICB2YXIgY3R4Q2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQgIT09IHJvb3QuY2xlYXJUaW1lb3V0ICYmIGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBjdHhOb3cgPSBEYXRlICYmIERhdGUubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUubm93LFxuICAgICAgICBjdHhTZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0ICE9PSByb290LnNldFRpbWVvdXQgJiYgY29udGV4dC5zZXRUaW1lb3V0O1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuICAgIHZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgICAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVKb2luID0gYXJyYXlQcm90by5qb2luLFxuICAgICAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluLFxuICAgICAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdyxcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgICAgbmF0aXZlUmV2ZXJzZSA9IGFycmF5UHJvdG8ucmV2ZXJzZTtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgJ0RhdGFWaWV3JyksXG4gICAgICAgIE1hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnTWFwJyksXG4gICAgICAgIFByb21pc2UgPSBnZXROYXRpdmUoY29udGV4dCwgJ1Byb21pc2UnKSxcbiAgICAgICAgU2V0ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdTZXQnKSxcbiAgICAgICAgV2Vha01hcCA9IGdldE5hdGl2ZShjb250ZXh0LCAnV2Vha01hcCcpLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgICAvKiogVXNlZCB0byBzdG9yZSBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbiAgICB2YXIgbWV0YU1hcCA9IFdlYWtNYXAgJiYgbmV3IFdlYWtNYXA7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbiAgICB2YXIgcmVhbE5hbWVzID0ge307XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xuICAgIHZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgICAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgICAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICAgICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xuICAgIHZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzLiBNZXRob2RzIHRoYXQgb3BlcmF0ZSBvbiBhbmQgcmV0dXJuIGFycmF5cywgY29sbGVjdGlvbnMsXG4gICAgICogYW5kIGZ1bmN0aW9ucyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci4gTWV0aG9kcyB0aGF0IHJldHJpZXZlIGEgc2luZ2xlIHZhbHVlXG4gICAgICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICAgICAqIGFuZCByZXR1cm4gdGhlIHVud3JhcHBlZCB2YWx1ZS4gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluIHNlcXVlbmNlcywgd2hpY2ggbXVzdCBiZSB1bndyYXBwZWQgd2l0aCBgXyN2YWx1ZWAsIG1heSBiZVxuICAgICAqIGVuYWJsZWQgdXNpbmcgYF8uY2hhaW5gLlxuICAgICAqXG4gICAgICogVGhlIGV4ZWN1dGlvbiBvZiBjaGFpbmVkIG1ldGhvZHMgaXMgbGF6eSwgdGhhdCBpcywgaXQncyBkZWZlcnJlZCB1bnRpbFxuICAgICAqIGBfI3ZhbHVlYCBpcyBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqXG4gICAgICogTGF6eSBldmFsdWF0aW9uIGFsbG93cyBzZXZlcmFsIG1ldGhvZHMgdG8gc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24uXG4gICAgICogU2hvcnRjdXQgZnVzaW9uIGlzIGFuIG9wdGltaXphdGlvbiB0byBtZXJnZSBpdGVyYXRlZSBjYWxsczsgdGhpcyBhdm9pZHNcbiAgICAgKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBpdGVyYXRlZSBleGVjdXRpb25zLiBTZWN0aW9ucyBvZiBhIGNoYWluIHNlcXVlbmNlIHF1YWxpZnkgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlmIHRoZSBzZWN0aW9uIGlzIGFwcGxpZWQgdG8gYW4gYXJyYXkgYW5kIGl0ZXJhdGVlcyBhY2NlcHQgb25seVxuICAgICAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpcyBzdWJqZWN0IHRvIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBkaXJlY3RseSBvciBpbmRpcmVjdGx5IGluY2x1ZGVkIGluIHRoZSBidWlsZC5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgQXJyYXlgIG1ldGhvZHMgYXJlOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBTdHJpbmdgIG1ldGhvZHMgYXJlOlxuICAgICAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uIGFyZTpcbiAgICAgKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICAgICAqIGBmaW5kTGFzdGAsIGBoZWFkYCwgYGluaXRpYWxgLCBgbGFzdGAsIGBtYXBgLCBgcmVqZWN0YCwgYHJldmVyc2VgLCBgc2xpY2VgLFxuICAgICAqIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCwgYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGFuZCBgdG9BcnJheWBcbiAgICAgKlxuICAgICAqIFRoZSBjaGFpbmFibGUgd3JhcHBlciBtZXRob2RzIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXJ5YCwgYGFzc2lnbmAsIGBhc3NpZ25JbmAsIGBhc3NpZ25JbldpdGhgLCBgYXNzaWduV2l0aGAsIGBhdGAsXG4gICAgICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICAgICAqIGBjb21taXRgLCBgY29tcGFjdGAsIGBjb25jYXRgLCBgY29uZm9ybXNgLCBgY29uc3RhbnRgLCBgY291bnRCeWAsIGBjcmVhdGVgLFxuICAgICAqIGBjdXJyeWAsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgZGVmZXJgLCBgZGVsYXlgLFxuICAgICAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gICAgICogYGRyb3BSaWdodFdoaWxlYCwgYGRyb3BXaGlsZWAsIGBleHRlbmRgLCBgZXh0ZW5kV2l0aGAsIGBmaWxsYCwgYGZpbHRlcmAsXG4gICAgICogYGZsYXRNYXBgLCBgZmxhdE1hcERlZXBgLCBgZmxhdE1hcERlcHRoYCwgYGZsYXR0ZW5gLCBgZmxhdHRlbkRlZXBgLFxuICAgICAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAgICAgKiBgZnVuY3Rpb25zSW5gLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnRlcnNlY3Rpb25CeWAsXG4gICAgICogYGludGVyc2VjdGlvbldpdGhgLCBgaW52ZXJ0YCwgYGludmVydEJ5YCwgYGludm9rZU1hcGAsIGBpdGVyYXRlZWAsIGBrZXlCeWAsXG4gICAgICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gICAgICogYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWVyZ2VXaXRoYCwgYG1ldGhvZGAsIGBtZXRob2RPZmAsIGBtaXhpbmAsIGBuZWdhdGVgLFxuICAgICAqIGBudGhBcmdgLCBgb21pdGAsIGBvbWl0QnlgLCBgb25jZWAsIGBvcmRlckJ5YCwgYG92ZXJgLCBgb3ZlckFyZ3NgLFxuICAgICAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICAgICAqIGBwaWNrQnlgLCBgcGxhbnRgLCBgcHJvcGVydHlgLCBgcHJvcGVydHlPZmAsIGBwdWxsYCwgYHB1bGxBbGxgLCBgcHVsbEFsbEJ5YCxcbiAgICAgKiBgcHVsbEFsbFdpdGhgLCBgcHVsbEF0YCwgYHB1c2hgLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZWFyZ2AsIGByZWplY3RgLFxuICAgICAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gICAgICogYHNsaWNlYCwgYHNvcnRgLCBgc29ydEJ5YCwgYHNwbGljZWAsIGBzcHJlYWRgLCBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRha2VSaWdodFdoaWxlYCwgYHRha2VXaGlsZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGhydWAsIGB0b0FycmF5YCxcbiAgICAgKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAgICAgKiBgdW5pb25gLCBgdW5pb25CeWAsIGB1bmlvbldpdGhgLCBgdW5pcWAsIGB1bmlxQnlgLCBgdW5pcVdpdGhgLCBgdW5zZXRgLFxuICAgICAqIGB1bnNoaWZ0YCwgYHVuemlwYCwgYHVuemlwV2l0aGAsIGB1cGRhdGVgLCBgdXBkYXRlV2l0aGAsIGB2YWx1ZXNgLFxuICAgICAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAgICAgKiBgemlwT2JqZWN0YCwgYHppcE9iamVjdERlZXBgLCBhbmQgYHppcFdpdGhgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICAgICAqIGBhZGRgLCBgYXR0ZW1wdGAsIGBjYW1lbENhc2VgLCBgY2FwaXRhbGl6ZWAsIGBjZWlsYCwgYGNsYW1wYCwgYGNsb25lYCxcbiAgICAgKiBgY2xvbmVEZWVwYCwgYGNsb25lRGVlcFdpdGhgLCBgY2xvbmVXaXRoYCwgYGNvbmZvcm1zVG9gLCBgZGVidXJyYCxcbiAgICAgKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICAgICAqIGBlc2NhcGVSZWdFeHBgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLCBgZmluZEtleWAsIGBmaW5kTGFzdGAsXG4gICAgICogYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgZmlyc3RgLCBgZmxvb3JgLCBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLFxuICAgICAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gICAgICogYGhhc0luYCwgYGhlYWRgLCBgaWRlbnRpdHlgLCBgaW5jbHVkZXNgLCBgaW5kZXhPZmAsIGBpblJhbmdlYCwgYGludm9rZWAsXG4gICAgICogYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNBcnJheUJ1ZmZlcmAsIGBpc0FycmF5TGlrZWAsIGBpc0FycmF5TGlrZU9iamVjdGAsXG4gICAgICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gICAgICogYGlzRXF1YWxXaXRoYCwgYGlzRXJyb3JgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc0ludGVnZXJgLCBgaXNMZW5ndGhgLFxuICAgICAqIGBpc01hcGAsIGBpc01hdGNoYCwgYGlzTWF0Y2hXaXRoYCwgYGlzTmFOYCwgYGlzTmF0aXZlYCwgYGlzTmlsYCwgYGlzTnVsbGAsXG4gICAgICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAgICAgKiBgaXNTYWZlSW50ZWdlcmAsIGBpc1NldGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBpc1R5cGVkQXJyYXlgLFxuICAgICAqIGBpc1dlYWtNYXBgLCBgaXNXZWFrU2V0YCwgYGpvaW5gLCBga2ViYWJDYXNlYCwgYGxhc3RgLCBgbGFzdEluZGV4T2ZgLFxuICAgICAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAgICAgKiBgbWluYCwgYG1pbkJ5YCwgYG11bHRpcGx5YCwgYG5vQ29uZmxpY3RgLCBgbm9vcGAsIGBub3dgLCBgbnRoYCwgYHBhZGAsXG4gICAgICogYHBhZEVuZGAsIGBwYWRTdGFydGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsXG4gICAgICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAgICAgKiBgc25ha2VDYXNlYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgc29ydGVkSW5kZXhCeWAsIGBzb3J0ZWRMYXN0SW5kZXhgLFxuICAgICAqIGBzb3J0ZWRMYXN0SW5kZXhCeWAsIGBzdGFydENhc2VgLCBgc3RhcnRzV2l0aGAsIGBzdHViQXJyYXlgLCBgc3R1YkZhbHNlYCxcbiAgICAgKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRpbWVzYCwgYHRvRmluaXRlYCwgYHRvSW50ZWdlcmAsIGB0b0pTT05gLCBgdG9MZW5ndGhgLFxuICAgICAqIGB0b0xvd2VyYCwgYHRvTnVtYmVyYCwgYHRvU2FmZUludGVnZXJgLCBgdG9TdHJpbmdgLCBgdG9VcHBlcmAsIGB0cmltYCxcbiAgICAgKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAgICAgKiBgdXBwZXJGaXJzdGAsIGB2YWx1ZWAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAbmFtZSBfXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIHdyYXBwZWQucmVkdWNlKF8uYWRkKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICAgICAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gd2hvc2UgcHJvdG90eXBlIGNoYWluIHNlcXVlbmNlIHdyYXBwZXJzIGluaGVyaXQgZnJvbS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUxvZGFzaCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjaGFpbkFsbF0gRW5hYmxlIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgIHRoaXMuX19pbmRleF9fID0gMDtcbiAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICAgICAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICAnXyc6IGxvZGFzaFxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG4gICAgbG9kYXNoLnByb3RvdHlwZSA9IGJhc2VMb2Rhc2gucHJvdG90eXBlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBsb2Rhc2g7XG5cbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBsYXp5IHdyYXBwZXIgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGxhenkgZXZhbHVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gICAgICB0aGlzLl9faXRlcmF0ZWVzX18gPSBbXTtcbiAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICB0aGlzLl9fdmlld3NfXyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgbGF6eSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xvbmVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eUNsb25lKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzLl9fd3JhcHBlZF9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2Rpcl9fID0gdGhpcy5fX2Rpcl9fO1xuICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRoaXMuX19maWx0ZXJlZF9fO1xuICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gdGhpcy5fX3Rha2VDb3VudF9fO1xuICAgICAgcmVzdWx0Ll9fdmlld3NfXyA9IGNvcHlBcnJheSh0aGlzLl9fdmlld3NfXyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBkaXJlY3Rpb24gb2YgbGF6eSBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgcmV2ZXJzZWQgYExhenlXcmFwcGVyYCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVJldmVyc2UoKSB7XG4gICAgICBpZiAodGhpcy5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gPSAtMTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fICo9IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgdW53cmFwcGVkIHZhbHVlIGZyb20gaXRzIGxhenkgd3JhcHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgTGF6eVdyYXBwZXJcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSxcbiAgICAgICAgICBkaXIgPSB0aGlzLl9fZGlyX18sXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGFycmF5KSxcbiAgICAgICAgICBpc1JpZ2h0ID0gZGlyIDwgMCxcbiAgICAgICAgICBhcnJMZW5ndGggPSBpc0FyciA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgdmlldyA9IGdldFZpZXcoMCwgYXJyTGVuZ3RoLCB0aGlzLl9fdmlld3NfXyksXG4gICAgICAgICAgc3RhcnQgPSB2aWV3LnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IHZpZXcuZW5kLFxuICAgICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IChzdGFydCAtIDEpLFxuICAgICAgICAgIGl0ZXJhdGVlcyA9IHRoaXMuX19pdGVyYXRlZXNfXyxcbiAgICAgICAgICBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgdGFrZUNvdW50ID0gbmF0aXZlTWluKGxlbmd0aCwgdGhpcy5fX3Rha2VDb3VudF9fKTtcblxuICAgICAgaWYgKCFpc0FyciB8fCAoIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKGxlbmd0aC0tICYmIHJlc0luZGV4IDwgdGFrZUNvdW50KSB7XG4gICAgICAgIGluZGV4ICs9IGRpcjtcblxuICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSxcbiAgICAgICAgICAgICAgaXRlcmF0ZWUgPSBkYXRhLml0ZXJhdGVlLFxuICAgICAgICAgICAgICB0eXBlID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBgTGF6eVdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuICAgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuICAgIEhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICBIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuICAgIEhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgZGF0YS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGFkZFxuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBhbGlhcyBwdXNoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG4gICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgfVxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG4gICAgU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICBTdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG4gICAgU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtiYXNlUmFuZG9tKDAsIGxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2FtcGxlU2l6ZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpLCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gICAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZ2dyZWdhdGVzIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBvbiBgYWNjdW11bGF0b3JgIHdpdGgga2V5cyB0cmFuc2Zvcm1lZFxuICAgICAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICAgKiB2YWx1ZSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc2tpcCA/IHVuZGVmaW5lZCA6IGdldChvYmplY3QsIHBhdGhzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA8PSB1cHBlciA/IG51bWJlciA6IHVwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICAgICAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBEZWVwIGNsb25lXG4gICAgICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQ7XG4gICAgICB9XG4gICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgICAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgICAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICAgICAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc1RvYCB3aGljaCBhY2NlcHRzIGBwcm9wc2AgdG8gY2hlY2suXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2xlbmd0aF0sXG4gICAgICAgICAgICBwcmVkaWNhdGUgPSBzb3VyY2Vba2V5XSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKCh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHx8ICFwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kZWxheWAgYW5kIGBfLmRlZmVyYCB3aGljaCBhY2NlcHRzIGBhcmdzYFxuICAgICAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURlbGF5KGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICovXG4gICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICAgICAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbGxgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IGxlbmd0aCkgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGFycmF5W3N0YXJ0KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAgICAgKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VGb3JgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllc1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvclJpZ2h0ID0gY3JlYXRlQmFzZUZvcih0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25SaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yUmlnaHQob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZnVuY3Rpb25zYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mXG4gICAgICogYG9iamVjdGAgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZmlsdGVyZWQgZnJvbSBgcHJvcHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmlsdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmplY3Rba2V5XSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICAgICAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5SYW5nZWAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gbnVtYmVyID49IG5hdGl2ZU1pbihzdGFydCwgZW5kKSAmJiBudW1iZXIgPCBuYXRpdmVNYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluY2x1ZGVzID0gY29tcGFyYXRvciA/IGFycmF5SW5jbHVkZXNXaXRoIDogYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgaWYgKG90aEluZGV4ICYmIGl0ZXJhdGVlKSB7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIHJlc3VsdC5sZW5ndGggPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMocmVzdWx0LCBjb21wdXRlZCwgY29tcGFyYXRvcilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoLS1vdGhJbmRleCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICA/IGNhY2hlSGFzKGNhY2hlLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZlcnRgIGFuZCBgXy5pbnZlcnRCeWAgd2hpY2ggaW52ZXJ0c1xuICAgICAqIGBvYmplY3RgIHdpdGggdmFsdWVzIHRyYW5zZm9ybWVkIGJ5IGBpdGVyYXRlZWAgYW5kIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUodmFsdWUpLCBrZXksIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbnZva2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIG1ldGhvZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHZhciBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJyYXlCdWZmZXJgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJyYXlCdWZmZXJUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNEYXRlYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGRhdGVUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICAgICAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICAgICAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgICAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTHQodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSxcbiAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKSxcbiAgICAgICAgICB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSBuYXRpdmVGbG9vcigobG93ICsgaGlnaCkgLyAyKSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSksXG4gICAgICAgICAgICBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZCxcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2woY29tcHV0ZWQpO1xuXG4gICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgIHZhciBzZXRMb3cgPSByZXRIaWdoZXN0IHx8IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzTnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNTeW1ib2wpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldExvdyA9IHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRVbmlxYCBhbmQgYF8uc29ydGVkVW5pcUJ5YCB3aXRob3V0XG4gICAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICB2YXIgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvTnVtYmVyYCB3aGljaCBkb2Vzbid0IGVuc3VyZSBjb3JyZWN0XG4gICAgICogY29udmVyc2lvbnMgb2YgYmluYXJ5LCBoZXhhZGVjaW1hbCwgb3Igb2N0YWwgc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udXBkYXRlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRyb3BXaGlsZWAgYW5kIGBfLnRha2VXaGlsZWBcbiAgICAgKiB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Ryb3BdIFNwZWNpZnkgZHJvcHBpbmcgZWxlbWVudHMgaW5zdGVhZCBvZiB0YWtpbmcgdGhlbS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTE7XG5cbiAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpICYmXG4gICAgICAgIHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHt9XG5cbiAgICAgIHJldHVybiBpc0Ryb3BcbiAgICAgICAgPyBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyAwIDogaW5kZXgpLCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSlcbiAgICAgICAgOiBiYXNlU2xpY2UoYXJyYXksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiAwKSwgKGZyb21SaWdodCA/IGxlbmd0aCA6IGluZGV4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHdyYXBwZXJWYWx1ZWAgd2hpY2ggcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gICAgICogcGVyZm9ybWluZyBhIHNlcXVlbmNlIG9mIGFjdGlvbnMgb24gdGhlIHVud3JhcHBlZCBgdmFsdWVgLCB3aGVyZSBlYWNoXG4gICAgICogc3VjY2Vzc2l2ZSBhY3Rpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhY3Rpb25zIEFjdGlvbnMgdG8gcGVyZm9ybSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmZ1bmMuYXBwbHkoYWN0aW9uLnRoaXNBcmcsIGFycmF5UHVzaChbcmVzdWx0XSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLCB0aGF0IGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5cyBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaW5kZXhdLFxuICAgICAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChvdGhJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQsIDEpLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduRnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VaaXBPYmplY3QocHJvcHMsIHZhbHVlcywgYXNzaWduRnVuYykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHZhbHNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmRleCA8IHZhbHNMZW5ndGggPyB2YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGBiYXNlUmVzdGAgYWxpYXMgd2hpY2ggY2FuIGJlIHJlcGxhY2VkIHdpdGggYGlkZW50aXR5YCBieSBtb2R1bGVcbiAgICAgKiByZXBsYWNlbWVudCBwbHVnaW5zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgY2FzdFJlc3QgPSBiYXNlUmVzdDtcblxuICAgIC8qKlxuICAgICAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgICAgcmV0dXJuICghc3RhcnQgJiYgZW5kID49IGxlbmd0aCkgPyBhcnJheSA6IGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYGNsZWFyVGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL2NsZWFyVGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gaWQgVGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0IG9mIHRoZSB0aW1lciB0byBjbGVhci5cbiAgICAgKi9cbiAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gcm9vdC5jbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICAgICAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICAgICAqXG4gICAgICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAgICAgKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gICAgICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAgIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLFxuICAgICAqIHBsYWNlaG9sZGVycywgYW5kIHByb3ZpZGVkIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtob2xkZXJzW2FyZ3NJbmRleF1dID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAocmFuZ2VMZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAgICAgKiBpcyB0YWlsb3JlZCBmb3IgYF8ucGFydGlhbFJpZ2h0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0luZGV4ID0gLTEsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgICAgICByaWdodExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSBhcmdzSW5kZXg7XG4gICAgICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W29mZnNldCArIHJpZ2h0SW5kZXhdID0gcGFydGlhbHNbcmlnaHRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ubG93ZXJGaXJzdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgU3RyaW5nYCBjYXNlIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgICAgIDogc3RyaW5nLmNoYXJBdCgwKTtcblxuICAgICAgICB2YXIgdHJhaWxpbmcgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvdW5kZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gICAgICogd2hldGhlciBpdCB3YXMgaW52b2tlZCBhcyBwYXJ0IG9mIGEgYG5ld2AgZXhwcmVzc2lvbiBvciBieSBgY2FsbGAgb3IgYGFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gQ3RvciBUaGUgY29uc3RydWN0b3IgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgICAgIC8vIGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtZnVuY3Rpb24tb2JqZWN0cy1jYWxsLXRoaXNhcmd1bWVudC1hcmd1bWVudHNsaXN0XG4gICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEN0b3I7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShDdG9yLnByb3RvdHlwZSksXG4gICAgICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgICAgICAvLyBNaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvci5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gZW5hYmxlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFyaXR5IFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSkge1xuICAgICAgdmFyIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9sZGVycyA9IChsZW5ndGggPCAzICYmIGFyZ3NbMF0gIT09IHBsYWNlaG9sZGVyICYmIGFyZ3NbbGVuZ3RoIC0gMV0gIT09IHBsYWNlaG9sZGVyKVxuICAgICAgICAgID8gW11cbiAgICAgICAgICA6IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBsZW5ndGggLT0gaG9sZGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5mbG93YCBvciBgXy5mbG93UmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbG93IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZsb3coZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcHJlcmVxID0gTG9kYXNoV3JhcHBlci5wcm90b3R5cGUudGhydTtcblxuICAgICAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgZnVuY3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSAnd3JhcHBlcicpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBmdW5jID0gZnVuY3NbaW5kZXhdO1xuXG4gICAgICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgICAgIGRhdGEgPSBmdW5jTmFtZSA9PSAnd3JhcHBlcicgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJlxuICAgICAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVs0XS5sZW5ndGggJiYgZGF0YVs5XSA9PSAxXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gKGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgICAgIDogd3JhcHBlci50aHJ1KGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgICAgIGlmICh3cmFwcGVyICYmIGFyZ3MubGVuZ3RoID09IDEgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgICByZXN1bHQgPSBsZW5ndGggPyBmdW5jc1tpbmRleF0uYXBwbHkodGhpcywgYXJncykgOiB2YWx1ZTtcblxuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jc1tpbmRleF0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIG9wdGlvbmFsIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICAgICAqICB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzUmlnaHRdIFRoZSBgcGFydGlhbHNSaWdodGAgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgICAgICBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRyxcbiAgICAgICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICAgICAgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKSxcbiAgICAgICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgICAgIHZhciBuZXdIb2xkZXJzID0gcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICAgICAgYXJncywgbmV3SG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5IC0gbGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcyxcbiAgICAgICAgICAgIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuXG4gICAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgYXJncyA9IHJlb3JkZXIoYXJncywgYXJnUG9zKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzLmxlbmd0aCA9IGFyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICAgICAgZm4gPSBDdG9yIHx8IGNyZWF0ZUN0b3IoZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5pbnZlcnRCeWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0b0l0ZXJhdGVlIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUpLCB7fSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgdXNlZCBmb3IgYHVuZGVmaW5lZGAgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIG90aGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLm92ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhcnJheUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgb3ZlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGl0ZXJhdGVlcykge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgdmFyIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhcnJheUZ1bmMoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYCBiYXNlZCBvbiBgbGVuZ3RoYC4gVGhlIGBjaGFyc2Agc3RyaW5nXG4gICAgICogaXMgdHJ1bmNhdGVkIGlmIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBleGNlZWRzIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFkZGluZyhsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBjaGFycyA9IGNoYXJzID09PSB1bmRlZmluZWQgPyAnICcgOiBiYXNlVG9TdHJpbmcoY2hhcnMpO1xuXG4gICAgICB2YXIgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICBpZiAoY2hhcnNMZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICByZXR1cm4gaGFzVW5pY29kZShjaGFycylcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShyZXN1bHQpLCAwLCBsZW5ndGgpLmpvaW4oJycpXG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVmdExlbmd0aCArIGFyZ3NMZW5ndGgpLFxuICAgICAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICBhcmdzW2xlZnRJbmRleCsrXSA9IGFyZ3VtZW50c1srK2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8ucmFuZ2VgIG9yIGBfLnJhbmdlUmlnaHRgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5nZShmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgZW5kID0gc3RlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcmVsYXRpb25hbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZWxhdGlvbmFsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKG9wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3RoZXIgPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBjb250aW51ZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICAgICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN1cnJ5KGZ1bmMsIGJpdG1hc2ssIHdyYXBGdW5jLCBwbGFjZWhvbGRlciwgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgICAgIG5ld0hvbGRlcnMgPSBpc0N1cnJ5ID8gaG9sZGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdIb2xkZXJzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogaG9sZGVycyxcbiAgICAgICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IHBhcnRpYWxzO1xuXG4gICAgICBiaXRtYXNrIHw9IChpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX0ZMQUcgOiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIG5ld1BhcnRpYWxzLCBuZXdIb2xkZXJzLCBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgICAgICBzZXREYXRhKHJlc3VsdCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcocmVzdWx0LCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5yb3VuZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBgTWF0aGAgbWV0aG9kIHRvIHVzZSB3aGVuIHJvdW5kaW5nLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJvdW5kKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gTWF0aFttZXRob2ROYW1lXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgIGlmIChwcmVjaXNpb24gJiYgbmF0aXZlSXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIENvbWJpbmluZyBzZXZlcmFsIHByZWRpY2F0ZXMgdXNpbmcgYF8ub3ZlckV2ZXJ5YCBvciBgXy5vdmVyU29tZWAuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8ub3ZlclNvbWUoW3sgJ2FnZSc6IDM2IH0sIFsnYWdlJywgNDBdXSkpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiAzMCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgMzBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgMzBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhIGZvcmJpZGRlbiBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGB2YXJpYWJsZWAsIHRvIHByZXZlbnRcbiAgICAgIC8vIHBvdGVudGlhbCBjb21tYW5kIGluamVjdGlvbiBhdHRhY2tzLlxuICAgICAgZWxzZSBpZiAocmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMudGVzdCh2YXJpYWJsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUcmltKHN0cmluZyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksIF8ubWF0Y2hlcyh7ICdhJzogNCB9KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZVxuICAgICAqIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdCB0byBgc3JjVmFsdWVgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZVxuICAgICAqIG9iamVjdCB2YWx1ZSBpcyBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3RcbiAgICAgKiBgc3JjVmFsdWVgIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlXG4gICAgICogYF8uaXNFcXVhbGAgZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTXVsdGlwbGUgdmFsdWVzIGNhbiBiZSBjaGVja2VkIGJ5IGNvbWJpbmluZyBzZXZlcmFsIG1hdGNoZXJzXG4gICAgICogdXNpbmcgYF8ub3ZlclNvbWVgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChvYmplY3RzLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCAxKSwgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KV0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgYmFzZUNsb25lKHNyY1ZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMikgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDEpIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZCgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoWydhJywgJ2InXSkpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciBtZXRob2QgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1ldGhvZGA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiB0aGUgbWV0aG9kIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBfLnRpbWVzKDMsIF8uY29uc3RhbnQpLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ubWV0aG9kT2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZE9mID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYWxsIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIElmIGBvYmplY3RgIGlzIGEgZnVuY3Rpb24sIHRoZW4gbWV0aG9kc1xuICAgICAqIGFyZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVXNlIGBfLnJ1bkluQ29udGV4dGAgdG8gY3JlYXRlIGEgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdG9cbiAgICAgKiBhdm9pZCBjb25mbGljdHMgY2F1c2VkIGJ5IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciBtaXhpbnMgYXJlIGNoYWluYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiB2b3dlbHMoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gXy5maWx0ZXIoc3RyaW5nLCBmdW5jdGlvbih2KSB7XG4gICAgICogICAgIHJldHVybiAvW2FlaW91XS9pLnRlc3Qodik7XG4gICAgICogICB9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9KTtcbiAgICAgKiBfLnZvd2VscygnZnJlZCcpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykudm93ZWxzKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCAmJlxuICAgICAgICAgICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhaW4gPSAhKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLFxuICAgICAgICAgIGlzRnVuYyA9IGlzRnVuY3Rpb24ob2JqZWN0KTtcblxuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBvYmplY3RbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG5cbiAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHsgJ2Z1bmMnOiBmdW5jLCAnYXJncyc6IGFyZ3VtZW50cywgJ3RoaXNBcmcnOiBvYmplY3QgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG9iamVjdCwgYXJyYXlQdXNoKFt0aGlzLnZhbHVlKCldLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGlmIChyb290Ll8gPT09IHRoaXMpIHtcbiAgICAgICAgcm9vdC5fID0gb2xkRGFzaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGdldHMgdGhlIGFyZ3VtZW50IGF0IGluZGV4IGBuYC4gSWYgYG5gIGlzIG5lZ2F0aXZlLFxuICAgICAqIHRoZSBudGggYXJndW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBhcmd1bWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFzcy10aHJ1IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKDEpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoLTIpO1xuICAgICAqIGZ1bmMoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiAnYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGhBcmcobikge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBiYXNlTnRoKGFyZ3MsIG4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgaXRlcmF0ZWVzYCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXNcbiAgICAgKiBhbmQgcmV0dXJucyB0aGVpciByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlcihbTWF0aC5tYXgsIE1hdGgubWluXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFs0LCAxXVxuICAgICAqL1xuICAgIHZhciBvdmVyID0gY3JlYXRlT3ZlcihhcnJheU1hcCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbGwqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogRm9sbG93aW5nIHNob3J0aGFuZHMgYXJlIHBvc3NpYmxlIGZvciBwcm92aWRpbmcgcHJlZGljYXRlcy5cbiAgICAgKiBQYXNzIGFuIGBPYmplY3RgIGFuZCBpdCB3aWxsIGJlIHVzZWQgYXMgYW4gcGFyYW1ldGVyIGZvciBgXy5tYXRjaGVzYCB0byBjcmVhdGUgdGhlIHByZWRpY2F0ZS5cbiAgICAgKiBQYXNzIGFuIGBBcnJheWAgb2YgcGFyYW1ldGVycyBmb3IgYF8ubWF0Y2hlc1Byb3BlcnR5YCBhbmQgdGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNyZWF0ZWQgdXNpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIG1hdGNoZXNGdW5jID0gXy5vdmVyU29tZShbeyAnYSc6IDEgfSwgeyAnYSc6IDIgfV0pXG4gICAgICogdmFyIG1hdGNoZXNQcm9wZXJ0eUZ1bmMgPSBfLm92ZXJTb21lKFtbJ2EnLCAxXSwgWydhJywgMl1dKVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSBsb2Rhc2hGdW5jLm5hbWUgKyAnJztcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywga2V5KSkge1xuICAgICAgICAgIHJlYWxOYW1lc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmVhbE5hbWVzW2tleV0ucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9